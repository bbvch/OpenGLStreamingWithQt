
#include "glproc.hpp"
#include "os.hpp"


static EGLint _fail_eglGetError(void) {
    const char *_name = "eglGetError";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLint _get_eglGetError(void) {
    PFN_EGLGETERROR _ptr;
    _ptr = (PFN_EGLGETERROR)_getPublicProcAddress("eglGetError");
    if (!_ptr) {
        _ptr = &_fail_eglGetError;
    }
    _eglGetError = _ptr;
    return _eglGetError();
}

PFN_EGLGETERROR _eglGetError = &_get_eglGetError;

static EGLDisplay _fail_eglGetDisplay(EGLNativeDisplayType display_id) {
    const char *_name = "eglGetDisplay";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLDisplay _get_eglGetDisplay(EGLNativeDisplayType display_id) {
    PFN_EGLGETDISPLAY _ptr;
    _ptr = (PFN_EGLGETDISPLAY)_getPublicProcAddress("eglGetDisplay");
    if (!_ptr) {
        _ptr = &_fail_eglGetDisplay;
    }
    _eglGetDisplay = _ptr;
    return _eglGetDisplay(display_id);
}

PFN_EGLGETDISPLAY _eglGetDisplay = &_get_eglGetDisplay;

static EGLBoolean _fail_eglInitialize(EGLDisplay dpy, EGLint * major, EGLint * minor) {
    const char *_name = "eglInitialize";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglInitialize(EGLDisplay dpy, EGLint * major, EGLint * minor) {
    PFN_EGLINITIALIZE _ptr;
    _ptr = (PFN_EGLINITIALIZE)_getPublicProcAddress("eglInitialize");
    if (!_ptr) {
        _ptr = &_fail_eglInitialize;
    }
    _eglInitialize = _ptr;
    return _eglInitialize(dpy, major, minor);
}

PFN_EGLINITIALIZE _eglInitialize = &_get_eglInitialize;

static EGLBoolean _fail_eglTerminate(EGLDisplay dpy) {
    const char *_name = "eglTerminate";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglTerminate(EGLDisplay dpy) {
    PFN_EGLTERMINATE _ptr;
    _ptr = (PFN_EGLTERMINATE)_getPublicProcAddress("eglTerminate");
    if (!_ptr) {
        _ptr = &_fail_eglTerminate;
    }
    _eglTerminate = _ptr;
    return _eglTerminate(dpy);
}

PFN_EGLTERMINATE _eglTerminate = &_get_eglTerminate;

static const char * _fail_eglQueryString(EGLDisplay dpy, EGLint name) {
    const char *_name = "eglQueryString";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static const char * _get_eglQueryString(EGLDisplay dpy, EGLint name) {
    PFN_EGLQUERYSTRING _ptr;
    _ptr = (PFN_EGLQUERYSTRING)_getPublicProcAddress("eglQueryString");
    if (!_ptr) {
        _ptr = &_fail_eglQueryString;
    }
    _eglQueryString = _ptr;
    return _eglQueryString(dpy, name);
}

PFN_EGLQUERYSTRING _eglQueryString = &_get_eglQueryString;

static EGLBoolean _fail_eglGetConfigs(EGLDisplay dpy, EGLConfig * configs, EGLint config_size, EGLint * num_config) {
    const char *_name = "eglGetConfigs";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglGetConfigs(EGLDisplay dpy, EGLConfig * configs, EGLint config_size, EGLint * num_config) {
    PFN_EGLGETCONFIGS _ptr;
    _ptr = (PFN_EGLGETCONFIGS)_getPublicProcAddress("eglGetConfigs");
    if (!_ptr) {
        _ptr = &_fail_eglGetConfigs;
    }
    _eglGetConfigs = _ptr;
    return _eglGetConfigs(dpy, configs, config_size, num_config);
}

PFN_EGLGETCONFIGS _eglGetConfigs = &_get_eglGetConfigs;

static EGLBoolean _fail_eglChooseConfig(EGLDisplay dpy, const EGLint * attrib_list, EGLConfig * configs, EGLint config_size, EGLint * num_config) {
    const char *_name = "eglChooseConfig";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglChooseConfig(EGLDisplay dpy, const EGLint * attrib_list, EGLConfig * configs, EGLint config_size, EGLint * num_config) {
    PFN_EGLCHOOSECONFIG _ptr;
    _ptr = (PFN_EGLCHOOSECONFIG)_getPublicProcAddress("eglChooseConfig");
    if (!_ptr) {
        _ptr = &_fail_eglChooseConfig;
    }
    _eglChooseConfig = _ptr;
    return _eglChooseConfig(dpy, attrib_list, configs, config_size, num_config);
}

PFN_EGLCHOOSECONFIG _eglChooseConfig = &_get_eglChooseConfig;

static EGLBoolean _fail_eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint * value) {
    const char *_name = "eglGetConfigAttrib";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint * value) {
    PFN_EGLGETCONFIGATTRIB _ptr;
    _ptr = (PFN_EGLGETCONFIGATTRIB)_getPublicProcAddress("eglGetConfigAttrib");
    if (!_ptr) {
        _ptr = &_fail_eglGetConfigAttrib;
    }
    _eglGetConfigAttrib = _ptr;
    return _eglGetConfigAttrib(dpy, config, attribute, value);
}

PFN_EGLGETCONFIGATTRIB _eglGetConfigAttrib = &_get_eglGetConfigAttrib;

static EGLSurface _fail_eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint * attrib_list) {
    const char *_name = "eglCreateWindowSurface";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLSurface _get_eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint * attrib_list) {
    PFN_EGLCREATEWINDOWSURFACE _ptr;
    _ptr = (PFN_EGLCREATEWINDOWSURFACE)_getPublicProcAddress("eglCreateWindowSurface");
    if (!_ptr) {
        _ptr = &_fail_eglCreateWindowSurface;
    }
    _eglCreateWindowSurface = _ptr;
    return _eglCreateWindowSurface(dpy, config, win, attrib_list);
}

PFN_EGLCREATEWINDOWSURFACE _eglCreateWindowSurface = &_get_eglCreateWindowSurface;

static EGLSurface _fail_eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint * attrib_list) {
    const char *_name = "eglCreatePbufferSurface";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLSurface _get_eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint * attrib_list) {
    PFN_EGLCREATEPBUFFERSURFACE _ptr;
    _ptr = (PFN_EGLCREATEPBUFFERSURFACE)_getPublicProcAddress("eglCreatePbufferSurface");
    if (!_ptr) {
        _ptr = &_fail_eglCreatePbufferSurface;
    }
    _eglCreatePbufferSurface = _ptr;
    return _eglCreatePbufferSurface(dpy, config, attrib_list);
}

PFN_EGLCREATEPBUFFERSURFACE _eglCreatePbufferSurface = &_get_eglCreatePbufferSurface;

static EGLSurface _fail_eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint * attrib_list) {
    const char *_name = "eglCreatePixmapSurface";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLSurface _get_eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint * attrib_list) {
    PFN_EGLCREATEPIXMAPSURFACE _ptr;
    _ptr = (PFN_EGLCREATEPIXMAPSURFACE)_getPublicProcAddress("eglCreatePixmapSurface");
    if (!_ptr) {
        _ptr = &_fail_eglCreatePixmapSurface;
    }
    _eglCreatePixmapSurface = _ptr;
    return _eglCreatePixmapSurface(dpy, config, pixmap, attrib_list);
}

PFN_EGLCREATEPIXMAPSURFACE _eglCreatePixmapSurface = &_get_eglCreatePixmapSurface;

static EGLBoolean _fail_eglDestroySurface(EGLDisplay dpy, EGLSurface surface) {
    const char *_name = "eglDestroySurface";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglDestroySurface(EGLDisplay dpy, EGLSurface surface) {
    PFN_EGLDESTROYSURFACE _ptr;
    _ptr = (PFN_EGLDESTROYSURFACE)_getPublicProcAddress("eglDestroySurface");
    if (!_ptr) {
        _ptr = &_fail_eglDestroySurface;
    }
    _eglDestroySurface = _ptr;
    return _eglDestroySurface(dpy, surface);
}

PFN_EGLDESTROYSURFACE _eglDestroySurface = &_get_eglDestroySurface;

static EGLBoolean _fail_eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint * value) {
    const char *_name = "eglQuerySurface";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint * value) {
    PFN_EGLQUERYSURFACE _ptr;
    _ptr = (PFN_EGLQUERYSURFACE)_getPublicProcAddress("eglQuerySurface");
    if (!_ptr) {
        _ptr = &_fail_eglQuerySurface;
    }
    _eglQuerySurface = _ptr;
    return _eglQuerySurface(dpy, surface, attribute, value);
}

PFN_EGLQUERYSURFACE _eglQuerySurface = &_get_eglQuerySurface;

static EGLBoolean _fail_eglBindAPI(EGLenum api) {
    const char *_name = "eglBindAPI";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglBindAPI(EGLenum api) {
    PFN_EGLBINDAPI _ptr;
    _ptr = (PFN_EGLBINDAPI)_getPublicProcAddress("eglBindAPI");
    if (!_ptr) {
        _ptr = &_fail_eglBindAPI;
    }
    _eglBindAPI = _ptr;
    return _eglBindAPI(api);
}

PFN_EGLBINDAPI _eglBindAPI = &_get_eglBindAPI;

static EGLenum _fail_eglQueryAPI(void) {
    const char *_name = "eglQueryAPI";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLenum _get_eglQueryAPI(void) {
    PFN_EGLQUERYAPI _ptr;
    _ptr = (PFN_EGLQUERYAPI)_getPublicProcAddress("eglQueryAPI");
    if (!_ptr) {
        _ptr = &_fail_eglQueryAPI;
    }
    _eglQueryAPI = _ptr;
    return _eglQueryAPI();
}

PFN_EGLQUERYAPI _eglQueryAPI = &_get_eglQueryAPI;

static EGLBoolean _fail_eglWaitClient(void) {
    const char *_name = "eglWaitClient";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglWaitClient(void) {
    PFN_EGLWAITCLIENT _ptr;
    _ptr = (PFN_EGLWAITCLIENT)_getPublicProcAddress("eglWaitClient");
    if (!_ptr) {
        _ptr = &_fail_eglWaitClient;
    }
    _eglWaitClient = _ptr;
    return _eglWaitClient();
}

PFN_EGLWAITCLIENT _eglWaitClient = &_get_eglWaitClient;

static EGLBoolean _fail_eglReleaseThread(void) {
    const char *_name = "eglReleaseThread";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglReleaseThread(void) {
    PFN_EGLRELEASETHREAD _ptr;
    _ptr = (PFN_EGLRELEASETHREAD)_getPublicProcAddress("eglReleaseThread");
    if (!_ptr) {
        _ptr = &_fail_eglReleaseThread;
    }
    _eglReleaseThread = _ptr;
    return _eglReleaseThread();
}

PFN_EGLRELEASETHREAD _eglReleaseThread = &_get_eglReleaseThread;

static EGLSurface _fail_eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint * attrib_list) {
    const char *_name = "eglCreatePbufferFromClientBuffer";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLSurface _get_eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint * attrib_list) {
    PFN_EGLCREATEPBUFFERFROMCLIENTBUFFER _ptr;
    _ptr = (PFN_EGLCREATEPBUFFERFROMCLIENTBUFFER)_getPublicProcAddress("eglCreatePbufferFromClientBuffer");
    if (!_ptr) {
        _ptr = &_fail_eglCreatePbufferFromClientBuffer;
    }
    _eglCreatePbufferFromClientBuffer = _ptr;
    return _eglCreatePbufferFromClientBuffer(dpy, buftype, buffer, config, attrib_list);
}

PFN_EGLCREATEPBUFFERFROMCLIENTBUFFER _eglCreatePbufferFromClientBuffer = &_get_eglCreatePbufferFromClientBuffer;

static EGLBoolean _fail_eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value) {
    const char *_name = "eglSurfaceAttrib";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value) {
    PFN_EGLSURFACEATTRIB _ptr;
    _ptr = (PFN_EGLSURFACEATTRIB)_getPublicProcAddress("eglSurfaceAttrib");
    if (!_ptr) {
        _ptr = &_fail_eglSurfaceAttrib;
    }
    _eglSurfaceAttrib = _ptr;
    return _eglSurfaceAttrib(dpy, surface, attribute, value);
}

PFN_EGLSURFACEATTRIB _eglSurfaceAttrib = &_get_eglSurfaceAttrib;

static EGLBoolean _fail_eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer) {
    const char *_name = "eglBindTexImage";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer) {
    PFN_EGLBINDTEXIMAGE _ptr;
    _ptr = (PFN_EGLBINDTEXIMAGE)_getPublicProcAddress("eglBindTexImage");
    if (!_ptr) {
        _ptr = &_fail_eglBindTexImage;
    }
    _eglBindTexImage = _ptr;
    return _eglBindTexImage(dpy, surface, buffer);
}

PFN_EGLBINDTEXIMAGE _eglBindTexImage = &_get_eglBindTexImage;

static EGLBoolean _fail_eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer) {
    const char *_name = "eglReleaseTexImage";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer) {
    PFN_EGLRELEASETEXIMAGE _ptr;
    _ptr = (PFN_EGLRELEASETEXIMAGE)_getPublicProcAddress("eglReleaseTexImage");
    if (!_ptr) {
        _ptr = &_fail_eglReleaseTexImage;
    }
    _eglReleaseTexImage = _ptr;
    return _eglReleaseTexImage(dpy, surface, buffer);
}

PFN_EGLRELEASETEXIMAGE _eglReleaseTexImage = &_get_eglReleaseTexImage;

static EGLBoolean _fail_eglSwapInterval(EGLDisplay dpy, EGLint interval) {
    const char *_name = "eglSwapInterval";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglSwapInterval(EGLDisplay dpy, EGLint interval) {
    PFN_EGLSWAPINTERVAL _ptr;
    _ptr = (PFN_EGLSWAPINTERVAL)_getPublicProcAddress("eglSwapInterval");
    if (!_ptr) {
        _ptr = &_fail_eglSwapInterval;
    }
    _eglSwapInterval = _ptr;
    return _eglSwapInterval(dpy, interval);
}

PFN_EGLSWAPINTERVAL _eglSwapInterval = &_get_eglSwapInterval;

static EGLContext _fail_eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint * attrib_list) {
    const char *_name = "eglCreateContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLContext _get_eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint * attrib_list) {
    PFN_EGLCREATECONTEXT _ptr;
    _ptr = (PFN_EGLCREATECONTEXT)_getPublicProcAddress("eglCreateContext");
    if (!_ptr) {
        _ptr = &_fail_eglCreateContext;
    }
    _eglCreateContext = _ptr;
    return _eglCreateContext(dpy, config, share_context, attrib_list);
}

PFN_EGLCREATECONTEXT _eglCreateContext = &_get_eglCreateContext;

static EGLBoolean _fail_eglDestroyContext(EGLDisplay dpy, EGLContext ctx) {
    const char *_name = "eglDestroyContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglDestroyContext(EGLDisplay dpy, EGLContext ctx) {
    PFN_EGLDESTROYCONTEXT _ptr;
    _ptr = (PFN_EGLDESTROYCONTEXT)_getPublicProcAddress("eglDestroyContext");
    if (!_ptr) {
        _ptr = &_fail_eglDestroyContext;
    }
    _eglDestroyContext = _ptr;
    return _eglDestroyContext(dpy, ctx);
}

PFN_EGLDESTROYCONTEXT _eglDestroyContext = &_get_eglDestroyContext;

static EGLBoolean _fail_eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx) {
    const char *_name = "eglMakeCurrent";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx) {
    PFN_EGLMAKECURRENT _ptr;
    _ptr = (PFN_EGLMAKECURRENT)_getPublicProcAddress("eglMakeCurrent");
    if (!_ptr) {
        _ptr = &_fail_eglMakeCurrent;
    }
    _eglMakeCurrent = _ptr;
    return _eglMakeCurrent(dpy, draw, read, ctx);
}

PFN_EGLMAKECURRENT _eglMakeCurrent = &_get_eglMakeCurrent;

static EGLContext _fail_eglGetCurrentContext(void) {
    const char *_name = "eglGetCurrentContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLContext _get_eglGetCurrentContext(void) {
    PFN_EGLGETCURRENTCONTEXT _ptr;
    _ptr = (PFN_EGLGETCURRENTCONTEXT)_getPublicProcAddress("eglGetCurrentContext");
    if (!_ptr) {
        _ptr = &_fail_eglGetCurrentContext;
    }
    _eglGetCurrentContext = _ptr;
    return _eglGetCurrentContext();
}

PFN_EGLGETCURRENTCONTEXT _eglGetCurrentContext = &_get_eglGetCurrentContext;

static EGLSurface _fail_eglGetCurrentSurface(EGLint readdraw) {
    const char *_name = "eglGetCurrentSurface";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLSurface _get_eglGetCurrentSurface(EGLint readdraw) {
    PFN_EGLGETCURRENTSURFACE _ptr;
    _ptr = (PFN_EGLGETCURRENTSURFACE)_getPublicProcAddress("eglGetCurrentSurface");
    if (!_ptr) {
        _ptr = &_fail_eglGetCurrentSurface;
    }
    _eglGetCurrentSurface = _ptr;
    return _eglGetCurrentSurface(readdraw);
}

PFN_EGLGETCURRENTSURFACE _eglGetCurrentSurface = &_get_eglGetCurrentSurface;

static EGLDisplay _fail_eglGetCurrentDisplay(void) {
    const char *_name = "eglGetCurrentDisplay";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLDisplay _get_eglGetCurrentDisplay(void) {
    PFN_EGLGETCURRENTDISPLAY _ptr;
    _ptr = (PFN_EGLGETCURRENTDISPLAY)_getPublicProcAddress("eglGetCurrentDisplay");
    if (!_ptr) {
        _ptr = &_fail_eglGetCurrentDisplay;
    }
    _eglGetCurrentDisplay = _ptr;
    return _eglGetCurrentDisplay();
}

PFN_EGLGETCURRENTDISPLAY _eglGetCurrentDisplay = &_get_eglGetCurrentDisplay;

static EGLBoolean _fail_eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint * value) {
    const char *_name = "eglQueryContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint * value) {
    PFN_EGLQUERYCONTEXT _ptr;
    _ptr = (PFN_EGLQUERYCONTEXT)_getPublicProcAddress("eglQueryContext");
    if (!_ptr) {
        _ptr = &_fail_eglQueryContext;
    }
    _eglQueryContext = _ptr;
    return _eglQueryContext(dpy, ctx, attribute, value);
}

PFN_EGLQUERYCONTEXT _eglQueryContext = &_get_eglQueryContext;

static EGLBoolean _fail_eglWaitGL(void) {
    const char *_name = "eglWaitGL";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglWaitGL(void) {
    PFN_EGLWAITGL _ptr;
    _ptr = (PFN_EGLWAITGL)_getPublicProcAddress("eglWaitGL");
    if (!_ptr) {
        _ptr = &_fail_eglWaitGL;
    }
    _eglWaitGL = _ptr;
    return _eglWaitGL();
}

PFN_EGLWAITGL _eglWaitGL = &_get_eglWaitGL;

static EGLBoolean _fail_eglWaitNative(EGLint engine) {
    const char *_name = "eglWaitNative";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglWaitNative(EGLint engine) {
    PFN_EGLWAITNATIVE _ptr;
    _ptr = (PFN_EGLWAITNATIVE)_getPublicProcAddress("eglWaitNative");
    if (!_ptr) {
        _ptr = &_fail_eglWaitNative;
    }
    _eglWaitNative = _ptr;
    return _eglWaitNative(engine);
}

PFN_EGLWAITNATIVE _eglWaitNative = &_get_eglWaitNative;

static EGLBoolean _fail_eglSwapBuffers(EGLDisplay dpy, EGLSurface surface) {
    const char *_name = "eglSwapBuffers";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglSwapBuffers(EGLDisplay dpy, EGLSurface surface) {
    PFN_EGLSWAPBUFFERS _ptr;
    _ptr = (PFN_EGLSWAPBUFFERS)_getPublicProcAddress("eglSwapBuffers");
    if (!_ptr) {
        _ptr = &_fail_eglSwapBuffers;
    }
    _eglSwapBuffers = _ptr;
    return _eglSwapBuffers(dpy, surface);
}

PFN_EGLSWAPBUFFERS _eglSwapBuffers = &_get_eglSwapBuffers;

static EGLBoolean _fail_eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target) {
    const char *_name = "eglCopyBuffers";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target) {
    PFN_EGLCOPYBUFFERS _ptr;
    _ptr = (PFN_EGLCOPYBUFFERS)_getPublicProcAddress("eglCopyBuffers");
    if (!_ptr) {
        _ptr = &_fail_eglCopyBuffers;
    }
    _eglCopyBuffers = _ptr;
    return _eglCopyBuffers(dpy, surface, target);
}

PFN_EGLCOPYBUFFERS _eglCopyBuffers = &_get_eglCopyBuffers;

static __eglMustCastToProperFunctionPointerType _fail_eglGetProcAddress(const char * procname) {
    const char *_name = "eglGetProcAddress";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static __eglMustCastToProperFunctionPointerType _get_eglGetProcAddress(const char * procname) {
    PFN_EGLGETPROCADDRESS _ptr;
    _ptr = (PFN_EGLGETPROCADDRESS)_getPublicProcAddress("eglGetProcAddress");
    if (!_ptr) {
        _ptr = &_fail_eglGetProcAddress;
    }
    _eglGetProcAddress = _ptr;
    return _eglGetProcAddress(procname);
}

PFN_EGLGETPROCADDRESS _eglGetProcAddress = &_get_eglGetProcAddress;

static EGLDisplay GL_APIENTRY _fail_eglGetPlatformDisplayEXT(EGLenum platform, void * native_display, const EGLint * attrib_list) {
    const char *_name = "eglGetPlatformDisplayEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLDisplay GL_APIENTRY _get_eglGetPlatformDisplayEXT(EGLenum platform, void * native_display, const EGLint * attrib_list) {
    PFN_EGLGETPLATFORMDISPLAYEXT _ptr;
    _ptr = (PFN_EGLGETPLATFORMDISPLAYEXT)_getPrivateProcAddress("eglGetPlatformDisplayEXT");
    if (!_ptr) {
        _ptr = &_fail_eglGetPlatformDisplayEXT;
    }
    _eglGetPlatformDisplayEXT = _ptr;
    return _eglGetPlatformDisplayEXT(platform, native_display, attrib_list);
}

PFN_EGLGETPLATFORMDISPLAYEXT _eglGetPlatformDisplayEXT = &_get_eglGetPlatformDisplayEXT;

static EGLSurface GL_APIENTRY _fail_eglCreatePlatformWindowSurfaceEXT(EGLDisplay dpy, EGLConfig config, void * native_window, const EGLint * attrib_list) {
    const char *_name = "eglCreatePlatformWindowSurfaceEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLSurface GL_APIENTRY _get_eglCreatePlatformWindowSurfaceEXT(EGLDisplay dpy, EGLConfig config, void * native_window, const EGLint * attrib_list) {
    PFN_EGLCREATEPLATFORMWINDOWSURFACEEXT _ptr;
    _ptr = (PFN_EGLCREATEPLATFORMWINDOWSURFACEEXT)_getPrivateProcAddress("eglCreatePlatformWindowSurfaceEXT");
    if (!_ptr) {
        _ptr = &_fail_eglCreatePlatformWindowSurfaceEXT;
    }
    _eglCreatePlatformWindowSurfaceEXT = _ptr;
    return _eglCreatePlatformWindowSurfaceEXT(dpy, config, native_window, attrib_list);
}

PFN_EGLCREATEPLATFORMWINDOWSURFACEEXT _eglCreatePlatformWindowSurfaceEXT = &_get_eglCreatePlatformWindowSurfaceEXT;

static EGLSurface GL_APIENTRY _fail_eglCreatePlatformPixmapSurfaceEXT(EGLDisplay dpy, EGLConfig config, void * native_pixmap, const EGLint * attrib_list) {
    const char *_name = "eglCreatePlatformPixmapSurfaceEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLSurface GL_APIENTRY _get_eglCreatePlatformPixmapSurfaceEXT(EGLDisplay dpy, EGLConfig config, void * native_pixmap, const EGLint * attrib_list) {
    PFN_EGLCREATEPLATFORMPIXMAPSURFACEEXT _ptr;
    _ptr = (PFN_EGLCREATEPLATFORMPIXMAPSURFACEEXT)_getPrivateProcAddress("eglCreatePlatformPixmapSurfaceEXT");
    if (!_ptr) {
        _ptr = &_fail_eglCreatePlatformPixmapSurfaceEXT;
    }
    _eglCreatePlatformPixmapSurfaceEXT = _ptr;
    return _eglCreatePlatformPixmapSurfaceEXT(dpy, config, native_pixmap, attrib_list);
}

PFN_EGLCREATEPLATFORMPIXMAPSURFACEEXT _eglCreatePlatformPixmapSurfaceEXT = &_get_eglCreatePlatformPixmapSurfaceEXT;

static EGLBoolean _fail_eglLockSurfaceKHR(EGLDisplay display, EGLSurface surface, const EGLint * attrib_list) {
    const char *_name = "eglLockSurfaceKHR";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglLockSurfaceKHR(EGLDisplay display, EGLSurface surface, const EGLint * attrib_list) {
    PFN_EGLLOCKSURFACEKHR _ptr;
    _ptr = (PFN_EGLLOCKSURFACEKHR)_getPrivateProcAddress("eglLockSurfaceKHR");
    if (!_ptr) {
        _ptr = &_fail_eglLockSurfaceKHR;
    }
    _eglLockSurfaceKHR = _ptr;
    return _eglLockSurfaceKHR(display, surface, attrib_list);
}

PFN_EGLLOCKSURFACEKHR _eglLockSurfaceKHR = &_get_eglLockSurfaceKHR;

static EGLBoolean _fail_eglUnlockSurfaceKHR(EGLDisplay display, EGLSurface surface) {
    const char *_name = "eglUnlockSurfaceKHR";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglUnlockSurfaceKHR(EGLDisplay display, EGLSurface surface) {
    PFN_EGLUNLOCKSURFACEKHR _ptr;
    _ptr = (PFN_EGLUNLOCKSURFACEKHR)_getPrivateProcAddress("eglUnlockSurfaceKHR");
    if (!_ptr) {
        _ptr = &_fail_eglUnlockSurfaceKHR;
    }
    _eglUnlockSurfaceKHR = _ptr;
    return _eglUnlockSurfaceKHR(display, surface);
}

PFN_EGLUNLOCKSURFACEKHR _eglUnlockSurfaceKHR = &_get_eglUnlockSurfaceKHR;

static EGLImageKHR _fail_eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint * attrib_list) {
    const char *_name = "eglCreateImageKHR";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLImageKHR _get_eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint * attrib_list) {
    PFN_EGLCREATEIMAGEKHR _ptr;
    _ptr = (PFN_EGLCREATEIMAGEKHR)_getPrivateProcAddress("eglCreateImageKHR");
    if (!_ptr) {
        _ptr = &_fail_eglCreateImageKHR;
    }
    _eglCreateImageKHR = _ptr;
    return _eglCreateImageKHR(dpy, ctx, target, buffer, attrib_list);
}

PFN_EGLCREATEIMAGEKHR _eglCreateImageKHR = &_get_eglCreateImageKHR;

static EGLBoolean _fail_eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR image) {
    const char *_name = "eglDestroyImageKHR";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR image) {
    PFN_EGLDESTROYIMAGEKHR _ptr;
    _ptr = (PFN_EGLDESTROYIMAGEKHR)_getPrivateProcAddress("eglDestroyImageKHR");
    if (!_ptr) {
        _ptr = &_fail_eglDestroyImageKHR;
    }
    _eglDestroyImageKHR = _ptr;
    return _eglDestroyImageKHR(dpy, image);
}

PFN_EGLDESTROYIMAGEKHR _eglDestroyImageKHR = &_get_eglDestroyImageKHR;

static EGLSyncKHR _fail_eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint * attrib_list) {
    const char *_name = "eglCreateSyncKHR";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLSyncKHR _get_eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint * attrib_list) {
    PFN_EGLCREATESYNCKHR _ptr;
    _ptr = (PFN_EGLCREATESYNCKHR)_getPrivateProcAddress("eglCreateSyncKHR");
    if (!_ptr) {
        _ptr = &_fail_eglCreateSyncKHR;
    }
    _eglCreateSyncKHR = _ptr;
    return _eglCreateSyncKHR(dpy, type, attrib_list);
}

PFN_EGLCREATESYNCKHR _eglCreateSyncKHR = &_get_eglCreateSyncKHR;

static EGLBoolean _fail_eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR sync) {
    const char *_name = "eglDestroySyncKHR";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR sync) {
    PFN_EGLDESTROYSYNCKHR _ptr;
    _ptr = (PFN_EGLDESTROYSYNCKHR)_getPrivateProcAddress("eglDestroySyncKHR");
    if (!_ptr) {
        _ptr = &_fail_eglDestroySyncKHR;
    }
    _eglDestroySyncKHR = _ptr;
    return _eglDestroySyncKHR(dpy, sync);
}

PFN_EGLDESTROYSYNCKHR _eglDestroySyncKHR = &_get_eglDestroySyncKHR;

static EGLint _fail_eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags, EGLTimeKHR timeout) {
    const char *_name = "eglClientWaitSyncKHR";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLint _get_eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags, EGLTimeKHR timeout) {
    PFN_EGLCLIENTWAITSYNCKHR _ptr;
    _ptr = (PFN_EGLCLIENTWAITSYNCKHR)_getPrivateProcAddress("eglClientWaitSyncKHR");
    if (!_ptr) {
        _ptr = &_fail_eglClientWaitSyncKHR;
    }
    _eglClientWaitSyncKHR = _ptr;
    return _eglClientWaitSyncKHR(dpy, sync, flags, timeout);
}

PFN_EGLCLIENTWAITSYNCKHR _eglClientWaitSyncKHR = &_get_eglClientWaitSyncKHR;

static EGLBoolean _fail_eglSignalSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode) {
    const char *_name = "eglSignalSyncKHR";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglSignalSyncKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode) {
    PFN_EGLSIGNALSYNCKHR _ptr;
    _ptr = (PFN_EGLSIGNALSYNCKHR)_getPrivateProcAddress("eglSignalSyncKHR");
    if (!_ptr) {
        _ptr = &_fail_eglSignalSyncKHR;
    }
    _eglSignalSyncKHR = _ptr;
    return _eglSignalSyncKHR(dpy, sync, mode);
}

PFN_EGLSIGNALSYNCKHR _eglSignalSyncKHR = &_get_eglSignalSyncKHR;

static EGLBoolean _fail_eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint attribute, EGLint * value) {
    const char *_name = "eglGetSyncAttribKHR";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync, EGLint attribute, EGLint * value) {
    PFN_EGLGETSYNCATTRIBKHR _ptr;
    _ptr = (PFN_EGLGETSYNCATTRIBKHR)_getPrivateProcAddress("eglGetSyncAttribKHR");
    if (!_ptr) {
        _ptr = &_fail_eglGetSyncAttribKHR;
    }
    _eglGetSyncAttribKHR = _ptr;
    return _eglGetSyncAttribKHR(dpy, sync, attribute, value);
}

PFN_EGLGETSYNCATTRIBKHR _eglGetSyncAttribKHR = &_get_eglGetSyncAttribKHR;

static EGLSyncNV _fail_eglCreateFenceSyncNV(EGLDisplay dpy, EGLenum condition, const EGLint * attrib_list) {
    const char *_name = "eglCreateFenceSyncNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLSyncNV _get_eglCreateFenceSyncNV(EGLDisplay dpy, EGLenum condition, const EGLint * attrib_list) {
    PFN_EGLCREATEFENCESYNCNV _ptr;
    _ptr = (PFN_EGLCREATEFENCESYNCNV)_getPrivateProcAddress("eglCreateFenceSyncNV");
    if (!_ptr) {
        _ptr = &_fail_eglCreateFenceSyncNV;
    }
    _eglCreateFenceSyncNV = _ptr;
    return _eglCreateFenceSyncNV(dpy, condition, attrib_list);
}

PFN_EGLCREATEFENCESYNCNV _eglCreateFenceSyncNV = &_get_eglCreateFenceSyncNV;

static EGLBoolean _fail_eglDestroySyncNV(EGLSyncNV sync) {
    const char *_name = "eglDestroySyncNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglDestroySyncNV(EGLSyncNV sync) {
    PFN_EGLDESTROYSYNCNV _ptr;
    _ptr = (PFN_EGLDESTROYSYNCNV)_getPrivateProcAddress("eglDestroySyncNV");
    if (!_ptr) {
        _ptr = &_fail_eglDestroySyncNV;
    }
    _eglDestroySyncNV = _ptr;
    return _eglDestroySyncNV(sync);
}

PFN_EGLDESTROYSYNCNV _eglDestroySyncNV = &_get_eglDestroySyncNV;

static EGLBoolean _fail_eglFenceNV(EGLSyncNV sync) {
    const char *_name = "eglFenceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglFenceNV(EGLSyncNV sync) {
    PFN_EGLFENCENV _ptr;
    _ptr = (PFN_EGLFENCENV)_getPrivateProcAddress("eglFenceNV");
    if (!_ptr) {
        _ptr = &_fail_eglFenceNV;
    }
    _eglFenceNV = _ptr;
    return _eglFenceNV(sync);
}

PFN_EGLFENCENV _eglFenceNV = &_get_eglFenceNV;

static EGLint _fail_eglClientWaitSyncNV(EGLSyncNV sync, EGLint flags, EGLTimeNV timeout) {
    const char *_name = "eglClientWaitSyncNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLint _get_eglClientWaitSyncNV(EGLSyncNV sync, EGLint flags, EGLTimeNV timeout) {
    PFN_EGLCLIENTWAITSYNCNV _ptr;
    _ptr = (PFN_EGLCLIENTWAITSYNCNV)_getPrivateProcAddress("eglClientWaitSyncNV");
    if (!_ptr) {
        _ptr = &_fail_eglClientWaitSyncNV;
    }
    _eglClientWaitSyncNV = _ptr;
    return _eglClientWaitSyncNV(sync, flags, timeout);
}

PFN_EGLCLIENTWAITSYNCNV _eglClientWaitSyncNV = &_get_eglClientWaitSyncNV;

static EGLBoolean _fail_eglSignalSyncNV(EGLSyncNV sync, EGLenum mode) {
    const char *_name = "eglSignalSyncNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglSignalSyncNV(EGLSyncNV sync, EGLenum mode) {
    PFN_EGLSIGNALSYNCNV _ptr;
    _ptr = (PFN_EGLSIGNALSYNCNV)_getPrivateProcAddress("eglSignalSyncNV");
    if (!_ptr) {
        _ptr = &_fail_eglSignalSyncNV;
    }
    _eglSignalSyncNV = _ptr;
    return _eglSignalSyncNV(sync, mode);
}

PFN_EGLSIGNALSYNCNV _eglSignalSyncNV = &_get_eglSignalSyncNV;

static EGLBoolean _fail_eglGetSyncAttribNV(EGLSyncNV sync, EGLint attribute, EGLint * value) {
    const char *_name = "eglGetSyncAttribNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglGetSyncAttribNV(EGLSyncNV sync, EGLint attribute, EGLint * value) {
    PFN_EGLGETSYNCATTRIBNV _ptr;
    _ptr = (PFN_EGLGETSYNCATTRIBNV)_getPrivateProcAddress("eglGetSyncAttribNV");
    if (!_ptr) {
        _ptr = &_fail_eglGetSyncAttribNV;
    }
    _eglGetSyncAttribNV = _ptr;
    return _eglGetSyncAttribNV(sync, attribute, value);
}

PFN_EGLGETSYNCATTRIBNV _eglGetSyncAttribNV = &_get_eglGetSyncAttribNV;

static EGLSurface _fail_eglCreatePixmapSurfaceHI(EGLDisplay dpy, EGLConfig config, struct EGLClientPixmapHI * pixmap) {
    const char *_name = "eglCreatePixmapSurfaceHI";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLSurface _get_eglCreatePixmapSurfaceHI(EGLDisplay dpy, EGLConfig config, struct EGLClientPixmapHI * pixmap) {
    PFN_EGLCREATEPIXMAPSURFACEHI _ptr;
    _ptr = (PFN_EGLCREATEPIXMAPSURFACEHI)_getPrivateProcAddress("eglCreatePixmapSurfaceHI");
    if (!_ptr) {
        _ptr = &_fail_eglCreatePixmapSurfaceHI;
    }
    _eglCreatePixmapSurfaceHI = _ptr;
    return _eglCreatePixmapSurfaceHI(dpy, config, pixmap);
}

PFN_EGLCREATEPIXMAPSURFACEHI _eglCreatePixmapSurfaceHI = &_get_eglCreatePixmapSurfaceHI;

static EGLImageKHR _fail_eglCreateDRMImageMESA(EGLDisplay dpy, const EGLint * attrib_list) {
    const char *_name = "eglCreateDRMImageMESA";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLImageKHR _get_eglCreateDRMImageMESA(EGLDisplay dpy, const EGLint * attrib_list) {
    PFN_EGLCREATEDRMIMAGEMESA _ptr;
    _ptr = (PFN_EGLCREATEDRMIMAGEMESA)_getPrivateProcAddress("eglCreateDRMImageMESA");
    if (!_ptr) {
        _ptr = &_fail_eglCreateDRMImageMESA;
    }
    _eglCreateDRMImageMESA = _ptr;
    return _eglCreateDRMImageMESA(dpy, attrib_list);
}

PFN_EGLCREATEDRMIMAGEMESA _eglCreateDRMImageMESA = &_get_eglCreateDRMImageMESA;

static EGLBoolean _fail_eglExportDRMImageMESA(EGLDisplay dpy, EGLImageKHR image, EGLint * name, EGLint * handle, EGLint * stride) {
    const char *_name = "eglExportDRMImageMESA";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglExportDRMImageMESA(EGLDisplay dpy, EGLImageKHR image, EGLint * name, EGLint * handle, EGLint * stride) {
    PFN_EGLEXPORTDRMIMAGEMESA _ptr;
    _ptr = (PFN_EGLEXPORTDRMIMAGEMESA)_getPrivateProcAddress("eglExportDRMImageMESA");
    if (!_ptr) {
        _ptr = &_fail_eglExportDRMImageMESA;
    }
    _eglExportDRMImageMESA = _ptr;
    return _eglExportDRMImageMESA(dpy, image, name, handle, stride);
}

PFN_EGLEXPORTDRMIMAGEMESA _eglExportDRMImageMESA = &_get_eglExportDRMImageMESA;

static EGLBoolean _fail_eglPostSubBufferNV(EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height) {
    const char *_name = "eglPostSubBufferNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglPostSubBufferNV(EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height) {
    PFN_EGLPOSTSUBBUFFERNV _ptr;
    _ptr = (PFN_EGLPOSTSUBBUFFERNV)_getPrivateProcAddress("eglPostSubBufferNV");
    if (!_ptr) {
        _ptr = &_fail_eglPostSubBufferNV;
    }
    _eglPostSubBufferNV = _ptr;
    return _eglPostSubBufferNV(dpy, surface, x, y, width, height);
}

PFN_EGLPOSTSUBBUFFERNV _eglPostSubBufferNV = &_get_eglPostSubBufferNV;

static EGLBoolean _fail_eglQuerySurfacePointerANGLE(EGLDisplay dpy, EGLSurface surface, EGLint attribute, void * * value) {
    const char *_name = "eglQuerySurfacePointerANGLE";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLBoolean _get_eglQuerySurfacePointerANGLE(EGLDisplay dpy, EGLSurface surface, EGLint attribute, void * * value) {
    PFN_EGLQUERYSURFACEPOINTERANGLE _ptr;
    _ptr = (PFN_EGLQUERYSURFACEPOINTERANGLE)_getPrivateProcAddress("eglQuerySurfacePointerANGLE");
    if (!_ptr) {
        _ptr = &_fail_eglQuerySurfacePointerANGLE;
    }
    _eglQuerySurfacePointerANGLE = _ptr;
    return _eglQuerySurfacePointerANGLE(dpy, surface, attribute, value);
}

PFN_EGLQUERYSURFACEPOINTERANGLE _eglQuerySurfacePointerANGLE = &_get_eglQuerySurfacePointerANGLE;

static EGLuint64NV _fail_eglGetSystemTimeFrequencyNV(void) {
    const char *_name = "eglGetSystemTimeFrequencyNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLuint64NV _get_eglGetSystemTimeFrequencyNV(void) {
    PFN_EGLGETSYSTEMTIMEFREQUENCYNV _ptr;
    _ptr = (PFN_EGLGETSYSTEMTIMEFREQUENCYNV)_getPrivateProcAddress("eglGetSystemTimeFrequencyNV");
    if (!_ptr) {
        _ptr = &_fail_eglGetSystemTimeFrequencyNV;
    }
    _eglGetSystemTimeFrequencyNV = _ptr;
    return _eglGetSystemTimeFrequencyNV();
}

PFN_EGLGETSYSTEMTIMEFREQUENCYNV _eglGetSystemTimeFrequencyNV = &_get_eglGetSystemTimeFrequencyNV;

static EGLuint64NV _fail_eglGetSystemTimeNV(void) {
    const char *_name = "eglGetSystemTimeNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static EGLuint64NV _get_eglGetSystemTimeNV(void) {
    PFN_EGLGETSYSTEMTIMENV _ptr;
    _ptr = (PFN_EGLGETSYSTEMTIMENV)_getPrivateProcAddress("eglGetSystemTimeNV");
    if (!_ptr) {
        _ptr = &_fail_eglGetSystemTimeNV;
    }
    _eglGetSystemTimeNV = _ptr;
    return _eglGetSystemTimeNV();
}

PFN_EGLGETSYSTEMTIMENV _eglGetSystemTimeNV = &_get_eglGetSystemTimeNV;

static void GL_APIENTRY _fail_glEGLImageTargetTexture2DOES(GLenum target, EGLImageKHR image) {
    const char *_name = "glEGLImageTargetTexture2DOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void GL_APIENTRY _get_glEGLImageTargetTexture2DOES(GLenum target, EGLImageKHR image) {
    PFN_GLEGLIMAGETARGETTEXTURE2DOES _ptr;
    _ptr = (PFN_GLEGLIMAGETARGETTEXTURE2DOES)_getPrivateProcAddress("glEGLImageTargetTexture2DOES");
    if (!_ptr) {
        _ptr = &_fail_glEGLImageTargetTexture2DOES;
    }
    _glEGLImageTargetTexture2DOES = _ptr;
    _glEGLImageTargetTexture2DOES(target, image);
}

PFN_GLEGLIMAGETARGETTEXTURE2DOES _glEGLImageTargetTexture2DOES = &_get_glEGLImageTargetTexture2DOES;

static void GL_APIENTRY _fail_glEGLImageTargetRenderbufferStorageOES(GLenum target, EGLImageKHR image) {
    const char *_name = "glEGLImageTargetRenderbufferStorageOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void GL_APIENTRY _get_glEGLImageTargetRenderbufferStorageOES(GLenum target, EGLImageKHR image) {
    PFN_GLEGLIMAGETARGETRENDERBUFFERSTORAGEOES _ptr;
    _ptr = (PFN_GLEGLIMAGETARGETRENDERBUFFERSTORAGEOES)_getPrivateProcAddress("glEGLImageTargetRenderbufferStorageOES");
    if (!_ptr) {
        _ptr = &_fail_glEGLImageTargetRenderbufferStorageOES;
    }
    _glEGLImageTargetRenderbufferStorageOES = _ptr;
    _glEGLImageTargetRenderbufferStorageOES(target, image);
}

PFN_GLEGLIMAGETARGETRENDERBUFFERSTORAGEOES _glEGLImageTargetRenderbufferStorageOES = &_get_glEGLImageTargetRenderbufferStorageOES;


#if defined(_WIN32)

static HGLRC __stdcall _fail_wglCreateContext(HDC hdc) {
    const char *_name = "wglCreateContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static HGLRC __stdcall _get_wglCreateContext(HDC hdc) {
    PFN_WGLCREATECONTEXT _ptr;
    _ptr = (PFN_WGLCREATECONTEXT)_getPublicProcAddress("wglCreateContext");
    if (!_ptr) {
        _ptr = &_fail_wglCreateContext;
    }
    _wglCreateContext = _ptr;
    return _wglCreateContext(hdc);
}

PFN_WGLCREATECONTEXT _wglCreateContext = &_get_wglCreateContext;

static BOOL __stdcall _fail_wglDeleteContext(HGLRC hglrc) {
    const char *_name = "wglDeleteContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglDeleteContext(HGLRC hglrc) {
    PFN_WGLDELETECONTEXT _ptr;
    _ptr = (PFN_WGLDELETECONTEXT)_getPublicProcAddress("wglDeleteContext");
    if (!_ptr) {
        _ptr = &_fail_wglDeleteContext;
    }
    _wglDeleteContext = _ptr;
    return _wglDeleteContext(hglrc);
}

PFN_WGLDELETECONTEXT _wglDeleteContext = &_get_wglDeleteContext;

static HGLRC __stdcall _fail_wglGetCurrentContext(void) {
    const char *_name = "wglGetCurrentContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static HGLRC __stdcall _get_wglGetCurrentContext(void) {
    PFN_WGLGETCURRENTCONTEXT _ptr;
    _ptr = (PFN_WGLGETCURRENTCONTEXT)_getPublicProcAddress("wglGetCurrentContext");
    if (!_ptr) {
        _ptr = &_fail_wglGetCurrentContext;
    }
    _wglGetCurrentContext = _ptr;
    return _wglGetCurrentContext();
}

PFN_WGLGETCURRENTCONTEXT _wglGetCurrentContext = &_get_wglGetCurrentContext;

static BOOL __stdcall _fail_wglMakeCurrent(HDC hdc, HGLRC hglrc) {
    const char *_name = "wglMakeCurrent";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglMakeCurrent(HDC hdc, HGLRC hglrc) {
    PFN_WGLMAKECURRENT _ptr;
    _ptr = (PFN_WGLMAKECURRENT)_getPublicProcAddress("wglMakeCurrent");
    if (!_ptr) {
        _ptr = &_fail_wglMakeCurrent;
    }
    _wglMakeCurrent = _ptr;
    return _wglMakeCurrent(hdc, hglrc);
}

PFN_WGLMAKECURRENT _wglMakeCurrent = &_get_wglMakeCurrent;

static BOOL __stdcall _fail_wglCopyContext(HGLRC hglrcSrc, HGLRC hglrcDst, UINT mask) {
    const char *_name = "wglCopyContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglCopyContext(HGLRC hglrcSrc, HGLRC hglrcDst, UINT mask) {
    PFN_WGLCOPYCONTEXT _ptr;
    _ptr = (PFN_WGLCOPYCONTEXT)_getPublicProcAddress("wglCopyContext");
    if (!_ptr) {
        _ptr = &_fail_wglCopyContext;
    }
    _wglCopyContext = _ptr;
    return _wglCopyContext(hglrcSrc, hglrcDst, mask);
}

PFN_WGLCOPYCONTEXT _wglCopyContext = &_get_wglCopyContext;

static int __stdcall _fail_wglChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR * ppfd) {
    const char *_name = "wglChoosePixelFormat";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int __stdcall _get_wglChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR * ppfd) {
    PFN_WGLCHOOSEPIXELFORMAT _ptr;
    _ptr = (PFN_WGLCHOOSEPIXELFORMAT)_getPublicProcAddress("wglChoosePixelFormat");
    if (!_ptr) {
        _ptr = &_fail_wglChoosePixelFormat;
    }
    _wglChoosePixelFormat = _ptr;
    return _wglChoosePixelFormat(hdc, ppfd);
}

PFN_WGLCHOOSEPIXELFORMAT _wglChoosePixelFormat = &_get_wglChoosePixelFormat;

static int __stdcall _fail_wglDescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, PIXELFORMATDESCRIPTOR * ppfd) {
    const char *_name = "wglDescribePixelFormat";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int __stdcall _get_wglDescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, PIXELFORMATDESCRIPTOR * ppfd) {
    PFN_WGLDESCRIBEPIXELFORMAT _ptr;
    _ptr = (PFN_WGLDESCRIBEPIXELFORMAT)_getPublicProcAddress("wglDescribePixelFormat");
    if (!_ptr) {
        _ptr = &_fail_wglDescribePixelFormat;
    }
    _wglDescribePixelFormat = _ptr;
    return _wglDescribePixelFormat(hdc, iPixelFormat, nBytes, ppfd);
}

PFN_WGLDESCRIBEPIXELFORMAT _wglDescribePixelFormat = &_get_wglDescribePixelFormat;

static HDC __stdcall _fail_wglGetCurrentDC(void) {
    const char *_name = "wglGetCurrentDC";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static HDC __stdcall _get_wglGetCurrentDC(void) {
    PFN_WGLGETCURRENTDC _ptr;
    _ptr = (PFN_WGLGETCURRENTDC)_getPublicProcAddress("wglGetCurrentDC");
    if (!_ptr) {
        _ptr = &_fail_wglGetCurrentDC;
    }
    _wglGetCurrentDC = _ptr;
    return _wglGetCurrentDC();
}

PFN_WGLGETCURRENTDC _wglGetCurrentDC = &_get_wglGetCurrentDC;

static PROC __stdcall _fail_wglGetDefaultProcAddress(const char * lpszProc) {
    const char *_name = "wglGetDefaultProcAddress";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static PROC __stdcall _get_wglGetDefaultProcAddress(const char * lpszProc) {
    PFN_WGLGETDEFAULTPROCADDRESS _ptr;
    _ptr = (PFN_WGLGETDEFAULTPROCADDRESS)_getPublicProcAddress("wglGetDefaultProcAddress");
    if (!_ptr) {
        _ptr = &_fail_wglGetDefaultProcAddress;
    }
    _wglGetDefaultProcAddress = _ptr;
    return _wglGetDefaultProcAddress(lpszProc);
}

PFN_WGLGETDEFAULTPROCADDRESS _wglGetDefaultProcAddress = &_get_wglGetDefaultProcAddress;

static int __stdcall _fail_wglGetPixelFormat(HDC hdc) {
    const char *_name = "wglGetPixelFormat";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int __stdcall _get_wglGetPixelFormat(HDC hdc) {
    PFN_WGLGETPIXELFORMAT _ptr;
    _ptr = (PFN_WGLGETPIXELFORMAT)_getPublicProcAddress("wglGetPixelFormat");
    if (!_ptr) {
        _ptr = &_fail_wglGetPixelFormat;
    }
    _wglGetPixelFormat = _ptr;
    return _wglGetPixelFormat(hdc);
}

PFN_WGLGETPIXELFORMAT _wglGetPixelFormat = &_get_wglGetPixelFormat;

static BOOL __stdcall _fail_wglSetPixelFormat(HDC hdc, int iPixelFormat, const PIXELFORMATDESCRIPTOR * ppfd) {
    const char *_name = "wglSetPixelFormat";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglSetPixelFormat(HDC hdc, int iPixelFormat, const PIXELFORMATDESCRIPTOR * ppfd) {
    PFN_WGLSETPIXELFORMAT _ptr;
    _ptr = (PFN_WGLSETPIXELFORMAT)_getPublicProcAddress("wglSetPixelFormat");
    if (!_ptr) {
        _ptr = &_fail_wglSetPixelFormat;
    }
    _wglSetPixelFormat = _ptr;
    return _wglSetPixelFormat(hdc, iPixelFormat, ppfd);
}

PFN_WGLSETPIXELFORMAT _wglSetPixelFormat = &_get_wglSetPixelFormat;

static BOOL __stdcall _fail_wglSwapBuffers(HDC hdc) {
    const char *_name = "wglSwapBuffers";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglSwapBuffers(HDC hdc) {
    PFN_WGLSWAPBUFFERS _ptr;
    _ptr = (PFN_WGLSWAPBUFFERS)_getPublicProcAddress("wglSwapBuffers");
    if (!_ptr) {
        _ptr = &_fail_wglSwapBuffers;
    }
    _wglSwapBuffers = _ptr;
    return _wglSwapBuffers(hdc);
}

PFN_WGLSWAPBUFFERS _wglSwapBuffers = &_get_wglSwapBuffers;

static BOOL __stdcall _fail_wglShareLists(HGLRC hglrc1, HGLRC hglrc2) {
    const char *_name = "wglShareLists";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglShareLists(HGLRC hglrc1, HGLRC hglrc2) {
    PFN_WGLSHARELISTS _ptr;
    _ptr = (PFN_WGLSHARELISTS)_getPublicProcAddress("wglShareLists");
    if (!_ptr) {
        _ptr = &_fail_wglShareLists;
    }
    _wglShareLists = _ptr;
    return _wglShareLists(hglrc1, hglrc2);
}

PFN_WGLSHARELISTS _wglShareLists = &_get_wglShareLists;

static HGLRC __stdcall _fail_wglCreateLayerContext(HDC hdc, int iLayerPlane) {
    const char *_name = "wglCreateLayerContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static HGLRC __stdcall _get_wglCreateLayerContext(HDC hdc, int iLayerPlane) {
    PFN_WGLCREATELAYERCONTEXT _ptr;
    _ptr = (PFN_WGLCREATELAYERCONTEXT)_getPublicProcAddress("wglCreateLayerContext");
    if (!_ptr) {
        _ptr = &_fail_wglCreateLayerContext;
    }
    _wglCreateLayerContext = _ptr;
    return _wglCreateLayerContext(hdc, iLayerPlane);
}

PFN_WGLCREATELAYERCONTEXT _wglCreateLayerContext = &_get_wglCreateLayerContext;

static BOOL __stdcall _fail_wglDescribeLayerPlane(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nBytes, LAYERPLANEDESCRIPTOR * plpd) {
    const char *_name = "wglDescribeLayerPlane";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglDescribeLayerPlane(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nBytes, LAYERPLANEDESCRIPTOR * plpd) {
    PFN_WGLDESCRIBELAYERPLANE _ptr;
    _ptr = (PFN_WGLDESCRIBELAYERPLANE)_getPublicProcAddress("wglDescribeLayerPlane");
    if (!_ptr) {
        _ptr = &_fail_wglDescribeLayerPlane;
    }
    _wglDescribeLayerPlane = _ptr;
    return _wglDescribeLayerPlane(hdc, iPixelFormat, iLayerPlane, nBytes, plpd);
}

PFN_WGLDESCRIBELAYERPLANE _wglDescribeLayerPlane = &_get_wglDescribeLayerPlane;

static int __stdcall _fail_wglSetLayerPaletteEntries(HDC hdc, int iLayerPlane, int iStart, int cEntries, const COLORREF * pcr) {
    const char *_name = "wglSetLayerPaletteEntries";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int __stdcall _get_wglSetLayerPaletteEntries(HDC hdc, int iLayerPlane, int iStart, int cEntries, const COLORREF * pcr) {
    PFN_WGLSETLAYERPALETTEENTRIES _ptr;
    _ptr = (PFN_WGLSETLAYERPALETTEENTRIES)_getPublicProcAddress("wglSetLayerPaletteEntries");
    if (!_ptr) {
        _ptr = &_fail_wglSetLayerPaletteEntries;
    }
    _wglSetLayerPaletteEntries = _ptr;
    return _wglSetLayerPaletteEntries(hdc, iLayerPlane, iStart, cEntries, pcr);
}

PFN_WGLSETLAYERPALETTEENTRIES _wglSetLayerPaletteEntries = &_get_wglSetLayerPaletteEntries;

static int __stdcall _fail_wglGetLayerPaletteEntries(HDC hdc, int iLayerPlane, int iStart, int cEntries, COLORREF * pcr) {
    const char *_name = "wglGetLayerPaletteEntries";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int __stdcall _get_wglGetLayerPaletteEntries(HDC hdc, int iLayerPlane, int iStart, int cEntries, COLORREF * pcr) {
    PFN_WGLGETLAYERPALETTEENTRIES _ptr;
    _ptr = (PFN_WGLGETLAYERPALETTEENTRIES)_getPublicProcAddress("wglGetLayerPaletteEntries");
    if (!_ptr) {
        _ptr = &_fail_wglGetLayerPaletteEntries;
    }
    _wglGetLayerPaletteEntries = _ptr;
    return _wglGetLayerPaletteEntries(hdc, iLayerPlane, iStart, cEntries, pcr);
}

PFN_WGLGETLAYERPALETTEENTRIES _wglGetLayerPaletteEntries = &_get_wglGetLayerPaletteEntries;

static BOOL __stdcall _fail_wglRealizeLayerPalette(HDC hdc, int iLayerPlane, BOOL bRealize) {
    const char *_name = "wglRealizeLayerPalette";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglRealizeLayerPalette(HDC hdc, int iLayerPlane, BOOL bRealize) {
    PFN_WGLREALIZELAYERPALETTE _ptr;
    _ptr = (PFN_WGLREALIZELAYERPALETTE)_getPublicProcAddress("wglRealizeLayerPalette");
    if (!_ptr) {
        _ptr = &_fail_wglRealizeLayerPalette;
    }
    _wglRealizeLayerPalette = _ptr;
    return _wglRealizeLayerPalette(hdc, iLayerPlane, bRealize);
}

PFN_WGLREALIZELAYERPALETTE _wglRealizeLayerPalette = &_get_wglRealizeLayerPalette;

static BOOL __stdcall _fail_wglSwapLayerBuffers(HDC hdc, UINT fuPlanes) {
    const char *_name = "wglSwapLayerBuffers";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglSwapLayerBuffers(HDC hdc, UINT fuPlanes) {
    PFN_WGLSWAPLAYERBUFFERS _ptr;
    _ptr = (PFN_WGLSWAPLAYERBUFFERS)_getPublicProcAddress("wglSwapLayerBuffers");
    if (!_ptr) {
        _ptr = &_fail_wglSwapLayerBuffers;
    }
    _wglSwapLayerBuffers = _ptr;
    return _wglSwapLayerBuffers(hdc, fuPlanes);
}

PFN_WGLSWAPLAYERBUFFERS _wglSwapLayerBuffers = &_get_wglSwapLayerBuffers;

static BOOL __stdcall _fail_wglUseFontBitmapsA(HDC hdc, DWORD first, DWORD count, DWORD listBase) {
    const char *_name = "wglUseFontBitmapsA";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglUseFontBitmapsA(HDC hdc, DWORD first, DWORD count, DWORD listBase) {
    PFN_WGLUSEFONTBITMAPSA _ptr;
    _ptr = (PFN_WGLUSEFONTBITMAPSA)_getPublicProcAddress("wglUseFontBitmapsA");
    if (!_ptr) {
        _ptr = &_fail_wglUseFontBitmapsA;
    }
    _wglUseFontBitmapsA = _ptr;
    return _wglUseFontBitmapsA(hdc, first, count, listBase);
}

PFN_WGLUSEFONTBITMAPSA _wglUseFontBitmapsA = &_get_wglUseFontBitmapsA;

static BOOL __stdcall _fail_wglUseFontBitmapsW(HDC hdc, DWORD first, DWORD count, DWORD listBase) {
    const char *_name = "wglUseFontBitmapsW";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglUseFontBitmapsW(HDC hdc, DWORD first, DWORD count, DWORD listBase) {
    PFN_WGLUSEFONTBITMAPSW _ptr;
    _ptr = (PFN_WGLUSEFONTBITMAPSW)_getPublicProcAddress("wglUseFontBitmapsW");
    if (!_ptr) {
        _ptr = &_fail_wglUseFontBitmapsW;
    }
    _wglUseFontBitmapsW = _ptr;
    return _wglUseFontBitmapsW(hdc, first, count, listBase);
}

PFN_WGLUSEFONTBITMAPSW _wglUseFontBitmapsW = &_get_wglUseFontBitmapsW;

static DWORD __stdcall _fail_wglSwapMultipleBuffers(UINT n, const WGLSWAP * ps) {
    const char *_name = "wglSwapMultipleBuffers";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static DWORD __stdcall _get_wglSwapMultipleBuffers(UINT n, const WGLSWAP * ps) {
    PFN_WGLSWAPMULTIPLEBUFFERS _ptr;
    _ptr = (PFN_WGLSWAPMULTIPLEBUFFERS)_getPublicProcAddress("wglSwapMultipleBuffers");
    if (!_ptr) {
        _ptr = &_fail_wglSwapMultipleBuffers;
    }
    _wglSwapMultipleBuffers = _ptr;
    return _wglSwapMultipleBuffers(n, ps);
}

PFN_WGLSWAPMULTIPLEBUFFERS _wglSwapMultipleBuffers = &_get_wglSwapMultipleBuffers;

static BOOL __stdcall _fail_wglUseFontOutlinesA(HDC hdc, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, GLYPHMETRICSFLOAT * lpgmf) {
    const char *_name = "wglUseFontOutlinesA";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglUseFontOutlinesA(HDC hdc, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, GLYPHMETRICSFLOAT * lpgmf) {
    PFN_WGLUSEFONTOUTLINESA _ptr;
    _ptr = (PFN_WGLUSEFONTOUTLINESA)_getPublicProcAddress("wglUseFontOutlinesA");
    if (!_ptr) {
        _ptr = &_fail_wglUseFontOutlinesA;
    }
    _wglUseFontOutlinesA = _ptr;
    return _wglUseFontOutlinesA(hdc, first, count, listBase, deviation, extrusion, format, lpgmf);
}

PFN_WGLUSEFONTOUTLINESA _wglUseFontOutlinesA = &_get_wglUseFontOutlinesA;

static BOOL __stdcall _fail_wglUseFontOutlinesW(HDC hdc, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, GLYPHMETRICSFLOAT * lpgmf) {
    const char *_name = "wglUseFontOutlinesW";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglUseFontOutlinesW(HDC hdc, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, GLYPHMETRICSFLOAT * lpgmf) {
    PFN_WGLUSEFONTOUTLINESW _ptr;
    _ptr = (PFN_WGLUSEFONTOUTLINESW)_getPublicProcAddress("wglUseFontOutlinesW");
    if (!_ptr) {
        _ptr = &_fail_wglUseFontOutlinesW;
    }
    _wglUseFontOutlinesW = _ptr;
    return _wglUseFontOutlinesW(hdc, first, count, listBase, deviation, extrusion, format, lpgmf);
}

PFN_WGLUSEFONTOUTLINESW _wglUseFontOutlinesW = &_get_wglUseFontOutlinesW;

static HANDLE __stdcall _fail_wglCreateBufferRegionARB(HDC hDC, int iLayerPlane, UINT uType) {
    const char *_name = "wglCreateBufferRegionARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static HANDLE __stdcall _get_wglCreateBufferRegionARB(HDC hDC, int iLayerPlane, UINT uType) {
    PFN_WGLCREATEBUFFERREGIONARB _ptr;
    _ptr = (PFN_WGLCREATEBUFFERREGIONARB)_getPrivateProcAddress("wglCreateBufferRegionARB");
    if (!_ptr) {
        _ptr = &_fail_wglCreateBufferRegionARB;
    }
    _wglCreateBufferRegionARB = _ptr;
    return _wglCreateBufferRegionARB(hDC, iLayerPlane, uType);
}

PFN_WGLCREATEBUFFERREGIONARB _wglCreateBufferRegionARB = &_get_wglCreateBufferRegionARB;

static void __stdcall _fail_wglDeleteBufferRegionARB(HANDLE hRegion) {
    const char *_name = "wglDeleteBufferRegionARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void __stdcall _get_wglDeleteBufferRegionARB(HANDLE hRegion) {
    PFN_WGLDELETEBUFFERREGIONARB _ptr;
    _ptr = (PFN_WGLDELETEBUFFERREGIONARB)_getPrivateProcAddress("wglDeleteBufferRegionARB");
    if (!_ptr) {
        _ptr = &_fail_wglDeleteBufferRegionARB;
    }
    _wglDeleteBufferRegionARB = _ptr;
    _wglDeleteBufferRegionARB(hRegion);
}

PFN_WGLDELETEBUFFERREGIONARB _wglDeleteBufferRegionARB = &_get_wglDeleteBufferRegionARB;

static BOOL __stdcall _fail_wglSaveBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height) {
    const char *_name = "wglSaveBufferRegionARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglSaveBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height) {
    PFN_WGLSAVEBUFFERREGIONARB _ptr;
    _ptr = (PFN_WGLSAVEBUFFERREGIONARB)_getPrivateProcAddress("wglSaveBufferRegionARB");
    if (!_ptr) {
        _ptr = &_fail_wglSaveBufferRegionARB;
    }
    _wglSaveBufferRegionARB = _ptr;
    return _wglSaveBufferRegionARB(hRegion, x, y, width, height);
}

PFN_WGLSAVEBUFFERREGIONARB _wglSaveBufferRegionARB = &_get_wglSaveBufferRegionARB;

static BOOL __stdcall _fail_wglRestoreBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc) {
    const char *_name = "wglRestoreBufferRegionARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglRestoreBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc) {
    PFN_WGLRESTOREBUFFERREGIONARB _ptr;
    _ptr = (PFN_WGLRESTOREBUFFERREGIONARB)_getPrivateProcAddress("wglRestoreBufferRegionARB");
    if (!_ptr) {
        _ptr = &_fail_wglRestoreBufferRegionARB;
    }
    _wglRestoreBufferRegionARB = _ptr;
    return _wglRestoreBufferRegionARB(hRegion, x, y, width, height, xSrc, ySrc);
}

PFN_WGLRESTOREBUFFERREGIONARB _wglRestoreBufferRegionARB = &_get_wglRestoreBufferRegionARB;

static const char * __stdcall _fail_wglGetExtensionsStringARB(HDC hdc) {
    const char *_name = "wglGetExtensionsStringARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static const char * __stdcall _get_wglGetExtensionsStringARB(HDC hdc) {
    PFN_WGLGETEXTENSIONSSTRINGARB _ptr;
    _ptr = (PFN_WGLGETEXTENSIONSSTRINGARB)_getPrivateProcAddress("wglGetExtensionsStringARB");
    if (!_ptr) {
        _ptr = &_fail_wglGetExtensionsStringARB;
    }
    _wglGetExtensionsStringARB = _ptr;
    return _wglGetExtensionsStringARB(hdc);
}

PFN_WGLGETEXTENSIONSSTRINGARB _wglGetExtensionsStringARB = &_get_wglGetExtensionsStringARB;

static BOOL __stdcall _fail_wglGetPixelFormatAttribivARB(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int * piAttributes, int * piValues) {
    const char *_name = "wglGetPixelFormatAttribivARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGetPixelFormatAttribivARB(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int * piAttributes, int * piValues) {
    PFN_WGLGETPIXELFORMATATTRIBIVARB _ptr;
    _ptr = (PFN_WGLGETPIXELFORMATATTRIBIVARB)_getPrivateProcAddress("wglGetPixelFormatAttribivARB");
    if (!_ptr) {
        _ptr = &_fail_wglGetPixelFormatAttribivARB;
    }
    _wglGetPixelFormatAttribivARB = _ptr;
    return _wglGetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
}

PFN_WGLGETPIXELFORMATATTRIBIVARB _wglGetPixelFormatAttribivARB = &_get_wglGetPixelFormatAttribivARB;

static BOOL __stdcall _fail_wglGetPixelFormatAttribfvARB(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int * piAttributes, FLOAT * pfValues) {
    const char *_name = "wglGetPixelFormatAttribfvARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGetPixelFormatAttribfvARB(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int * piAttributes, FLOAT * pfValues) {
    PFN_WGLGETPIXELFORMATATTRIBFVARB _ptr;
    _ptr = (PFN_WGLGETPIXELFORMATATTRIBFVARB)_getPrivateProcAddress("wglGetPixelFormatAttribfvARB");
    if (!_ptr) {
        _ptr = &_fail_wglGetPixelFormatAttribfvARB;
    }
    _wglGetPixelFormatAttribfvARB = _ptr;
    return _wglGetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
}

PFN_WGLGETPIXELFORMATATTRIBFVARB _wglGetPixelFormatAttribfvARB = &_get_wglGetPixelFormatAttribfvARB;

static BOOL __stdcall _fail_wglChoosePixelFormatARB(HDC hdc, const int * piAttribIList, const FLOAT * pfAttribFList, UINT nMaxFormats, int * piFormats, UINT * nNumFormats) {
    const char *_name = "wglChoosePixelFormatARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglChoosePixelFormatARB(HDC hdc, const int * piAttribIList, const FLOAT * pfAttribFList, UINT nMaxFormats, int * piFormats, UINT * nNumFormats) {
    PFN_WGLCHOOSEPIXELFORMATARB _ptr;
    _ptr = (PFN_WGLCHOOSEPIXELFORMATARB)_getPrivateProcAddress("wglChoosePixelFormatARB");
    if (!_ptr) {
        _ptr = &_fail_wglChoosePixelFormatARB;
    }
    _wglChoosePixelFormatARB = _ptr;
    return _wglChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
}

PFN_WGLCHOOSEPIXELFORMATARB _wglChoosePixelFormatARB = &_get_wglChoosePixelFormatARB;

static BOOL __stdcall _fail_wglMakeContextCurrentARB(HDC hDrawDC, HDC hReadDC, HGLRC hglrc) {
    const char *_name = "wglMakeContextCurrentARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglMakeContextCurrentARB(HDC hDrawDC, HDC hReadDC, HGLRC hglrc) {
    PFN_WGLMAKECONTEXTCURRENTARB _ptr;
    _ptr = (PFN_WGLMAKECONTEXTCURRENTARB)_getPrivateProcAddress("wglMakeContextCurrentARB");
    if (!_ptr) {
        _ptr = &_fail_wglMakeContextCurrentARB;
    }
    _wglMakeContextCurrentARB = _ptr;
    return _wglMakeContextCurrentARB(hDrawDC, hReadDC, hglrc);
}

PFN_WGLMAKECONTEXTCURRENTARB _wglMakeContextCurrentARB = &_get_wglMakeContextCurrentARB;

static HDC __stdcall _fail_wglGetCurrentReadDCARB(void) {
    const char *_name = "wglGetCurrentReadDCARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static HDC __stdcall _get_wglGetCurrentReadDCARB(void) {
    PFN_WGLGETCURRENTREADDCARB _ptr;
    _ptr = (PFN_WGLGETCURRENTREADDCARB)_getPrivateProcAddress("wglGetCurrentReadDCARB");
    if (!_ptr) {
        _ptr = &_fail_wglGetCurrentReadDCARB;
    }
    _wglGetCurrentReadDCARB = _ptr;
    return _wglGetCurrentReadDCARB();
}

PFN_WGLGETCURRENTREADDCARB _wglGetCurrentReadDCARB = &_get_wglGetCurrentReadDCARB;

static HPBUFFERARB __stdcall _fail_wglCreatePbufferARB(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int * piAttribList) {
    const char *_name = "wglCreatePbufferARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static HPBUFFERARB __stdcall _get_wglCreatePbufferARB(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int * piAttribList) {
    PFN_WGLCREATEPBUFFERARB _ptr;
    _ptr = (PFN_WGLCREATEPBUFFERARB)_getPrivateProcAddress("wglCreatePbufferARB");
    if (!_ptr) {
        _ptr = &_fail_wglCreatePbufferARB;
    }
    _wglCreatePbufferARB = _ptr;
    return _wglCreatePbufferARB(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
}

PFN_WGLCREATEPBUFFERARB _wglCreatePbufferARB = &_get_wglCreatePbufferARB;

static HDC __stdcall _fail_wglGetPbufferDCARB(HPBUFFERARB hPbuffer) {
    const char *_name = "wglGetPbufferDCARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static HDC __stdcall _get_wglGetPbufferDCARB(HPBUFFERARB hPbuffer) {
    PFN_WGLGETPBUFFERDCARB _ptr;
    _ptr = (PFN_WGLGETPBUFFERDCARB)_getPrivateProcAddress("wglGetPbufferDCARB");
    if (!_ptr) {
        _ptr = &_fail_wglGetPbufferDCARB;
    }
    _wglGetPbufferDCARB = _ptr;
    return _wglGetPbufferDCARB(hPbuffer);
}

PFN_WGLGETPBUFFERDCARB _wglGetPbufferDCARB = &_get_wglGetPbufferDCARB;

static int __stdcall _fail_wglReleasePbufferDCARB(HPBUFFERARB hPbuffer, HDC hDC) {
    const char *_name = "wglReleasePbufferDCARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int __stdcall _get_wglReleasePbufferDCARB(HPBUFFERARB hPbuffer, HDC hDC) {
    PFN_WGLRELEASEPBUFFERDCARB _ptr;
    _ptr = (PFN_WGLRELEASEPBUFFERDCARB)_getPrivateProcAddress("wglReleasePbufferDCARB");
    if (!_ptr) {
        _ptr = &_fail_wglReleasePbufferDCARB;
    }
    _wglReleasePbufferDCARB = _ptr;
    return _wglReleasePbufferDCARB(hPbuffer, hDC);
}

PFN_WGLRELEASEPBUFFERDCARB _wglReleasePbufferDCARB = &_get_wglReleasePbufferDCARB;

static BOOL __stdcall _fail_wglDestroyPbufferARB(HPBUFFERARB hPbuffer) {
    const char *_name = "wglDestroyPbufferARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglDestroyPbufferARB(HPBUFFERARB hPbuffer) {
    PFN_WGLDESTROYPBUFFERARB _ptr;
    _ptr = (PFN_WGLDESTROYPBUFFERARB)_getPrivateProcAddress("wglDestroyPbufferARB");
    if (!_ptr) {
        _ptr = &_fail_wglDestroyPbufferARB;
    }
    _wglDestroyPbufferARB = _ptr;
    return _wglDestroyPbufferARB(hPbuffer);
}

PFN_WGLDESTROYPBUFFERARB _wglDestroyPbufferARB = &_get_wglDestroyPbufferARB;

static BOOL __stdcall _fail_wglQueryPbufferARB(HPBUFFERARB hPbuffer, int iAttribute, int * piValue) {
    const char *_name = "wglQueryPbufferARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglQueryPbufferARB(HPBUFFERARB hPbuffer, int iAttribute, int * piValue) {
    PFN_WGLQUERYPBUFFERARB _ptr;
    _ptr = (PFN_WGLQUERYPBUFFERARB)_getPrivateProcAddress("wglQueryPbufferARB");
    if (!_ptr) {
        _ptr = &_fail_wglQueryPbufferARB;
    }
    _wglQueryPbufferARB = _ptr;
    return _wglQueryPbufferARB(hPbuffer, iAttribute, piValue);
}

PFN_WGLQUERYPBUFFERARB _wglQueryPbufferARB = &_get_wglQueryPbufferARB;

static BOOL __stdcall _fail_wglBindTexImageARB(HPBUFFERARB hPbuffer, int iBuffer) {
    const char *_name = "wglBindTexImageARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglBindTexImageARB(HPBUFFERARB hPbuffer, int iBuffer) {
    PFN_WGLBINDTEXIMAGEARB _ptr;
    _ptr = (PFN_WGLBINDTEXIMAGEARB)_getPrivateProcAddress("wglBindTexImageARB");
    if (!_ptr) {
        _ptr = &_fail_wglBindTexImageARB;
    }
    _wglBindTexImageARB = _ptr;
    return _wglBindTexImageARB(hPbuffer, iBuffer);
}

PFN_WGLBINDTEXIMAGEARB _wglBindTexImageARB = &_get_wglBindTexImageARB;

static BOOL __stdcall _fail_wglReleaseTexImageARB(HPBUFFERARB hPbuffer, int iBuffer) {
    const char *_name = "wglReleaseTexImageARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglReleaseTexImageARB(HPBUFFERARB hPbuffer, int iBuffer) {
    PFN_WGLRELEASETEXIMAGEARB _ptr;
    _ptr = (PFN_WGLRELEASETEXIMAGEARB)_getPrivateProcAddress("wglReleaseTexImageARB");
    if (!_ptr) {
        _ptr = &_fail_wglReleaseTexImageARB;
    }
    _wglReleaseTexImageARB = _ptr;
    return _wglReleaseTexImageARB(hPbuffer, iBuffer);
}

PFN_WGLRELEASETEXIMAGEARB _wglReleaseTexImageARB = &_get_wglReleaseTexImageARB;

static BOOL __stdcall _fail_wglSetPbufferAttribARB(HPBUFFERARB hPbuffer, const int * piAttribList) {
    const char *_name = "wglSetPbufferAttribARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglSetPbufferAttribARB(HPBUFFERARB hPbuffer, const int * piAttribList) {
    PFN_WGLSETPBUFFERATTRIBARB _ptr;
    _ptr = (PFN_WGLSETPBUFFERATTRIBARB)_getPrivateProcAddress("wglSetPbufferAttribARB");
    if (!_ptr) {
        _ptr = &_fail_wglSetPbufferAttribARB;
    }
    _wglSetPbufferAttribARB = _ptr;
    return _wglSetPbufferAttribARB(hPbuffer, piAttribList);
}

PFN_WGLSETPBUFFERATTRIBARB _wglSetPbufferAttribARB = &_get_wglSetPbufferAttribARB;

static HGLRC __stdcall _fail_wglCreateContextAttribsARB(HDC hDC, HGLRC hShareContext, const int * attribList) {
    const char *_name = "wglCreateContextAttribsARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static HGLRC __stdcall _get_wglCreateContextAttribsARB(HDC hDC, HGLRC hShareContext, const int * attribList) {
    PFN_WGLCREATECONTEXTATTRIBSARB _ptr;
    _ptr = (PFN_WGLCREATECONTEXTATTRIBSARB)_getPrivateProcAddress("wglCreateContextAttribsARB");
    if (!_ptr) {
        _ptr = &_fail_wglCreateContextAttribsARB;
    }
    _wglCreateContextAttribsARB = _ptr;
    return _wglCreateContextAttribsARB(hDC, hShareContext, attribList);
}

PFN_WGLCREATECONTEXTATTRIBSARB _wglCreateContextAttribsARB = &_get_wglCreateContextAttribsARB;

static GLboolean __stdcall _fail_wglCreateDisplayColorTableEXT(GLushort id) {
    const char *_name = "wglCreateDisplayColorTableEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean __stdcall _get_wglCreateDisplayColorTableEXT(GLushort id) {
    PFN_WGLCREATEDISPLAYCOLORTABLEEXT _ptr;
    _ptr = (PFN_WGLCREATEDISPLAYCOLORTABLEEXT)_getPrivateProcAddress("wglCreateDisplayColorTableEXT");
    if (!_ptr) {
        _ptr = &_fail_wglCreateDisplayColorTableEXT;
    }
    _wglCreateDisplayColorTableEXT = _ptr;
    return _wglCreateDisplayColorTableEXT(id);
}

PFN_WGLCREATEDISPLAYCOLORTABLEEXT _wglCreateDisplayColorTableEXT = &_get_wglCreateDisplayColorTableEXT;

static GLboolean __stdcall _fail_wglLoadDisplayColorTableEXT(const GLushort * table, GLuint length) {
    const char *_name = "wglLoadDisplayColorTableEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean __stdcall _get_wglLoadDisplayColorTableEXT(const GLushort * table, GLuint length) {
    PFN_WGLLOADDISPLAYCOLORTABLEEXT _ptr;
    _ptr = (PFN_WGLLOADDISPLAYCOLORTABLEEXT)_getPrivateProcAddress("wglLoadDisplayColorTableEXT");
    if (!_ptr) {
        _ptr = &_fail_wglLoadDisplayColorTableEXT;
    }
    _wglLoadDisplayColorTableEXT = _ptr;
    return _wglLoadDisplayColorTableEXT(table, length);
}

PFN_WGLLOADDISPLAYCOLORTABLEEXT _wglLoadDisplayColorTableEXT = &_get_wglLoadDisplayColorTableEXT;

static GLboolean __stdcall _fail_wglBindDisplayColorTableEXT(GLushort id) {
    const char *_name = "wglBindDisplayColorTableEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean __stdcall _get_wglBindDisplayColorTableEXT(GLushort id) {
    PFN_WGLBINDDISPLAYCOLORTABLEEXT _ptr;
    _ptr = (PFN_WGLBINDDISPLAYCOLORTABLEEXT)_getPrivateProcAddress("wglBindDisplayColorTableEXT");
    if (!_ptr) {
        _ptr = &_fail_wglBindDisplayColorTableEXT;
    }
    _wglBindDisplayColorTableEXT = _ptr;
    return _wglBindDisplayColorTableEXT(id);
}

PFN_WGLBINDDISPLAYCOLORTABLEEXT _wglBindDisplayColorTableEXT = &_get_wglBindDisplayColorTableEXT;

static void __stdcall _fail_wglDestroyDisplayColorTableEXT(GLushort id) {
    const char *_name = "wglDestroyDisplayColorTableEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void __stdcall _get_wglDestroyDisplayColorTableEXT(GLushort id) {
    PFN_WGLDESTROYDISPLAYCOLORTABLEEXT _ptr;
    _ptr = (PFN_WGLDESTROYDISPLAYCOLORTABLEEXT)_getPrivateProcAddress("wglDestroyDisplayColorTableEXT");
    if (!_ptr) {
        _ptr = &_fail_wglDestroyDisplayColorTableEXT;
    }
    _wglDestroyDisplayColorTableEXT = _ptr;
    _wglDestroyDisplayColorTableEXT(id);
}

PFN_WGLDESTROYDISPLAYCOLORTABLEEXT _wglDestroyDisplayColorTableEXT = &_get_wglDestroyDisplayColorTableEXT;

static const char * __stdcall _fail_wglGetExtensionsStringEXT(void) {
    const char *_name = "wglGetExtensionsStringEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static const char * __stdcall _get_wglGetExtensionsStringEXT(void) {
    PFN_WGLGETEXTENSIONSSTRINGEXT _ptr;
    _ptr = (PFN_WGLGETEXTENSIONSSTRINGEXT)_getPrivateProcAddress("wglGetExtensionsStringEXT");
    if (!_ptr) {
        _ptr = &_fail_wglGetExtensionsStringEXT;
    }
    _wglGetExtensionsStringEXT = _ptr;
    return _wglGetExtensionsStringEXT();
}

PFN_WGLGETEXTENSIONSSTRINGEXT _wglGetExtensionsStringEXT = &_get_wglGetExtensionsStringEXT;

static BOOL __stdcall _fail_wglMakeContextCurrentEXT(HDC hDrawDC, HDC hReadDC, HGLRC hglrc) {
    const char *_name = "wglMakeContextCurrentEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglMakeContextCurrentEXT(HDC hDrawDC, HDC hReadDC, HGLRC hglrc) {
    PFN_WGLMAKECONTEXTCURRENTEXT _ptr;
    _ptr = (PFN_WGLMAKECONTEXTCURRENTEXT)_getPrivateProcAddress("wglMakeContextCurrentEXT");
    if (!_ptr) {
        _ptr = &_fail_wglMakeContextCurrentEXT;
    }
    _wglMakeContextCurrentEXT = _ptr;
    return _wglMakeContextCurrentEXT(hDrawDC, hReadDC, hglrc);
}

PFN_WGLMAKECONTEXTCURRENTEXT _wglMakeContextCurrentEXT = &_get_wglMakeContextCurrentEXT;

static HDC __stdcall _fail_wglGetCurrentReadDCEXT(void) {
    const char *_name = "wglGetCurrentReadDCEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static HDC __stdcall _get_wglGetCurrentReadDCEXT(void) {
    PFN_WGLGETCURRENTREADDCEXT _ptr;
    _ptr = (PFN_WGLGETCURRENTREADDCEXT)_getPrivateProcAddress("wglGetCurrentReadDCEXT");
    if (!_ptr) {
        _ptr = &_fail_wglGetCurrentReadDCEXT;
    }
    _wglGetCurrentReadDCEXT = _ptr;
    return _wglGetCurrentReadDCEXT();
}

PFN_WGLGETCURRENTREADDCEXT _wglGetCurrentReadDCEXT = &_get_wglGetCurrentReadDCEXT;

static HPBUFFEREXT __stdcall _fail_wglCreatePbufferEXT(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int * piAttribList) {
    const char *_name = "wglCreatePbufferEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static HPBUFFEREXT __stdcall _get_wglCreatePbufferEXT(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int * piAttribList) {
    PFN_WGLCREATEPBUFFEREXT _ptr;
    _ptr = (PFN_WGLCREATEPBUFFEREXT)_getPrivateProcAddress("wglCreatePbufferEXT");
    if (!_ptr) {
        _ptr = &_fail_wglCreatePbufferEXT;
    }
    _wglCreatePbufferEXT = _ptr;
    return _wglCreatePbufferEXT(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
}

PFN_WGLCREATEPBUFFEREXT _wglCreatePbufferEXT = &_get_wglCreatePbufferEXT;

static HDC __stdcall _fail_wglGetPbufferDCEXT(HPBUFFEREXT hPbuffer) {
    const char *_name = "wglGetPbufferDCEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static HDC __stdcall _get_wglGetPbufferDCEXT(HPBUFFEREXT hPbuffer) {
    PFN_WGLGETPBUFFERDCEXT _ptr;
    _ptr = (PFN_WGLGETPBUFFERDCEXT)_getPrivateProcAddress("wglGetPbufferDCEXT");
    if (!_ptr) {
        _ptr = &_fail_wglGetPbufferDCEXT;
    }
    _wglGetPbufferDCEXT = _ptr;
    return _wglGetPbufferDCEXT(hPbuffer);
}

PFN_WGLGETPBUFFERDCEXT _wglGetPbufferDCEXT = &_get_wglGetPbufferDCEXT;

static int __stdcall _fail_wglReleasePbufferDCEXT(HPBUFFEREXT hPbuffer, HDC hDC) {
    const char *_name = "wglReleasePbufferDCEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int __stdcall _get_wglReleasePbufferDCEXT(HPBUFFEREXT hPbuffer, HDC hDC) {
    PFN_WGLRELEASEPBUFFERDCEXT _ptr;
    _ptr = (PFN_WGLRELEASEPBUFFERDCEXT)_getPrivateProcAddress("wglReleasePbufferDCEXT");
    if (!_ptr) {
        _ptr = &_fail_wglReleasePbufferDCEXT;
    }
    _wglReleasePbufferDCEXT = _ptr;
    return _wglReleasePbufferDCEXT(hPbuffer, hDC);
}

PFN_WGLRELEASEPBUFFERDCEXT _wglReleasePbufferDCEXT = &_get_wglReleasePbufferDCEXT;

static BOOL __stdcall _fail_wglDestroyPbufferEXT(HPBUFFEREXT hPbuffer) {
    const char *_name = "wglDestroyPbufferEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglDestroyPbufferEXT(HPBUFFEREXT hPbuffer) {
    PFN_WGLDESTROYPBUFFEREXT _ptr;
    _ptr = (PFN_WGLDESTROYPBUFFEREXT)_getPrivateProcAddress("wglDestroyPbufferEXT");
    if (!_ptr) {
        _ptr = &_fail_wglDestroyPbufferEXT;
    }
    _wglDestroyPbufferEXT = _ptr;
    return _wglDestroyPbufferEXT(hPbuffer);
}

PFN_WGLDESTROYPBUFFEREXT _wglDestroyPbufferEXT = &_get_wglDestroyPbufferEXT;

static BOOL __stdcall _fail_wglQueryPbufferEXT(HPBUFFEREXT hPbuffer, int iAttribute, int * piValue) {
    const char *_name = "wglQueryPbufferEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglQueryPbufferEXT(HPBUFFEREXT hPbuffer, int iAttribute, int * piValue) {
    PFN_WGLQUERYPBUFFEREXT _ptr;
    _ptr = (PFN_WGLQUERYPBUFFEREXT)_getPrivateProcAddress("wglQueryPbufferEXT");
    if (!_ptr) {
        _ptr = &_fail_wglQueryPbufferEXT;
    }
    _wglQueryPbufferEXT = _ptr;
    return _wglQueryPbufferEXT(hPbuffer, iAttribute, piValue);
}

PFN_WGLQUERYPBUFFEREXT _wglQueryPbufferEXT = &_get_wglQueryPbufferEXT;

static BOOL __stdcall _fail_wglGetPixelFormatAttribivEXT(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int * piAttributes, int * piValues) {
    const char *_name = "wglGetPixelFormatAttribivEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGetPixelFormatAttribivEXT(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int * piAttributes, int * piValues) {
    PFN_WGLGETPIXELFORMATATTRIBIVEXT _ptr;
    _ptr = (PFN_WGLGETPIXELFORMATATTRIBIVEXT)_getPrivateProcAddress("wglGetPixelFormatAttribivEXT");
    if (!_ptr) {
        _ptr = &_fail_wglGetPixelFormatAttribivEXT;
    }
    _wglGetPixelFormatAttribivEXT = _ptr;
    return _wglGetPixelFormatAttribivEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
}

PFN_WGLGETPIXELFORMATATTRIBIVEXT _wglGetPixelFormatAttribivEXT = &_get_wglGetPixelFormatAttribivEXT;

static BOOL __stdcall _fail_wglGetPixelFormatAttribfvEXT(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int * piAttributes, FLOAT * pfValues) {
    const char *_name = "wglGetPixelFormatAttribfvEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGetPixelFormatAttribfvEXT(HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int * piAttributes, FLOAT * pfValues) {
    PFN_WGLGETPIXELFORMATATTRIBFVEXT _ptr;
    _ptr = (PFN_WGLGETPIXELFORMATATTRIBFVEXT)_getPrivateProcAddress("wglGetPixelFormatAttribfvEXT");
    if (!_ptr) {
        _ptr = &_fail_wglGetPixelFormatAttribfvEXT;
    }
    _wglGetPixelFormatAttribfvEXT = _ptr;
    return _wglGetPixelFormatAttribfvEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
}

PFN_WGLGETPIXELFORMATATTRIBFVEXT _wglGetPixelFormatAttribfvEXT = &_get_wglGetPixelFormatAttribfvEXT;

static BOOL __stdcall _fail_wglChoosePixelFormatEXT(HDC hdc, const int * piAttribIList, const FLOAT * pfAttribFList, UINT nMaxFormats, int * piFormats, UINT * nNumFormats) {
    const char *_name = "wglChoosePixelFormatEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglChoosePixelFormatEXT(HDC hdc, const int * piAttribIList, const FLOAT * pfAttribFList, UINT nMaxFormats, int * piFormats, UINT * nNumFormats) {
    PFN_WGLCHOOSEPIXELFORMATEXT _ptr;
    _ptr = (PFN_WGLCHOOSEPIXELFORMATEXT)_getPrivateProcAddress("wglChoosePixelFormatEXT");
    if (!_ptr) {
        _ptr = &_fail_wglChoosePixelFormatEXT;
    }
    _wglChoosePixelFormatEXT = _ptr;
    return _wglChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
}

PFN_WGLCHOOSEPIXELFORMATEXT _wglChoosePixelFormatEXT = &_get_wglChoosePixelFormatEXT;

static BOOL __stdcall _fail_wglSwapIntervalEXT(int interval) {
    const char *_name = "wglSwapIntervalEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglSwapIntervalEXT(int interval) {
    PFN_WGLSWAPINTERVALEXT _ptr;
    _ptr = (PFN_WGLSWAPINTERVALEXT)_getPrivateProcAddress("wglSwapIntervalEXT");
    if (!_ptr) {
        _ptr = &_fail_wglSwapIntervalEXT;
    }
    _wglSwapIntervalEXT = _ptr;
    return _wglSwapIntervalEXT(interval);
}

PFN_WGLSWAPINTERVALEXT _wglSwapIntervalEXT = &_get_wglSwapIntervalEXT;

static int __stdcall _fail_wglGetSwapIntervalEXT(void) {
    const char *_name = "wglGetSwapIntervalEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int __stdcall _get_wglGetSwapIntervalEXT(void) {
    PFN_WGLGETSWAPINTERVALEXT _ptr;
    _ptr = (PFN_WGLGETSWAPINTERVALEXT)_getPrivateProcAddress("wglGetSwapIntervalEXT");
    if (!_ptr) {
        _ptr = &_fail_wglGetSwapIntervalEXT;
    }
    _wglGetSwapIntervalEXT = _ptr;
    return _wglGetSwapIntervalEXT();
}

PFN_WGLGETSWAPINTERVALEXT _wglGetSwapIntervalEXT = &_get_wglGetSwapIntervalEXT;

static void * __stdcall _fail_wglAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority) {
    const char *_name = "wglAllocateMemoryNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static void * __stdcall _get_wglAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority) {
    PFN_WGLALLOCATEMEMORYNV _ptr;
    _ptr = (PFN_WGLALLOCATEMEMORYNV)_getPrivateProcAddress("wglAllocateMemoryNV");
    if (!_ptr) {
        _ptr = &_fail_wglAllocateMemoryNV;
    }
    _wglAllocateMemoryNV = _ptr;
    return _wglAllocateMemoryNV(size, readfreq, writefreq, priority);
}

PFN_WGLALLOCATEMEMORYNV _wglAllocateMemoryNV = &_get_wglAllocateMemoryNV;

static void __stdcall _fail_wglFreeMemoryNV(void * pointer) {
    const char *_name = "wglFreeMemoryNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void __stdcall _get_wglFreeMemoryNV(void * pointer) {
    PFN_WGLFREEMEMORYNV _ptr;
    _ptr = (PFN_WGLFREEMEMORYNV)_getPrivateProcAddress("wglFreeMemoryNV");
    if (!_ptr) {
        _ptr = &_fail_wglFreeMemoryNV;
    }
    _wglFreeMemoryNV = _ptr;
    _wglFreeMemoryNV(pointer);
}

PFN_WGLFREEMEMORYNV _wglFreeMemoryNV = &_get_wglFreeMemoryNV;

static BOOL __stdcall _fail_wglGetSyncValuesOML(HDC hdc, INT64 * ust, INT64 * msc, INT64 * sbc) {
    const char *_name = "wglGetSyncValuesOML";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGetSyncValuesOML(HDC hdc, INT64 * ust, INT64 * msc, INT64 * sbc) {
    PFN_WGLGETSYNCVALUESOML _ptr;
    _ptr = (PFN_WGLGETSYNCVALUESOML)_getPrivateProcAddress("wglGetSyncValuesOML");
    if (!_ptr) {
        _ptr = &_fail_wglGetSyncValuesOML;
    }
    _wglGetSyncValuesOML = _ptr;
    return _wglGetSyncValuesOML(hdc, ust, msc, sbc);
}

PFN_WGLGETSYNCVALUESOML _wglGetSyncValuesOML = &_get_wglGetSyncValuesOML;

static BOOL __stdcall _fail_wglGetMscRateOML(HDC hdc, INT32 * numerator, INT32 * denominator) {
    const char *_name = "wglGetMscRateOML";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGetMscRateOML(HDC hdc, INT32 * numerator, INT32 * denominator) {
    PFN_WGLGETMSCRATEOML _ptr;
    _ptr = (PFN_WGLGETMSCRATEOML)_getPrivateProcAddress("wglGetMscRateOML");
    if (!_ptr) {
        _ptr = &_fail_wglGetMscRateOML;
    }
    _wglGetMscRateOML = _ptr;
    return _wglGetMscRateOML(hdc, numerator, denominator);
}

PFN_WGLGETMSCRATEOML _wglGetMscRateOML = &_get_wglGetMscRateOML;

static INT64 __stdcall _fail_wglSwapBuffersMscOML(HDC hdc, INT64 target_msc, INT64 divisor, INT64 remainder) {
    const char *_name = "wglSwapBuffersMscOML";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static INT64 __stdcall _get_wglSwapBuffersMscOML(HDC hdc, INT64 target_msc, INT64 divisor, INT64 remainder) {
    PFN_WGLSWAPBUFFERSMSCOML _ptr;
    _ptr = (PFN_WGLSWAPBUFFERSMSCOML)_getPrivateProcAddress("wglSwapBuffersMscOML");
    if (!_ptr) {
        _ptr = &_fail_wglSwapBuffersMscOML;
    }
    _wglSwapBuffersMscOML = _ptr;
    return _wglSwapBuffersMscOML(hdc, target_msc, divisor, remainder);
}

PFN_WGLSWAPBUFFERSMSCOML _wglSwapBuffersMscOML = &_get_wglSwapBuffersMscOML;

static INT64 __stdcall _fail_wglSwapLayerBuffersMscOML(HDC hdc, int fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder) {
    const char *_name = "wglSwapLayerBuffersMscOML";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static INT64 __stdcall _get_wglSwapLayerBuffersMscOML(HDC hdc, int fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder) {
    PFN_WGLSWAPLAYERBUFFERSMSCOML _ptr;
    _ptr = (PFN_WGLSWAPLAYERBUFFERSMSCOML)_getPrivateProcAddress("wglSwapLayerBuffersMscOML");
    if (!_ptr) {
        _ptr = &_fail_wglSwapLayerBuffersMscOML;
    }
    _wglSwapLayerBuffersMscOML = _ptr;
    return _wglSwapLayerBuffersMscOML(hdc, fuPlanes, target_msc, divisor, remainder);
}

PFN_WGLSWAPLAYERBUFFERSMSCOML _wglSwapLayerBuffersMscOML = &_get_wglSwapLayerBuffersMscOML;

static BOOL __stdcall _fail_wglWaitForMscOML(HDC hdc, INT64 target_msc, INT64 divisor, INT64 remainder, INT64 * ust, INT64 * msc, INT64 * sbc) {
    const char *_name = "wglWaitForMscOML";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglWaitForMscOML(HDC hdc, INT64 target_msc, INT64 divisor, INT64 remainder, INT64 * ust, INT64 * msc, INT64 * sbc) {
    PFN_WGLWAITFORMSCOML _ptr;
    _ptr = (PFN_WGLWAITFORMSCOML)_getPrivateProcAddress("wglWaitForMscOML");
    if (!_ptr) {
        _ptr = &_fail_wglWaitForMscOML;
    }
    _wglWaitForMscOML = _ptr;
    return _wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust, msc, sbc);
}

PFN_WGLWAITFORMSCOML _wglWaitForMscOML = &_get_wglWaitForMscOML;

static BOOL __stdcall _fail_wglWaitForSbcOML(HDC hdc, INT64 target_sbc, INT64 * ust, INT64 * msc, INT64 * sbc) {
    const char *_name = "wglWaitForSbcOML";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglWaitForSbcOML(HDC hdc, INT64 target_sbc, INT64 * ust, INT64 * msc, INT64 * sbc) {
    PFN_WGLWAITFORSBCOML _ptr;
    _ptr = (PFN_WGLWAITFORSBCOML)_getPrivateProcAddress("wglWaitForSbcOML");
    if (!_ptr) {
        _ptr = &_fail_wglWaitForSbcOML;
    }
    _wglWaitForSbcOML = _ptr;
    return _wglWaitForSbcOML(hdc, target_sbc, ust, msc, sbc);
}

PFN_WGLWAITFORSBCOML _wglWaitForSbcOML = &_get_wglWaitForSbcOML;

static BOOL __stdcall _fail_wglGetDigitalVideoParametersI3D(HDC hDC, int iAttribute, int * piValue) {
    const char *_name = "wglGetDigitalVideoParametersI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGetDigitalVideoParametersI3D(HDC hDC, int iAttribute, int * piValue) {
    PFN_WGLGETDIGITALVIDEOPARAMETERSI3D _ptr;
    _ptr = (PFN_WGLGETDIGITALVIDEOPARAMETERSI3D)_getPrivateProcAddress("wglGetDigitalVideoParametersI3D");
    if (!_ptr) {
        _ptr = &_fail_wglGetDigitalVideoParametersI3D;
    }
    _wglGetDigitalVideoParametersI3D = _ptr;
    return _wglGetDigitalVideoParametersI3D(hDC, iAttribute, piValue);
}

PFN_WGLGETDIGITALVIDEOPARAMETERSI3D _wglGetDigitalVideoParametersI3D = &_get_wglGetDigitalVideoParametersI3D;

static BOOL __stdcall _fail_wglSetDigitalVideoParametersI3D(HDC hDC, int iAttribute, const int * piValue) {
    const char *_name = "wglSetDigitalVideoParametersI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglSetDigitalVideoParametersI3D(HDC hDC, int iAttribute, const int * piValue) {
    PFN_WGLSETDIGITALVIDEOPARAMETERSI3D _ptr;
    _ptr = (PFN_WGLSETDIGITALVIDEOPARAMETERSI3D)_getPrivateProcAddress("wglSetDigitalVideoParametersI3D");
    if (!_ptr) {
        _ptr = &_fail_wglSetDigitalVideoParametersI3D;
    }
    _wglSetDigitalVideoParametersI3D = _ptr;
    return _wglSetDigitalVideoParametersI3D(hDC, iAttribute, piValue);
}

PFN_WGLSETDIGITALVIDEOPARAMETERSI3D _wglSetDigitalVideoParametersI3D = &_get_wglSetDigitalVideoParametersI3D;

static BOOL __stdcall _fail_wglGetGammaTableParametersI3D(HDC hDC, int iAttribute, int * piValue) {
    const char *_name = "wglGetGammaTableParametersI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGetGammaTableParametersI3D(HDC hDC, int iAttribute, int * piValue) {
    PFN_WGLGETGAMMATABLEPARAMETERSI3D _ptr;
    _ptr = (PFN_WGLGETGAMMATABLEPARAMETERSI3D)_getPrivateProcAddress("wglGetGammaTableParametersI3D");
    if (!_ptr) {
        _ptr = &_fail_wglGetGammaTableParametersI3D;
    }
    _wglGetGammaTableParametersI3D = _ptr;
    return _wglGetGammaTableParametersI3D(hDC, iAttribute, piValue);
}

PFN_WGLGETGAMMATABLEPARAMETERSI3D _wglGetGammaTableParametersI3D = &_get_wglGetGammaTableParametersI3D;

static BOOL __stdcall _fail_wglSetGammaTableParametersI3D(HDC hDC, int iAttribute, const int * piValue) {
    const char *_name = "wglSetGammaTableParametersI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglSetGammaTableParametersI3D(HDC hDC, int iAttribute, const int * piValue) {
    PFN_WGLSETGAMMATABLEPARAMETERSI3D _ptr;
    _ptr = (PFN_WGLSETGAMMATABLEPARAMETERSI3D)_getPrivateProcAddress("wglSetGammaTableParametersI3D");
    if (!_ptr) {
        _ptr = &_fail_wglSetGammaTableParametersI3D;
    }
    _wglSetGammaTableParametersI3D = _ptr;
    return _wglSetGammaTableParametersI3D(hDC, iAttribute, piValue);
}

PFN_WGLSETGAMMATABLEPARAMETERSI3D _wglSetGammaTableParametersI3D = &_get_wglSetGammaTableParametersI3D;

static BOOL __stdcall _fail_wglGetGammaTableI3D(HDC hDC, int iEntries, USHORT * puRed, USHORT * puGreen, USHORT * puBlue) {
    const char *_name = "wglGetGammaTableI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGetGammaTableI3D(HDC hDC, int iEntries, USHORT * puRed, USHORT * puGreen, USHORT * puBlue) {
    PFN_WGLGETGAMMATABLEI3D _ptr;
    _ptr = (PFN_WGLGETGAMMATABLEI3D)_getPrivateProcAddress("wglGetGammaTableI3D");
    if (!_ptr) {
        _ptr = &_fail_wglGetGammaTableI3D;
    }
    _wglGetGammaTableI3D = _ptr;
    return _wglGetGammaTableI3D(hDC, iEntries, puRed, puGreen, puBlue);
}

PFN_WGLGETGAMMATABLEI3D _wglGetGammaTableI3D = &_get_wglGetGammaTableI3D;

static BOOL __stdcall _fail_wglSetGammaTableI3D(HDC hDC, int iEntries, const USHORT * puRed, const USHORT * puGreen, const USHORT * puBlue) {
    const char *_name = "wglSetGammaTableI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglSetGammaTableI3D(HDC hDC, int iEntries, const USHORT * puRed, const USHORT * puGreen, const USHORT * puBlue) {
    PFN_WGLSETGAMMATABLEI3D _ptr;
    _ptr = (PFN_WGLSETGAMMATABLEI3D)_getPrivateProcAddress("wglSetGammaTableI3D");
    if (!_ptr) {
        _ptr = &_fail_wglSetGammaTableI3D;
    }
    _wglSetGammaTableI3D = _ptr;
    return _wglSetGammaTableI3D(hDC, iEntries, puRed, puGreen, puBlue);
}

PFN_WGLSETGAMMATABLEI3D _wglSetGammaTableI3D = &_get_wglSetGammaTableI3D;

static BOOL __stdcall _fail_wglEnableGenlockI3D(HDC hDC) {
    const char *_name = "wglEnableGenlockI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglEnableGenlockI3D(HDC hDC) {
    PFN_WGLENABLEGENLOCKI3D _ptr;
    _ptr = (PFN_WGLENABLEGENLOCKI3D)_getPrivateProcAddress("wglEnableGenlockI3D");
    if (!_ptr) {
        _ptr = &_fail_wglEnableGenlockI3D;
    }
    _wglEnableGenlockI3D = _ptr;
    return _wglEnableGenlockI3D(hDC);
}

PFN_WGLENABLEGENLOCKI3D _wglEnableGenlockI3D = &_get_wglEnableGenlockI3D;

static BOOL __stdcall _fail_wglDisableGenlockI3D(HDC hDC) {
    const char *_name = "wglDisableGenlockI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglDisableGenlockI3D(HDC hDC) {
    PFN_WGLDISABLEGENLOCKI3D _ptr;
    _ptr = (PFN_WGLDISABLEGENLOCKI3D)_getPrivateProcAddress("wglDisableGenlockI3D");
    if (!_ptr) {
        _ptr = &_fail_wglDisableGenlockI3D;
    }
    _wglDisableGenlockI3D = _ptr;
    return _wglDisableGenlockI3D(hDC);
}

PFN_WGLDISABLEGENLOCKI3D _wglDisableGenlockI3D = &_get_wglDisableGenlockI3D;

static BOOL __stdcall _fail_wglIsEnabledGenlockI3D(HDC hDC, BOOL * pFlag) {
    const char *_name = "wglIsEnabledGenlockI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglIsEnabledGenlockI3D(HDC hDC, BOOL * pFlag) {
    PFN_WGLISENABLEDGENLOCKI3D _ptr;
    _ptr = (PFN_WGLISENABLEDGENLOCKI3D)_getPrivateProcAddress("wglIsEnabledGenlockI3D");
    if (!_ptr) {
        _ptr = &_fail_wglIsEnabledGenlockI3D;
    }
    _wglIsEnabledGenlockI3D = _ptr;
    return _wglIsEnabledGenlockI3D(hDC, pFlag);
}

PFN_WGLISENABLEDGENLOCKI3D _wglIsEnabledGenlockI3D = &_get_wglIsEnabledGenlockI3D;

static BOOL __stdcall _fail_wglGenlockSourceI3D(HDC hDC, UINT uSource) {
    const char *_name = "wglGenlockSourceI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGenlockSourceI3D(HDC hDC, UINT uSource) {
    PFN_WGLGENLOCKSOURCEI3D _ptr;
    _ptr = (PFN_WGLGENLOCKSOURCEI3D)_getPrivateProcAddress("wglGenlockSourceI3D");
    if (!_ptr) {
        _ptr = &_fail_wglGenlockSourceI3D;
    }
    _wglGenlockSourceI3D = _ptr;
    return _wglGenlockSourceI3D(hDC, uSource);
}

PFN_WGLGENLOCKSOURCEI3D _wglGenlockSourceI3D = &_get_wglGenlockSourceI3D;

static BOOL __stdcall _fail_wglGetGenlockSourceI3D(HDC hDC, UINT * uSource) {
    const char *_name = "wglGetGenlockSourceI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGetGenlockSourceI3D(HDC hDC, UINT * uSource) {
    PFN_WGLGETGENLOCKSOURCEI3D _ptr;
    _ptr = (PFN_WGLGETGENLOCKSOURCEI3D)_getPrivateProcAddress("wglGetGenlockSourceI3D");
    if (!_ptr) {
        _ptr = &_fail_wglGetGenlockSourceI3D;
    }
    _wglGetGenlockSourceI3D = _ptr;
    return _wglGetGenlockSourceI3D(hDC, uSource);
}

PFN_WGLGETGENLOCKSOURCEI3D _wglGetGenlockSourceI3D = &_get_wglGetGenlockSourceI3D;

static BOOL __stdcall _fail_wglGenlockSourceEdgeI3D(HDC hDC, UINT uEdge) {
    const char *_name = "wglGenlockSourceEdgeI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGenlockSourceEdgeI3D(HDC hDC, UINT uEdge) {
    PFN_WGLGENLOCKSOURCEEDGEI3D _ptr;
    _ptr = (PFN_WGLGENLOCKSOURCEEDGEI3D)_getPrivateProcAddress("wglGenlockSourceEdgeI3D");
    if (!_ptr) {
        _ptr = &_fail_wglGenlockSourceEdgeI3D;
    }
    _wglGenlockSourceEdgeI3D = _ptr;
    return _wglGenlockSourceEdgeI3D(hDC, uEdge);
}

PFN_WGLGENLOCKSOURCEEDGEI3D _wglGenlockSourceEdgeI3D = &_get_wglGenlockSourceEdgeI3D;

static BOOL __stdcall _fail_wglGetGenlockSourceEdgeI3D(HDC hDC, UINT * uEdge) {
    const char *_name = "wglGetGenlockSourceEdgeI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGetGenlockSourceEdgeI3D(HDC hDC, UINT * uEdge) {
    PFN_WGLGETGENLOCKSOURCEEDGEI3D _ptr;
    _ptr = (PFN_WGLGETGENLOCKSOURCEEDGEI3D)_getPrivateProcAddress("wglGetGenlockSourceEdgeI3D");
    if (!_ptr) {
        _ptr = &_fail_wglGetGenlockSourceEdgeI3D;
    }
    _wglGetGenlockSourceEdgeI3D = _ptr;
    return _wglGetGenlockSourceEdgeI3D(hDC, uEdge);
}

PFN_WGLGETGENLOCKSOURCEEDGEI3D _wglGetGenlockSourceEdgeI3D = &_get_wglGetGenlockSourceEdgeI3D;

static BOOL __stdcall _fail_wglGenlockSampleRateI3D(HDC hDC, UINT uRate) {
    const char *_name = "wglGenlockSampleRateI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGenlockSampleRateI3D(HDC hDC, UINT uRate) {
    PFN_WGLGENLOCKSAMPLERATEI3D _ptr;
    _ptr = (PFN_WGLGENLOCKSAMPLERATEI3D)_getPrivateProcAddress("wglGenlockSampleRateI3D");
    if (!_ptr) {
        _ptr = &_fail_wglGenlockSampleRateI3D;
    }
    _wglGenlockSampleRateI3D = _ptr;
    return _wglGenlockSampleRateI3D(hDC, uRate);
}

PFN_WGLGENLOCKSAMPLERATEI3D _wglGenlockSampleRateI3D = &_get_wglGenlockSampleRateI3D;

static BOOL __stdcall _fail_wglGetGenlockSampleRateI3D(HDC hDC, UINT * uRate) {
    const char *_name = "wglGetGenlockSampleRateI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGetGenlockSampleRateI3D(HDC hDC, UINT * uRate) {
    PFN_WGLGETGENLOCKSAMPLERATEI3D _ptr;
    _ptr = (PFN_WGLGETGENLOCKSAMPLERATEI3D)_getPrivateProcAddress("wglGetGenlockSampleRateI3D");
    if (!_ptr) {
        _ptr = &_fail_wglGetGenlockSampleRateI3D;
    }
    _wglGetGenlockSampleRateI3D = _ptr;
    return _wglGetGenlockSampleRateI3D(hDC, uRate);
}

PFN_WGLGETGENLOCKSAMPLERATEI3D _wglGetGenlockSampleRateI3D = &_get_wglGetGenlockSampleRateI3D;

static BOOL __stdcall _fail_wglGenlockSourceDelayI3D(HDC hDC, UINT uDelay) {
    const char *_name = "wglGenlockSourceDelayI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGenlockSourceDelayI3D(HDC hDC, UINT uDelay) {
    PFN_WGLGENLOCKSOURCEDELAYI3D _ptr;
    _ptr = (PFN_WGLGENLOCKSOURCEDELAYI3D)_getPrivateProcAddress("wglGenlockSourceDelayI3D");
    if (!_ptr) {
        _ptr = &_fail_wglGenlockSourceDelayI3D;
    }
    _wglGenlockSourceDelayI3D = _ptr;
    return _wglGenlockSourceDelayI3D(hDC, uDelay);
}

PFN_WGLGENLOCKSOURCEDELAYI3D _wglGenlockSourceDelayI3D = &_get_wglGenlockSourceDelayI3D;

static BOOL __stdcall _fail_wglGetGenlockSourceDelayI3D(HDC hDC, UINT * uDelay) {
    const char *_name = "wglGetGenlockSourceDelayI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGetGenlockSourceDelayI3D(HDC hDC, UINT * uDelay) {
    PFN_WGLGETGENLOCKSOURCEDELAYI3D _ptr;
    _ptr = (PFN_WGLGETGENLOCKSOURCEDELAYI3D)_getPrivateProcAddress("wglGetGenlockSourceDelayI3D");
    if (!_ptr) {
        _ptr = &_fail_wglGetGenlockSourceDelayI3D;
    }
    _wglGetGenlockSourceDelayI3D = _ptr;
    return _wglGetGenlockSourceDelayI3D(hDC, uDelay);
}

PFN_WGLGETGENLOCKSOURCEDELAYI3D _wglGetGenlockSourceDelayI3D = &_get_wglGetGenlockSourceDelayI3D;

static BOOL __stdcall _fail_wglQueryGenlockMaxSourceDelayI3D(HDC hDC, UINT * uMaxLineDelay, UINT * uMaxPixelDelay) {
    const char *_name = "wglQueryGenlockMaxSourceDelayI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglQueryGenlockMaxSourceDelayI3D(HDC hDC, UINT * uMaxLineDelay, UINT * uMaxPixelDelay) {
    PFN_WGLQUERYGENLOCKMAXSOURCEDELAYI3D _ptr;
    _ptr = (PFN_WGLQUERYGENLOCKMAXSOURCEDELAYI3D)_getPrivateProcAddress("wglQueryGenlockMaxSourceDelayI3D");
    if (!_ptr) {
        _ptr = &_fail_wglQueryGenlockMaxSourceDelayI3D;
    }
    _wglQueryGenlockMaxSourceDelayI3D = _ptr;
    return _wglQueryGenlockMaxSourceDelayI3D(hDC, uMaxLineDelay, uMaxPixelDelay);
}

PFN_WGLQUERYGENLOCKMAXSOURCEDELAYI3D _wglQueryGenlockMaxSourceDelayI3D = &_get_wglQueryGenlockMaxSourceDelayI3D;

static void * __stdcall _fail_wglCreateImageBufferI3D(HDC hDC, DWORD dwSize, UINT uFlags) {
    const char *_name = "wglCreateImageBufferI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static void * __stdcall _get_wglCreateImageBufferI3D(HDC hDC, DWORD dwSize, UINT uFlags) {
    PFN_WGLCREATEIMAGEBUFFERI3D _ptr;
    _ptr = (PFN_WGLCREATEIMAGEBUFFERI3D)_getPrivateProcAddress("wglCreateImageBufferI3D");
    if (!_ptr) {
        _ptr = &_fail_wglCreateImageBufferI3D;
    }
    _wglCreateImageBufferI3D = _ptr;
    return _wglCreateImageBufferI3D(hDC, dwSize, uFlags);
}

PFN_WGLCREATEIMAGEBUFFERI3D _wglCreateImageBufferI3D = &_get_wglCreateImageBufferI3D;

static BOOL __stdcall _fail_wglDestroyImageBufferI3D(HDC hDC, void * pAddress) {
    const char *_name = "wglDestroyImageBufferI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglDestroyImageBufferI3D(HDC hDC, void * pAddress) {
    PFN_WGLDESTROYIMAGEBUFFERI3D _ptr;
    _ptr = (PFN_WGLDESTROYIMAGEBUFFERI3D)_getPrivateProcAddress("wglDestroyImageBufferI3D");
    if (!_ptr) {
        _ptr = &_fail_wglDestroyImageBufferI3D;
    }
    _wglDestroyImageBufferI3D = _ptr;
    return _wglDestroyImageBufferI3D(hDC, pAddress);
}

PFN_WGLDESTROYIMAGEBUFFERI3D _wglDestroyImageBufferI3D = &_get_wglDestroyImageBufferI3D;

static BOOL __stdcall _fail_wglAssociateImageBufferEventsI3D(HDC hDC, const HANDLE * pEvent, void * const * pAddress, const DWORD * pSize, UINT count) {
    const char *_name = "wglAssociateImageBufferEventsI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglAssociateImageBufferEventsI3D(HDC hDC, const HANDLE * pEvent, void * const * pAddress, const DWORD * pSize, UINT count) {
    PFN_WGLASSOCIATEIMAGEBUFFEREVENTSI3D _ptr;
    _ptr = (PFN_WGLASSOCIATEIMAGEBUFFEREVENTSI3D)_getPrivateProcAddress("wglAssociateImageBufferEventsI3D");
    if (!_ptr) {
        _ptr = &_fail_wglAssociateImageBufferEventsI3D;
    }
    _wglAssociateImageBufferEventsI3D = _ptr;
    return _wglAssociateImageBufferEventsI3D(hDC, pEvent, pAddress, pSize, count);
}

PFN_WGLASSOCIATEIMAGEBUFFEREVENTSI3D _wglAssociateImageBufferEventsI3D = &_get_wglAssociateImageBufferEventsI3D;

static BOOL __stdcall _fail_wglReleaseImageBufferEventsI3D(HDC hDC, void * const * pAddress, UINT count) {
    const char *_name = "wglReleaseImageBufferEventsI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglReleaseImageBufferEventsI3D(HDC hDC, void * const * pAddress, UINT count) {
    PFN_WGLRELEASEIMAGEBUFFEREVENTSI3D _ptr;
    _ptr = (PFN_WGLRELEASEIMAGEBUFFEREVENTSI3D)_getPrivateProcAddress("wglReleaseImageBufferEventsI3D");
    if (!_ptr) {
        _ptr = &_fail_wglReleaseImageBufferEventsI3D;
    }
    _wglReleaseImageBufferEventsI3D = _ptr;
    return _wglReleaseImageBufferEventsI3D(hDC, pAddress, count);
}

PFN_WGLRELEASEIMAGEBUFFEREVENTSI3D _wglReleaseImageBufferEventsI3D = &_get_wglReleaseImageBufferEventsI3D;

static BOOL __stdcall _fail_wglEnableFrameLockI3D(void) {
    const char *_name = "wglEnableFrameLockI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglEnableFrameLockI3D(void) {
    PFN_WGLENABLEFRAMELOCKI3D _ptr;
    _ptr = (PFN_WGLENABLEFRAMELOCKI3D)_getPrivateProcAddress("wglEnableFrameLockI3D");
    if (!_ptr) {
        _ptr = &_fail_wglEnableFrameLockI3D;
    }
    _wglEnableFrameLockI3D = _ptr;
    return _wglEnableFrameLockI3D();
}

PFN_WGLENABLEFRAMELOCKI3D _wglEnableFrameLockI3D = &_get_wglEnableFrameLockI3D;

static BOOL __stdcall _fail_wglDisableFrameLockI3D(void) {
    const char *_name = "wglDisableFrameLockI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglDisableFrameLockI3D(void) {
    PFN_WGLDISABLEFRAMELOCKI3D _ptr;
    _ptr = (PFN_WGLDISABLEFRAMELOCKI3D)_getPrivateProcAddress("wglDisableFrameLockI3D");
    if (!_ptr) {
        _ptr = &_fail_wglDisableFrameLockI3D;
    }
    _wglDisableFrameLockI3D = _ptr;
    return _wglDisableFrameLockI3D();
}

PFN_WGLDISABLEFRAMELOCKI3D _wglDisableFrameLockI3D = &_get_wglDisableFrameLockI3D;

static BOOL __stdcall _fail_wglIsEnabledFrameLockI3D(BOOL * pFlag) {
    const char *_name = "wglIsEnabledFrameLockI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglIsEnabledFrameLockI3D(BOOL * pFlag) {
    PFN_WGLISENABLEDFRAMELOCKI3D _ptr;
    _ptr = (PFN_WGLISENABLEDFRAMELOCKI3D)_getPrivateProcAddress("wglIsEnabledFrameLockI3D");
    if (!_ptr) {
        _ptr = &_fail_wglIsEnabledFrameLockI3D;
    }
    _wglIsEnabledFrameLockI3D = _ptr;
    return _wglIsEnabledFrameLockI3D(pFlag);
}

PFN_WGLISENABLEDFRAMELOCKI3D _wglIsEnabledFrameLockI3D = &_get_wglIsEnabledFrameLockI3D;

static BOOL __stdcall _fail_wglQueryFrameLockMasterI3D(BOOL * pFlag) {
    const char *_name = "wglQueryFrameLockMasterI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglQueryFrameLockMasterI3D(BOOL * pFlag) {
    PFN_WGLQUERYFRAMELOCKMASTERI3D _ptr;
    _ptr = (PFN_WGLQUERYFRAMELOCKMASTERI3D)_getPrivateProcAddress("wglQueryFrameLockMasterI3D");
    if (!_ptr) {
        _ptr = &_fail_wglQueryFrameLockMasterI3D;
    }
    _wglQueryFrameLockMasterI3D = _ptr;
    return _wglQueryFrameLockMasterI3D(pFlag);
}

PFN_WGLQUERYFRAMELOCKMASTERI3D _wglQueryFrameLockMasterI3D = &_get_wglQueryFrameLockMasterI3D;

static BOOL __stdcall _fail_wglGetFrameUsageI3D(float * pUsage) {
    const char *_name = "wglGetFrameUsageI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGetFrameUsageI3D(float * pUsage) {
    PFN_WGLGETFRAMEUSAGEI3D _ptr;
    _ptr = (PFN_WGLGETFRAMEUSAGEI3D)_getPrivateProcAddress("wglGetFrameUsageI3D");
    if (!_ptr) {
        _ptr = &_fail_wglGetFrameUsageI3D;
    }
    _wglGetFrameUsageI3D = _ptr;
    return _wglGetFrameUsageI3D(pUsage);
}

PFN_WGLGETFRAMEUSAGEI3D _wglGetFrameUsageI3D = &_get_wglGetFrameUsageI3D;

static BOOL __stdcall _fail_wglBeginFrameTrackingI3D(void) {
    const char *_name = "wglBeginFrameTrackingI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglBeginFrameTrackingI3D(void) {
    PFN_WGLBEGINFRAMETRACKINGI3D _ptr;
    _ptr = (PFN_WGLBEGINFRAMETRACKINGI3D)_getPrivateProcAddress("wglBeginFrameTrackingI3D");
    if (!_ptr) {
        _ptr = &_fail_wglBeginFrameTrackingI3D;
    }
    _wglBeginFrameTrackingI3D = _ptr;
    return _wglBeginFrameTrackingI3D();
}

PFN_WGLBEGINFRAMETRACKINGI3D _wglBeginFrameTrackingI3D = &_get_wglBeginFrameTrackingI3D;

static BOOL __stdcall _fail_wglEndFrameTrackingI3D(void) {
    const char *_name = "wglEndFrameTrackingI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglEndFrameTrackingI3D(void) {
    PFN_WGLENDFRAMETRACKINGI3D _ptr;
    _ptr = (PFN_WGLENDFRAMETRACKINGI3D)_getPrivateProcAddress("wglEndFrameTrackingI3D");
    if (!_ptr) {
        _ptr = &_fail_wglEndFrameTrackingI3D;
    }
    _wglEndFrameTrackingI3D = _ptr;
    return _wglEndFrameTrackingI3D();
}

PFN_WGLENDFRAMETRACKINGI3D _wglEndFrameTrackingI3D = &_get_wglEndFrameTrackingI3D;

static BOOL __stdcall _fail_wglQueryFrameTrackingI3D(DWORD * pFrameCount, DWORD * pMissedFrames, float * pLastMissedUsage) {
    const char *_name = "wglQueryFrameTrackingI3D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglQueryFrameTrackingI3D(DWORD * pFrameCount, DWORD * pMissedFrames, float * pLastMissedUsage) {
    PFN_WGLQUERYFRAMETRACKINGI3D _ptr;
    _ptr = (PFN_WGLQUERYFRAMETRACKINGI3D)_getPrivateProcAddress("wglQueryFrameTrackingI3D");
    if (!_ptr) {
        _ptr = &_fail_wglQueryFrameTrackingI3D;
    }
    _wglQueryFrameTrackingI3D = _ptr;
    return _wglQueryFrameTrackingI3D(pFrameCount, pMissedFrames, pLastMissedUsage);
}

PFN_WGLQUERYFRAMETRACKINGI3D _wglQueryFrameTrackingI3D = &_get_wglQueryFrameTrackingI3D;

static BOOL __stdcall _fail_wglSetStereoEmitterState3DL(HDC hDC, UINT uState) {
    const char *_name = "wglSetStereoEmitterState3DL";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglSetStereoEmitterState3DL(HDC hDC, UINT uState) {
    PFN_WGLSETSTEREOEMITTERSTATE3DL _ptr;
    _ptr = (PFN_WGLSETSTEREOEMITTERSTATE3DL)_getPrivateProcAddress("wglSetStereoEmitterState3DL");
    if (!_ptr) {
        _ptr = &_fail_wglSetStereoEmitterState3DL;
    }
    _wglSetStereoEmitterState3DL = _ptr;
    return _wglSetStereoEmitterState3DL(hDC, uState);
}

PFN_WGLSETSTEREOEMITTERSTATE3DL _wglSetStereoEmitterState3DL = &_get_wglSetStereoEmitterState3DL;

static int __stdcall _fail_wglEnumerateVideoDevicesNV(HDC hDC, HVIDEOOUTPUTDEVICENV * phDeviceList) {
    const char *_name = "wglEnumerateVideoDevicesNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int __stdcall _get_wglEnumerateVideoDevicesNV(HDC hDC, HVIDEOOUTPUTDEVICENV * phDeviceList) {
    PFN_WGLENUMERATEVIDEODEVICESNV _ptr;
    _ptr = (PFN_WGLENUMERATEVIDEODEVICESNV)_getPrivateProcAddress("wglEnumerateVideoDevicesNV");
    if (!_ptr) {
        _ptr = &_fail_wglEnumerateVideoDevicesNV;
    }
    _wglEnumerateVideoDevicesNV = _ptr;
    return _wglEnumerateVideoDevicesNV(hDC, phDeviceList);
}

PFN_WGLENUMERATEVIDEODEVICESNV _wglEnumerateVideoDevicesNV = &_get_wglEnumerateVideoDevicesNV;

static BOOL __stdcall _fail_wglBindVideoDeviceNV(HDC hDC, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int * piAttribList) {
    const char *_name = "wglBindVideoDeviceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglBindVideoDeviceNV(HDC hDC, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int * piAttribList) {
    PFN_WGLBINDVIDEODEVICENV _ptr;
    _ptr = (PFN_WGLBINDVIDEODEVICENV)_getPrivateProcAddress("wglBindVideoDeviceNV");
    if (!_ptr) {
        _ptr = &_fail_wglBindVideoDeviceNV;
    }
    _wglBindVideoDeviceNV = _ptr;
    return _wglBindVideoDeviceNV(hDC, uVideoSlot, hVideoDevice, piAttribList);
}

PFN_WGLBINDVIDEODEVICENV _wglBindVideoDeviceNV = &_get_wglBindVideoDeviceNV;

static BOOL __stdcall _fail_wglQueryCurrentContextNV(int iAttribute, int * piValue) {
    const char *_name = "wglQueryCurrentContextNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglQueryCurrentContextNV(int iAttribute, int * piValue) {
    PFN_WGLQUERYCURRENTCONTEXTNV _ptr;
    _ptr = (PFN_WGLQUERYCURRENTCONTEXTNV)_getPrivateProcAddress("wglQueryCurrentContextNV");
    if (!_ptr) {
        _ptr = &_fail_wglQueryCurrentContextNV;
    }
    _wglQueryCurrentContextNV = _ptr;
    return _wglQueryCurrentContextNV(iAttribute, piValue);
}

PFN_WGLQUERYCURRENTCONTEXTNV _wglQueryCurrentContextNV = &_get_wglQueryCurrentContextNV;

static BOOL __stdcall _fail_wglGetVideoDeviceNV(HDC hDC, int numDevices, HPVIDEODEV * hVideoDevice) {
    const char *_name = "wglGetVideoDeviceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGetVideoDeviceNV(HDC hDC, int numDevices, HPVIDEODEV * hVideoDevice) {
    PFN_WGLGETVIDEODEVICENV _ptr;
    _ptr = (PFN_WGLGETVIDEODEVICENV)_getPrivateProcAddress("wglGetVideoDeviceNV");
    if (!_ptr) {
        _ptr = &_fail_wglGetVideoDeviceNV;
    }
    _wglGetVideoDeviceNV = _ptr;
    return _wglGetVideoDeviceNV(hDC, numDevices, hVideoDevice);
}

PFN_WGLGETVIDEODEVICENV _wglGetVideoDeviceNV = &_get_wglGetVideoDeviceNV;

static BOOL __stdcall _fail_wglReleaseVideoDeviceNV(HPVIDEODEV hVideoDevice) {
    const char *_name = "wglReleaseVideoDeviceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglReleaseVideoDeviceNV(HPVIDEODEV hVideoDevice) {
    PFN_WGLRELEASEVIDEODEVICENV _ptr;
    _ptr = (PFN_WGLRELEASEVIDEODEVICENV)_getPrivateProcAddress("wglReleaseVideoDeviceNV");
    if (!_ptr) {
        _ptr = &_fail_wglReleaseVideoDeviceNV;
    }
    _wglReleaseVideoDeviceNV = _ptr;
    return _wglReleaseVideoDeviceNV(hVideoDevice);
}

PFN_WGLRELEASEVIDEODEVICENV _wglReleaseVideoDeviceNV = &_get_wglReleaseVideoDeviceNV;

static BOOL __stdcall _fail_wglBindVideoImageNV(HPVIDEODEV hVideoDevice, HPBUFFERARB hPbuffer, int iVideoBuffer) {
    const char *_name = "wglBindVideoImageNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglBindVideoImageNV(HPVIDEODEV hVideoDevice, HPBUFFERARB hPbuffer, int iVideoBuffer) {
    PFN_WGLBINDVIDEOIMAGENV _ptr;
    _ptr = (PFN_WGLBINDVIDEOIMAGENV)_getPrivateProcAddress("wglBindVideoImageNV");
    if (!_ptr) {
        _ptr = &_fail_wglBindVideoImageNV;
    }
    _wglBindVideoImageNV = _ptr;
    return _wglBindVideoImageNV(hVideoDevice, hPbuffer, iVideoBuffer);
}

PFN_WGLBINDVIDEOIMAGENV _wglBindVideoImageNV = &_get_wglBindVideoImageNV;

static BOOL __stdcall _fail_wglReleaseVideoImageNV(HPBUFFERARB hPbuffer, int iVideoBuffer) {
    const char *_name = "wglReleaseVideoImageNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglReleaseVideoImageNV(HPBUFFERARB hPbuffer, int iVideoBuffer) {
    PFN_WGLRELEASEVIDEOIMAGENV _ptr;
    _ptr = (PFN_WGLRELEASEVIDEOIMAGENV)_getPrivateProcAddress("wglReleaseVideoImageNV");
    if (!_ptr) {
        _ptr = &_fail_wglReleaseVideoImageNV;
    }
    _wglReleaseVideoImageNV = _ptr;
    return _wglReleaseVideoImageNV(hPbuffer, iVideoBuffer);
}

PFN_WGLRELEASEVIDEOIMAGENV _wglReleaseVideoImageNV = &_get_wglReleaseVideoImageNV;

static BOOL __stdcall _fail_wglSendPbufferToVideoNV(HPBUFFERARB hPbuffer, int iBufferType, unsigned long * pulCounterPbuffer, BOOL bBlock) {
    const char *_name = "wglSendPbufferToVideoNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglSendPbufferToVideoNV(HPBUFFERARB hPbuffer, int iBufferType, unsigned long * pulCounterPbuffer, BOOL bBlock) {
    PFN_WGLSENDPBUFFERTOVIDEONV _ptr;
    _ptr = (PFN_WGLSENDPBUFFERTOVIDEONV)_getPrivateProcAddress("wglSendPbufferToVideoNV");
    if (!_ptr) {
        _ptr = &_fail_wglSendPbufferToVideoNV;
    }
    _wglSendPbufferToVideoNV = _ptr;
    return _wglSendPbufferToVideoNV(hPbuffer, iBufferType, pulCounterPbuffer, bBlock);
}

PFN_WGLSENDPBUFFERTOVIDEONV _wglSendPbufferToVideoNV = &_get_wglSendPbufferToVideoNV;

static BOOL __stdcall _fail_wglGetVideoInfoNV(HPVIDEODEV hpVideoDevice, unsigned long * pulCounterOutputPbuffer, unsigned long * pulCounterOutputVideo) {
    const char *_name = "wglGetVideoInfoNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglGetVideoInfoNV(HPVIDEODEV hpVideoDevice, unsigned long * pulCounterOutputPbuffer, unsigned long * pulCounterOutputVideo) {
    PFN_WGLGETVIDEOINFONV _ptr;
    _ptr = (PFN_WGLGETVIDEOINFONV)_getPrivateProcAddress("wglGetVideoInfoNV");
    if (!_ptr) {
        _ptr = &_fail_wglGetVideoInfoNV;
    }
    _wglGetVideoInfoNV = _ptr;
    return _wglGetVideoInfoNV(hpVideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
}

PFN_WGLGETVIDEOINFONV _wglGetVideoInfoNV = &_get_wglGetVideoInfoNV;

static BOOL __stdcall _fail_wglJoinSwapGroupNV(HDC hDC, GLuint group) {
    const char *_name = "wglJoinSwapGroupNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglJoinSwapGroupNV(HDC hDC, GLuint group) {
    PFN_WGLJOINSWAPGROUPNV _ptr;
    _ptr = (PFN_WGLJOINSWAPGROUPNV)_getPrivateProcAddress("wglJoinSwapGroupNV");
    if (!_ptr) {
        _ptr = &_fail_wglJoinSwapGroupNV;
    }
    _wglJoinSwapGroupNV = _ptr;
    return _wglJoinSwapGroupNV(hDC, group);
}

PFN_WGLJOINSWAPGROUPNV _wglJoinSwapGroupNV = &_get_wglJoinSwapGroupNV;

static BOOL __stdcall _fail_wglBindSwapBarrierNV(GLuint group, GLuint barrier) {
    const char *_name = "wglBindSwapBarrierNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglBindSwapBarrierNV(GLuint group, GLuint barrier) {
    PFN_WGLBINDSWAPBARRIERNV _ptr;
    _ptr = (PFN_WGLBINDSWAPBARRIERNV)_getPrivateProcAddress("wglBindSwapBarrierNV");
    if (!_ptr) {
        _ptr = &_fail_wglBindSwapBarrierNV;
    }
    _wglBindSwapBarrierNV = _ptr;
    return _wglBindSwapBarrierNV(group, barrier);
}

PFN_WGLBINDSWAPBARRIERNV _wglBindSwapBarrierNV = &_get_wglBindSwapBarrierNV;

static BOOL __stdcall _fail_wglQuerySwapGroupNV(HDC hDC, GLuint * group, GLuint * barrier) {
    const char *_name = "wglQuerySwapGroupNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglQuerySwapGroupNV(HDC hDC, GLuint * group, GLuint * barrier) {
    PFN_WGLQUERYSWAPGROUPNV _ptr;
    _ptr = (PFN_WGLQUERYSWAPGROUPNV)_getPrivateProcAddress("wglQuerySwapGroupNV");
    if (!_ptr) {
        _ptr = &_fail_wglQuerySwapGroupNV;
    }
    _wglQuerySwapGroupNV = _ptr;
    return _wglQuerySwapGroupNV(hDC, group, barrier);
}

PFN_WGLQUERYSWAPGROUPNV _wglQuerySwapGroupNV = &_get_wglQuerySwapGroupNV;

static BOOL __stdcall _fail_wglQueryMaxSwapGroupsNV(HDC hDC, GLuint * maxGroups, GLuint * maxBarriers) {
    const char *_name = "wglQueryMaxSwapGroupsNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglQueryMaxSwapGroupsNV(HDC hDC, GLuint * maxGroups, GLuint * maxBarriers) {
    PFN_WGLQUERYMAXSWAPGROUPSNV _ptr;
    _ptr = (PFN_WGLQUERYMAXSWAPGROUPSNV)_getPrivateProcAddress("wglQueryMaxSwapGroupsNV");
    if (!_ptr) {
        _ptr = &_fail_wglQueryMaxSwapGroupsNV;
    }
    _wglQueryMaxSwapGroupsNV = _ptr;
    return _wglQueryMaxSwapGroupsNV(hDC, maxGroups, maxBarriers);
}

PFN_WGLQUERYMAXSWAPGROUPSNV _wglQueryMaxSwapGroupsNV = &_get_wglQueryMaxSwapGroupsNV;

static BOOL __stdcall _fail_wglQueryFrameCountNV(HDC hDC, GLuint * count) {
    const char *_name = "wglQueryFrameCountNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglQueryFrameCountNV(HDC hDC, GLuint * count) {
    PFN_WGLQUERYFRAMECOUNTNV _ptr;
    _ptr = (PFN_WGLQUERYFRAMECOUNTNV)_getPrivateProcAddress("wglQueryFrameCountNV");
    if (!_ptr) {
        _ptr = &_fail_wglQueryFrameCountNV;
    }
    _wglQueryFrameCountNV = _ptr;
    return _wglQueryFrameCountNV(hDC, count);
}

PFN_WGLQUERYFRAMECOUNTNV _wglQueryFrameCountNV = &_get_wglQueryFrameCountNV;

static BOOL __stdcall _fail_wglResetFrameCountNV(HDC hDC) {
    const char *_name = "wglResetFrameCountNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglResetFrameCountNV(HDC hDC) {
    PFN_WGLRESETFRAMECOUNTNV _ptr;
    _ptr = (PFN_WGLRESETFRAMECOUNTNV)_getPrivateProcAddress("wglResetFrameCountNV");
    if (!_ptr) {
        _ptr = &_fail_wglResetFrameCountNV;
    }
    _wglResetFrameCountNV = _ptr;
    return _wglResetFrameCountNV(hDC);
}

PFN_WGLRESETFRAMECOUNTNV _wglResetFrameCountNV = &_get_wglResetFrameCountNV;

static BOOL __stdcall _fail_wglEnumGpusNV(UINT iGpuIndex, HGPUNV * phGpu) {
    const char *_name = "wglEnumGpusNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglEnumGpusNV(UINT iGpuIndex, HGPUNV * phGpu) {
    PFN_WGLENUMGPUSNV _ptr;
    _ptr = (PFN_WGLENUMGPUSNV)_getPrivateProcAddress("wglEnumGpusNV");
    if (!_ptr) {
        _ptr = &_fail_wglEnumGpusNV;
    }
    _wglEnumGpusNV = _ptr;
    return _wglEnumGpusNV(iGpuIndex, phGpu);
}

PFN_WGLENUMGPUSNV _wglEnumGpusNV = &_get_wglEnumGpusNV;

static BOOL __stdcall _fail_wglEnumGpuDevicesNV(HGPUNV hGpu, UINT iDeviceIndex, _GPU_DEVICE * lpGpuDevice) {
    const char *_name = "wglEnumGpuDevicesNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglEnumGpuDevicesNV(HGPUNV hGpu, UINT iDeviceIndex, _GPU_DEVICE * lpGpuDevice) {
    PFN_WGLENUMGPUDEVICESNV _ptr;
    _ptr = (PFN_WGLENUMGPUDEVICESNV)_getPrivateProcAddress("wglEnumGpuDevicesNV");
    if (!_ptr) {
        _ptr = &_fail_wglEnumGpuDevicesNV;
    }
    _wglEnumGpuDevicesNV = _ptr;
    return _wglEnumGpuDevicesNV(hGpu, iDeviceIndex, lpGpuDevice);
}

PFN_WGLENUMGPUDEVICESNV _wglEnumGpuDevicesNV = &_get_wglEnumGpuDevicesNV;

static HDC __stdcall _fail_wglCreateAffinityDCNV(const HGPUNV * phGpuList) {
    const char *_name = "wglCreateAffinityDCNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static HDC __stdcall _get_wglCreateAffinityDCNV(const HGPUNV * phGpuList) {
    PFN_WGLCREATEAFFINITYDCNV _ptr;
    _ptr = (PFN_WGLCREATEAFFINITYDCNV)_getPrivateProcAddress("wglCreateAffinityDCNV");
    if (!_ptr) {
        _ptr = &_fail_wglCreateAffinityDCNV;
    }
    _wglCreateAffinityDCNV = _ptr;
    return _wglCreateAffinityDCNV(phGpuList);
}

PFN_WGLCREATEAFFINITYDCNV _wglCreateAffinityDCNV = &_get_wglCreateAffinityDCNV;

static BOOL __stdcall _fail_wglEnumGpusFromAffinityDCNV(HDC hAffinityDC, UINT iGpuIndex, HGPUNV * hGpu) {
    const char *_name = "wglEnumGpusFromAffinityDCNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglEnumGpusFromAffinityDCNV(HDC hAffinityDC, UINT iGpuIndex, HGPUNV * hGpu) {
    PFN_WGLENUMGPUSFROMAFFINITYDCNV _ptr;
    _ptr = (PFN_WGLENUMGPUSFROMAFFINITYDCNV)_getPrivateProcAddress("wglEnumGpusFromAffinityDCNV");
    if (!_ptr) {
        _ptr = &_fail_wglEnumGpusFromAffinityDCNV;
    }
    _wglEnumGpusFromAffinityDCNV = _ptr;
    return _wglEnumGpusFromAffinityDCNV(hAffinityDC, iGpuIndex, hGpu);
}

PFN_WGLENUMGPUSFROMAFFINITYDCNV _wglEnumGpusFromAffinityDCNV = &_get_wglEnumGpusFromAffinityDCNV;

static BOOL __stdcall _fail_wglDeleteDCNV(HDC hdc) {
    const char *_name = "wglDeleteDCNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglDeleteDCNV(HDC hdc) {
    PFN_WGLDELETEDCNV _ptr;
    _ptr = (PFN_WGLDELETEDCNV)_getPrivateProcAddress("wglDeleteDCNV");
    if (!_ptr) {
        _ptr = &_fail_wglDeleteDCNV;
    }
    _wglDeleteDCNV = _ptr;
    return _wglDeleteDCNV(hdc);
}

PFN_WGLDELETEDCNV _wglDeleteDCNV = &_get_wglDeleteDCNV;

static UINT __stdcall _fail_wglGetGPUIDsAMD(UINT maxCount, UINT * ids) {
    const char *_name = "wglGetGPUIDsAMD";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static UINT __stdcall _get_wglGetGPUIDsAMD(UINT maxCount, UINT * ids) {
    PFN_WGLGETGPUIDSAMD _ptr;
    _ptr = (PFN_WGLGETGPUIDSAMD)_getPrivateProcAddress("wglGetGPUIDsAMD");
    if (!_ptr) {
        _ptr = &_fail_wglGetGPUIDsAMD;
    }
    _wglGetGPUIDsAMD = _ptr;
    return _wglGetGPUIDsAMD(maxCount, ids);
}

PFN_WGLGETGPUIDSAMD _wglGetGPUIDsAMD = &_get_wglGetGPUIDsAMD;

static INT __stdcall _fail_wglGetGPUInfoAMD(UINT id, int property, GLenum dataType, UINT size, void * data) {
    const char *_name = "wglGetGPUInfoAMD";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static INT __stdcall _get_wglGetGPUInfoAMD(UINT id, int property, GLenum dataType, UINT size, void * data) {
    PFN_WGLGETGPUINFOAMD _ptr;
    _ptr = (PFN_WGLGETGPUINFOAMD)_getPrivateProcAddress("wglGetGPUInfoAMD");
    if (!_ptr) {
        _ptr = &_fail_wglGetGPUInfoAMD;
    }
    _wglGetGPUInfoAMD = _ptr;
    return _wglGetGPUInfoAMD(id, property, dataType, size, data);
}

PFN_WGLGETGPUINFOAMD _wglGetGPUInfoAMD = &_get_wglGetGPUInfoAMD;

static UINT __stdcall _fail_wglGetContextGPUIDAMD(HGLRC hglrc) {
    const char *_name = "wglGetContextGPUIDAMD";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static UINT __stdcall _get_wglGetContextGPUIDAMD(HGLRC hglrc) {
    PFN_WGLGETCONTEXTGPUIDAMD _ptr;
    _ptr = (PFN_WGLGETCONTEXTGPUIDAMD)_getPrivateProcAddress("wglGetContextGPUIDAMD");
    if (!_ptr) {
        _ptr = &_fail_wglGetContextGPUIDAMD;
    }
    _wglGetContextGPUIDAMD = _ptr;
    return _wglGetContextGPUIDAMD(hglrc);
}

PFN_WGLGETCONTEXTGPUIDAMD _wglGetContextGPUIDAMD = &_get_wglGetContextGPUIDAMD;

static HGLRC __stdcall _fail_wglCreateAssociatedContextAMD(UINT id) {
    const char *_name = "wglCreateAssociatedContextAMD";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static HGLRC __stdcall _get_wglCreateAssociatedContextAMD(UINT id) {
    PFN_WGLCREATEASSOCIATEDCONTEXTAMD _ptr;
    _ptr = (PFN_WGLCREATEASSOCIATEDCONTEXTAMD)_getPrivateProcAddress("wglCreateAssociatedContextAMD");
    if (!_ptr) {
        _ptr = &_fail_wglCreateAssociatedContextAMD;
    }
    _wglCreateAssociatedContextAMD = _ptr;
    return _wglCreateAssociatedContextAMD(id);
}

PFN_WGLCREATEASSOCIATEDCONTEXTAMD _wglCreateAssociatedContextAMD = &_get_wglCreateAssociatedContextAMD;

static HGLRC __stdcall _fail_wglCreateAssociatedContextAttribsAMD(UINT id, HGLRC hShareContext, const int * attribList) {
    const char *_name = "wglCreateAssociatedContextAttribsAMD";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static HGLRC __stdcall _get_wglCreateAssociatedContextAttribsAMD(UINT id, HGLRC hShareContext, const int * attribList) {
    PFN_WGLCREATEASSOCIATEDCONTEXTATTRIBSAMD _ptr;
    _ptr = (PFN_WGLCREATEASSOCIATEDCONTEXTATTRIBSAMD)_getPrivateProcAddress("wglCreateAssociatedContextAttribsAMD");
    if (!_ptr) {
        _ptr = &_fail_wglCreateAssociatedContextAttribsAMD;
    }
    _wglCreateAssociatedContextAttribsAMD = _ptr;
    return _wglCreateAssociatedContextAttribsAMD(id, hShareContext, attribList);
}

PFN_WGLCREATEASSOCIATEDCONTEXTATTRIBSAMD _wglCreateAssociatedContextAttribsAMD = &_get_wglCreateAssociatedContextAttribsAMD;

static BOOL __stdcall _fail_wglDeleteAssociatedContextAMD(HGLRC hglrc) {
    const char *_name = "wglDeleteAssociatedContextAMD";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglDeleteAssociatedContextAMD(HGLRC hglrc) {
    PFN_WGLDELETEASSOCIATEDCONTEXTAMD _ptr;
    _ptr = (PFN_WGLDELETEASSOCIATEDCONTEXTAMD)_getPrivateProcAddress("wglDeleteAssociatedContextAMD");
    if (!_ptr) {
        _ptr = &_fail_wglDeleteAssociatedContextAMD;
    }
    _wglDeleteAssociatedContextAMD = _ptr;
    return _wglDeleteAssociatedContextAMD(hglrc);
}

PFN_WGLDELETEASSOCIATEDCONTEXTAMD _wglDeleteAssociatedContextAMD = &_get_wglDeleteAssociatedContextAMD;

static BOOL __stdcall _fail_wglMakeAssociatedContextCurrentAMD(HGLRC hglrc) {
    const char *_name = "wglMakeAssociatedContextCurrentAMD";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglMakeAssociatedContextCurrentAMD(HGLRC hglrc) {
    PFN_WGLMAKEASSOCIATEDCONTEXTCURRENTAMD _ptr;
    _ptr = (PFN_WGLMAKEASSOCIATEDCONTEXTCURRENTAMD)_getPrivateProcAddress("wglMakeAssociatedContextCurrentAMD");
    if (!_ptr) {
        _ptr = &_fail_wglMakeAssociatedContextCurrentAMD;
    }
    _wglMakeAssociatedContextCurrentAMD = _ptr;
    return _wglMakeAssociatedContextCurrentAMD(hglrc);
}

PFN_WGLMAKEASSOCIATEDCONTEXTCURRENTAMD _wglMakeAssociatedContextCurrentAMD = &_get_wglMakeAssociatedContextCurrentAMD;

static HGLRC __stdcall _fail_wglGetCurrentAssociatedContextAMD(void) {
    const char *_name = "wglGetCurrentAssociatedContextAMD";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static HGLRC __stdcall _get_wglGetCurrentAssociatedContextAMD(void) {
    PFN_WGLGETCURRENTASSOCIATEDCONTEXTAMD _ptr;
    _ptr = (PFN_WGLGETCURRENTASSOCIATEDCONTEXTAMD)_getPrivateProcAddress("wglGetCurrentAssociatedContextAMD");
    if (!_ptr) {
        _ptr = &_fail_wglGetCurrentAssociatedContextAMD;
    }
    _wglGetCurrentAssociatedContextAMD = _ptr;
    return _wglGetCurrentAssociatedContextAMD();
}

PFN_WGLGETCURRENTASSOCIATEDCONTEXTAMD _wglGetCurrentAssociatedContextAMD = &_get_wglGetCurrentAssociatedContextAMD;

static void __stdcall _fail_wglBlitContextFramebufferAMD(HGLRC dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
    const char *_name = "wglBlitContextFramebufferAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void __stdcall _get_wglBlitContextFramebufferAMD(HGLRC dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
    PFN_WGLBLITCONTEXTFRAMEBUFFERAMD _ptr;
    _ptr = (PFN_WGLBLITCONTEXTFRAMEBUFFERAMD)_getPrivateProcAddress("wglBlitContextFramebufferAMD");
    if (!_ptr) {
        _ptr = &_fail_wglBlitContextFramebufferAMD;
    }
    _wglBlitContextFramebufferAMD = _ptr;
    _wglBlitContextFramebufferAMD(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

PFN_WGLBLITCONTEXTFRAMEBUFFERAMD _wglBlitContextFramebufferAMD = &_get_wglBlitContextFramebufferAMD;

static BOOL __stdcall _fail_wglBindVideoCaptureDeviceNV(UINT uVideoSlot, HVIDEOINPUTDEVICENV hDevice) {
    const char *_name = "wglBindVideoCaptureDeviceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglBindVideoCaptureDeviceNV(UINT uVideoSlot, HVIDEOINPUTDEVICENV hDevice) {
    PFN_WGLBINDVIDEOCAPTUREDEVICENV _ptr;
    _ptr = (PFN_WGLBINDVIDEOCAPTUREDEVICENV)_getPrivateProcAddress("wglBindVideoCaptureDeviceNV");
    if (!_ptr) {
        _ptr = &_fail_wglBindVideoCaptureDeviceNV;
    }
    _wglBindVideoCaptureDeviceNV = _ptr;
    return _wglBindVideoCaptureDeviceNV(uVideoSlot, hDevice);
}

PFN_WGLBINDVIDEOCAPTUREDEVICENV _wglBindVideoCaptureDeviceNV = &_get_wglBindVideoCaptureDeviceNV;

static UINT __stdcall _fail_wglEnumerateVideoCaptureDevicesNV(HDC hDc, HVIDEOINPUTDEVICENV * phDeviceList) {
    const char *_name = "wglEnumerateVideoCaptureDevicesNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static UINT __stdcall _get_wglEnumerateVideoCaptureDevicesNV(HDC hDc, HVIDEOINPUTDEVICENV * phDeviceList) {
    PFN_WGLENUMERATEVIDEOCAPTUREDEVICESNV _ptr;
    _ptr = (PFN_WGLENUMERATEVIDEOCAPTUREDEVICESNV)_getPrivateProcAddress("wglEnumerateVideoCaptureDevicesNV");
    if (!_ptr) {
        _ptr = &_fail_wglEnumerateVideoCaptureDevicesNV;
    }
    _wglEnumerateVideoCaptureDevicesNV = _ptr;
    return _wglEnumerateVideoCaptureDevicesNV(hDc, phDeviceList);
}

PFN_WGLENUMERATEVIDEOCAPTUREDEVICESNV _wglEnumerateVideoCaptureDevicesNV = &_get_wglEnumerateVideoCaptureDevicesNV;

static BOOL __stdcall _fail_wglLockVideoCaptureDeviceNV(HDC hDc, HVIDEOINPUTDEVICENV hDevice) {
    const char *_name = "wglLockVideoCaptureDeviceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglLockVideoCaptureDeviceNV(HDC hDc, HVIDEOINPUTDEVICENV hDevice) {
    PFN_WGLLOCKVIDEOCAPTUREDEVICENV _ptr;
    _ptr = (PFN_WGLLOCKVIDEOCAPTUREDEVICENV)_getPrivateProcAddress("wglLockVideoCaptureDeviceNV");
    if (!_ptr) {
        _ptr = &_fail_wglLockVideoCaptureDeviceNV;
    }
    _wglLockVideoCaptureDeviceNV = _ptr;
    return _wglLockVideoCaptureDeviceNV(hDc, hDevice);
}

PFN_WGLLOCKVIDEOCAPTUREDEVICENV _wglLockVideoCaptureDeviceNV = &_get_wglLockVideoCaptureDeviceNV;

static BOOL __stdcall _fail_wglQueryVideoCaptureDeviceNV(HDC hDc, HVIDEOINPUTDEVICENV hDevice, int iAttribute, int * piValue) {
    const char *_name = "wglQueryVideoCaptureDeviceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglQueryVideoCaptureDeviceNV(HDC hDc, HVIDEOINPUTDEVICENV hDevice, int iAttribute, int * piValue) {
    PFN_WGLQUERYVIDEOCAPTUREDEVICENV _ptr;
    _ptr = (PFN_WGLQUERYVIDEOCAPTUREDEVICENV)_getPrivateProcAddress("wglQueryVideoCaptureDeviceNV");
    if (!_ptr) {
        _ptr = &_fail_wglQueryVideoCaptureDeviceNV;
    }
    _wglQueryVideoCaptureDeviceNV = _ptr;
    return _wglQueryVideoCaptureDeviceNV(hDc, hDevice, iAttribute, piValue);
}

PFN_WGLQUERYVIDEOCAPTUREDEVICENV _wglQueryVideoCaptureDeviceNV = &_get_wglQueryVideoCaptureDeviceNV;

static BOOL __stdcall _fail_wglReleaseVideoCaptureDeviceNV(HDC hDc, HVIDEOINPUTDEVICENV hDevice) {
    const char *_name = "wglReleaseVideoCaptureDeviceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglReleaseVideoCaptureDeviceNV(HDC hDc, HVIDEOINPUTDEVICENV hDevice) {
    PFN_WGLRELEASEVIDEOCAPTUREDEVICENV _ptr;
    _ptr = (PFN_WGLRELEASEVIDEOCAPTUREDEVICENV)_getPrivateProcAddress("wglReleaseVideoCaptureDeviceNV");
    if (!_ptr) {
        _ptr = &_fail_wglReleaseVideoCaptureDeviceNV;
    }
    _wglReleaseVideoCaptureDeviceNV = _ptr;
    return _wglReleaseVideoCaptureDeviceNV(hDc, hDevice);
}

PFN_WGLRELEASEVIDEOCAPTUREDEVICENV _wglReleaseVideoCaptureDeviceNV = &_get_wglReleaseVideoCaptureDeviceNV;

static BOOL __stdcall _fail_wglCopyImageSubDataNV(HGLRC hSrcRC, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, HGLRC hDstRC, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) {
    const char *_name = "wglCopyImageSubDataNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglCopyImageSubDataNV(HGLRC hSrcRC, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, HGLRC hDstRC, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) {
    PFN_WGLCOPYIMAGESUBDATANV _ptr;
    _ptr = (PFN_WGLCOPYIMAGESUBDATANV)_getPrivateProcAddress("wglCopyImageSubDataNV");
    if (!_ptr) {
        _ptr = &_fail_wglCopyImageSubDataNV;
    }
    _wglCopyImageSubDataNV = _ptr;
    return _wglCopyImageSubDataNV(hSrcRC, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, hDstRC, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
}

PFN_WGLCOPYIMAGESUBDATANV _wglCopyImageSubDataNV = &_get_wglCopyImageSubDataNV;

static BOOL __stdcall _fail_wglDXSetResourceShareHandleNV(void * dxObject, HANDLE shareHandle) {
    const char *_name = "wglDXSetResourceShareHandleNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglDXSetResourceShareHandleNV(void * dxObject, HANDLE shareHandle) {
    PFN_WGLDXSETRESOURCESHAREHANDLENV _ptr;
    _ptr = (PFN_WGLDXSETRESOURCESHAREHANDLENV)_getPrivateProcAddress("wglDXSetResourceShareHandleNV");
    if (!_ptr) {
        _ptr = &_fail_wglDXSetResourceShareHandleNV;
    }
    _wglDXSetResourceShareHandleNV = _ptr;
    return _wglDXSetResourceShareHandleNV(dxObject, shareHandle);
}

PFN_WGLDXSETRESOURCESHAREHANDLENV _wglDXSetResourceShareHandleNV = &_get_wglDXSetResourceShareHandleNV;

static HANDLE __stdcall _fail_wglDXOpenDeviceNV(void * dxDevice) {
    const char *_name = "wglDXOpenDeviceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static HANDLE __stdcall _get_wglDXOpenDeviceNV(void * dxDevice) {
    PFN_WGLDXOPENDEVICENV _ptr;
    _ptr = (PFN_WGLDXOPENDEVICENV)_getPrivateProcAddress("wglDXOpenDeviceNV");
    if (!_ptr) {
        _ptr = &_fail_wglDXOpenDeviceNV;
    }
    _wglDXOpenDeviceNV = _ptr;
    return _wglDXOpenDeviceNV(dxDevice);
}

PFN_WGLDXOPENDEVICENV _wglDXOpenDeviceNV = &_get_wglDXOpenDeviceNV;

static BOOL __stdcall _fail_wglDXCloseDeviceNV(HANDLE hDevice) {
    const char *_name = "wglDXCloseDeviceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglDXCloseDeviceNV(HANDLE hDevice) {
    PFN_WGLDXCLOSEDEVICENV _ptr;
    _ptr = (PFN_WGLDXCLOSEDEVICENV)_getPrivateProcAddress("wglDXCloseDeviceNV");
    if (!_ptr) {
        _ptr = &_fail_wglDXCloseDeviceNV;
    }
    _wglDXCloseDeviceNV = _ptr;
    return _wglDXCloseDeviceNV(hDevice);
}

PFN_WGLDXCLOSEDEVICENV _wglDXCloseDeviceNV = &_get_wglDXCloseDeviceNV;

static HANDLE __stdcall _fail_wglDXRegisterObjectNV(HANDLE hDevice, void * dxObject, GLuint name, GLenum type, GLenum access) {
    const char *_name = "wglDXRegisterObjectNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static HANDLE __stdcall _get_wglDXRegisterObjectNV(HANDLE hDevice, void * dxObject, GLuint name, GLenum type, GLenum access) {
    PFN_WGLDXREGISTEROBJECTNV _ptr;
    _ptr = (PFN_WGLDXREGISTEROBJECTNV)_getPrivateProcAddress("wglDXRegisterObjectNV");
    if (!_ptr) {
        _ptr = &_fail_wglDXRegisterObjectNV;
    }
    _wglDXRegisterObjectNV = _ptr;
    return _wglDXRegisterObjectNV(hDevice, dxObject, name, type, access);
}

PFN_WGLDXREGISTEROBJECTNV _wglDXRegisterObjectNV = &_get_wglDXRegisterObjectNV;

static BOOL __stdcall _fail_wglDXUnregisterObjectNV(HANDLE hDevice, HANDLE hObject) {
    const char *_name = "wglDXUnregisterObjectNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglDXUnregisterObjectNV(HANDLE hDevice, HANDLE hObject) {
    PFN_WGLDXUNREGISTEROBJECTNV _ptr;
    _ptr = (PFN_WGLDXUNREGISTEROBJECTNV)_getPrivateProcAddress("wglDXUnregisterObjectNV");
    if (!_ptr) {
        _ptr = &_fail_wglDXUnregisterObjectNV;
    }
    _wglDXUnregisterObjectNV = _ptr;
    return _wglDXUnregisterObjectNV(hDevice, hObject);
}

PFN_WGLDXUNREGISTEROBJECTNV _wglDXUnregisterObjectNV = &_get_wglDXUnregisterObjectNV;

static BOOL __stdcall _fail_wglDXObjectAccessNV(HANDLE hObject, GLenum access) {
    const char *_name = "wglDXObjectAccessNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglDXObjectAccessNV(HANDLE hObject, GLenum access) {
    PFN_WGLDXOBJECTACCESSNV _ptr;
    _ptr = (PFN_WGLDXOBJECTACCESSNV)_getPrivateProcAddress("wglDXObjectAccessNV");
    if (!_ptr) {
        _ptr = &_fail_wglDXObjectAccessNV;
    }
    _wglDXObjectAccessNV = _ptr;
    return _wglDXObjectAccessNV(hObject, access);
}

PFN_WGLDXOBJECTACCESSNV _wglDXObjectAccessNV = &_get_wglDXObjectAccessNV;

static BOOL __stdcall _fail_wglDXLockObjectsNV(HANDLE hDevice, GLint count, HANDLE * hObjects) {
    const char *_name = "wglDXLockObjectsNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglDXLockObjectsNV(HANDLE hDevice, GLint count, HANDLE * hObjects) {
    PFN_WGLDXLOCKOBJECTSNV _ptr;
    _ptr = (PFN_WGLDXLOCKOBJECTSNV)_getPrivateProcAddress("wglDXLockObjectsNV");
    if (!_ptr) {
        _ptr = &_fail_wglDXLockObjectsNV;
    }
    _wglDXLockObjectsNV = _ptr;
    return _wglDXLockObjectsNV(hDevice, count, hObjects);
}

PFN_WGLDXLOCKOBJECTSNV _wglDXLockObjectsNV = &_get_wglDXLockObjectsNV;

static BOOL __stdcall _fail_wglDXUnlockObjectsNV(HANDLE hDevice, GLint count, HANDLE * hObjects) {
    const char *_name = "wglDXUnlockObjectsNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglDXUnlockObjectsNV(HANDLE hDevice, GLint count, HANDLE * hObjects) {
    PFN_WGLDXUNLOCKOBJECTSNV _ptr;
    _ptr = (PFN_WGLDXUNLOCKOBJECTSNV)_getPrivateProcAddress("wglDXUnlockObjectsNV");
    if (!_ptr) {
        _ptr = &_fail_wglDXUnlockObjectsNV;
    }
    _wglDXUnlockObjectsNV = _ptr;
    return _wglDXUnlockObjectsNV(hDevice, count, hObjects);
}

PFN_WGLDXUNLOCKOBJECTSNV _wglDXUnlockObjectsNV = &_get_wglDXUnlockObjectsNV;

static BOOL __stdcall _fail_wglDelayBeforeSwapNV(HDC hDC, GLfloat seconds) {
    const char *_name = "wglDelayBeforeSwapNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static BOOL __stdcall _get_wglDelayBeforeSwapNV(HDC hDC, GLfloat seconds) {
    PFN_WGLDELAYBEFORESWAPNV _ptr;
    _ptr = (PFN_WGLDELAYBEFORESWAPNV)_getPrivateProcAddress("wglDelayBeforeSwapNV");
    if (!_ptr) {
        _ptr = &_fail_wglDelayBeforeSwapNV;
    }
    _wglDelayBeforeSwapNV = _ptr;
    return _wglDelayBeforeSwapNV(hDC, seconds);
}

PFN_WGLDELAYBEFORESWAPNV _wglDelayBeforeSwapNV = &_get_wglDelayBeforeSwapNV;

static PROC __stdcall _fail_wglGetProcAddress(const char * lpszProc) {
    const char *_name = "wglGetProcAddress";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static PROC __stdcall _get_wglGetProcAddress(const char * lpszProc) {
    PFN_WGLGETPROCADDRESS _ptr;
    _ptr = (PFN_WGLGETPROCADDRESS)_getPublicProcAddress("wglGetProcAddress");
    if (!_ptr) {
        _ptr = &_fail_wglGetProcAddress;
    }
    _wglGetProcAddress = _ptr;
    return _wglGetProcAddress(lpszProc);
}

PFN_WGLGETPROCADDRESS _wglGetProcAddress = &_get_wglGetProcAddress;


#elif defined(__APPLE__)

static inline bool
translateDebugLabelIdentifier(GLenum & identifier)
{
    switch (identifier) {
    case GL_TEXTURE:
    case GL_FRAMEBUFFER:
    case GL_RENDERBUFFER:
    case GL_SAMPLER:
    case GL_TRANSFORM_FEEDBACK:
       return true;
    case GL_BUFFER:
       identifier = GL_BUFFER_OBJECT_EXT;
       return true;
    case GL_SHADER:
       identifier = GL_SHADER_OBJECT_EXT;
       return true;
    case GL_PROGRAM:
       identifier = GL_PROGRAM_OBJECT_EXT;
       return true;
    case GL_VERTEX_ARRAY:
       identifier = GL_VERTEX_ARRAY_OBJECT_EXT;
       return true;
    case GL_QUERY:
       identifier = GL_QUERY_OBJECT_EXT;
       return true;
    case GL_PROGRAM_PIPELINE:
       identifier = GL_PROGRAM_PIPELINE_OBJECT_EXT;
       return true;
    default:
       return false;
    }
}

static CGLError _fail_CGLSetCurrentContext(CGLContextObj ctx) {
    const char *_name = "CGLSetCurrentContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLSetCurrentContext(CGLContextObj ctx) {
    PFN_CGLSETCURRENTCONTEXT _ptr;
    _ptr = (PFN_CGLSETCURRENTCONTEXT)_getPublicProcAddress("CGLSetCurrentContext");
    if (!_ptr) {
        _ptr = &_fail_CGLSetCurrentContext;
    }
    _CGLSetCurrentContext = _ptr;
    return _CGLSetCurrentContext(ctx);
}

PFN_CGLSETCURRENTCONTEXT _CGLSetCurrentContext = &_get_CGLSetCurrentContext;

static CGLContextObj _fail_CGLGetCurrentContext(void) {
    const char *_name = "CGLGetCurrentContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLContextObj _get_CGLGetCurrentContext(void) {
    PFN_CGLGETCURRENTCONTEXT _ptr;
    _ptr = (PFN_CGLGETCURRENTCONTEXT)_getPublicProcAddress("CGLGetCurrentContext");
    if (!_ptr) {
        _ptr = &_fail_CGLGetCurrentContext;
    }
    _CGLGetCurrentContext = _ptr;
    return _CGLGetCurrentContext();
}

PFN_CGLGETCURRENTCONTEXT _CGLGetCurrentContext = &_get_CGLGetCurrentContext;

static CGLError _fail_CGLChoosePixelFormat(const CGLPixelFormatAttribute * attribs, CGLPixelFormatObj * pix, GLint * npix) {
    const char *_name = "CGLChoosePixelFormat";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLChoosePixelFormat(const CGLPixelFormatAttribute * attribs, CGLPixelFormatObj * pix, GLint * npix) {
    PFN_CGLCHOOSEPIXELFORMAT _ptr;
    _ptr = (PFN_CGLCHOOSEPIXELFORMAT)_getPublicProcAddress("CGLChoosePixelFormat");
    if (!_ptr) {
        _ptr = &_fail_CGLChoosePixelFormat;
    }
    _CGLChoosePixelFormat = _ptr;
    return _CGLChoosePixelFormat(attribs, pix, npix);
}

PFN_CGLCHOOSEPIXELFORMAT _CGLChoosePixelFormat = &_get_CGLChoosePixelFormat;

static CGLError _fail_CGLDestroyPixelFormat(CGLPixelFormatObj pix) {
    const char *_name = "CGLDestroyPixelFormat";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLDestroyPixelFormat(CGLPixelFormatObj pix) {
    PFN_CGLDESTROYPIXELFORMAT _ptr;
    _ptr = (PFN_CGLDESTROYPIXELFORMAT)_getPublicProcAddress("CGLDestroyPixelFormat");
    if (!_ptr) {
        _ptr = &_fail_CGLDestroyPixelFormat;
    }
    _CGLDestroyPixelFormat = _ptr;
    return _CGLDestroyPixelFormat(pix);
}

PFN_CGLDESTROYPIXELFORMAT _CGLDestroyPixelFormat = &_get_CGLDestroyPixelFormat;

static CGLError _fail_CGLDescribePixelFormat(CGLPixelFormatObj pix, GLint pix_num, CGLPixelFormatAttribute attrib, GLint * value) {
    const char *_name = "CGLDescribePixelFormat";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLDescribePixelFormat(CGLPixelFormatObj pix, GLint pix_num, CGLPixelFormatAttribute attrib, GLint * value) {
    PFN_CGLDESCRIBEPIXELFORMAT _ptr;
    _ptr = (PFN_CGLDESCRIBEPIXELFORMAT)_getPublicProcAddress("CGLDescribePixelFormat");
    if (!_ptr) {
        _ptr = &_fail_CGLDescribePixelFormat;
    }
    _CGLDescribePixelFormat = _ptr;
    return _CGLDescribePixelFormat(pix, pix_num, attrib, value);
}

PFN_CGLDESCRIBEPIXELFORMAT _CGLDescribePixelFormat = &_get_CGLDescribePixelFormat;

static void _fail_CGLReleasePixelFormat(CGLPixelFormatObj pix) {
    const char *_name = "CGLReleasePixelFormat";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_CGLReleasePixelFormat(CGLPixelFormatObj pix) {
    PFN_CGLRELEASEPIXELFORMAT _ptr;
    _ptr = (PFN_CGLRELEASEPIXELFORMAT)_getPublicProcAddress("CGLReleasePixelFormat");
    if (!_ptr) {
        _ptr = &_fail_CGLReleasePixelFormat;
    }
    _CGLReleasePixelFormat = _ptr;
    _CGLReleasePixelFormat(pix);
}

PFN_CGLRELEASEPIXELFORMAT _CGLReleasePixelFormat = &_get_CGLReleasePixelFormat;

static CGLPixelFormatObj _fail_CGLRetainPixelFormat(CGLPixelFormatObj pix) {
    const char *_name = "CGLRetainPixelFormat";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLPixelFormatObj _get_CGLRetainPixelFormat(CGLPixelFormatObj pix) {
    PFN_CGLRETAINPIXELFORMAT _ptr;
    _ptr = (PFN_CGLRETAINPIXELFORMAT)_getPublicProcAddress("CGLRetainPixelFormat");
    if (!_ptr) {
        _ptr = &_fail_CGLRetainPixelFormat;
    }
    _CGLRetainPixelFormat = _ptr;
    return _CGLRetainPixelFormat(pix);
}

PFN_CGLRETAINPIXELFORMAT _CGLRetainPixelFormat = &_get_CGLRetainPixelFormat;

static GLuint _fail_CGLGetPixelFormatRetainCount(CGLPixelFormatObj pix) {
    const char *_name = "CGLGetPixelFormatRetainCount";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint _get_CGLGetPixelFormatRetainCount(CGLPixelFormatObj pix) {
    PFN_CGLGETPIXELFORMATRETAINCOUNT _ptr;
    _ptr = (PFN_CGLGETPIXELFORMATRETAINCOUNT)_getPublicProcAddress("CGLGetPixelFormatRetainCount");
    if (!_ptr) {
        _ptr = &_fail_CGLGetPixelFormatRetainCount;
    }
    _CGLGetPixelFormatRetainCount = _ptr;
    return _CGLGetPixelFormatRetainCount(pix);
}

PFN_CGLGETPIXELFORMATRETAINCOUNT _CGLGetPixelFormatRetainCount = &_get_CGLGetPixelFormatRetainCount;

static CGLError _fail_CGLQueryRendererInfo(GLuint display_mask, CGLRendererInfoObj * rend, GLint * nrend) {
    const char *_name = "CGLQueryRendererInfo";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLQueryRendererInfo(GLuint display_mask, CGLRendererInfoObj * rend, GLint * nrend) {
    PFN_CGLQUERYRENDERERINFO _ptr;
    _ptr = (PFN_CGLQUERYRENDERERINFO)_getPublicProcAddress("CGLQueryRendererInfo");
    if (!_ptr) {
        _ptr = &_fail_CGLQueryRendererInfo;
    }
    _CGLQueryRendererInfo = _ptr;
    return _CGLQueryRendererInfo(display_mask, rend, nrend);
}

PFN_CGLQUERYRENDERERINFO _CGLQueryRendererInfo = &_get_CGLQueryRendererInfo;

static CGLError _fail_CGLDestroyRendererInfo(CGLRendererInfoObj rend) {
    const char *_name = "CGLDestroyRendererInfo";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLDestroyRendererInfo(CGLRendererInfoObj rend) {
    PFN_CGLDESTROYRENDERERINFO _ptr;
    _ptr = (PFN_CGLDESTROYRENDERERINFO)_getPublicProcAddress("CGLDestroyRendererInfo");
    if (!_ptr) {
        _ptr = &_fail_CGLDestroyRendererInfo;
    }
    _CGLDestroyRendererInfo = _ptr;
    return _CGLDestroyRendererInfo(rend);
}

PFN_CGLDESTROYRENDERERINFO _CGLDestroyRendererInfo = &_get_CGLDestroyRendererInfo;

static CGLError _fail_CGLDescribeRenderer(CGLRendererInfoObj rend, GLint rend_num, CGLRendererProperty prop, GLint * value) {
    const char *_name = "CGLDescribeRenderer";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLDescribeRenderer(CGLRendererInfoObj rend, GLint rend_num, CGLRendererProperty prop, GLint * value) {
    PFN_CGLDESCRIBERENDERER _ptr;
    _ptr = (PFN_CGLDESCRIBERENDERER)_getPublicProcAddress("CGLDescribeRenderer");
    if (!_ptr) {
        _ptr = &_fail_CGLDescribeRenderer;
    }
    _CGLDescribeRenderer = _ptr;
    return _CGLDescribeRenderer(rend, rend_num, prop, value);
}

PFN_CGLDESCRIBERENDERER _CGLDescribeRenderer = &_get_CGLDescribeRenderer;

static CGLError _fail_CGLCreateContext(CGLPixelFormatObj pix, CGLContextObj share, CGLContextObj * ctx) {
    const char *_name = "CGLCreateContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLCreateContext(CGLPixelFormatObj pix, CGLContextObj share, CGLContextObj * ctx) {
    PFN_CGLCREATECONTEXT _ptr;
    _ptr = (PFN_CGLCREATECONTEXT)_getPublicProcAddress("CGLCreateContext");
    if (!_ptr) {
        _ptr = &_fail_CGLCreateContext;
    }
    _CGLCreateContext = _ptr;
    return _CGLCreateContext(pix, share, ctx);
}

PFN_CGLCREATECONTEXT _CGLCreateContext = &_get_CGLCreateContext;

static CGLError _fail_CGLDestroyContext(CGLContextObj ctx) {
    const char *_name = "CGLDestroyContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLDestroyContext(CGLContextObj ctx) {
    PFN_CGLDESTROYCONTEXT _ptr;
    _ptr = (PFN_CGLDESTROYCONTEXT)_getPublicProcAddress("CGLDestroyContext");
    if (!_ptr) {
        _ptr = &_fail_CGLDestroyContext;
    }
    _CGLDestroyContext = _ptr;
    return _CGLDestroyContext(ctx);
}

PFN_CGLDESTROYCONTEXT _CGLDestroyContext = &_get_CGLDestroyContext;

static CGLError _fail_CGLCopyContext(CGLContextObj src, CGLContextObj dst, GLbitfield mask) {
    const char *_name = "CGLCopyContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLCopyContext(CGLContextObj src, CGLContextObj dst, GLbitfield mask) {
    PFN_CGLCOPYCONTEXT _ptr;
    _ptr = (PFN_CGLCOPYCONTEXT)_getPublicProcAddress("CGLCopyContext");
    if (!_ptr) {
        _ptr = &_fail_CGLCopyContext;
    }
    _CGLCopyContext = _ptr;
    return _CGLCopyContext(src, dst, mask);
}

PFN_CGLCOPYCONTEXT _CGLCopyContext = &_get_CGLCopyContext;

static CGLContextObj _fail_CGLRetainContext(CGLContextObj ctx) {
    const char *_name = "CGLRetainContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLContextObj _get_CGLRetainContext(CGLContextObj ctx) {
    PFN_CGLRETAINCONTEXT _ptr;
    _ptr = (PFN_CGLRETAINCONTEXT)_getPublicProcAddress("CGLRetainContext");
    if (!_ptr) {
        _ptr = &_fail_CGLRetainContext;
    }
    _CGLRetainContext = _ptr;
    return _CGLRetainContext(ctx);
}

PFN_CGLRETAINCONTEXT _CGLRetainContext = &_get_CGLRetainContext;

static void _fail_CGLReleaseContext(CGLContextObj ctx) {
    const char *_name = "CGLReleaseContext";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_CGLReleaseContext(CGLContextObj ctx) {
    PFN_CGLRELEASECONTEXT _ptr;
    _ptr = (PFN_CGLRELEASECONTEXT)_getPublicProcAddress("CGLReleaseContext");
    if (!_ptr) {
        _ptr = &_fail_CGLReleaseContext;
    }
    _CGLReleaseContext = _ptr;
    _CGLReleaseContext(ctx);
}

PFN_CGLRELEASECONTEXT _CGLReleaseContext = &_get_CGLReleaseContext;

static GLuint _fail_CGLGetContextRetainCount(CGLContextObj ctx) {
    const char *_name = "CGLGetContextRetainCount";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint _get_CGLGetContextRetainCount(CGLContextObj ctx) {
    PFN_CGLGETCONTEXTRETAINCOUNT _ptr;
    _ptr = (PFN_CGLGETCONTEXTRETAINCOUNT)_getPublicProcAddress("CGLGetContextRetainCount");
    if (!_ptr) {
        _ptr = &_fail_CGLGetContextRetainCount;
    }
    _CGLGetContextRetainCount = _ptr;
    return _CGLGetContextRetainCount(ctx);
}

PFN_CGLGETCONTEXTRETAINCOUNT _CGLGetContextRetainCount = &_get_CGLGetContextRetainCount;

static CGLPixelFormatObj _fail_CGLGetPixelFormat(CGLContextObj ctx) {
    const char *_name = "CGLGetPixelFormat";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLPixelFormatObj _get_CGLGetPixelFormat(CGLContextObj ctx) {
    PFN_CGLGETPIXELFORMAT _ptr;
    _ptr = (PFN_CGLGETPIXELFORMAT)_getPublicProcAddress("CGLGetPixelFormat");
    if (!_ptr) {
        _ptr = &_fail_CGLGetPixelFormat;
    }
    _CGLGetPixelFormat = _ptr;
    return _CGLGetPixelFormat(ctx);
}

PFN_CGLGETPIXELFORMAT _CGLGetPixelFormat = &_get_CGLGetPixelFormat;

static CGLError _fail_CGLCreatePBuffer(GLsizei width, GLsizei height, GLenum target, GLenum internalFormat, GLint max_level, CGLPBufferObj * pbuffer) {
    const char *_name = "CGLCreatePBuffer";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLCreatePBuffer(GLsizei width, GLsizei height, GLenum target, GLenum internalFormat, GLint max_level, CGLPBufferObj * pbuffer) {
    PFN_CGLCREATEPBUFFER _ptr;
    _ptr = (PFN_CGLCREATEPBUFFER)_getPublicProcAddress("CGLCreatePBuffer");
    if (!_ptr) {
        _ptr = &_fail_CGLCreatePBuffer;
    }
    _CGLCreatePBuffer = _ptr;
    return _CGLCreatePBuffer(width, height, target, internalFormat, max_level, pbuffer);
}

PFN_CGLCREATEPBUFFER _CGLCreatePBuffer = &_get_CGLCreatePBuffer;

static CGLError _fail_CGLDestroyPBuffer(CGLPBufferObj pbuffer) {
    const char *_name = "CGLDestroyPBuffer";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLDestroyPBuffer(CGLPBufferObj pbuffer) {
    PFN_CGLDESTROYPBUFFER _ptr;
    _ptr = (PFN_CGLDESTROYPBUFFER)_getPublicProcAddress("CGLDestroyPBuffer");
    if (!_ptr) {
        _ptr = &_fail_CGLDestroyPBuffer;
    }
    _CGLDestroyPBuffer = _ptr;
    return _CGLDestroyPBuffer(pbuffer);
}

PFN_CGLDESTROYPBUFFER _CGLDestroyPBuffer = &_get_CGLDestroyPBuffer;

static CGLError _fail_CGLDescribePBuffer(CGLPBufferObj obj, GLsizei * width, GLsizei * height, GLenum * target, GLenum * internalFormat, GLint * mipmap) {
    const char *_name = "CGLDescribePBuffer";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLDescribePBuffer(CGLPBufferObj obj, GLsizei * width, GLsizei * height, GLenum * target, GLenum * internalFormat, GLint * mipmap) {
    PFN_CGLDESCRIBEPBUFFER _ptr;
    _ptr = (PFN_CGLDESCRIBEPBUFFER)_getPublicProcAddress("CGLDescribePBuffer");
    if (!_ptr) {
        _ptr = &_fail_CGLDescribePBuffer;
    }
    _CGLDescribePBuffer = _ptr;
    return _CGLDescribePBuffer(obj, width, height, target, internalFormat, mipmap);
}

PFN_CGLDESCRIBEPBUFFER _CGLDescribePBuffer = &_get_CGLDescribePBuffer;

static CGLError _fail_CGLTexImagePBuffer(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum source) {
    const char *_name = "CGLTexImagePBuffer";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLTexImagePBuffer(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum source) {
    PFN_CGLTEXIMAGEPBUFFER _ptr;
    _ptr = (PFN_CGLTEXIMAGEPBUFFER)_getPublicProcAddress("CGLTexImagePBuffer");
    if (!_ptr) {
        _ptr = &_fail_CGLTexImagePBuffer;
    }
    _CGLTexImagePBuffer = _ptr;
    return _CGLTexImagePBuffer(ctx, pbuffer, source);
}

PFN_CGLTEXIMAGEPBUFFER _CGLTexImagePBuffer = &_get_CGLTexImagePBuffer;

static CGLPBufferObj _fail_CGLRetainPBuffer(CGLPBufferObj pbuffer) {
    const char *_name = "CGLRetainPBuffer";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLPBufferObj _get_CGLRetainPBuffer(CGLPBufferObj pbuffer) {
    PFN_CGLRETAINPBUFFER _ptr;
    _ptr = (PFN_CGLRETAINPBUFFER)_getPublicProcAddress("CGLRetainPBuffer");
    if (!_ptr) {
        _ptr = &_fail_CGLRetainPBuffer;
    }
    _CGLRetainPBuffer = _ptr;
    return _CGLRetainPBuffer(pbuffer);
}

PFN_CGLRETAINPBUFFER _CGLRetainPBuffer = &_get_CGLRetainPBuffer;

static void _fail_CGLReleasePBuffer(CGLPBufferObj pbuffer) {
    const char *_name = "CGLReleasePBuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_CGLReleasePBuffer(CGLPBufferObj pbuffer) {
    PFN_CGLRELEASEPBUFFER _ptr;
    _ptr = (PFN_CGLRELEASEPBUFFER)_getPublicProcAddress("CGLReleasePBuffer");
    if (!_ptr) {
        _ptr = &_fail_CGLReleasePBuffer;
    }
    _CGLReleasePBuffer = _ptr;
    _CGLReleasePBuffer(pbuffer);
}

PFN_CGLRELEASEPBUFFER _CGLReleasePBuffer = &_get_CGLReleasePBuffer;

static GLuint _fail_CGLGetPBufferRetainCount(CGLPBufferObj pbuffer) {
    const char *_name = "CGLGetPBufferRetainCount";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint _get_CGLGetPBufferRetainCount(CGLPBufferObj pbuffer) {
    PFN_CGLGETPBUFFERRETAINCOUNT _ptr;
    _ptr = (PFN_CGLGETPBUFFERRETAINCOUNT)_getPublicProcAddress("CGLGetPBufferRetainCount");
    if (!_ptr) {
        _ptr = &_fail_CGLGetPBufferRetainCount;
    }
    _CGLGetPBufferRetainCount = _ptr;
    return _CGLGetPBufferRetainCount(pbuffer);
}

PFN_CGLGETPBUFFERRETAINCOUNT _CGLGetPBufferRetainCount = &_get_CGLGetPBufferRetainCount;

static CGLError _fail_CGLSetOffScreen(CGLContextObj ctx, GLsizei width, GLsizei height, GLint rowbytes, void * baseaddr) {
    const char *_name = "CGLSetOffScreen";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLSetOffScreen(CGLContextObj ctx, GLsizei width, GLsizei height, GLint rowbytes, void * baseaddr) {
    PFN_CGLSETOFFSCREEN _ptr;
    _ptr = (PFN_CGLSETOFFSCREEN)_getPublicProcAddress("CGLSetOffScreen");
    if (!_ptr) {
        _ptr = &_fail_CGLSetOffScreen;
    }
    _CGLSetOffScreen = _ptr;
    return _CGLSetOffScreen(ctx, width, height, rowbytes, baseaddr);
}

PFN_CGLSETOFFSCREEN _CGLSetOffScreen = &_get_CGLSetOffScreen;

static CGLError _fail_CGLGetOffScreen(CGLContextObj ctx, GLsizei * width, GLsizei * height, GLint * rowbytes, void * * baseaddr) {
    const char *_name = "CGLGetOffScreen";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLGetOffScreen(CGLContextObj ctx, GLsizei * width, GLsizei * height, GLint * rowbytes, void * * baseaddr) {
    PFN_CGLGETOFFSCREEN _ptr;
    _ptr = (PFN_CGLGETOFFSCREEN)_getPublicProcAddress("CGLGetOffScreen");
    if (!_ptr) {
        _ptr = &_fail_CGLGetOffScreen;
    }
    _CGLGetOffScreen = _ptr;
    return _CGLGetOffScreen(ctx, width, height, rowbytes, baseaddr);
}

PFN_CGLGETOFFSCREEN _CGLGetOffScreen = &_get_CGLGetOffScreen;

static CGLError _fail_CGLSetFullScreen(CGLContextObj ctx) {
    const char *_name = "CGLSetFullScreen";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLSetFullScreen(CGLContextObj ctx) {
    PFN_CGLSETFULLSCREEN _ptr;
    _ptr = (PFN_CGLSETFULLSCREEN)_getPublicProcAddress("CGLSetFullScreen");
    if (!_ptr) {
        _ptr = &_fail_CGLSetFullScreen;
    }
    _CGLSetFullScreen = _ptr;
    return _CGLSetFullScreen(ctx);
}

PFN_CGLSETFULLSCREEN _CGLSetFullScreen = &_get_CGLSetFullScreen;

static CGLError _fail_CGLSetFullScreenOnDisplay(CGLContextObj ctx, GLuint display_mask) {
    const char *_name = "CGLSetFullScreenOnDisplay";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLSetFullScreenOnDisplay(CGLContextObj ctx, GLuint display_mask) {
    PFN_CGLSETFULLSCREENONDISPLAY _ptr;
    _ptr = (PFN_CGLSETFULLSCREENONDISPLAY)_getPublicProcAddress("CGLSetFullScreenOnDisplay");
    if (!_ptr) {
        _ptr = &_fail_CGLSetFullScreenOnDisplay;
    }
    _CGLSetFullScreenOnDisplay = _ptr;
    return _CGLSetFullScreenOnDisplay(ctx, display_mask);
}

PFN_CGLSETFULLSCREENONDISPLAY _CGLSetFullScreenOnDisplay = &_get_CGLSetFullScreenOnDisplay;

static CGLError _fail_CGLSetPBuffer(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum face, GLint level, GLint screen) {
    const char *_name = "CGLSetPBuffer";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLSetPBuffer(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum face, GLint level, GLint screen) {
    PFN_CGLSETPBUFFER _ptr;
    _ptr = (PFN_CGLSETPBUFFER)_getPublicProcAddress("CGLSetPBuffer");
    if (!_ptr) {
        _ptr = &_fail_CGLSetPBuffer;
    }
    _CGLSetPBuffer = _ptr;
    return _CGLSetPBuffer(ctx, pbuffer, face, level, screen);
}

PFN_CGLSETPBUFFER _CGLSetPBuffer = &_get_CGLSetPBuffer;

static CGLError _fail_CGLGetPBuffer(CGLContextObj ctx, CGLPBufferObj * pbuffer, GLenum * face, GLint * level, GLint * screen) {
    const char *_name = "CGLGetPBuffer";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLGetPBuffer(CGLContextObj ctx, CGLPBufferObj * pbuffer, GLenum * face, GLint * level, GLint * screen) {
    PFN_CGLGETPBUFFER _ptr;
    _ptr = (PFN_CGLGETPBUFFER)_getPublicProcAddress("CGLGetPBuffer");
    if (!_ptr) {
        _ptr = &_fail_CGLGetPBuffer;
    }
    _CGLGetPBuffer = _ptr;
    return _CGLGetPBuffer(ctx, pbuffer, face, level, screen);
}

PFN_CGLGETPBUFFER _CGLGetPBuffer = &_get_CGLGetPBuffer;

static CGLError _fail_CGLClearDrawable(CGLContextObj ctx) {
    const char *_name = "CGLClearDrawable";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLClearDrawable(CGLContextObj ctx) {
    PFN_CGLCLEARDRAWABLE _ptr;
    _ptr = (PFN_CGLCLEARDRAWABLE)_getPublicProcAddress("CGLClearDrawable");
    if (!_ptr) {
        _ptr = &_fail_CGLClearDrawable;
    }
    _CGLClearDrawable = _ptr;
    return _CGLClearDrawable(ctx);
}

PFN_CGLCLEARDRAWABLE _CGLClearDrawable = &_get_CGLClearDrawable;

static CGLError _fail_CGLFlushDrawable(CGLContextObj ctx) {
    const char *_name = "CGLFlushDrawable";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLFlushDrawable(CGLContextObj ctx) {
    PFN_CGLFLUSHDRAWABLE _ptr;
    _ptr = (PFN_CGLFLUSHDRAWABLE)_getPublicProcAddress("CGLFlushDrawable");
    if (!_ptr) {
        _ptr = &_fail_CGLFlushDrawable;
    }
    _CGLFlushDrawable = _ptr;
    return _CGLFlushDrawable(ctx);
}

PFN_CGLFLUSHDRAWABLE _CGLFlushDrawable = &_get_CGLFlushDrawable;

static CGLError _fail_CGLEnable(CGLContextObj ctx, CGLContextEnable pname) {
    const char *_name = "CGLEnable";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLEnable(CGLContextObj ctx, CGLContextEnable pname) {
    PFN_CGLENABLE _ptr;
    _ptr = (PFN_CGLENABLE)_getPublicProcAddress("CGLEnable");
    if (!_ptr) {
        _ptr = &_fail_CGLEnable;
    }
    _CGLEnable = _ptr;
    return _CGLEnable(ctx, pname);
}

PFN_CGLENABLE _CGLEnable = &_get_CGLEnable;

static CGLError _fail_CGLDisable(CGLContextObj ctx, CGLContextEnable pname) {
    const char *_name = "CGLDisable";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLDisable(CGLContextObj ctx, CGLContextEnable pname) {
    PFN_CGLDISABLE _ptr;
    _ptr = (PFN_CGLDISABLE)_getPublicProcAddress("CGLDisable");
    if (!_ptr) {
        _ptr = &_fail_CGLDisable;
    }
    _CGLDisable = _ptr;
    return _CGLDisable(ctx, pname);
}

PFN_CGLDISABLE _CGLDisable = &_get_CGLDisable;

static CGLError _fail_CGLIsEnabled(CGLContextObj ctx, CGLContextEnable pname, GLint * enable) {
    const char *_name = "CGLIsEnabled";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLIsEnabled(CGLContextObj ctx, CGLContextEnable pname, GLint * enable) {
    PFN_CGLISENABLED _ptr;
    _ptr = (PFN_CGLISENABLED)_getPublicProcAddress("CGLIsEnabled");
    if (!_ptr) {
        _ptr = &_fail_CGLIsEnabled;
    }
    _CGLIsEnabled = _ptr;
    return _CGLIsEnabled(ctx, pname, enable);
}

PFN_CGLISENABLED _CGLIsEnabled = &_get_CGLIsEnabled;

static CGLError _fail_CGLSetParameter(CGLContextObj ctx, CGLContextParameter pname, const GLint * params) {
    const char *_name = "CGLSetParameter";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLSetParameter(CGLContextObj ctx, CGLContextParameter pname, const GLint * params) {
    PFN_CGLSETPARAMETER _ptr;
    _ptr = (PFN_CGLSETPARAMETER)_getPublicProcAddress("CGLSetParameter");
    if (!_ptr) {
        _ptr = &_fail_CGLSetParameter;
    }
    _CGLSetParameter = _ptr;
    return _CGLSetParameter(ctx, pname, params);
}

PFN_CGLSETPARAMETER _CGLSetParameter = &_get_CGLSetParameter;

static CGLError _fail_CGLGetParameter(CGLContextObj ctx, CGLContextParameter pname, GLint * params) {
    const char *_name = "CGLGetParameter";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLGetParameter(CGLContextObj ctx, CGLContextParameter pname, GLint * params) {
    PFN_CGLGETPARAMETER _ptr;
    _ptr = (PFN_CGLGETPARAMETER)_getPublicProcAddress("CGLGetParameter");
    if (!_ptr) {
        _ptr = &_fail_CGLGetParameter;
    }
    _CGLGetParameter = _ptr;
    return _CGLGetParameter(ctx, pname, params);
}

PFN_CGLGETPARAMETER _CGLGetParameter = &_get_CGLGetParameter;

static CGLError _fail_CGLSetVirtualScreen(CGLContextObj ctx, GLint screen) {
    const char *_name = "CGLSetVirtualScreen";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLSetVirtualScreen(CGLContextObj ctx, GLint screen) {
    PFN_CGLSETVIRTUALSCREEN _ptr;
    _ptr = (PFN_CGLSETVIRTUALSCREEN)_getPublicProcAddress("CGLSetVirtualScreen");
    if (!_ptr) {
        _ptr = &_fail_CGLSetVirtualScreen;
    }
    _CGLSetVirtualScreen = _ptr;
    return _CGLSetVirtualScreen(ctx, screen);
}

PFN_CGLSETVIRTUALSCREEN _CGLSetVirtualScreen = &_get_CGLSetVirtualScreen;

static CGLError _fail_CGLGetVirtualScreen(CGLContextObj ctx, GLint * screen) {
    const char *_name = "CGLGetVirtualScreen";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLGetVirtualScreen(CGLContextObj ctx, GLint * screen) {
    PFN_CGLGETVIRTUALSCREEN _ptr;
    _ptr = (PFN_CGLGETVIRTUALSCREEN)_getPublicProcAddress("CGLGetVirtualScreen");
    if (!_ptr) {
        _ptr = &_fail_CGLGetVirtualScreen;
    }
    _CGLGetVirtualScreen = _ptr;
    return _CGLGetVirtualScreen(ctx, screen);
}

PFN_CGLGETVIRTUALSCREEN _CGLGetVirtualScreen = &_get_CGLGetVirtualScreen;

static CGLError _fail_CGLSetGlobalOption(CGLGlobalOption pname, const GLint * params) {
    const char *_name = "CGLSetGlobalOption";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLSetGlobalOption(CGLGlobalOption pname, const GLint * params) {
    PFN_CGLSETGLOBALOPTION _ptr;
    _ptr = (PFN_CGLSETGLOBALOPTION)_getPublicProcAddress("CGLSetGlobalOption");
    if (!_ptr) {
        _ptr = &_fail_CGLSetGlobalOption;
    }
    _CGLSetGlobalOption = _ptr;
    return _CGLSetGlobalOption(pname, params);
}

PFN_CGLSETGLOBALOPTION _CGLSetGlobalOption = &_get_CGLSetGlobalOption;

static CGLError _fail_CGLGetGlobalOption(CGLGlobalOption pname, GLint * params) {
    const char *_name = "CGLGetGlobalOption";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLGetGlobalOption(CGLGlobalOption pname, GLint * params) {
    PFN_CGLGETGLOBALOPTION _ptr;
    _ptr = (PFN_CGLGETGLOBALOPTION)_getPublicProcAddress("CGLGetGlobalOption");
    if (!_ptr) {
        _ptr = &_fail_CGLGetGlobalOption;
    }
    _CGLGetGlobalOption = _ptr;
    return _CGLGetGlobalOption(pname, params);
}

PFN_CGLGETGLOBALOPTION _CGLGetGlobalOption = &_get_CGLGetGlobalOption;

static CGLError _fail_CGLSetOption(CGLGlobalOption pname, GLint param) {
    const char *_name = "CGLSetOption";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLSetOption(CGLGlobalOption pname, GLint param) {
    PFN_CGLSETOPTION _ptr;
    _ptr = (PFN_CGLSETOPTION)_getPublicProcAddress("CGLSetOption");
    if (!_ptr) {
        _ptr = &_fail_CGLSetOption;
    }
    _CGLSetOption = _ptr;
    return _CGLSetOption(pname, param);
}

PFN_CGLSETOPTION _CGLSetOption = &_get_CGLSetOption;

static CGLError _fail_CGLGetOption(CGLGlobalOption pname, GLint * param) {
    const char *_name = "CGLGetOption";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLGetOption(CGLGlobalOption pname, GLint * param) {
    PFN_CGLGETOPTION _ptr;
    _ptr = (PFN_CGLGETOPTION)_getPublicProcAddress("CGLGetOption");
    if (!_ptr) {
        _ptr = &_fail_CGLGetOption;
    }
    _CGLGetOption = _ptr;
    return _CGLGetOption(pname, param);
}

PFN_CGLGETOPTION _CGLGetOption = &_get_CGLGetOption;

static CGLError _fail_CGLLockContext(CGLContextObj ctx) {
    const char *_name = "CGLLockContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLLockContext(CGLContextObj ctx) {
    PFN_CGLLOCKCONTEXT _ptr;
    _ptr = (PFN_CGLLOCKCONTEXT)_getPublicProcAddress("CGLLockContext");
    if (!_ptr) {
        _ptr = &_fail_CGLLockContext;
    }
    _CGLLockContext = _ptr;
    return _CGLLockContext(ctx);
}

PFN_CGLLOCKCONTEXT _CGLLockContext = &_get_CGLLockContext;

static CGLError _fail_CGLUnlockContext(CGLContextObj ctx) {
    const char *_name = "CGLUnlockContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLUnlockContext(CGLContextObj ctx) {
    PFN_CGLUNLOCKCONTEXT _ptr;
    _ptr = (PFN_CGLUNLOCKCONTEXT)_getPublicProcAddress("CGLUnlockContext");
    if (!_ptr) {
        _ptr = &_fail_CGLUnlockContext;
    }
    _CGLUnlockContext = _ptr;
    return _CGLUnlockContext(ctx);
}

PFN_CGLUNLOCKCONTEXT _CGLUnlockContext = &_get_CGLUnlockContext;

static void _fail_CGLGetVersion(GLint * majorvers, GLint * minorvers) {
    const char *_name = "CGLGetVersion";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_CGLGetVersion(GLint * majorvers, GLint * minorvers) {
    PFN_CGLGETVERSION _ptr;
    _ptr = (PFN_CGLGETVERSION)_getPublicProcAddress("CGLGetVersion");
    if (!_ptr) {
        _ptr = &_fail_CGLGetVersion;
    }
    _CGLGetVersion = _ptr;
    _CGLGetVersion(majorvers, minorvers);
}

PFN_CGLGETVERSION _CGLGetVersion = &_get_CGLGetVersion;

static const char * _fail_CGLErrorString(CGLError error) {
    const char *_name = "CGLErrorString";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static const char * _get_CGLErrorString(CGLError error) {
    PFN_CGLERRORSTRING _ptr;
    _ptr = (PFN_CGLERRORSTRING)_getPublicProcAddress("CGLErrorString");
    if (!_ptr) {
        _ptr = &_fail_CGLErrorString;
    }
    _CGLErrorString = _ptr;
    return _CGLErrorString(error);
}

PFN_CGLERRORSTRING _CGLErrorString = &_get_CGLErrorString;

static CGLError _fail_CGLTexImageIOSurface2D(CGLContextObj ctx, GLenum target, GLenum internal_format, GLsizei width, GLsizei height, GLenum format, GLenum type, IOSurfaceRef ioSurface, GLuint plane) {
    const char *_name = "CGLTexImageIOSurface2D";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLTexImageIOSurface2D(CGLContextObj ctx, GLenum target, GLenum internal_format, GLsizei width, GLsizei height, GLenum format, GLenum type, IOSurfaceRef ioSurface, GLuint plane) {
    PFN_CGLTEXIMAGEIOSURFACE2D _ptr;
    _ptr = (PFN_CGLTEXIMAGEIOSURFACE2D)_getPublicProcAddress("CGLTexImageIOSurface2D");
    if (!_ptr) {
        _ptr = &_fail_CGLTexImageIOSurface2D;
    }
    _CGLTexImageIOSurface2D = _ptr;
    return _CGLTexImageIOSurface2D(ctx, target, internal_format, width, height, format, type, ioSurface, plane);
}

PFN_CGLTEXIMAGEIOSURFACE2D _CGLTexImageIOSurface2D = &_get_CGLTexImageIOSurface2D;

static CGLShareGroupObj _fail_CGLGetShareGroup(CGLContextObj ctx) {
    const char *_name = "CGLGetShareGroup";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLShareGroupObj _get_CGLGetShareGroup(CGLContextObj ctx) {
    PFN_CGLGETSHAREGROUP _ptr;
    _ptr = (PFN_CGLGETSHAREGROUP)_getPublicProcAddress("CGLGetShareGroup");
    if (!_ptr) {
        _ptr = &_fail_CGLGetShareGroup;
    }
    _CGLGetShareGroup = _ptr;
    return _CGLGetShareGroup(ctx);
}

PFN_CGLGETSHAREGROUP _CGLGetShareGroup = &_get_CGLGetShareGroup;

static CGLError _fail_CGLSetSurface(CGLContextObj ctx, CGSConnectionID cid, CGSWindowID wid, CGSSurfaceID sid) {
    const char *_name = "CGLSetSurface";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLSetSurface(CGLContextObj ctx, CGSConnectionID cid, CGSWindowID wid, CGSSurfaceID sid) {
    PFN_CGLSETSURFACE _ptr;
    _ptr = (PFN_CGLSETSURFACE)_getPublicProcAddress("CGLSetSurface");
    if (!_ptr) {
        _ptr = &_fail_CGLSetSurface;
    }
    _CGLSetSurface = _ptr;
    return _CGLSetSurface(ctx, cid, wid, sid);
}

PFN_CGLSETSURFACE _CGLSetSurface = &_get_CGLSetSurface;

static CGLError _fail_CGLGetSurface(CGLContextObj ctx, CGSConnectionID * cid, CGSWindowID * wid, CGSSurfaceID * sid) {
    const char *_name = "CGLGetSurface";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLGetSurface(CGLContextObj ctx, CGSConnectionID * cid, CGSWindowID * wid, CGSSurfaceID * sid) {
    PFN_CGLGETSURFACE _ptr;
    _ptr = (PFN_CGLGETSURFACE)_getPublicProcAddress("CGLGetSurface");
    if (!_ptr) {
        _ptr = &_fail_CGLGetSurface;
    }
    _CGLGetSurface = _ptr;
    return _CGLGetSurface(ctx, cid, wid, sid);
}

PFN_CGLGETSURFACE _CGLGetSurface = &_get_CGLGetSurface;

static CGLError _fail_CGLUpdateContext(CGLContextObj ctx) {
    const char *_name = "CGLUpdateContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLUpdateContext(CGLContextObj ctx) {
    PFN_CGLUPDATECONTEXT _ptr;
    _ptr = (PFN_CGLUPDATECONTEXT)_getPublicProcAddress("CGLUpdateContext");
    if (!_ptr) {
        _ptr = &_fail_CGLUpdateContext;
    }
    _CGLUpdateContext = _ptr;
    return _CGLUpdateContext(ctx);
}

PFN_CGLUPDATECONTEXT _CGLUpdateContext = &_get_CGLUpdateContext;

static CGLError _fail_CGLOpenCLMuxLockDown(void) {
    const char *_name = "CGLOpenCLMuxLockDown";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLOpenCLMuxLockDown(void) {
    PFN_CGLOPENCLMUXLOCKDOWN _ptr;
    _ptr = (PFN_CGLOPENCLMUXLOCKDOWN)_getPublicProcAddress("CGLOpenCLMuxLockDown");
    if (!_ptr) {
        _ptr = &_fail_CGLOpenCLMuxLockDown;
    }
    _CGLOpenCLMuxLockDown = _ptr;
    return _CGLOpenCLMuxLockDown();
}

PFN_CGLOPENCLMUXLOCKDOWN _CGLOpenCLMuxLockDown = &_get_CGLOpenCLMuxLockDown;

static GLboolean _fail_CGLAreContextsShared(CGLContextObj ctx1, CGLContextObj ctx2) {
    const char *_name = "CGLAreContextsShared";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean _get_CGLAreContextsShared(CGLContextObj ctx1, CGLContextObj ctx2) {
    PFN_CGLARECONTEXTSSHARED _ptr;
    _ptr = (PFN_CGLARECONTEXTSSHARED)_getPublicProcAddress("CGLAreContextsShared");
    if (!_ptr) {
        _ptr = &_fail_CGLAreContextsShared;
    }
    _CGLAreContextsShared = _ptr;
    return _CGLAreContextsShared(ctx1, ctx2);
}

PFN_CGLARECONTEXTSSHARED _CGLAreContextsShared = &_get_CGLAreContextsShared;

static CGLContextObj _fail_CGLGetNextContext(CGLContextObj ctx) {
    const char *_name = "CGLGetNextContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLContextObj _get_CGLGetNextContext(CGLContextObj ctx) {
    PFN_CGLGETNEXTCONTEXT _ptr;
    _ptr = (PFN_CGLGETNEXTCONTEXT)_getPublicProcAddress("CGLGetNextContext");
    if (!_ptr) {
        _ptr = &_fail_CGLGetNextContext;
    }
    _CGLGetNextContext = _ptr;
    return _CGLGetNextContext(ctx);
}

PFN_CGLGETNEXTCONTEXT _CGLGetNextContext = &_get_CGLGetNextContext;

static void * _fail_CGLFrontDispatch(CGLContextObj ctx) {
    const char *_name = "CGLFrontDispatch";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static void * _get_CGLFrontDispatch(CGLContextObj ctx) {
    PFN_CGLFRONTDISPATCH _ptr;
    _ptr = (PFN_CGLFRONTDISPATCH)_getPublicProcAddress("CGLFrontDispatch");
    if (!_ptr) {
        _ptr = &_fail_CGLFrontDispatch;
    }
    _CGLFrontDispatch = _ptr;
    return _CGLFrontDispatch(ctx);
}

PFN_CGLFRONTDISPATCH _CGLFrontDispatch = &_get_CGLFrontDispatch;

static void * _fail_CGLBackDispatch(CGLContextObj ctx) {
    const char *_name = "CGLBackDispatch";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static void * _get_CGLBackDispatch(CGLContextObj ctx) {
    PFN_CGLBACKDISPATCH _ptr;
    _ptr = (PFN_CGLBACKDISPATCH)_getPublicProcAddress("CGLBackDispatch");
    if (!_ptr) {
        _ptr = &_fail_CGLBackDispatch;
    }
    _CGLBackDispatch = _ptr;
    return _CGLBackDispatch(ctx);
}

PFN_CGLBACKDISPATCH _CGLBackDispatch = &_get_CGLBackDispatch;

static void _fail_CGLSelectDispatch(CGLContextObj ctx, void * dispatch) {
    const char *_name = "CGLSelectDispatch";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_CGLSelectDispatch(CGLContextObj ctx, void * dispatch) {
    PFN_CGLSELECTDISPATCH _ptr;
    _ptr = (PFN_CGLSELECTDISPATCH)_getPublicProcAddress("CGLSelectDispatch");
    if (!_ptr) {
        _ptr = &_fail_CGLSelectDispatch;
    }
    _CGLSelectDispatch = _ptr;
    _CGLSelectDispatch(ctx, dispatch);
}

PFN_CGLSELECTDISPATCH _CGLSelectDispatch = &_get_CGLSelectDispatch;

static void _fail_CGLSelectDispatchBounded(CGLContextObj ctx, void * dispatch, GLint size) {
    const char *_name = "CGLSelectDispatchBounded";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_CGLSelectDispatchBounded(CGLContextObj ctx, void * dispatch, GLint size) {
    PFN_CGLSELECTDISPATCHBOUNDED _ptr;
    _ptr = (PFN_CGLSELECTDISPATCHBOUNDED)_getPublicProcAddress("CGLSelectDispatchBounded");
    if (!_ptr) {
        _ptr = &_fail_CGLSelectDispatchBounded;
    }
    _CGLSelectDispatchBounded = _ptr;
    _CGLSelectDispatchBounded(ctx, dispatch, size);
}

PFN_CGLSELECTDISPATCHBOUNDED _CGLSelectDispatchBounded = &_get_CGLSelectDispatchBounded;

static void _fail_CGLSelectDispatchFunction(CGLContextObj ctx, void * functionPtr, GLint functionId) {
    const char *_name = "CGLSelectDispatchFunction";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_CGLSelectDispatchFunction(CGLContextObj ctx, void * functionPtr, GLint functionId) {
    PFN_CGLSELECTDISPATCHFUNCTION _ptr;
    _ptr = (PFN_CGLSELECTDISPATCHFUNCTION)_getPublicProcAddress("CGLSelectDispatchFunction");
    if (!_ptr) {
        _ptr = &_fail_CGLSelectDispatchFunction;
    }
    _CGLSelectDispatchFunction = _ptr;
    _CGLSelectDispatchFunction(ctx, functionPtr, functionId);
}

PFN_CGLSELECTDISPATCHFUNCTION _CGLSelectDispatchFunction = &_get_CGLSelectDispatchFunction;

static void _fail_CGLRestoreDispatch(CGLContextObj ctx) {
    const char *_name = "CGLRestoreDispatch";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_CGLRestoreDispatch(CGLContextObj ctx) {
    PFN_CGLRESTOREDISPATCH _ptr;
    _ptr = (PFN_CGLRESTOREDISPATCH)_getPublicProcAddress("CGLRestoreDispatch");
    if (!_ptr) {
        _ptr = &_fail_CGLRestoreDispatch;
    }
    _CGLRestoreDispatch = _ptr;
    _CGLRestoreDispatch(ctx);
}

PFN_CGLRESTOREDISPATCH _CGLRestoreDispatch = &_get_CGLRestoreDispatch;

static void _fail_CGLRestoreDispatchFunction(CGLContextObj ctx, GLint functionId) {
    const char *_name = "CGLRestoreDispatchFunction";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_CGLRestoreDispatchFunction(CGLContextObj ctx, GLint functionId) {
    PFN_CGLRESTOREDISPATCHFUNCTION _ptr;
    _ptr = (PFN_CGLRESTOREDISPATCHFUNCTION)_getPublicProcAddress("CGLRestoreDispatchFunction");
    if (!_ptr) {
        _ptr = &_fail_CGLRestoreDispatchFunction;
    }
    _CGLRestoreDispatchFunction = _ptr;
    _CGLRestoreDispatchFunction(ctx, functionId);
}

PFN_CGLRESTOREDISPATCHFUNCTION _CGLRestoreDispatchFunction = &_get_CGLRestoreDispatchFunction;

static CGLError _fail_CGLSetPBufferVolatileState(CGLPBufferObj pbuffer, void * state) {
    const char *_name = "CGLSetPBufferVolatileState";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static CGLError _get_CGLSetPBufferVolatileState(CGLPBufferObj pbuffer, void * state) {
    PFN_CGLSETPBUFFERVOLATILESTATE _ptr;
    _ptr = (PFN_CGLSETPBUFFERVOLATILESTATE)_getPublicProcAddress("CGLSetPBufferVolatileState");
    if (!_ptr) {
        _ptr = &_fail_CGLSetPBufferVolatileState;
    }
    _CGLSetPBufferVolatileState = _ptr;
    return _CGLSetPBufferVolatileState(pbuffer, state);
}

PFN_CGLSETPBUFFERVOLATILESTATE _CGLSetPBufferVolatileState = &_get_CGLSetPBufferVolatileState;


#elif defined(HAVE_X11)

static XVisualInfo * _fail_glXChooseVisual(Display * dpy, int screen, int * attribList) {
    const char *_name = "glXChooseVisual";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static XVisualInfo * _get_glXChooseVisual(Display * dpy, int screen, int * attribList) {
    PFN_GLXCHOOSEVISUAL _ptr;
    _ptr = (PFN_GLXCHOOSEVISUAL)_getPublicProcAddress("glXChooseVisual");
    if (!_ptr) {
        _ptr = &_fail_glXChooseVisual;
    }
    _glXChooseVisual = _ptr;
    return _glXChooseVisual(dpy, screen, attribList);
}

PFN_GLXCHOOSEVISUAL _glXChooseVisual = &_get_glXChooseVisual;

static GLXContext _fail_glXCreateContext(Display * dpy, XVisualInfo * vis, GLXContext shareList, int direct) {
    const char *_name = "glXCreateContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXContext _get_glXCreateContext(Display * dpy, XVisualInfo * vis, GLXContext shareList, int direct) {
    PFN_GLXCREATECONTEXT _ptr;
    _ptr = (PFN_GLXCREATECONTEXT)_getPublicProcAddress("glXCreateContext");
    if (!_ptr) {
        _ptr = &_fail_glXCreateContext;
    }
    _glXCreateContext = _ptr;
    return _glXCreateContext(dpy, vis, shareList, direct);
}

PFN_GLXCREATECONTEXT _glXCreateContext = &_get_glXCreateContext;

static void _fail_glXDestroyContext(Display * dpy, GLXContext ctx) {
    const char *_name = "glXDestroyContext";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXDestroyContext(Display * dpy, GLXContext ctx) {
    PFN_GLXDESTROYCONTEXT _ptr;
    _ptr = (PFN_GLXDESTROYCONTEXT)_getPublicProcAddress("glXDestroyContext");
    if (!_ptr) {
        _ptr = &_fail_glXDestroyContext;
    }
    _glXDestroyContext = _ptr;
    _glXDestroyContext(dpy, ctx);
}

PFN_GLXDESTROYCONTEXT _glXDestroyContext = &_get_glXDestroyContext;

static int _fail_glXMakeCurrent(Display * dpy, GLXDrawable drawable, GLXContext ctx) {
    const char *_name = "glXMakeCurrent";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXMakeCurrent(Display * dpy, GLXDrawable drawable, GLXContext ctx) {
    PFN_GLXMAKECURRENT _ptr;
    _ptr = (PFN_GLXMAKECURRENT)_getPublicProcAddress("glXMakeCurrent");
    if (!_ptr) {
        _ptr = &_fail_glXMakeCurrent;
    }
    _glXMakeCurrent = _ptr;
    return _glXMakeCurrent(dpy, drawable, ctx);
}

PFN_GLXMAKECURRENT _glXMakeCurrent = &_get_glXMakeCurrent;

static void _fail_glXCopyContext(Display * dpy, GLXContext src, GLXContext dst, unsigned long mask) {
    const char *_name = "glXCopyContext";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXCopyContext(Display * dpy, GLXContext src, GLXContext dst, unsigned long mask) {
    PFN_GLXCOPYCONTEXT _ptr;
    _ptr = (PFN_GLXCOPYCONTEXT)_getPublicProcAddress("glXCopyContext");
    if (!_ptr) {
        _ptr = &_fail_glXCopyContext;
    }
    _glXCopyContext = _ptr;
    _glXCopyContext(dpy, src, dst, mask);
}

PFN_GLXCOPYCONTEXT _glXCopyContext = &_get_glXCopyContext;

static void _fail_glXSwapBuffers(Display * dpy, GLXDrawable drawable) {
    const char *_name = "glXSwapBuffers";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXSwapBuffers(Display * dpy, GLXDrawable drawable) {
    PFN_GLXSWAPBUFFERS _ptr;
    _ptr = (PFN_GLXSWAPBUFFERS)_getPublicProcAddress("glXSwapBuffers");
    if (!_ptr) {
        _ptr = &_fail_glXSwapBuffers;
    }
    _glXSwapBuffers = _ptr;
    _glXSwapBuffers(dpy, drawable);
}

PFN_GLXSWAPBUFFERS _glXSwapBuffers = &_get_glXSwapBuffers;

static GLXPixmap _fail_glXCreateGLXPixmap(Display * dpy, XVisualInfo * visual, Pixmap pixmap) {
    const char *_name = "glXCreateGLXPixmap";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXPixmap _get_glXCreateGLXPixmap(Display * dpy, XVisualInfo * visual, Pixmap pixmap) {
    PFN_GLXCREATEGLXPIXMAP _ptr;
    _ptr = (PFN_GLXCREATEGLXPIXMAP)_getPublicProcAddress("glXCreateGLXPixmap");
    if (!_ptr) {
        _ptr = &_fail_glXCreateGLXPixmap;
    }
    _glXCreateGLXPixmap = _ptr;
    return _glXCreateGLXPixmap(dpy, visual, pixmap);
}

PFN_GLXCREATEGLXPIXMAP _glXCreateGLXPixmap = &_get_glXCreateGLXPixmap;

static void _fail_glXDestroyGLXPixmap(Display * dpy, GLXPixmap pixmap) {
    const char *_name = "glXDestroyGLXPixmap";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXDestroyGLXPixmap(Display * dpy, GLXPixmap pixmap) {
    PFN_GLXDESTROYGLXPIXMAP _ptr;
    _ptr = (PFN_GLXDESTROYGLXPIXMAP)_getPublicProcAddress("glXDestroyGLXPixmap");
    if (!_ptr) {
        _ptr = &_fail_glXDestroyGLXPixmap;
    }
    _glXDestroyGLXPixmap = _ptr;
    _glXDestroyGLXPixmap(dpy, pixmap);
}

PFN_GLXDESTROYGLXPIXMAP _glXDestroyGLXPixmap = &_get_glXDestroyGLXPixmap;

static int _fail_glXQueryExtension(Display * dpy, int * errorb, int * event) {
    const char *_name = "glXQueryExtension";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXQueryExtension(Display * dpy, int * errorb, int * event) {
    PFN_GLXQUERYEXTENSION _ptr;
    _ptr = (PFN_GLXQUERYEXTENSION)_getPublicProcAddress("glXQueryExtension");
    if (!_ptr) {
        _ptr = &_fail_glXQueryExtension;
    }
    _glXQueryExtension = _ptr;
    return _glXQueryExtension(dpy, errorb, event);
}

PFN_GLXQUERYEXTENSION _glXQueryExtension = &_get_glXQueryExtension;

static int _fail_glXQueryVersion(Display * dpy, int * maj, int * min) {
    const char *_name = "glXQueryVersion";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXQueryVersion(Display * dpy, int * maj, int * min) {
    PFN_GLXQUERYVERSION _ptr;
    _ptr = (PFN_GLXQUERYVERSION)_getPublicProcAddress("glXQueryVersion");
    if (!_ptr) {
        _ptr = &_fail_glXQueryVersion;
    }
    _glXQueryVersion = _ptr;
    return _glXQueryVersion(dpy, maj, min);
}

PFN_GLXQUERYVERSION _glXQueryVersion = &_get_glXQueryVersion;

static int _fail_glXIsDirect(Display * dpy, GLXContext ctx) {
    const char *_name = "glXIsDirect";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXIsDirect(Display * dpy, GLXContext ctx) {
    PFN_GLXISDIRECT _ptr;
    _ptr = (PFN_GLXISDIRECT)_getPublicProcAddress("glXIsDirect");
    if (!_ptr) {
        _ptr = &_fail_glXIsDirect;
    }
    _glXIsDirect = _ptr;
    return _glXIsDirect(dpy, ctx);
}

PFN_GLXISDIRECT _glXIsDirect = &_get_glXIsDirect;

static int _fail_glXGetConfig(Display * dpy, XVisualInfo * visual, int attrib, int * value) {
    const char *_name = "glXGetConfig";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXGetConfig(Display * dpy, XVisualInfo * visual, int attrib, int * value) {
    PFN_GLXGETCONFIG _ptr;
    _ptr = (PFN_GLXGETCONFIG)_getPublicProcAddress("glXGetConfig");
    if (!_ptr) {
        _ptr = &_fail_glXGetConfig;
    }
    _glXGetConfig = _ptr;
    return _glXGetConfig(dpy, visual, attrib, value);
}

PFN_GLXGETCONFIG _glXGetConfig = &_get_glXGetConfig;

static GLXContext _fail_glXGetCurrentContext(void) {
    const char *_name = "glXGetCurrentContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXContext _get_glXGetCurrentContext(void) {
    PFN_GLXGETCURRENTCONTEXT _ptr;
    _ptr = (PFN_GLXGETCURRENTCONTEXT)_getPublicProcAddress("glXGetCurrentContext");
    if (!_ptr) {
        _ptr = &_fail_glXGetCurrentContext;
    }
    _glXGetCurrentContext = _ptr;
    return _glXGetCurrentContext();
}

PFN_GLXGETCURRENTCONTEXT _glXGetCurrentContext = &_get_glXGetCurrentContext;

static GLXDrawable _fail_glXGetCurrentDrawable(void) {
    const char *_name = "glXGetCurrentDrawable";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXDrawable _get_glXGetCurrentDrawable(void) {
    PFN_GLXGETCURRENTDRAWABLE _ptr;
    _ptr = (PFN_GLXGETCURRENTDRAWABLE)_getPublicProcAddress("glXGetCurrentDrawable");
    if (!_ptr) {
        _ptr = &_fail_glXGetCurrentDrawable;
    }
    _glXGetCurrentDrawable = _ptr;
    return _glXGetCurrentDrawable();
}

PFN_GLXGETCURRENTDRAWABLE _glXGetCurrentDrawable = &_get_glXGetCurrentDrawable;

static void _fail_glXWaitGL(void) {
    const char *_name = "glXWaitGL";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXWaitGL(void) {
    PFN_GLXWAITGL _ptr;
    _ptr = (PFN_GLXWAITGL)_getPublicProcAddress("glXWaitGL");
    if (!_ptr) {
        _ptr = &_fail_glXWaitGL;
    }
    _glXWaitGL = _ptr;
    _glXWaitGL();
}

PFN_GLXWAITGL _glXWaitGL = &_get_glXWaitGL;

static void _fail_glXWaitX(void) {
    const char *_name = "glXWaitX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXWaitX(void) {
    PFN_GLXWAITX _ptr;
    _ptr = (PFN_GLXWAITX)_getPublicProcAddress("glXWaitX");
    if (!_ptr) {
        _ptr = &_fail_glXWaitX;
    }
    _glXWaitX = _ptr;
    _glXWaitX();
}

PFN_GLXWAITX _glXWaitX = &_get_glXWaitX;

static void _fail_glXUseXFont(Font font, int first, int count, int list) {
    const char *_name = "glXUseXFont";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXUseXFont(Font font, int first, int count, int list) {
    PFN_GLXUSEXFONT _ptr;
    _ptr = (PFN_GLXUSEXFONT)_getPublicProcAddress("glXUseXFont");
    if (!_ptr) {
        _ptr = &_fail_glXUseXFont;
    }
    _glXUseXFont = _ptr;
    _glXUseXFont(font, first, count, list);
}

PFN_GLXUSEXFONT _glXUseXFont = &_get_glXUseXFont;

static const char * _fail_glXQueryExtensionsString(Display * dpy, int screen) {
    const char *_name = "glXQueryExtensionsString";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static const char * _get_glXQueryExtensionsString(Display * dpy, int screen) {
    PFN_GLXQUERYEXTENSIONSSTRING _ptr;
    _ptr = (PFN_GLXQUERYEXTENSIONSSTRING)_getPublicProcAddress("glXQueryExtensionsString");
    if (!_ptr) {
        _ptr = &_fail_glXQueryExtensionsString;
    }
    _glXQueryExtensionsString = _ptr;
    return _glXQueryExtensionsString(dpy, screen);
}

PFN_GLXQUERYEXTENSIONSSTRING _glXQueryExtensionsString = &_get_glXQueryExtensionsString;

static const char * _fail_glXQueryServerString(Display * dpy, int screen, int name) {
    const char *_name = "glXQueryServerString";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static const char * _get_glXQueryServerString(Display * dpy, int screen, int name) {
    PFN_GLXQUERYSERVERSTRING _ptr;
    _ptr = (PFN_GLXQUERYSERVERSTRING)_getPublicProcAddress("glXQueryServerString");
    if (!_ptr) {
        _ptr = &_fail_glXQueryServerString;
    }
    _glXQueryServerString = _ptr;
    return _glXQueryServerString(dpy, screen, name);
}

PFN_GLXQUERYSERVERSTRING _glXQueryServerString = &_get_glXQueryServerString;

static const char * _fail_glXGetClientString(Display * dpy, int name) {
    const char *_name = "glXGetClientString";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static const char * _get_glXGetClientString(Display * dpy, int name) {
    PFN_GLXGETCLIENTSTRING _ptr;
    _ptr = (PFN_GLXGETCLIENTSTRING)_getPublicProcAddress("glXGetClientString");
    if (!_ptr) {
        _ptr = &_fail_glXGetClientString;
    }
    _glXGetClientString = _ptr;
    return _glXGetClientString(dpy, name);
}

PFN_GLXGETCLIENTSTRING _glXGetClientString = &_get_glXGetClientString;

static Display * _fail_glXGetCurrentDisplay(void) {
    const char *_name = "glXGetCurrentDisplay";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static Display * _get_glXGetCurrentDisplay(void) {
    PFN_GLXGETCURRENTDISPLAY _ptr;
    _ptr = (PFN_GLXGETCURRENTDISPLAY)_getPublicProcAddress("glXGetCurrentDisplay");
    if (!_ptr) {
        _ptr = &_fail_glXGetCurrentDisplay;
    }
    _glXGetCurrentDisplay = _ptr;
    return _glXGetCurrentDisplay();
}

PFN_GLXGETCURRENTDISPLAY _glXGetCurrentDisplay = &_get_glXGetCurrentDisplay;

static GLXFBConfig * _fail_glXChooseFBConfig(Display * dpy, int screen, const int * attribList, int * nitems) {
    const char *_name = "glXChooseFBConfig";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXFBConfig * _get_glXChooseFBConfig(Display * dpy, int screen, const int * attribList, int * nitems) {
    PFN_GLXCHOOSEFBCONFIG _ptr;
    _ptr = (PFN_GLXCHOOSEFBCONFIG)_getPublicProcAddress("glXChooseFBConfig");
    if (!_ptr) {
        _ptr = &_fail_glXChooseFBConfig;
    }
    _glXChooseFBConfig = _ptr;
    return _glXChooseFBConfig(dpy, screen, attribList, nitems);
}

PFN_GLXCHOOSEFBCONFIG _glXChooseFBConfig = &_get_glXChooseFBConfig;

static int _fail_glXGetFBConfigAttrib(Display * dpy, GLXFBConfig config, int attribute, int * value) {
    const char *_name = "glXGetFBConfigAttrib";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXGetFBConfigAttrib(Display * dpy, GLXFBConfig config, int attribute, int * value) {
    PFN_GLXGETFBCONFIGATTRIB _ptr;
    _ptr = (PFN_GLXGETFBCONFIGATTRIB)_getPublicProcAddress("glXGetFBConfigAttrib");
    if (!_ptr) {
        _ptr = &_fail_glXGetFBConfigAttrib;
    }
    _glXGetFBConfigAttrib = _ptr;
    return _glXGetFBConfigAttrib(dpy, config, attribute, value);
}

PFN_GLXGETFBCONFIGATTRIB _glXGetFBConfigAttrib = &_get_glXGetFBConfigAttrib;

static GLXFBConfig * _fail_glXGetFBConfigs(Display * dpy, int screen, int * nelements) {
    const char *_name = "glXGetFBConfigs";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXFBConfig * _get_glXGetFBConfigs(Display * dpy, int screen, int * nelements) {
    PFN_GLXGETFBCONFIGS _ptr;
    _ptr = (PFN_GLXGETFBCONFIGS)_getPublicProcAddress("glXGetFBConfigs");
    if (!_ptr) {
        _ptr = &_fail_glXGetFBConfigs;
    }
    _glXGetFBConfigs = _ptr;
    return _glXGetFBConfigs(dpy, screen, nelements);
}

PFN_GLXGETFBCONFIGS _glXGetFBConfigs = &_get_glXGetFBConfigs;

static XVisualInfo * _fail_glXGetVisualFromFBConfig(Display * dpy, GLXFBConfig config) {
    const char *_name = "glXGetVisualFromFBConfig";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static XVisualInfo * _get_glXGetVisualFromFBConfig(Display * dpy, GLXFBConfig config) {
    PFN_GLXGETVISUALFROMFBCONFIG _ptr;
    _ptr = (PFN_GLXGETVISUALFROMFBCONFIG)_getPublicProcAddress("glXGetVisualFromFBConfig");
    if (!_ptr) {
        _ptr = &_fail_glXGetVisualFromFBConfig;
    }
    _glXGetVisualFromFBConfig = _ptr;
    return _glXGetVisualFromFBConfig(dpy, config);
}

PFN_GLXGETVISUALFROMFBCONFIG _glXGetVisualFromFBConfig = &_get_glXGetVisualFromFBConfig;

static GLXWindow _fail_glXCreateWindow(Display * dpy, GLXFBConfig config, Window win, const int * attribList) {
    const char *_name = "glXCreateWindow";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXWindow _get_glXCreateWindow(Display * dpy, GLXFBConfig config, Window win, const int * attribList) {
    PFN_GLXCREATEWINDOW _ptr;
    _ptr = (PFN_GLXCREATEWINDOW)_getPublicProcAddress("glXCreateWindow");
    if (!_ptr) {
        _ptr = &_fail_glXCreateWindow;
    }
    _glXCreateWindow = _ptr;
    return _glXCreateWindow(dpy, config, win, attribList);
}

PFN_GLXCREATEWINDOW _glXCreateWindow = &_get_glXCreateWindow;

static void _fail_glXDestroyWindow(Display * dpy, GLXWindow window) {
    const char *_name = "glXDestroyWindow";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXDestroyWindow(Display * dpy, GLXWindow window) {
    PFN_GLXDESTROYWINDOW _ptr;
    _ptr = (PFN_GLXDESTROYWINDOW)_getPublicProcAddress("glXDestroyWindow");
    if (!_ptr) {
        _ptr = &_fail_glXDestroyWindow;
    }
    _glXDestroyWindow = _ptr;
    _glXDestroyWindow(dpy, window);
}

PFN_GLXDESTROYWINDOW _glXDestroyWindow = &_get_glXDestroyWindow;

static GLXPixmap _fail_glXCreatePixmap(Display * dpy, GLXFBConfig config, Pixmap pixmap, const int * attribList) {
    const char *_name = "glXCreatePixmap";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXPixmap _get_glXCreatePixmap(Display * dpy, GLXFBConfig config, Pixmap pixmap, const int * attribList) {
    PFN_GLXCREATEPIXMAP _ptr;
    _ptr = (PFN_GLXCREATEPIXMAP)_getPublicProcAddress("glXCreatePixmap");
    if (!_ptr) {
        _ptr = &_fail_glXCreatePixmap;
    }
    _glXCreatePixmap = _ptr;
    return _glXCreatePixmap(dpy, config, pixmap, attribList);
}

PFN_GLXCREATEPIXMAP _glXCreatePixmap = &_get_glXCreatePixmap;

static void _fail_glXDestroyPixmap(Display * dpy, GLXPixmap pixmap) {
    const char *_name = "glXDestroyPixmap";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXDestroyPixmap(Display * dpy, GLXPixmap pixmap) {
    PFN_GLXDESTROYPIXMAP _ptr;
    _ptr = (PFN_GLXDESTROYPIXMAP)_getPublicProcAddress("glXDestroyPixmap");
    if (!_ptr) {
        _ptr = &_fail_glXDestroyPixmap;
    }
    _glXDestroyPixmap = _ptr;
    _glXDestroyPixmap(dpy, pixmap);
}

PFN_GLXDESTROYPIXMAP _glXDestroyPixmap = &_get_glXDestroyPixmap;

static GLXPbuffer _fail_glXCreatePbuffer(Display * dpy, GLXFBConfig config, const int * attribList) {
    const char *_name = "glXCreatePbuffer";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXPbuffer _get_glXCreatePbuffer(Display * dpy, GLXFBConfig config, const int * attribList) {
    PFN_GLXCREATEPBUFFER _ptr;
    _ptr = (PFN_GLXCREATEPBUFFER)_getPublicProcAddress("glXCreatePbuffer");
    if (!_ptr) {
        _ptr = &_fail_glXCreatePbuffer;
    }
    _glXCreatePbuffer = _ptr;
    return _glXCreatePbuffer(dpy, config, attribList);
}

PFN_GLXCREATEPBUFFER _glXCreatePbuffer = &_get_glXCreatePbuffer;

static void _fail_glXDestroyPbuffer(Display * dpy, GLXPbuffer pbuf) {
    const char *_name = "glXDestroyPbuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXDestroyPbuffer(Display * dpy, GLXPbuffer pbuf) {
    PFN_GLXDESTROYPBUFFER _ptr;
    _ptr = (PFN_GLXDESTROYPBUFFER)_getPublicProcAddress("glXDestroyPbuffer");
    if (!_ptr) {
        _ptr = &_fail_glXDestroyPbuffer;
    }
    _glXDestroyPbuffer = _ptr;
    _glXDestroyPbuffer(dpy, pbuf);
}

PFN_GLXDESTROYPBUFFER _glXDestroyPbuffer = &_get_glXDestroyPbuffer;

static void _fail_glXQueryDrawable(Display * dpy, GLXDrawable draw, int attribute, unsigned int * value) {
    const char *_name = "glXQueryDrawable";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXQueryDrawable(Display * dpy, GLXDrawable draw, int attribute, unsigned int * value) {
    PFN_GLXQUERYDRAWABLE _ptr;
    _ptr = (PFN_GLXQUERYDRAWABLE)_getPublicProcAddress("glXQueryDrawable");
    if (!_ptr) {
        _ptr = &_fail_glXQueryDrawable;
    }
    _glXQueryDrawable = _ptr;
    _glXQueryDrawable(dpy, draw, attribute, value);
}

PFN_GLXQUERYDRAWABLE _glXQueryDrawable = &_get_glXQueryDrawable;

static GLXContext _fail_glXCreateNewContext(Display * dpy, GLXFBConfig config, int renderType, GLXContext shareList, int direct) {
    const char *_name = "glXCreateNewContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXContext _get_glXCreateNewContext(Display * dpy, GLXFBConfig config, int renderType, GLXContext shareList, int direct) {
    PFN_GLXCREATENEWCONTEXT _ptr;
    _ptr = (PFN_GLXCREATENEWCONTEXT)_getPublicProcAddress("glXCreateNewContext");
    if (!_ptr) {
        _ptr = &_fail_glXCreateNewContext;
    }
    _glXCreateNewContext = _ptr;
    return _glXCreateNewContext(dpy, config, renderType, shareList, direct);
}

PFN_GLXCREATENEWCONTEXT _glXCreateNewContext = &_get_glXCreateNewContext;

static int _fail_glXMakeContextCurrent(Display * dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx) {
    const char *_name = "glXMakeContextCurrent";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXMakeContextCurrent(Display * dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx) {
    PFN_GLXMAKECONTEXTCURRENT _ptr;
    _ptr = (PFN_GLXMAKECONTEXTCURRENT)_getPublicProcAddress("glXMakeContextCurrent");
    if (!_ptr) {
        _ptr = &_fail_glXMakeContextCurrent;
    }
    _glXMakeContextCurrent = _ptr;
    return _glXMakeContextCurrent(dpy, draw, read, ctx);
}

PFN_GLXMAKECONTEXTCURRENT _glXMakeContextCurrent = &_get_glXMakeContextCurrent;

static GLXDrawable _fail_glXGetCurrentReadDrawable(void) {
    const char *_name = "glXGetCurrentReadDrawable";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXDrawable _get_glXGetCurrentReadDrawable(void) {
    PFN_GLXGETCURRENTREADDRAWABLE _ptr;
    _ptr = (PFN_GLXGETCURRENTREADDRAWABLE)_getPublicProcAddress("glXGetCurrentReadDrawable");
    if (!_ptr) {
        _ptr = &_fail_glXGetCurrentReadDrawable;
    }
    _glXGetCurrentReadDrawable = _ptr;
    return _glXGetCurrentReadDrawable();
}

PFN_GLXGETCURRENTREADDRAWABLE _glXGetCurrentReadDrawable = &_get_glXGetCurrentReadDrawable;

static int _fail_glXQueryContext(Display * dpy, GLXContext ctx, int attribute, int * value) {
    const char *_name = "glXQueryContext";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXQueryContext(Display * dpy, GLXContext ctx, int attribute, int * value) {
    PFN_GLXQUERYCONTEXT _ptr;
    _ptr = (PFN_GLXQUERYCONTEXT)_getPublicProcAddress("glXQueryContext");
    if (!_ptr) {
        _ptr = &_fail_glXQueryContext;
    }
    _glXQueryContext = _ptr;
    return _glXQueryContext(dpy, ctx, attribute, value);
}

PFN_GLXQUERYCONTEXT _glXQueryContext = &_get_glXQueryContext;

static void _fail_glXSelectEvent(Display * dpy, GLXDrawable drawable, unsigned long mask) {
    const char *_name = "glXSelectEvent";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXSelectEvent(Display * dpy, GLXDrawable drawable, unsigned long mask) {
    PFN_GLXSELECTEVENT _ptr;
    _ptr = (PFN_GLXSELECTEVENT)_getPublicProcAddress("glXSelectEvent");
    if (!_ptr) {
        _ptr = &_fail_glXSelectEvent;
    }
    _glXSelectEvent = _ptr;
    _glXSelectEvent(dpy, drawable, mask);
}

PFN_GLXSELECTEVENT _glXSelectEvent = &_get_glXSelectEvent;

static void _fail_glXGetSelectedEvent(Display * dpy, GLXDrawable drawable, unsigned long * mask) {
    const char *_name = "glXGetSelectedEvent";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXGetSelectedEvent(Display * dpy, GLXDrawable drawable, unsigned long * mask) {
    PFN_GLXGETSELECTEDEVENT _ptr;
    _ptr = (PFN_GLXGETSELECTEDEVENT)_getPublicProcAddress("glXGetSelectedEvent");
    if (!_ptr) {
        _ptr = &_fail_glXGetSelectedEvent;
    }
    _glXGetSelectedEvent = _ptr;
    _glXGetSelectedEvent(dpy, drawable, mask);
}

PFN_GLXGETSELECTEDEVENT _glXGetSelectedEvent = &_get_glXGetSelectedEvent;

static GLXContext _fail_glXCreateContextAttribsARB(Display * dpy, GLXFBConfig config, GLXContext share_context, int direct, const int * attrib_list) {
    const char *_name = "glXCreateContextAttribsARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXContext _get_glXCreateContextAttribsARB(Display * dpy, GLXFBConfig config, GLXContext share_context, int direct, const int * attrib_list) {
    PFN_GLXCREATECONTEXTATTRIBSARB _ptr;
    _ptr = (PFN_GLXCREATECONTEXTATTRIBSARB)_getPrivateProcAddress("glXCreateContextAttribsARB");
    if (!_ptr) {
        _ptr = &_fail_glXCreateContextAttribsARB;
    }
    _glXCreateContextAttribsARB = _ptr;
    return _glXCreateContextAttribsARB(dpy, config, share_context, direct, attrib_list);
}

PFN_GLXCREATECONTEXTATTRIBSARB _glXCreateContextAttribsARB = &_get_glXCreateContextAttribsARB;

static Display * _fail_glXGetCurrentDisplayEXT(void) {
    const char *_name = "glXGetCurrentDisplayEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static Display * _get_glXGetCurrentDisplayEXT(void) {
    PFN_GLXGETCURRENTDISPLAYEXT _ptr;
    _ptr = (PFN_GLXGETCURRENTDISPLAYEXT)_getPrivateProcAddress("glXGetCurrentDisplayEXT");
    if (!_ptr) {
        _ptr = &_fail_glXGetCurrentDisplayEXT;
    }
    _glXGetCurrentDisplayEXT = _ptr;
    return _glXGetCurrentDisplayEXT();
}

PFN_GLXGETCURRENTDISPLAYEXT _glXGetCurrentDisplayEXT = &_get_glXGetCurrentDisplayEXT;

static int _fail_glXQueryContextInfoEXT(Display * dpy, GLXContext context, int attribute, int * value) {
    const char *_name = "glXQueryContextInfoEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXQueryContextInfoEXT(Display * dpy, GLXContext context, int attribute, int * value) {
    PFN_GLXQUERYCONTEXTINFOEXT _ptr;
    _ptr = (PFN_GLXQUERYCONTEXTINFOEXT)_getPrivateProcAddress("glXQueryContextInfoEXT");
    if (!_ptr) {
        _ptr = &_fail_glXQueryContextInfoEXT;
    }
    _glXQueryContextInfoEXT = _ptr;
    return _glXQueryContextInfoEXT(dpy, context, attribute, value);
}

PFN_GLXQUERYCONTEXTINFOEXT _glXQueryContextInfoEXT = &_get_glXQueryContextInfoEXT;

static GLXContextID _fail_glXGetContextIDEXT(const GLXContext context) {
    const char *_name = "glXGetContextIDEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXContextID _get_glXGetContextIDEXT(const GLXContext context) {
    PFN_GLXGETCONTEXTIDEXT _ptr;
    _ptr = (PFN_GLXGETCONTEXTIDEXT)_getPrivateProcAddress("glXGetContextIDEXT");
    if (!_ptr) {
        _ptr = &_fail_glXGetContextIDEXT;
    }
    _glXGetContextIDEXT = _ptr;
    return _glXGetContextIDEXT(context);
}

PFN_GLXGETCONTEXTIDEXT _glXGetContextIDEXT = &_get_glXGetContextIDEXT;

static GLXContext _fail_glXImportContextEXT(Display * dpy, GLXContextID contextID) {
    const char *_name = "glXImportContextEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXContext _get_glXImportContextEXT(Display * dpy, GLXContextID contextID) {
    PFN_GLXIMPORTCONTEXTEXT _ptr;
    _ptr = (PFN_GLXIMPORTCONTEXTEXT)_getPrivateProcAddress("glXImportContextEXT");
    if (!_ptr) {
        _ptr = &_fail_glXImportContextEXT;
    }
    _glXImportContextEXT = _ptr;
    return _glXImportContextEXT(dpy, contextID);
}

PFN_GLXIMPORTCONTEXTEXT _glXImportContextEXT = &_get_glXImportContextEXT;

static void _fail_glXFreeContextEXT(Display * dpy, GLXContext context) {
    const char *_name = "glXFreeContextEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXFreeContextEXT(Display * dpy, GLXContext context) {
    PFN_GLXFREECONTEXTEXT _ptr;
    _ptr = (PFN_GLXFREECONTEXTEXT)_getPrivateProcAddress("glXFreeContextEXT");
    if (!_ptr) {
        _ptr = &_fail_glXFreeContextEXT;
    }
    _glXFreeContextEXT = _ptr;
    _glXFreeContextEXT(dpy, context);
}

PFN_GLXFREECONTEXTEXT _glXFreeContextEXT = &_get_glXFreeContextEXT;

static void _fail_glXSwapIntervalEXT(Display * dpy, GLXDrawable drawable, int interval) {
    const char *_name = "glXSwapIntervalEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXSwapIntervalEXT(Display * dpy, GLXDrawable drawable, int interval) {
    PFN_GLXSWAPINTERVALEXT _ptr;
    _ptr = (PFN_GLXSWAPINTERVALEXT)_getPrivateProcAddress("glXSwapIntervalEXT");
    if (!_ptr) {
        _ptr = &_fail_glXSwapIntervalEXT;
    }
    _glXSwapIntervalEXT = _ptr;
    _glXSwapIntervalEXT(dpy, drawable, interval);
}

PFN_GLXSWAPINTERVALEXT _glXSwapIntervalEXT = &_get_glXSwapIntervalEXT;

static void _fail_glXBindTexImageEXT(Display * display, GLXDrawable drawable, int buffer, const int * attrib_list) {
    const char *_name = "glXBindTexImageEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXBindTexImageEXT(Display * display, GLXDrawable drawable, int buffer, const int * attrib_list) {
    PFN_GLXBINDTEXIMAGEEXT _ptr;
    _ptr = (PFN_GLXBINDTEXIMAGEEXT)_getPrivateProcAddress("glXBindTexImageEXT");
    if (!_ptr) {
        _ptr = &_fail_glXBindTexImageEXT;
    }
    _glXBindTexImageEXT = _ptr;
    _glXBindTexImageEXT(display, drawable, buffer, attrib_list);
}

PFN_GLXBINDTEXIMAGEEXT _glXBindTexImageEXT = &_get_glXBindTexImageEXT;

static void _fail_glXReleaseTexImageEXT(Display * display, GLXDrawable drawable, int buffer) {
    const char *_name = "glXReleaseTexImageEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXReleaseTexImageEXT(Display * display, GLXDrawable drawable, int buffer) {
    PFN_GLXRELEASETEXIMAGEEXT _ptr;
    _ptr = (PFN_GLXRELEASETEXIMAGEEXT)_getPrivateProcAddress("glXReleaseTexImageEXT");
    if (!_ptr) {
        _ptr = &_fail_glXReleaseTexImageEXT;
    }
    _glXReleaseTexImageEXT = _ptr;
    _glXReleaseTexImageEXT(display, drawable, buffer);
}

PFN_GLXRELEASETEXIMAGEEXT _glXReleaseTexImageEXT = &_get_glXReleaseTexImageEXT;

static unsigned int _fail_glXGetAGPOffsetMESA(const void * pointer) {
    const char *_name = "glXGetAGPOffsetMESA";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static unsigned int _get_glXGetAGPOffsetMESA(const void * pointer) {
    PFN_GLXGETAGPOFFSETMESA _ptr;
    _ptr = (PFN_GLXGETAGPOFFSETMESA)_getPrivateProcAddress("glXGetAGPOffsetMESA");
    if (!_ptr) {
        _ptr = &_fail_glXGetAGPOffsetMESA;
    }
    _glXGetAGPOffsetMESA = _ptr;
    return _glXGetAGPOffsetMESA(pointer);
}

PFN_GLXGETAGPOFFSETMESA _glXGetAGPOffsetMESA = &_get_glXGetAGPOffsetMESA;

static void _fail_glXCopySubBufferMESA(Display * dpy, GLXDrawable drawable, int x, int y, int width, int height) {
    const char *_name = "glXCopySubBufferMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXCopySubBufferMESA(Display * dpy, GLXDrawable drawable, int x, int y, int width, int height) {
    PFN_GLXCOPYSUBBUFFERMESA _ptr;
    _ptr = (PFN_GLXCOPYSUBBUFFERMESA)_getPrivateProcAddress("glXCopySubBufferMESA");
    if (!_ptr) {
        _ptr = &_fail_glXCopySubBufferMESA;
    }
    _glXCopySubBufferMESA = _ptr;
    _glXCopySubBufferMESA(dpy, drawable, x, y, width, height);
}

PFN_GLXCOPYSUBBUFFERMESA _glXCopySubBufferMESA = &_get_glXCopySubBufferMESA;

static GLXPixmap _fail_glXCreateGLXPixmapMESA(Display * dpy, XVisualInfo * visual, Pixmap pixmap, Colormap cmap) {
    const char *_name = "glXCreateGLXPixmapMESA";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXPixmap _get_glXCreateGLXPixmapMESA(Display * dpy, XVisualInfo * visual, Pixmap pixmap, Colormap cmap) {
    PFN_GLXCREATEGLXPIXMAPMESA _ptr;
    _ptr = (PFN_GLXCREATEGLXPIXMAPMESA)_getPrivateProcAddress("glXCreateGLXPixmapMESA");
    if (!_ptr) {
        _ptr = &_fail_glXCreateGLXPixmapMESA;
    }
    _glXCreateGLXPixmapMESA = _ptr;
    return _glXCreateGLXPixmapMESA(dpy, visual, pixmap, cmap);
}

PFN_GLXCREATEGLXPIXMAPMESA _glXCreateGLXPixmapMESA = &_get_glXCreateGLXPixmapMESA;

static int APIENTRY _fail_glXQueryCurrentRendererIntegerMESA(int attribute, unsigned int * value) {
    const char *_name = "glXQueryCurrentRendererIntegerMESA";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int APIENTRY _get_glXQueryCurrentRendererIntegerMESA(int attribute, unsigned int * value) {
    PFN_GLXQUERYCURRENTRENDERERINTEGERMESA _ptr;
    _ptr = (PFN_GLXQUERYCURRENTRENDERERINTEGERMESA)_getPrivateProcAddress("glXQueryCurrentRendererIntegerMESA");
    if (!_ptr) {
        _ptr = &_fail_glXQueryCurrentRendererIntegerMESA;
    }
    _glXQueryCurrentRendererIntegerMESA = _ptr;
    return _glXQueryCurrentRendererIntegerMESA(attribute, value);
}

PFN_GLXQUERYCURRENTRENDERERINTEGERMESA _glXQueryCurrentRendererIntegerMESA = &_get_glXQueryCurrentRendererIntegerMESA;

static const char * APIENTRY _fail_glXQueryCurrentRendererStringMESA(int attribute) {
    const char *_name = "glXQueryCurrentRendererStringMESA";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static const char * APIENTRY _get_glXQueryCurrentRendererStringMESA(int attribute) {
    PFN_GLXQUERYCURRENTRENDERERSTRINGMESA _ptr;
    _ptr = (PFN_GLXQUERYCURRENTRENDERERSTRINGMESA)_getPrivateProcAddress("glXQueryCurrentRendererStringMESA");
    if (!_ptr) {
        _ptr = &_fail_glXQueryCurrentRendererStringMESA;
    }
    _glXQueryCurrentRendererStringMESA = _ptr;
    return _glXQueryCurrentRendererStringMESA(attribute);
}

PFN_GLXQUERYCURRENTRENDERERSTRINGMESA _glXQueryCurrentRendererStringMESA = &_get_glXQueryCurrentRendererStringMESA;

static int APIENTRY _fail_glXQueryRendererIntegerMESA(Display * dpy, int screen, int renderer, int attribute, unsigned int * value) {
    const char *_name = "glXQueryRendererIntegerMESA";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int APIENTRY _get_glXQueryRendererIntegerMESA(Display * dpy, int screen, int renderer, int attribute, unsigned int * value) {
    PFN_GLXQUERYRENDERERINTEGERMESA _ptr;
    _ptr = (PFN_GLXQUERYRENDERERINTEGERMESA)_getPrivateProcAddress("glXQueryRendererIntegerMESA");
    if (!_ptr) {
        _ptr = &_fail_glXQueryRendererIntegerMESA;
    }
    _glXQueryRendererIntegerMESA = _ptr;
    return _glXQueryRendererIntegerMESA(dpy, screen, renderer, attribute, value);
}

PFN_GLXQUERYRENDERERINTEGERMESA _glXQueryRendererIntegerMESA = &_get_glXQueryRendererIntegerMESA;

static const char * APIENTRY _fail_glXQueryRendererStringMESA(Display * dpy, int screen, int renderer, int attribute) {
    const char *_name = "glXQueryRendererStringMESA";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static const char * APIENTRY _get_glXQueryRendererStringMESA(Display * dpy, int screen, int renderer, int attribute) {
    PFN_GLXQUERYRENDERERSTRINGMESA _ptr;
    _ptr = (PFN_GLXQUERYRENDERERSTRINGMESA)_getPrivateProcAddress("glXQueryRendererStringMESA");
    if (!_ptr) {
        _ptr = &_fail_glXQueryRendererStringMESA;
    }
    _glXQueryRendererStringMESA = _ptr;
    return _glXQueryRendererStringMESA(dpy, screen, renderer, attribute);
}

PFN_GLXQUERYRENDERERSTRINGMESA _glXQueryRendererStringMESA = &_get_glXQueryRendererStringMESA;

static int _fail_glXReleaseBuffersMESA(Display * dpy, GLXDrawable drawable) {
    const char *_name = "glXReleaseBuffersMESA";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXReleaseBuffersMESA(Display * dpy, GLXDrawable drawable) {
    PFN_GLXRELEASEBUFFERSMESA _ptr;
    _ptr = (PFN_GLXRELEASEBUFFERSMESA)_getPrivateProcAddress("glXReleaseBuffersMESA");
    if (!_ptr) {
        _ptr = &_fail_glXReleaseBuffersMESA;
    }
    _glXReleaseBuffersMESA = _ptr;
    return _glXReleaseBuffersMESA(dpy, drawable);
}

PFN_GLXRELEASEBUFFERSMESA _glXReleaseBuffersMESA = &_get_glXReleaseBuffersMESA;

static int _fail_glXSet3DfxModeMESA(int mode) {
    const char *_name = "glXSet3DfxModeMESA";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXSet3DfxModeMESA(int mode) {
    PFN_GLXSET3DFXMODEMESA _ptr;
    _ptr = (PFN_GLXSET3DFXMODEMESA)_getPrivateProcAddress("glXSet3DfxModeMESA");
    if (!_ptr) {
        _ptr = &_fail_glXSet3DfxModeMESA;
    }
    _glXSet3DfxModeMESA = _ptr;
    return _glXSet3DfxModeMESA(mode);
}

PFN_GLXSET3DFXMODEMESA _glXSet3DfxModeMESA = &_get_glXSet3DfxModeMESA;

static int _fail_glXSwapIntervalMESA(unsigned int interval) {
    const char *_name = "glXSwapIntervalMESA";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXSwapIntervalMESA(unsigned int interval) {
    PFN_GLXSWAPINTERVALMESA _ptr;
    _ptr = (PFN_GLXSWAPINTERVALMESA)_getPrivateProcAddress("glXSwapIntervalMESA");
    if (!_ptr) {
        _ptr = &_fail_glXSwapIntervalMESA;
    }
    _glXSwapIntervalMESA = _ptr;
    return _glXSwapIntervalMESA(interval);
}

PFN_GLXSWAPINTERVALMESA _glXSwapIntervalMESA = &_get_glXSwapIntervalMESA;

static int _fail_glXGetSwapIntervalMESA(void) {
    const char *_name = "glXGetSwapIntervalMESA";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXGetSwapIntervalMESA(void) {
    PFN_GLXGETSWAPINTERVALMESA _ptr;
    _ptr = (PFN_GLXGETSWAPINTERVALMESA)_getPrivateProcAddress("glXGetSwapIntervalMESA");
    if (!_ptr) {
        _ptr = &_fail_glXGetSwapIntervalMESA;
    }
    _glXGetSwapIntervalMESA = _ptr;
    return _glXGetSwapIntervalMESA();
}

PFN_GLXGETSWAPINTERVALMESA _glXGetSwapIntervalMESA = &_get_glXGetSwapIntervalMESA;

static void _fail_glXCopyImageSubDataNV(Display * dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) {
    const char *_name = "glXCopyImageSubDataNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXCopyImageSubDataNV(Display * dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) {
    PFN_GLXCOPYIMAGESUBDATANV _ptr;
    _ptr = (PFN_GLXCOPYIMAGESUBDATANV)_getPrivateProcAddress("glXCopyImageSubDataNV");
    if (!_ptr) {
        _ptr = &_fail_glXCopyImageSubDataNV;
    }
    _glXCopyImageSubDataNV = _ptr;
    _glXCopyImageSubDataNV(dpy, srcCtx, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstCtx, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
}

PFN_GLXCOPYIMAGESUBDATANV _glXCopyImageSubDataNV = &_get_glXCopyImageSubDataNV;

static unsigned int * _fail_glXEnumerateVideoDevicesNV(Display * dpy, int screen, int * nelements) {
    const char *_name = "glXEnumerateVideoDevicesNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static unsigned int * _get_glXEnumerateVideoDevicesNV(Display * dpy, int screen, int * nelements) {
    PFN_GLXENUMERATEVIDEODEVICESNV _ptr;
    _ptr = (PFN_GLXENUMERATEVIDEODEVICESNV)_getPrivateProcAddress("glXEnumerateVideoDevicesNV");
    if (!_ptr) {
        _ptr = &_fail_glXEnumerateVideoDevicesNV;
    }
    _glXEnumerateVideoDevicesNV = _ptr;
    return _glXEnumerateVideoDevicesNV(dpy, screen, nelements);
}

PFN_GLXENUMERATEVIDEODEVICESNV _glXEnumerateVideoDevicesNV = &_get_glXEnumerateVideoDevicesNV;

static int _fail_glXBindVideoDeviceNV(Display * dpy, unsigned int video_slot, unsigned int video_device, const int * attrib_list) {
    const char *_name = "glXBindVideoDeviceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXBindVideoDeviceNV(Display * dpy, unsigned int video_slot, unsigned int video_device, const int * attrib_list) {
    PFN_GLXBINDVIDEODEVICENV _ptr;
    _ptr = (PFN_GLXBINDVIDEODEVICENV)_getPrivateProcAddress("glXBindVideoDeviceNV");
    if (!_ptr) {
        _ptr = &_fail_glXBindVideoDeviceNV;
    }
    _glXBindVideoDeviceNV = _ptr;
    return _glXBindVideoDeviceNV(dpy, video_slot, video_device, attrib_list);
}

PFN_GLXBINDVIDEODEVICENV _glXBindVideoDeviceNV = &_get_glXBindVideoDeviceNV;

static int _fail_glXJoinSwapGroupNV(Display * dpy, GLXDrawable drawable, GLuint group) {
    const char *_name = "glXJoinSwapGroupNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXJoinSwapGroupNV(Display * dpy, GLXDrawable drawable, GLuint group) {
    PFN_GLXJOINSWAPGROUPNV _ptr;
    _ptr = (PFN_GLXJOINSWAPGROUPNV)_getPrivateProcAddress("glXJoinSwapGroupNV");
    if (!_ptr) {
        _ptr = &_fail_glXJoinSwapGroupNV;
    }
    _glXJoinSwapGroupNV = _ptr;
    return _glXJoinSwapGroupNV(dpy, drawable, group);
}

PFN_GLXJOINSWAPGROUPNV _glXJoinSwapGroupNV = &_get_glXJoinSwapGroupNV;

static int _fail_glXBindSwapBarrierNV(Display * dpy, GLuint group, GLuint barrier) {
    const char *_name = "glXBindSwapBarrierNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXBindSwapBarrierNV(Display * dpy, GLuint group, GLuint barrier) {
    PFN_GLXBINDSWAPBARRIERNV _ptr;
    _ptr = (PFN_GLXBINDSWAPBARRIERNV)_getPrivateProcAddress("glXBindSwapBarrierNV");
    if (!_ptr) {
        _ptr = &_fail_glXBindSwapBarrierNV;
    }
    _glXBindSwapBarrierNV = _ptr;
    return _glXBindSwapBarrierNV(dpy, group, barrier);
}

PFN_GLXBINDSWAPBARRIERNV _glXBindSwapBarrierNV = &_get_glXBindSwapBarrierNV;

static int _fail_glXQuerySwapGroupNV(Display * dpy, GLXDrawable drawable, GLuint * group, GLuint * barrier) {
    const char *_name = "glXQuerySwapGroupNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXQuerySwapGroupNV(Display * dpy, GLXDrawable drawable, GLuint * group, GLuint * barrier) {
    PFN_GLXQUERYSWAPGROUPNV _ptr;
    _ptr = (PFN_GLXQUERYSWAPGROUPNV)_getPrivateProcAddress("glXQuerySwapGroupNV");
    if (!_ptr) {
        _ptr = &_fail_glXQuerySwapGroupNV;
    }
    _glXQuerySwapGroupNV = _ptr;
    return _glXQuerySwapGroupNV(dpy, drawable, group, barrier);
}

PFN_GLXQUERYSWAPGROUPNV _glXQuerySwapGroupNV = &_get_glXQuerySwapGroupNV;

static int _fail_glXQueryMaxSwapGroupsNV(Display * dpy, int screen, GLuint * maxGroups, GLuint * maxBarriers) {
    const char *_name = "glXQueryMaxSwapGroupsNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXQueryMaxSwapGroupsNV(Display * dpy, int screen, GLuint * maxGroups, GLuint * maxBarriers) {
    PFN_GLXQUERYMAXSWAPGROUPSNV _ptr;
    _ptr = (PFN_GLXQUERYMAXSWAPGROUPSNV)_getPrivateProcAddress("glXQueryMaxSwapGroupsNV");
    if (!_ptr) {
        _ptr = &_fail_glXQueryMaxSwapGroupsNV;
    }
    _glXQueryMaxSwapGroupsNV = _ptr;
    return _glXQueryMaxSwapGroupsNV(dpy, screen, maxGroups, maxBarriers);
}

PFN_GLXQUERYMAXSWAPGROUPSNV _glXQueryMaxSwapGroupsNV = &_get_glXQueryMaxSwapGroupsNV;

static int _fail_glXQueryFrameCountNV(Display * dpy, int screen, GLuint * count) {
    const char *_name = "glXQueryFrameCountNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXQueryFrameCountNV(Display * dpy, int screen, GLuint * count) {
    PFN_GLXQUERYFRAMECOUNTNV _ptr;
    _ptr = (PFN_GLXQUERYFRAMECOUNTNV)_getPrivateProcAddress("glXQueryFrameCountNV");
    if (!_ptr) {
        _ptr = &_fail_glXQueryFrameCountNV;
    }
    _glXQueryFrameCountNV = _ptr;
    return _glXQueryFrameCountNV(dpy, screen, count);
}

PFN_GLXQUERYFRAMECOUNTNV _glXQueryFrameCountNV = &_get_glXQueryFrameCountNV;

static int _fail_glXResetFrameCountNV(Display * dpy, int screen) {
    const char *_name = "glXResetFrameCountNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXResetFrameCountNV(Display * dpy, int screen) {
    PFN_GLXRESETFRAMECOUNTNV _ptr;
    _ptr = (PFN_GLXRESETFRAMECOUNTNV)_getPrivateProcAddress("glXResetFrameCountNV");
    if (!_ptr) {
        _ptr = &_fail_glXResetFrameCountNV;
    }
    _glXResetFrameCountNV = _ptr;
    return _glXResetFrameCountNV(dpy, screen);
}

PFN_GLXRESETFRAMECOUNTNV _glXResetFrameCountNV = &_get_glXResetFrameCountNV;

static void * _fail_glXAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority) {
    const char *_name = "glXAllocateMemoryNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static void * _get_glXAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority) {
    PFN_GLXALLOCATEMEMORYNV _ptr;
    _ptr = (PFN_GLXALLOCATEMEMORYNV)_getPrivateProcAddress("glXAllocateMemoryNV");
    if (!_ptr) {
        _ptr = &_fail_glXAllocateMemoryNV;
    }
    _glXAllocateMemoryNV = _ptr;
    return _glXAllocateMemoryNV(size, readfreq, writefreq, priority);
}

PFN_GLXALLOCATEMEMORYNV _glXAllocateMemoryNV = &_get_glXAllocateMemoryNV;

static void _fail_glXFreeMemoryNV(void * pointer) {
    const char *_name = "glXFreeMemoryNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXFreeMemoryNV(void * pointer) {
    PFN_GLXFREEMEMORYNV _ptr;
    _ptr = (PFN_GLXFREEMEMORYNV)_getPrivateProcAddress("glXFreeMemoryNV");
    if (!_ptr) {
        _ptr = &_fail_glXFreeMemoryNV;
    }
    _glXFreeMemoryNV = _ptr;
    _glXFreeMemoryNV(pointer);
}

PFN_GLXFREEMEMORYNV _glXFreeMemoryNV = &_get_glXFreeMemoryNV;

static int _fail_glXBindVideoCaptureDeviceNV(Display * dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device) {
    const char *_name = "glXBindVideoCaptureDeviceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXBindVideoCaptureDeviceNV(Display * dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device) {
    PFN_GLXBINDVIDEOCAPTUREDEVICENV _ptr;
    _ptr = (PFN_GLXBINDVIDEOCAPTUREDEVICENV)_getPrivateProcAddress("glXBindVideoCaptureDeviceNV");
    if (!_ptr) {
        _ptr = &_fail_glXBindVideoCaptureDeviceNV;
    }
    _glXBindVideoCaptureDeviceNV = _ptr;
    return _glXBindVideoCaptureDeviceNV(dpy, video_capture_slot, device);
}

PFN_GLXBINDVIDEOCAPTUREDEVICENV _glXBindVideoCaptureDeviceNV = &_get_glXBindVideoCaptureDeviceNV;

static GLXVideoCaptureDeviceNV * _fail_glXEnumerateVideoCaptureDevicesNV(Display * dpy, int screen, int * nelements) {
    const char *_name = "glXEnumerateVideoCaptureDevicesNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXVideoCaptureDeviceNV * _get_glXEnumerateVideoCaptureDevicesNV(Display * dpy, int screen, int * nelements) {
    PFN_GLXENUMERATEVIDEOCAPTUREDEVICESNV _ptr;
    _ptr = (PFN_GLXENUMERATEVIDEOCAPTUREDEVICESNV)_getPrivateProcAddress("glXEnumerateVideoCaptureDevicesNV");
    if (!_ptr) {
        _ptr = &_fail_glXEnumerateVideoCaptureDevicesNV;
    }
    _glXEnumerateVideoCaptureDevicesNV = _ptr;
    return _glXEnumerateVideoCaptureDevicesNV(dpy, screen, nelements);
}

PFN_GLXENUMERATEVIDEOCAPTUREDEVICESNV _glXEnumerateVideoCaptureDevicesNV = &_get_glXEnumerateVideoCaptureDevicesNV;

static void _fail_glXLockVideoCaptureDeviceNV(Display * dpy, GLXVideoCaptureDeviceNV device) {
    const char *_name = "glXLockVideoCaptureDeviceNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXLockVideoCaptureDeviceNV(Display * dpy, GLXVideoCaptureDeviceNV device) {
    PFN_GLXLOCKVIDEOCAPTUREDEVICENV _ptr;
    _ptr = (PFN_GLXLOCKVIDEOCAPTUREDEVICENV)_getPrivateProcAddress("glXLockVideoCaptureDeviceNV");
    if (!_ptr) {
        _ptr = &_fail_glXLockVideoCaptureDeviceNV;
    }
    _glXLockVideoCaptureDeviceNV = _ptr;
    _glXLockVideoCaptureDeviceNV(dpy, device);
}

PFN_GLXLOCKVIDEOCAPTUREDEVICENV _glXLockVideoCaptureDeviceNV = &_get_glXLockVideoCaptureDeviceNV;

static int _fail_glXQueryVideoCaptureDeviceNV(Display * dpy, GLXVideoCaptureDeviceNV device, int attribute, int * value) {
    const char *_name = "glXQueryVideoCaptureDeviceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXQueryVideoCaptureDeviceNV(Display * dpy, GLXVideoCaptureDeviceNV device, int attribute, int * value) {
    PFN_GLXQUERYVIDEOCAPTUREDEVICENV _ptr;
    _ptr = (PFN_GLXQUERYVIDEOCAPTUREDEVICENV)_getPrivateProcAddress("glXQueryVideoCaptureDeviceNV");
    if (!_ptr) {
        _ptr = &_fail_glXQueryVideoCaptureDeviceNV;
    }
    _glXQueryVideoCaptureDeviceNV = _ptr;
    return _glXQueryVideoCaptureDeviceNV(dpy, device, attribute, value);
}

PFN_GLXQUERYVIDEOCAPTUREDEVICENV _glXQueryVideoCaptureDeviceNV = &_get_glXQueryVideoCaptureDeviceNV;

static void _fail_glXReleaseVideoCaptureDeviceNV(Display * dpy, GLXVideoCaptureDeviceNV device) {
    const char *_name = "glXReleaseVideoCaptureDeviceNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXReleaseVideoCaptureDeviceNV(Display * dpy, GLXVideoCaptureDeviceNV device) {
    PFN_GLXRELEASEVIDEOCAPTUREDEVICENV _ptr;
    _ptr = (PFN_GLXRELEASEVIDEOCAPTUREDEVICENV)_getPrivateProcAddress("glXReleaseVideoCaptureDeviceNV");
    if (!_ptr) {
        _ptr = &_fail_glXReleaseVideoCaptureDeviceNV;
    }
    _glXReleaseVideoCaptureDeviceNV = _ptr;
    _glXReleaseVideoCaptureDeviceNV(dpy, device);
}

PFN_GLXRELEASEVIDEOCAPTUREDEVICENV _glXReleaseVideoCaptureDeviceNV = &_get_glXReleaseVideoCaptureDeviceNV;

static int _fail_glXGetVideoDeviceNV(Display * dpy, int screen, int numVideoDevices, GLXVideoDeviceNV * pVideoDevice) {
    const char *_name = "glXGetVideoDeviceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXGetVideoDeviceNV(Display * dpy, int screen, int numVideoDevices, GLXVideoDeviceNV * pVideoDevice) {
    PFN_GLXGETVIDEODEVICENV _ptr;
    _ptr = (PFN_GLXGETVIDEODEVICENV)_getPrivateProcAddress("glXGetVideoDeviceNV");
    if (!_ptr) {
        _ptr = &_fail_glXGetVideoDeviceNV;
    }
    _glXGetVideoDeviceNV = _ptr;
    return _glXGetVideoDeviceNV(dpy, screen, numVideoDevices, pVideoDevice);
}

PFN_GLXGETVIDEODEVICENV _glXGetVideoDeviceNV = &_get_glXGetVideoDeviceNV;

static int _fail_glXReleaseVideoDeviceNV(Display * dpy, int screen, GLXVideoDeviceNV VideoDevice) {
    const char *_name = "glXReleaseVideoDeviceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXReleaseVideoDeviceNV(Display * dpy, int screen, GLXVideoDeviceNV VideoDevice) {
    PFN_GLXRELEASEVIDEODEVICENV _ptr;
    _ptr = (PFN_GLXRELEASEVIDEODEVICENV)_getPrivateProcAddress("glXReleaseVideoDeviceNV");
    if (!_ptr) {
        _ptr = &_fail_glXReleaseVideoDeviceNV;
    }
    _glXReleaseVideoDeviceNV = _ptr;
    return _glXReleaseVideoDeviceNV(dpy, screen, VideoDevice);
}

PFN_GLXRELEASEVIDEODEVICENV _glXReleaseVideoDeviceNV = &_get_glXReleaseVideoDeviceNV;

static int _fail_glXBindVideoImageNV(Display * dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer) {
    const char *_name = "glXBindVideoImageNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXBindVideoImageNV(Display * dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer) {
    PFN_GLXBINDVIDEOIMAGENV _ptr;
    _ptr = (PFN_GLXBINDVIDEOIMAGENV)_getPrivateProcAddress("glXBindVideoImageNV");
    if (!_ptr) {
        _ptr = &_fail_glXBindVideoImageNV;
    }
    _glXBindVideoImageNV = _ptr;
    return _glXBindVideoImageNV(dpy, VideoDevice, pbuf, iVideoBuffer);
}

PFN_GLXBINDVIDEOIMAGENV _glXBindVideoImageNV = &_get_glXBindVideoImageNV;

static int _fail_glXReleaseVideoImageNV(Display * dpy, GLXPbuffer pbuf) {
    const char *_name = "glXReleaseVideoImageNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXReleaseVideoImageNV(Display * dpy, GLXPbuffer pbuf) {
    PFN_GLXRELEASEVIDEOIMAGENV _ptr;
    _ptr = (PFN_GLXRELEASEVIDEOIMAGENV)_getPrivateProcAddress("glXReleaseVideoImageNV");
    if (!_ptr) {
        _ptr = &_fail_glXReleaseVideoImageNV;
    }
    _glXReleaseVideoImageNV = _ptr;
    return _glXReleaseVideoImageNV(dpy, pbuf);
}

PFN_GLXRELEASEVIDEOIMAGENV _glXReleaseVideoImageNV = &_get_glXReleaseVideoImageNV;

static int _fail_glXSendPbufferToVideoNV(Display * dpy, GLXPbuffer pbuf, int iBufferType, unsigned long * pulCounterPbuffer, GLboolean bBlock) {
    const char *_name = "glXSendPbufferToVideoNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXSendPbufferToVideoNV(Display * dpy, GLXPbuffer pbuf, int iBufferType, unsigned long * pulCounterPbuffer, GLboolean bBlock) {
    PFN_GLXSENDPBUFFERTOVIDEONV _ptr;
    _ptr = (PFN_GLXSENDPBUFFERTOVIDEONV)_getPrivateProcAddress("glXSendPbufferToVideoNV");
    if (!_ptr) {
        _ptr = &_fail_glXSendPbufferToVideoNV;
    }
    _glXSendPbufferToVideoNV = _ptr;
    return _glXSendPbufferToVideoNV(dpy, pbuf, iBufferType, pulCounterPbuffer, bBlock);
}

PFN_GLXSENDPBUFFERTOVIDEONV _glXSendPbufferToVideoNV = &_get_glXSendPbufferToVideoNV;

static int _fail_glXGetVideoInfoNV(Display * dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long * pulCounterOutputPbuffer, unsigned long * pulCounterOutputVideo) {
    const char *_name = "glXGetVideoInfoNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXGetVideoInfoNV(Display * dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long * pulCounterOutputPbuffer, unsigned long * pulCounterOutputVideo) {
    PFN_GLXGETVIDEOINFONV _ptr;
    _ptr = (PFN_GLXGETVIDEOINFONV)_getPrivateProcAddress("glXGetVideoInfoNV");
    if (!_ptr) {
        _ptr = &_fail_glXGetVideoInfoNV;
    }
    _glXGetVideoInfoNV = _ptr;
    return _glXGetVideoInfoNV(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
}

PFN_GLXGETVIDEOINFONV _glXGetVideoInfoNV = &_get_glXGetVideoInfoNV;

static int _fail_glXGetSyncValuesOML(Display * dpy, GLXDrawable drawable, int64_t * ust, int64_t * msc, int64_t * sbc) {
    const char *_name = "glXGetSyncValuesOML";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXGetSyncValuesOML(Display * dpy, GLXDrawable drawable, int64_t * ust, int64_t * msc, int64_t * sbc) {
    PFN_GLXGETSYNCVALUESOML _ptr;
    _ptr = (PFN_GLXGETSYNCVALUESOML)_getPrivateProcAddress("glXGetSyncValuesOML");
    if (!_ptr) {
        _ptr = &_fail_glXGetSyncValuesOML;
    }
    _glXGetSyncValuesOML = _ptr;
    return _glXGetSyncValuesOML(dpy, drawable, ust, msc, sbc);
}

PFN_GLXGETSYNCVALUESOML _glXGetSyncValuesOML = &_get_glXGetSyncValuesOML;

static int _fail_glXGetMscRateOML(Display * dpy, GLXDrawable drawable, int32_t * numerator, int32_t * denominator) {
    const char *_name = "glXGetMscRateOML";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXGetMscRateOML(Display * dpy, GLXDrawable drawable, int32_t * numerator, int32_t * denominator) {
    PFN_GLXGETMSCRATEOML _ptr;
    _ptr = (PFN_GLXGETMSCRATEOML)_getPrivateProcAddress("glXGetMscRateOML");
    if (!_ptr) {
        _ptr = &_fail_glXGetMscRateOML;
    }
    _glXGetMscRateOML = _ptr;
    return _glXGetMscRateOML(dpy, drawable, numerator, denominator);
}

PFN_GLXGETMSCRATEOML _glXGetMscRateOML = &_get_glXGetMscRateOML;

static int64_t _fail_glXSwapBuffersMscOML(Display * dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder) {
    const char *_name = "glXSwapBuffersMscOML";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int64_t _get_glXSwapBuffersMscOML(Display * dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder) {
    PFN_GLXSWAPBUFFERSMSCOML _ptr;
    _ptr = (PFN_GLXSWAPBUFFERSMSCOML)_getPrivateProcAddress("glXSwapBuffersMscOML");
    if (!_ptr) {
        _ptr = &_fail_glXSwapBuffersMscOML;
    }
    _glXSwapBuffersMscOML = _ptr;
    return _glXSwapBuffersMscOML(dpy, drawable, target_msc, divisor, remainder);
}

PFN_GLXSWAPBUFFERSMSCOML _glXSwapBuffersMscOML = &_get_glXSwapBuffersMscOML;

static int _fail_glXWaitForMscOML(Display * dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t * ust, int64_t * msc, int64_t * sbc) {
    const char *_name = "glXWaitForMscOML";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXWaitForMscOML(Display * dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t * ust, int64_t * msc, int64_t * sbc) {
    PFN_GLXWAITFORMSCOML _ptr;
    _ptr = (PFN_GLXWAITFORMSCOML)_getPrivateProcAddress("glXWaitForMscOML");
    if (!_ptr) {
        _ptr = &_fail_glXWaitForMscOML;
    }
    _glXWaitForMscOML = _ptr;
    return _glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
}

PFN_GLXWAITFORMSCOML _glXWaitForMscOML = &_get_glXWaitForMscOML;

static int _fail_glXWaitForSbcOML(Display * dpy, GLXDrawable drawable, int64_t target_sbc, int64_t * ust, int64_t * msc, int64_t * sbc) {
    const char *_name = "glXWaitForSbcOML";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXWaitForSbcOML(Display * dpy, GLXDrawable drawable, int64_t target_sbc, int64_t * ust, int64_t * msc, int64_t * sbc) {
    PFN_GLXWAITFORSBCOML _ptr;
    _ptr = (PFN_GLXWAITFORSBCOML)_getPrivateProcAddress("glXWaitForSbcOML");
    if (!_ptr) {
        _ptr = &_fail_glXWaitForSbcOML;
    }
    _glXWaitForSbcOML = _ptr;
    return _glXWaitForSbcOML(dpy, drawable, target_sbc, ust, msc, sbc);
}

PFN_GLXWAITFORSBCOML _glXWaitForSbcOML = &_get_glXWaitForSbcOML;

static void _fail_glXCushionSGI(Display * dpy, Window window, float cushion) {
    const char *_name = "glXCushionSGI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXCushionSGI(Display * dpy, Window window, float cushion) {
    PFN_GLXCUSHIONSGI _ptr;
    _ptr = (PFN_GLXCUSHIONSGI)_getPrivateProcAddress("glXCushionSGI");
    if (!_ptr) {
        _ptr = &_fail_glXCushionSGI;
    }
    _glXCushionSGI = _ptr;
    _glXCushionSGI(dpy, window, cushion);
}

PFN_GLXCUSHIONSGI _glXCushionSGI = &_get_glXCushionSGI;

static int _fail_glXMakeCurrentReadSGI(Display * dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx) {
    const char *_name = "glXMakeCurrentReadSGI";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXMakeCurrentReadSGI(Display * dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx) {
    PFN_GLXMAKECURRENTREADSGI _ptr;
    _ptr = (PFN_GLXMAKECURRENTREADSGI)_getPrivateProcAddress("glXMakeCurrentReadSGI");
    if (!_ptr) {
        _ptr = &_fail_glXMakeCurrentReadSGI;
    }
    _glXMakeCurrentReadSGI = _ptr;
    return _glXMakeCurrentReadSGI(dpy, draw, read, ctx);
}

PFN_GLXMAKECURRENTREADSGI _glXMakeCurrentReadSGI = &_get_glXMakeCurrentReadSGI;

static GLXDrawable _fail_glXGetCurrentReadDrawableSGI(void) {
    const char *_name = "glXGetCurrentReadDrawableSGI";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXDrawable _get_glXGetCurrentReadDrawableSGI(void) {
    PFN_GLXGETCURRENTREADDRAWABLESGI _ptr;
    _ptr = (PFN_GLXGETCURRENTREADDRAWABLESGI)_getPrivateProcAddress("glXGetCurrentReadDrawableSGI");
    if (!_ptr) {
        _ptr = &_fail_glXGetCurrentReadDrawableSGI;
    }
    _glXGetCurrentReadDrawableSGI = _ptr;
    return _glXGetCurrentReadDrawableSGI();
}

PFN_GLXGETCURRENTREADDRAWABLESGI _glXGetCurrentReadDrawableSGI = &_get_glXGetCurrentReadDrawableSGI;

static int _fail_glXSwapIntervalSGI(int interval) {
    const char *_name = "glXSwapIntervalSGI";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXSwapIntervalSGI(int interval) {
    PFN_GLXSWAPINTERVALSGI _ptr;
    _ptr = (PFN_GLXSWAPINTERVALSGI)_getPrivateProcAddress("glXSwapIntervalSGI");
    if (!_ptr) {
        _ptr = &_fail_glXSwapIntervalSGI;
    }
    _glXSwapIntervalSGI = _ptr;
    return _glXSwapIntervalSGI(interval);
}

PFN_GLXSWAPINTERVALSGI _glXSwapIntervalSGI = &_get_glXSwapIntervalSGI;

static int _fail_glXGetVideoSyncSGI(unsigned int * count) {
    const char *_name = "glXGetVideoSyncSGI";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXGetVideoSyncSGI(unsigned int * count) {
    PFN_GLXGETVIDEOSYNCSGI _ptr;
    _ptr = (PFN_GLXGETVIDEOSYNCSGI)_getPrivateProcAddress("glXGetVideoSyncSGI");
    if (!_ptr) {
        _ptr = &_fail_glXGetVideoSyncSGI;
    }
    _glXGetVideoSyncSGI = _ptr;
    return _glXGetVideoSyncSGI(count);
}

PFN_GLXGETVIDEOSYNCSGI _glXGetVideoSyncSGI = &_get_glXGetVideoSyncSGI;

static int _fail_glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int * count) {
    const char *_name = "glXWaitVideoSyncSGI";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int * count) {
    PFN_GLXWAITVIDEOSYNCSGI _ptr;
    _ptr = (PFN_GLXWAITVIDEOSYNCSGI)_getPrivateProcAddress("glXWaitVideoSyncSGI");
    if (!_ptr) {
        _ptr = &_fail_glXWaitVideoSyncSGI;
    }
    _glXWaitVideoSyncSGI = _ptr;
    return _glXWaitVideoSyncSGI(divisor, remainder, count);
}

PFN_GLXWAITVIDEOSYNCSGI _glXWaitVideoSyncSGI = &_get_glXWaitVideoSyncSGI;

static int _fail_glXGetFBConfigAttribSGIX(Display * dpy, GLXFBConfigSGIX config, int attribute, int * value) {
    const char *_name = "glXGetFBConfigAttribSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXGetFBConfigAttribSGIX(Display * dpy, GLXFBConfigSGIX config, int attribute, int * value) {
    PFN_GLXGETFBCONFIGATTRIBSGIX _ptr;
    _ptr = (PFN_GLXGETFBCONFIGATTRIBSGIX)_getPrivateProcAddress("glXGetFBConfigAttribSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXGetFBConfigAttribSGIX;
    }
    _glXGetFBConfigAttribSGIX = _ptr;
    return _glXGetFBConfigAttribSGIX(dpy, config, attribute, value);
}

PFN_GLXGETFBCONFIGATTRIBSGIX _glXGetFBConfigAttribSGIX = &_get_glXGetFBConfigAttribSGIX;

static GLXFBConfigSGIX * _fail_glXChooseFBConfigSGIX(Display * dpy, int screen, int * attrib_list, int * nelements) {
    const char *_name = "glXChooseFBConfigSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXFBConfigSGIX * _get_glXChooseFBConfigSGIX(Display * dpy, int screen, int * attrib_list, int * nelements) {
    PFN_GLXCHOOSEFBCONFIGSGIX _ptr;
    _ptr = (PFN_GLXCHOOSEFBCONFIGSGIX)_getPrivateProcAddress("glXChooseFBConfigSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXChooseFBConfigSGIX;
    }
    _glXChooseFBConfigSGIX = _ptr;
    return _glXChooseFBConfigSGIX(dpy, screen, attrib_list, nelements);
}

PFN_GLXCHOOSEFBCONFIGSGIX _glXChooseFBConfigSGIX = &_get_glXChooseFBConfigSGIX;

static GLXPixmap _fail_glXCreateGLXPixmapWithConfigSGIX(Display * dpy, GLXFBConfigSGIX config, Pixmap pixmap) {
    const char *_name = "glXCreateGLXPixmapWithConfigSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXPixmap _get_glXCreateGLXPixmapWithConfigSGIX(Display * dpy, GLXFBConfigSGIX config, Pixmap pixmap) {
    PFN_GLXCREATEGLXPIXMAPWITHCONFIGSGIX _ptr;
    _ptr = (PFN_GLXCREATEGLXPIXMAPWITHCONFIGSGIX)_getPrivateProcAddress("glXCreateGLXPixmapWithConfigSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXCreateGLXPixmapWithConfigSGIX;
    }
    _glXCreateGLXPixmapWithConfigSGIX = _ptr;
    return _glXCreateGLXPixmapWithConfigSGIX(dpy, config, pixmap);
}

PFN_GLXCREATEGLXPIXMAPWITHCONFIGSGIX _glXCreateGLXPixmapWithConfigSGIX = &_get_glXCreateGLXPixmapWithConfigSGIX;

static GLXContext _fail_glXCreateContextWithConfigSGIX(Display * dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, int direct) {
    const char *_name = "glXCreateContextWithConfigSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXContext _get_glXCreateContextWithConfigSGIX(Display * dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, int direct) {
    PFN_GLXCREATECONTEXTWITHCONFIGSGIX _ptr;
    _ptr = (PFN_GLXCREATECONTEXTWITHCONFIGSGIX)_getPrivateProcAddress("glXCreateContextWithConfigSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXCreateContextWithConfigSGIX;
    }
    _glXCreateContextWithConfigSGIX = _ptr;
    return _glXCreateContextWithConfigSGIX(dpy, config, render_type, share_list, direct);
}

PFN_GLXCREATECONTEXTWITHCONFIGSGIX _glXCreateContextWithConfigSGIX = &_get_glXCreateContextWithConfigSGIX;

static XVisualInfo * _fail_glXGetVisualFromFBConfigSGIX(Display * dpy, GLXFBConfigSGIX config) {
    const char *_name = "glXGetVisualFromFBConfigSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static XVisualInfo * _get_glXGetVisualFromFBConfigSGIX(Display * dpy, GLXFBConfigSGIX config) {
    PFN_GLXGETVISUALFROMFBCONFIGSGIX _ptr;
    _ptr = (PFN_GLXGETVISUALFROMFBCONFIGSGIX)_getPrivateProcAddress("glXGetVisualFromFBConfigSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXGetVisualFromFBConfigSGIX;
    }
    _glXGetVisualFromFBConfigSGIX = _ptr;
    return _glXGetVisualFromFBConfigSGIX(dpy, config);
}

PFN_GLXGETVISUALFROMFBCONFIGSGIX _glXGetVisualFromFBConfigSGIX = &_get_glXGetVisualFromFBConfigSGIX;

static GLXFBConfigSGIX _fail_glXGetFBConfigFromVisualSGIX(Display * dpy, XVisualInfo * vis) {
    const char *_name = "glXGetFBConfigFromVisualSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXFBConfigSGIX _get_glXGetFBConfigFromVisualSGIX(Display * dpy, XVisualInfo * vis) {
    PFN_GLXGETFBCONFIGFROMVISUALSGIX _ptr;
    _ptr = (PFN_GLXGETFBCONFIGFROMVISUALSGIX)_getPrivateProcAddress("glXGetFBConfigFromVisualSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXGetFBConfigFromVisualSGIX;
    }
    _glXGetFBConfigFromVisualSGIX = _ptr;
    return _glXGetFBConfigFromVisualSGIX(dpy, vis);
}

PFN_GLXGETFBCONFIGFROMVISUALSGIX _glXGetFBConfigFromVisualSGIX = &_get_glXGetFBConfigFromVisualSGIX;

static GLXPbufferSGIX _fail_glXCreateGLXPbufferSGIX(Display * dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int * attrib_list) {
    const char *_name = "glXCreateGLXPbufferSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLXPbufferSGIX _get_glXCreateGLXPbufferSGIX(Display * dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int * attrib_list) {
    PFN_GLXCREATEGLXPBUFFERSGIX _ptr;
    _ptr = (PFN_GLXCREATEGLXPBUFFERSGIX)_getPrivateProcAddress("glXCreateGLXPbufferSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXCreateGLXPbufferSGIX;
    }
    _glXCreateGLXPbufferSGIX = _ptr;
    return _glXCreateGLXPbufferSGIX(dpy, config, width, height, attrib_list);
}

PFN_GLXCREATEGLXPBUFFERSGIX _glXCreateGLXPbufferSGIX = &_get_glXCreateGLXPbufferSGIX;

static void _fail_glXDestroyGLXPbufferSGIX(Display * dpy, GLXPbufferSGIX pbuf) {
    const char *_name = "glXDestroyGLXPbufferSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXDestroyGLXPbufferSGIX(Display * dpy, GLXPbufferSGIX pbuf) {
    PFN_GLXDESTROYGLXPBUFFERSGIX _ptr;
    _ptr = (PFN_GLXDESTROYGLXPBUFFERSGIX)_getPrivateProcAddress("glXDestroyGLXPbufferSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXDestroyGLXPbufferSGIX;
    }
    _glXDestroyGLXPbufferSGIX = _ptr;
    _glXDestroyGLXPbufferSGIX(dpy, pbuf);
}

PFN_GLXDESTROYGLXPBUFFERSGIX _glXDestroyGLXPbufferSGIX = &_get_glXDestroyGLXPbufferSGIX;

static int _fail_glXQueryGLXPbufferSGIX(Display * dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int * value) {
    const char *_name = "glXQueryGLXPbufferSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXQueryGLXPbufferSGIX(Display * dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int * value) {
    PFN_GLXQUERYGLXPBUFFERSGIX _ptr;
    _ptr = (PFN_GLXQUERYGLXPBUFFERSGIX)_getPrivateProcAddress("glXQueryGLXPbufferSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXQueryGLXPbufferSGIX;
    }
    _glXQueryGLXPbufferSGIX = _ptr;
    return _glXQueryGLXPbufferSGIX(dpy, pbuf, attribute, value);
}

PFN_GLXQUERYGLXPBUFFERSGIX _glXQueryGLXPbufferSGIX = &_get_glXQueryGLXPbufferSGIX;

static void _fail_glXSelectEventSGIX(Display * dpy, GLXDrawable drawable, unsigned long mask) {
    const char *_name = "glXSelectEventSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXSelectEventSGIX(Display * dpy, GLXDrawable drawable, unsigned long mask) {
    PFN_GLXSELECTEVENTSGIX _ptr;
    _ptr = (PFN_GLXSELECTEVENTSGIX)_getPrivateProcAddress("glXSelectEventSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXSelectEventSGIX;
    }
    _glXSelectEventSGIX = _ptr;
    _glXSelectEventSGIX(dpy, drawable, mask);
}

PFN_GLXSELECTEVENTSGIX _glXSelectEventSGIX = &_get_glXSelectEventSGIX;

static void _fail_glXGetSelectedEventSGIX(Display * dpy, GLXDrawable drawable, unsigned long * mask) {
    const char *_name = "glXGetSelectedEventSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXGetSelectedEventSGIX(Display * dpy, GLXDrawable drawable, unsigned long * mask) {
    PFN_GLXGETSELECTEDEVENTSGIX _ptr;
    _ptr = (PFN_GLXGETSELECTEDEVENTSGIX)_getPrivateProcAddress("glXGetSelectedEventSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXGetSelectedEventSGIX;
    }
    _glXGetSelectedEventSGIX = _ptr;
    _glXGetSelectedEventSGIX(dpy, drawable, mask);
}

PFN_GLXGETSELECTEDEVENTSGIX _glXGetSelectedEventSGIX = &_get_glXGetSelectedEventSGIX;

static void _fail_glXBindSwapBarrierSGIX(Display * dpy, GLXDrawable drawable, int barrier) {
    const char *_name = "glXBindSwapBarrierSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXBindSwapBarrierSGIX(Display * dpy, GLXDrawable drawable, int barrier) {
    PFN_GLXBINDSWAPBARRIERSGIX _ptr;
    _ptr = (PFN_GLXBINDSWAPBARRIERSGIX)_getPrivateProcAddress("glXBindSwapBarrierSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXBindSwapBarrierSGIX;
    }
    _glXBindSwapBarrierSGIX = _ptr;
    _glXBindSwapBarrierSGIX(dpy, drawable, barrier);
}

PFN_GLXBINDSWAPBARRIERSGIX _glXBindSwapBarrierSGIX = &_get_glXBindSwapBarrierSGIX;

static int _fail_glXQueryMaxSwapBarriersSGIX(Display * dpy, int screen, int * max) {
    const char *_name = "glXQueryMaxSwapBarriersSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXQueryMaxSwapBarriersSGIX(Display * dpy, int screen, int * max) {
    PFN_GLXQUERYMAXSWAPBARRIERSSGIX _ptr;
    _ptr = (PFN_GLXQUERYMAXSWAPBARRIERSSGIX)_getPrivateProcAddress("glXQueryMaxSwapBarriersSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXQueryMaxSwapBarriersSGIX;
    }
    _glXQueryMaxSwapBarriersSGIX = _ptr;
    return _glXQueryMaxSwapBarriersSGIX(dpy, screen, max);
}

PFN_GLXQUERYMAXSWAPBARRIERSSGIX _glXQueryMaxSwapBarriersSGIX = &_get_glXQueryMaxSwapBarriersSGIX;

static void _fail_glXJoinSwapGroupSGIX(Display * dpy, GLXDrawable drawable, GLXDrawable member) {
    const char *_name = "glXJoinSwapGroupSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void _get_glXJoinSwapGroupSGIX(Display * dpy, GLXDrawable drawable, GLXDrawable member) {
    PFN_GLXJOINSWAPGROUPSGIX _ptr;
    _ptr = (PFN_GLXJOINSWAPGROUPSGIX)_getPrivateProcAddress("glXJoinSwapGroupSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXJoinSwapGroupSGIX;
    }
    _glXJoinSwapGroupSGIX = _ptr;
    _glXJoinSwapGroupSGIX(dpy, drawable, member);
}

PFN_GLXJOINSWAPGROUPSGIX _glXJoinSwapGroupSGIX = &_get_glXJoinSwapGroupSGIX;

static int _fail_glXBindChannelToWindowSGIX(Display * display, int screen, int channel, Window window) {
    const char *_name = "glXBindChannelToWindowSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXBindChannelToWindowSGIX(Display * display, int screen, int channel, Window window) {
    PFN_GLXBINDCHANNELTOWINDOWSGIX _ptr;
    _ptr = (PFN_GLXBINDCHANNELTOWINDOWSGIX)_getPrivateProcAddress("glXBindChannelToWindowSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXBindChannelToWindowSGIX;
    }
    _glXBindChannelToWindowSGIX = _ptr;
    return _glXBindChannelToWindowSGIX(display, screen, channel, window);
}

PFN_GLXBINDCHANNELTOWINDOWSGIX _glXBindChannelToWindowSGIX = &_get_glXBindChannelToWindowSGIX;

static int _fail_glXChannelRectSGIX(Display * display, int screen, int channel, int x, int y, int w, int h) {
    const char *_name = "glXChannelRectSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXChannelRectSGIX(Display * display, int screen, int channel, int x, int y, int w, int h) {
    PFN_GLXCHANNELRECTSGIX _ptr;
    _ptr = (PFN_GLXCHANNELRECTSGIX)_getPrivateProcAddress("glXChannelRectSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXChannelRectSGIX;
    }
    _glXChannelRectSGIX = _ptr;
    return _glXChannelRectSGIX(display, screen, channel, x, y, w, h);
}

PFN_GLXCHANNELRECTSGIX _glXChannelRectSGIX = &_get_glXChannelRectSGIX;

static int _fail_glXQueryChannelRectSGIX(Display * display, int screen, int channel, int * dx, int * dy, int * dw, int * dh) {
    const char *_name = "glXQueryChannelRectSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXQueryChannelRectSGIX(Display * display, int screen, int channel, int * dx, int * dy, int * dw, int * dh) {
    PFN_GLXQUERYCHANNELRECTSGIX _ptr;
    _ptr = (PFN_GLXQUERYCHANNELRECTSGIX)_getPrivateProcAddress("glXQueryChannelRectSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXQueryChannelRectSGIX;
    }
    _glXQueryChannelRectSGIX = _ptr;
    return _glXQueryChannelRectSGIX(display, screen, channel, dx, dy, dw, dh);
}

PFN_GLXQUERYCHANNELRECTSGIX _glXQueryChannelRectSGIX = &_get_glXQueryChannelRectSGIX;

static int _fail_glXQueryChannelDeltasSGIX(Display * display, int screen, int channel, int * x, int * y, int * w, int * h) {
    const char *_name = "glXQueryChannelDeltasSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXQueryChannelDeltasSGIX(Display * display, int screen, int channel, int * x, int * y, int * w, int * h) {
    PFN_GLXQUERYCHANNELDELTASSGIX _ptr;
    _ptr = (PFN_GLXQUERYCHANNELDELTASSGIX)_getPrivateProcAddress("glXQueryChannelDeltasSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXQueryChannelDeltasSGIX;
    }
    _glXQueryChannelDeltasSGIX = _ptr;
    return _glXQueryChannelDeltasSGIX(display, screen, channel, x, y, w, h);
}

PFN_GLXQUERYCHANNELDELTASSGIX _glXQueryChannelDeltasSGIX = &_get_glXQueryChannelDeltasSGIX;

static int _fail_glXChannelRectSyncSGIX(Display * display, int screen, int channel, GLenum synctype) {
    const char *_name = "glXChannelRectSyncSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static int _get_glXChannelRectSyncSGIX(Display * display, int screen, int channel, GLenum synctype) {
    PFN_GLXCHANNELRECTSYNCSGIX _ptr;
    _ptr = (PFN_GLXCHANNELRECTSYNCSGIX)_getPrivateProcAddress("glXChannelRectSyncSGIX");
    if (!_ptr) {
        _ptr = &_fail_glXChannelRectSyncSGIX;
    }
    _glXChannelRectSyncSGIX = _ptr;
    return _glXChannelRectSyncSGIX(display, screen, channel, synctype);
}

PFN_GLXCHANNELRECTSYNCSGIX _glXChannelRectSyncSGIX = &_get_glXChannelRectSyncSGIX;

static __GLXextFuncPtr _fail_glXGetProcAddressARB(const GLubyte * procName) {
    const char *_name = "glXGetProcAddressARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static __GLXextFuncPtr _get_glXGetProcAddressARB(const GLubyte * procName) {
    PFN_GLXGETPROCADDRESSARB _ptr;
    _ptr = (PFN_GLXGETPROCADDRESSARB)_getPublicProcAddress("glXGetProcAddressARB");
    if (!_ptr) {
        _ptr = &_fail_glXGetProcAddressARB;
    }
    _glXGetProcAddressARB = _ptr;
    return _glXGetProcAddressARB(procName);
}

PFN_GLXGETPROCADDRESSARB _glXGetProcAddressARB = &_get_glXGetProcAddressARB;

static __GLXextFuncPtr _fail_glXGetProcAddress(const GLubyte * procName) {
    const char *_name = "glXGetProcAddress";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static __GLXextFuncPtr _get_glXGetProcAddress(const GLubyte * procName) {
    PFN_GLXGETPROCADDRESS _ptr;
    _ptr = (PFN_GLXGETPROCADDRESS)_getPublicProcAddress("glXGetProcAddress");
    if (!_ptr) {
        _ptr = &_fail_glXGetProcAddress;
    }
    _glXGetProcAddress = _ptr;
    return _glXGetProcAddress(procName);
}

PFN_GLXGETPROCADDRESS _glXGetProcAddress = &_get_glXGetProcAddress;


#endif

static void APIENTRY _fail_glCullFace(GLenum mode) {
    const char *_name = "glCullFace";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCullFace(GLenum mode) {
    PFN_GLCULLFACE _ptr;
    _ptr = (PFN_GLCULLFACE)_getPublicProcAddress("glCullFace");
    if (!_ptr) {
        _ptr = &_fail_glCullFace;
    }
    _glCullFace = _ptr;
    _glCullFace(mode);
}

PFN_GLCULLFACE _glCullFace = &_get_glCullFace;

static void APIENTRY _fail_glFrontFace(GLenum mode) {
    const char *_name = "glFrontFace";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFrontFace(GLenum mode) {
    PFN_GLFRONTFACE _ptr;
    _ptr = (PFN_GLFRONTFACE)_getPublicProcAddress("glFrontFace");
    if (!_ptr) {
        _ptr = &_fail_glFrontFace;
    }
    _glFrontFace = _ptr;
    _glFrontFace(mode);
}

PFN_GLFRONTFACE _glFrontFace = &_get_glFrontFace;

static void APIENTRY _fail_glHint(GLenum target, GLenum mode) {
    const char *_name = "glHint";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glHint(GLenum target, GLenum mode) {
    PFN_GLHINT _ptr;
    _ptr = (PFN_GLHINT)_getPublicProcAddress("glHint");
    if (!_ptr) {
        _ptr = &_fail_glHint;
    }
    _glHint = _ptr;
    _glHint(target, mode);
}

PFN_GLHINT _glHint = &_get_glHint;

static void APIENTRY _fail_glLineWidth(GLfloat width) {
    const char *_name = "glLineWidth";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLineWidth(GLfloat width) {
    PFN_GLLINEWIDTH _ptr;
    _ptr = (PFN_GLLINEWIDTH)_getPublicProcAddress("glLineWidth");
    if (!_ptr) {
        _ptr = &_fail_glLineWidth;
    }
    _glLineWidth = _ptr;
    _glLineWidth(width);
}

PFN_GLLINEWIDTH _glLineWidth = &_get_glLineWidth;

static void APIENTRY _fail_glPointSize(GLfloat size) {
    const char *_name = "glPointSize";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPointSize(GLfloat size) {
    PFN_GLPOINTSIZE _ptr;
    _ptr = (PFN_GLPOINTSIZE)_getPublicProcAddress("glPointSize");
    if (!_ptr) {
        _ptr = &_fail_glPointSize;
    }
    _glPointSize = _ptr;
    _glPointSize(size);
}

PFN_GLPOINTSIZE _glPointSize = &_get_glPointSize;

static void APIENTRY _fail_glPolygonMode(GLenum face, GLenum mode) {
    const char *_name = "glPolygonMode";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPolygonMode(GLenum face, GLenum mode) {
    PFN_GLPOLYGONMODE _ptr;
    _ptr = (PFN_GLPOLYGONMODE)_getPublicProcAddress("glPolygonMode");
    if (!_ptr) {
        _ptr = &_fail_glPolygonMode;
    }
    _glPolygonMode = _ptr;
    _glPolygonMode(face, mode);
}

PFN_GLPOLYGONMODE _glPolygonMode = &_get_glPolygonMode;

static void APIENTRY _fail_glScissor(GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glScissor";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glScissor(GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLSCISSOR _ptr;
    _ptr = (PFN_GLSCISSOR)_getPublicProcAddress("glScissor");
    if (!_ptr) {
        _ptr = &_fail_glScissor;
    }
    _glScissor = _ptr;
    _glScissor(x, y, width, height);
}

PFN_GLSCISSOR _glScissor = &_get_glScissor;

static void APIENTRY _fail_glTexParameterf(GLenum target, GLenum pname, GLfloat param) {
    const char *_name = "glTexParameterf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexParameterf(GLenum target, GLenum pname, GLfloat param) {
    PFN_GLTEXPARAMETERF _ptr;
    _ptr = (PFN_GLTEXPARAMETERF)_getPublicProcAddress("glTexParameterf");
    if (!_ptr) {
        _ptr = &_fail_glTexParameterf;
    }
    _glTexParameterf = _ptr;
    _glTexParameterf(target, pname, param);
}

PFN_GLTEXPARAMETERF _glTexParameterf = &_get_glTexParameterf;

static void APIENTRY _fail_glTexParameterfv(GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glTexParameterfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexParameterfv(GLenum target, GLenum pname, const GLfloat * params) {
    PFN_GLTEXPARAMETERFV _ptr;
    _ptr = (PFN_GLTEXPARAMETERFV)_getPublicProcAddress("glTexParameterfv");
    if (!_ptr) {
        _ptr = &_fail_glTexParameterfv;
    }
    _glTexParameterfv = _ptr;
    _glTexParameterfv(target, pname, params);
}

PFN_GLTEXPARAMETERFV _glTexParameterfv = &_get_glTexParameterfv;

static void APIENTRY _fail_glTexParameteri(GLenum target, GLenum pname, GLint param) {
    const char *_name = "glTexParameteri";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexParameteri(GLenum target, GLenum pname, GLint param) {
    PFN_GLTEXPARAMETERI _ptr;
    _ptr = (PFN_GLTEXPARAMETERI)_getPublicProcAddress("glTexParameteri");
    if (!_ptr) {
        _ptr = &_fail_glTexParameteri;
    }
    _glTexParameteri = _ptr;
    _glTexParameteri(target, pname, param);
}

PFN_GLTEXPARAMETERI _glTexParameteri = &_get_glTexParameteri;

static void APIENTRY _fail_glTexParameteriv(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glTexParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexParameteriv(GLenum target, GLenum pname, const GLint * params) {
    PFN_GLTEXPARAMETERIV _ptr;
    _ptr = (PFN_GLTEXPARAMETERIV)_getPublicProcAddress("glTexParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glTexParameteriv;
    }
    _glTexParameteriv = _ptr;
    _glTexParameteriv(target, pname, params);
}

PFN_GLTEXPARAMETERIV _glTexParameteriv = &_get_glTexParameteriv;

static void APIENTRY _fail_glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexImage1D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXIMAGE1D _ptr;
    _ptr = (PFN_GLTEXIMAGE1D)_getPublicProcAddress("glTexImage1D");
    if (!_ptr) {
        _ptr = &_fail_glTexImage1D;
    }
    _glTexImage1D = _ptr;
    _glTexImage1D(target, level, internalformat, width, border, format, type, pixels);
}

PFN_GLTEXIMAGE1D _glTexImage1D = &_get_glTexImage1D;

static void APIENTRY _fail_glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexImage2D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXIMAGE2D _ptr;
    _ptr = (PFN_GLTEXIMAGE2D)_getPublicProcAddress("glTexImage2D");
    if (!_ptr) {
        _ptr = &_fail_glTexImage2D;
    }
    _glTexImage2D = _ptr;
    _glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
}

PFN_GLTEXIMAGE2D _glTexImage2D = &_get_glTexImage2D;

static void APIENTRY _fail_glDrawBuffer(GLenum mode) {
    const char *_name = "glDrawBuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawBuffer(GLenum mode) {
    PFN_GLDRAWBUFFER _ptr;
    _ptr = (PFN_GLDRAWBUFFER)_getPublicProcAddress("glDrawBuffer");
    if (!_ptr) {
        _ptr = &_fail_glDrawBuffer;
    }
    _glDrawBuffer = _ptr;
    _glDrawBuffer(mode);
}

PFN_GLDRAWBUFFER _glDrawBuffer = &_get_glDrawBuffer;

static void APIENTRY _fail_glClear(GLbitfield mask) {
    const char *_name = "glClear";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClear(GLbitfield mask) {
    PFN_GLCLEAR _ptr;
    _ptr = (PFN_GLCLEAR)_getPublicProcAddress("glClear");
    if (!_ptr) {
        _ptr = &_fail_glClear;
    }
    _glClear = _ptr;
    _glClear(mask);
}

PFN_GLCLEAR _glClear = &_get_glClear;

static void APIENTRY _fail_glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    const char *_name = "glClearColor";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    PFN_GLCLEARCOLOR _ptr;
    _ptr = (PFN_GLCLEARCOLOR)_getPublicProcAddress("glClearColor");
    if (!_ptr) {
        _ptr = &_fail_glClearColor;
    }
    _glClearColor = _ptr;
    _glClearColor(red, green, blue, alpha);
}

PFN_GLCLEARCOLOR _glClearColor = &_get_glClearColor;

static void APIENTRY _fail_glClearStencil(GLint s) {
    const char *_name = "glClearStencil";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearStencil(GLint s) {
    PFN_GLCLEARSTENCIL _ptr;
    _ptr = (PFN_GLCLEARSTENCIL)_getPublicProcAddress("glClearStencil");
    if (!_ptr) {
        _ptr = &_fail_glClearStencil;
    }
    _glClearStencil = _ptr;
    _glClearStencil(s);
}

PFN_GLCLEARSTENCIL _glClearStencil = &_get_glClearStencil;

static void APIENTRY _fail_glClearDepth(GLdouble depth) {
    const char *_name = "glClearDepth";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearDepth(GLdouble depth) {
    PFN_GLCLEARDEPTH _ptr;
    _ptr = (PFN_GLCLEARDEPTH)_getPublicProcAddress("glClearDepth");
    if (!_ptr) {
        _ptr = &_fail_glClearDepth;
    }
    _glClearDepth = _ptr;
    _glClearDepth(depth);
}

PFN_GLCLEARDEPTH _glClearDepth = &_get_glClearDepth;

static void APIENTRY _fail_glStencilMask(GLuint mask) {
    const char *_name = "glStencilMask";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStencilMask(GLuint mask) {
    PFN_GLSTENCILMASK _ptr;
    _ptr = (PFN_GLSTENCILMASK)_getPublicProcAddress("glStencilMask");
    if (!_ptr) {
        _ptr = &_fail_glStencilMask;
    }
    _glStencilMask = _ptr;
    _glStencilMask(mask);
}

PFN_GLSTENCILMASK _glStencilMask = &_get_glStencilMask;

static void APIENTRY _fail_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {
    const char *_name = "glColorMask";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {
    PFN_GLCOLORMASK _ptr;
    _ptr = (PFN_GLCOLORMASK)_getPublicProcAddress("glColorMask");
    if (!_ptr) {
        _ptr = &_fail_glColorMask;
    }
    _glColorMask = _ptr;
    _glColorMask(red, green, blue, alpha);
}

PFN_GLCOLORMASK _glColorMask = &_get_glColorMask;

static void APIENTRY _fail_glDepthMask(GLboolean flag) {
    const char *_name = "glDepthMask";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDepthMask(GLboolean flag) {
    PFN_GLDEPTHMASK _ptr;
    _ptr = (PFN_GLDEPTHMASK)_getPublicProcAddress("glDepthMask");
    if (!_ptr) {
        _ptr = &_fail_glDepthMask;
    }
    _glDepthMask = _ptr;
    _glDepthMask(flag);
}

PFN_GLDEPTHMASK _glDepthMask = &_get_glDepthMask;

static void APIENTRY _fail_glDisable(GLenum cap) {
    const char *_name = "glDisable";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDisable(GLenum cap) {
    PFN_GLDISABLE _ptr;
    _ptr = (PFN_GLDISABLE)_getPublicProcAddress("glDisable");
    if (!_ptr) {
        _ptr = &_fail_glDisable;
    }
    _glDisable = _ptr;
    _glDisable(cap);
}

PFN_GLDISABLE _glDisable = &_get_glDisable;

static void APIENTRY _fail_glEnable(GLenum cap) {
    const char *_name = "glEnable";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEnable(GLenum cap) {
    PFN_GLENABLE _ptr;
    _ptr = (PFN_GLENABLE)_getPublicProcAddress("glEnable");
    if (!_ptr) {
        _ptr = &_fail_glEnable;
    }
    _glEnable = _ptr;
    _glEnable(cap);
}

PFN_GLENABLE _glEnable = &_get_glEnable;

static void APIENTRY _fail_glFinish(void) {
    const char *_name = "glFinish";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFinish(void) {
    PFN_GLFINISH _ptr;
    _ptr = (PFN_GLFINISH)_getPublicProcAddress("glFinish");
    if (!_ptr) {
        _ptr = &_fail_glFinish;
    }
    _glFinish = _ptr;
    _glFinish();
}

PFN_GLFINISH _glFinish = &_get_glFinish;

static void APIENTRY _fail_glFlush(void) {
    const char *_name = "glFlush";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFlush(void) {
    PFN_GLFLUSH _ptr;
    _ptr = (PFN_GLFLUSH)_getPublicProcAddress("glFlush");
    if (!_ptr) {
        _ptr = &_fail_glFlush;
    }
    _glFlush = _ptr;
    _glFlush();
}

PFN_GLFLUSH _glFlush = &_get_glFlush;

static void APIENTRY _fail_glBlendFunc(GLenum sfactor, GLenum dfactor) {
    const char *_name = "glBlendFunc";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendFunc(GLenum sfactor, GLenum dfactor) {
    PFN_GLBLENDFUNC _ptr;
    _ptr = (PFN_GLBLENDFUNC)_getPublicProcAddress("glBlendFunc");
    if (!_ptr) {
        _ptr = &_fail_glBlendFunc;
    }
    _glBlendFunc = _ptr;
    _glBlendFunc(sfactor, dfactor);
}

PFN_GLBLENDFUNC _glBlendFunc = &_get_glBlendFunc;

static void APIENTRY _fail_glLogicOp(GLenum opcode) {
    const char *_name = "glLogicOp";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLogicOp(GLenum opcode) {
    PFN_GLLOGICOP _ptr;
    _ptr = (PFN_GLLOGICOP)_getPublicProcAddress("glLogicOp");
    if (!_ptr) {
        _ptr = &_fail_glLogicOp;
    }
    _glLogicOp = _ptr;
    _glLogicOp(opcode);
}

PFN_GLLOGICOP _glLogicOp = &_get_glLogicOp;

static void APIENTRY _fail_glStencilFunc(GLenum func, GLint ref, GLuint mask) {
    const char *_name = "glStencilFunc";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStencilFunc(GLenum func, GLint ref, GLuint mask) {
    PFN_GLSTENCILFUNC _ptr;
    _ptr = (PFN_GLSTENCILFUNC)_getPublicProcAddress("glStencilFunc");
    if (!_ptr) {
        _ptr = &_fail_glStencilFunc;
    }
    _glStencilFunc = _ptr;
    _glStencilFunc(func, ref, mask);
}

PFN_GLSTENCILFUNC _glStencilFunc = &_get_glStencilFunc;

static void APIENTRY _fail_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass) {
    const char *_name = "glStencilOp";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass) {
    PFN_GLSTENCILOP _ptr;
    _ptr = (PFN_GLSTENCILOP)_getPublicProcAddress("glStencilOp");
    if (!_ptr) {
        _ptr = &_fail_glStencilOp;
    }
    _glStencilOp = _ptr;
    _glStencilOp(fail, zfail, zpass);
}

PFN_GLSTENCILOP _glStencilOp = &_get_glStencilOp;

static void APIENTRY _fail_glDepthFunc(GLenum func) {
    const char *_name = "glDepthFunc";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDepthFunc(GLenum func) {
    PFN_GLDEPTHFUNC _ptr;
    _ptr = (PFN_GLDEPTHFUNC)_getPublicProcAddress("glDepthFunc");
    if (!_ptr) {
        _ptr = &_fail_glDepthFunc;
    }
    _glDepthFunc = _ptr;
    _glDepthFunc(func);
}

PFN_GLDEPTHFUNC _glDepthFunc = &_get_glDepthFunc;

static void APIENTRY _fail_glPixelStoref(GLenum pname, GLfloat param) {
    const char *_name = "glPixelStoref";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPixelStoref(GLenum pname, GLfloat param) {
    PFN_GLPIXELSTOREF _ptr;
    _ptr = (PFN_GLPIXELSTOREF)_getPublicProcAddress("glPixelStoref");
    if (!_ptr) {
        _ptr = &_fail_glPixelStoref;
    }
    _glPixelStoref = _ptr;
    _glPixelStoref(pname, param);
}

PFN_GLPIXELSTOREF _glPixelStoref = &_get_glPixelStoref;

static void APIENTRY _fail_glPixelStorei(GLenum pname, GLint param) {
    const char *_name = "glPixelStorei";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPixelStorei(GLenum pname, GLint param) {
    PFN_GLPIXELSTOREI _ptr;
    _ptr = (PFN_GLPIXELSTOREI)_getPublicProcAddress("glPixelStorei");
    if (!_ptr) {
        _ptr = &_fail_glPixelStorei;
    }
    _glPixelStorei = _ptr;
    _glPixelStorei(pname, param);
}

PFN_GLPIXELSTOREI _glPixelStorei = &_get_glPixelStorei;

static void APIENTRY _fail_glReadBuffer(GLenum mode) {
    const char *_name = "glReadBuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReadBuffer(GLenum mode) {
    PFN_GLREADBUFFER _ptr;
    _ptr = (PFN_GLREADBUFFER)_getPublicProcAddress("glReadBuffer");
    if (!_ptr) {
        _ptr = &_fail_glReadBuffer;
    }
    _glReadBuffer = _ptr;
    _glReadBuffer(mode);
}

PFN_GLREADBUFFER _glReadBuffer = &_get_glReadBuffer;

static void APIENTRY _fail_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid * pixels) {
    const char *_name = "glReadPixels";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid * pixels) {
    PFN_GLREADPIXELS _ptr;
    _ptr = (PFN_GLREADPIXELS)_getPublicProcAddress("glReadPixels");
    if (!_ptr) {
        _ptr = &_fail_glReadPixels;
    }
    _glReadPixels = _ptr;
    _glReadPixels(x, y, width, height, format, type, pixels);
}

PFN_GLREADPIXELS _glReadPixels = &_get_glReadPixels;

static void APIENTRY _fail_glGetBooleanv(GLenum pname, GLboolean * params) {
    const char *_name = "glGetBooleanv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetBooleanv(GLenum pname, GLboolean * params) {
    PFN_GLGETBOOLEANV _ptr;
    _ptr = (PFN_GLGETBOOLEANV)_getPublicProcAddress("glGetBooleanv");
    if (!_ptr) {
        _ptr = &_fail_glGetBooleanv;
    }
    _glGetBooleanv = _ptr;
    _glGetBooleanv(pname, params);
}

PFN_GLGETBOOLEANV _glGetBooleanv = &_get_glGetBooleanv;

static void APIENTRY _fail_glGetDoublev(GLenum pname, GLdouble * params) {
    const char *_name = "glGetDoublev";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetDoublev(GLenum pname, GLdouble * params) {
    PFN_GLGETDOUBLEV _ptr;
    _ptr = (PFN_GLGETDOUBLEV)_getPublicProcAddress("glGetDoublev");
    if (!_ptr) {
        _ptr = &_fail_glGetDoublev;
    }
    _glGetDoublev = _ptr;
    _glGetDoublev(pname, params);
}

PFN_GLGETDOUBLEV _glGetDoublev = &_get_glGetDoublev;

static GLenum APIENTRY _fail_glGetError(void) {
    const char *_name = "glGetError";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLenum APIENTRY _get_glGetError(void) {
    PFN_GLGETERROR _ptr;
    _ptr = (PFN_GLGETERROR)_getPublicProcAddress("glGetError");
    if (!_ptr) {
        _ptr = &_fail_glGetError;
    }
    _glGetError = _ptr;
    return _glGetError();
}

PFN_GLGETERROR _glGetError = &_get_glGetError;

static void APIENTRY _fail_glGetFloatv(GLenum pname, GLfloat * params) {
    const char *_name = "glGetFloatv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFloatv(GLenum pname, GLfloat * params) {
    PFN_GLGETFLOATV _ptr;
    _ptr = (PFN_GLGETFLOATV)_getPublicProcAddress("glGetFloatv");
    if (!_ptr) {
        _ptr = &_fail_glGetFloatv;
    }
    _glGetFloatv = _ptr;
    _glGetFloatv(pname, params);
}

PFN_GLGETFLOATV _glGetFloatv = &_get_glGetFloatv;

static void APIENTRY _fail_glGetIntegerv(GLenum pname, GLint * params) {
    const char *_name = "glGetIntegerv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetIntegerv(GLenum pname, GLint * params) {
    PFN_GLGETINTEGERV _ptr;
    _ptr = (PFN_GLGETINTEGERV)_getPublicProcAddress("glGetIntegerv");
    if (!_ptr) {
        _ptr = &_fail_glGetIntegerv;
    }
    _glGetIntegerv = _ptr;
    _glGetIntegerv(pname, params);
}

PFN_GLGETINTEGERV _glGetIntegerv = &_get_glGetIntegerv;

static const GLubyte * APIENTRY _fail_glGetString(GLenum name) {
    const char *_name = "glGetString";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static const GLubyte * APIENTRY _get_glGetString(GLenum name) {
    PFN_GLGETSTRING _ptr;
    _ptr = (PFN_GLGETSTRING)_getPublicProcAddress("glGetString");
    if (!_ptr) {
        _ptr = &_fail_glGetString;
    }
    _glGetString = _ptr;
    return _glGetString(name);
}

PFN_GLGETSTRING _glGetString = &_get_glGetString;

static void APIENTRY _fail_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels) {
    const char *_name = "glGetTexImage";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels) {
    PFN_GLGETTEXIMAGE _ptr;
    _ptr = (PFN_GLGETTEXIMAGE)_getPublicProcAddress("glGetTexImage");
    if (!_ptr) {
        _ptr = &_fail_glGetTexImage;
    }
    _glGetTexImage = _ptr;
    _glGetTexImage(target, level, format, type, pixels);
}

PFN_GLGETTEXIMAGE _glGetTexImage = &_get_glGetTexImage;

static void APIENTRY _fail_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetTexParameterfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params) {
    PFN_GLGETTEXPARAMETERFV _ptr;
    _ptr = (PFN_GLGETTEXPARAMETERFV)_getPublicProcAddress("glGetTexParameterfv");
    if (!_ptr) {
        _ptr = &_fail_glGetTexParameterfv;
    }
    _glGetTexParameterfv = _ptr;
    _glGetTexParameterfv(target, pname, params);
}

PFN_GLGETTEXPARAMETERFV _glGetTexParameterfv = &_get_glGetTexParameterfv;

static void APIENTRY _fail_glGetTexParameteriv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetTexParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexParameteriv(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETTEXPARAMETERIV _ptr;
    _ptr = (PFN_GLGETTEXPARAMETERIV)_getPublicProcAddress("glGetTexParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glGetTexParameteriv;
    }
    _glGetTexParameteriv = _ptr;
    _glGetTexParameteriv(target, pname, params);
}

PFN_GLGETTEXPARAMETERIV _glGetTexParameteriv = &_get_glGetTexParameteriv;

static void APIENTRY _fail_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat * params) {
    const char *_name = "glGetTexLevelParameterfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat * params) {
    PFN_GLGETTEXLEVELPARAMETERFV _ptr;
    _ptr = (PFN_GLGETTEXLEVELPARAMETERFV)_getPublicProcAddress("glGetTexLevelParameterfv");
    if (!_ptr) {
        _ptr = &_fail_glGetTexLevelParameterfv;
    }
    _glGetTexLevelParameterfv = _ptr;
    _glGetTexLevelParameterfv(target, level, pname, params);
}

PFN_GLGETTEXLEVELPARAMETERFV _glGetTexLevelParameterfv = &_get_glGetTexLevelParameterfv;

static void APIENTRY _fail_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint * params) {
    const char *_name = "glGetTexLevelParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint * params) {
    PFN_GLGETTEXLEVELPARAMETERIV _ptr;
    _ptr = (PFN_GLGETTEXLEVELPARAMETERIV)_getPublicProcAddress("glGetTexLevelParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glGetTexLevelParameteriv;
    }
    _glGetTexLevelParameteriv = _ptr;
    _glGetTexLevelParameteriv(target, level, pname, params);
}

PFN_GLGETTEXLEVELPARAMETERIV _glGetTexLevelParameteriv = &_get_glGetTexLevelParameteriv;

static GLboolean APIENTRY _fail_glIsEnabled(GLenum cap) {
    const char *_name = "glIsEnabled";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsEnabled(GLenum cap) {
    PFN_GLISENABLED _ptr;
    _ptr = (PFN_GLISENABLED)_getPublicProcAddress("glIsEnabled");
    if (!_ptr) {
        _ptr = &_fail_glIsEnabled;
    }
    _glIsEnabled = _ptr;
    return _glIsEnabled(cap);
}

PFN_GLISENABLED _glIsEnabled = &_get_glIsEnabled;

static void APIENTRY _fail_glDepthRange(GLdouble zNear, GLdouble zFar) {
    const char *_name = "glDepthRange";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDepthRange(GLdouble zNear, GLdouble zFar) {
    PFN_GLDEPTHRANGE _ptr;
    _ptr = (PFN_GLDEPTHRANGE)_getPublicProcAddress("glDepthRange");
    if (!_ptr) {
        _ptr = &_fail_glDepthRange;
    }
    _glDepthRange = _ptr;
    _glDepthRange(zNear, zFar);
}

PFN_GLDEPTHRANGE _glDepthRange = &_get_glDepthRange;

static void APIENTRY _fail_glViewport(GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glViewport";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glViewport(GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLVIEWPORT _ptr;
    _ptr = (PFN_GLVIEWPORT)_getPublicProcAddress("glViewport");
    if (!_ptr) {
        _ptr = &_fail_glViewport;
    }
    _glViewport = _ptr;
    _glViewport(x, y, width, height);
}

PFN_GLVIEWPORT _glViewport = &_get_glViewport;

static void APIENTRY _fail_glNewList(GLuint list, GLenum mode) {
    const char *_name = "glNewList";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNewList(GLuint list, GLenum mode) {
    PFN_GLNEWLIST _ptr;
    _ptr = (PFN_GLNEWLIST)_getPublicProcAddress("glNewList");
    if (!_ptr) {
        _ptr = &_fail_glNewList;
    }
    _glNewList = _ptr;
    _glNewList(list, mode);
}

PFN_GLNEWLIST _glNewList = &_get_glNewList;

static void APIENTRY _fail_glEndList(void) {
    const char *_name = "glEndList";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEndList(void) {
    PFN_GLENDLIST _ptr;
    _ptr = (PFN_GLENDLIST)_getPublicProcAddress("glEndList");
    if (!_ptr) {
        _ptr = &_fail_glEndList;
    }
    _glEndList = _ptr;
    _glEndList();
}

PFN_GLENDLIST _glEndList = &_get_glEndList;

static void APIENTRY _fail_glCallList(GLuint list) {
    const char *_name = "glCallList";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCallList(GLuint list) {
    PFN_GLCALLLIST _ptr;
    _ptr = (PFN_GLCALLLIST)_getPublicProcAddress("glCallList");
    if (!_ptr) {
        _ptr = &_fail_glCallList;
    }
    _glCallList = _ptr;
    _glCallList(list);
}

PFN_GLCALLLIST _glCallList = &_get_glCallList;

static void APIENTRY _fail_glCallLists(GLsizei n, GLenum type, const GLvoid * lists) {
    const char *_name = "glCallLists";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCallLists(GLsizei n, GLenum type, const GLvoid * lists) {
    PFN_GLCALLLISTS _ptr;
    _ptr = (PFN_GLCALLLISTS)_getPublicProcAddress("glCallLists");
    if (!_ptr) {
        _ptr = &_fail_glCallLists;
    }
    _glCallLists = _ptr;
    _glCallLists(n, type, lists);
}

PFN_GLCALLLISTS _glCallLists = &_get_glCallLists;

static void APIENTRY _fail_glDeleteLists(GLuint list, GLsizei range) {
    const char *_name = "glDeleteLists";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteLists(GLuint list, GLsizei range) {
    PFN_GLDELETELISTS _ptr;
    _ptr = (PFN_GLDELETELISTS)_getPublicProcAddress("glDeleteLists");
    if (!_ptr) {
        _ptr = &_fail_glDeleteLists;
    }
    _glDeleteLists = _ptr;
    _glDeleteLists(list, range);
}

PFN_GLDELETELISTS _glDeleteLists = &_get_glDeleteLists;

static GLuint APIENTRY _fail_glGenLists(GLsizei range) {
    const char *_name = "glGenLists";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glGenLists(GLsizei range) {
    PFN_GLGENLISTS _ptr;
    _ptr = (PFN_GLGENLISTS)_getPublicProcAddress("glGenLists");
    if (!_ptr) {
        _ptr = &_fail_glGenLists;
    }
    _glGenLists = _ptr;
    return _glGenLists(range);
}

PFN_GLGENLISTS _glGenLists = &_get_glGenLists;

static void APIENTRY _fail_glListBase(GLuint base) {
    const char *_name = "glListBase";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glListBase(GLuint base) {
    PFN_GLLISTBASE _ptr;
    _ptr = (PFN_GLLISTBASE)_getPublicProcAddress("glListBase");
    if (!_ptr) {
        _ptr = &_fail_glListBase;
    }
    _glListBase = _ptr;
    _glListBase(base);
}

PFN_GLLISTBASE _glListBase = &_get_glListBase;

static void APIENTRY _fail_glBegin(GLenum mode) {
    const char *_name = "glBegin";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBegin(GLenum mode) {
    PFN_GLBEGIN _ptr;
    _ptr = (PFN_GLBEGIN)_getPublicProcAddress("glBegin");
    if (!_ptr) {
        _ptr = &_fail_glBegin;
    }
    _glBegin = _ptr;
    _glBegin(mode);
}

PFN_GLBEGIN _glBegin = &_get_glBegin;

static void APIENTRY _fail_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte * bitmap) {
    const char *_name = "glBitmap";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte * bitmap) {
    PFN_GLBITMAP _ptr;
    _ptr = (PFN_GLBITMAP)_getPublicProcAddress("glBitmap");
    if (!_ptr) {
        _ptr = &_fail_glBitmap;
    }
    _glBitmap = _ptr;
    _glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap);
}

PFN_GLBITMAP _glBitmap = &_get_glBitmap;

static void APIENTRY _fail_glColor3b(GLbyte red, GLbyte green, GLbyte blue) {
    const char *_name = "glColor3b";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3b(GLbyte red, GLbyte green, GLbyte blue) {
    PFN_GLCOLOR3B _ptr;
    _ptr = (PFN_GLCOLOR3B)_getPublicProcAddress("glColor3b");
    if (!_ptr) {
        _ptr = &_fail_glColor3b;
    }
    _glColor3b = _ptr;
    _glColor3b(red, green, blue);
}

PFN_GLCOLOR3B _glColor3b = &_get_glColor3b;

static void APIENTRY _fail_glColor3bv(const GLbyte * v) {
    const char *_name = "glColor3bv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3bv(const GLbyte * v) {
    PFN_GLCOLOR3BV _ptr;
    _ptr = (PFN_GLCOLOR3BV)_getPublicProcAddress("glColor3bv");
    if (!_ptr) {
        _ptr = &_fail_glColor3bv;
    }
    _glColor3bv = _ptr;
    _glColor3bv(v);
}

PFN_GLCOLOR3BV _glColor3bv = &_get_glColor3bv;

static void APIENTRY _fail_glColor3d(GLdouble red, GLdouble green, GLdouble blue) {
    const char *_name = "glColor3d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3d(GLdouble red, GLdouble green, GLdouble blue) {
    PFN_GLCOLOR3D _ptr;
    _ptr = (PFN_GLCOLOR3D)_getPublicProcAddress("glColor3d");
    if (!_ptr) {
        _ptr = &_fail_glColor3d;
    }
    _glColor3d = _ptr;
    _glColor3d(red, green, blue);
}

PFN_GLCOLOR3D _glColor3d = &_get_glColor3d;

static void APIENTRY _fail_glColor3dv(const GLdouble * v) {
    const char *_name = "glColor3dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3dv(const GLdouble * v) {
    PFN_GLCOLOR3DV _ptr;
    _ptr = (PFN_GLCOLOR3DV)_getPublicProcAddress("glColor3dv");
    if (!_ptr) {
        _ptr = &_fail_glColor3dv;
    }
    _glColor3dv = _ptr;
    _glColor3dv(v);
}

PFN_GLCOLOR3DV _glColor3dv = &_get_glColor3dv;

static void APIENTRY _fail_glColor3f(GLfloat red, GLfloat green, GLfloat blue) {
    const char *_name = "glColor3f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3f(GLfloat red, GLfloat green, GLfloat blue) {
    PFN_GLCOLOR3F _ptr;
    _ptr = (PFN_GLCOLOR3F)_getPublicProcAddress("glColor3f");
    if (!_ptr) {
        _ptr = &_fail_glColor3f;
    }
    _glColor3f = _ptr;
    _glColor3f(red, green, blue);
}

PFN_GLCOLOR3F _glColor3f = &_get_glColor3f;

static void APIENTRY _fail_glColor3fv(const GLfloat * v) {
    const char *_name = "glColor3fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3fv(const GLfloat * v) {
    PFN_GLCOLOR3FV _ptr;
    _ptr = (PFN_GLCOLOR3FV)_getPublicProcAddress("glColor3fv");
    if (!_ptr) {
        _ptr = &_fail_glColor3fv;
    }
    _glColor3fv = _ptr;
    _glColor3fv(v);
}

PFN_GLCOLOR3FV _glColor3fv = &_get_glColor3fv;

static void APIENTRY _fail_glColor3i(GLint red, GLint green, GLint blue) {
    const char *_name = "glColor3i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3i(GLint red, GLint green, GLint blue) {
    PFN_GLCOLOR3I _ptr;
    _ptr = (PFN_GLCOLOR3I)_getPublicProcAddress("glColor3i");
    if (!_ptr) {
        _ptr = &_fail_glColor3i;
    }
    _glColor3i = _ptr;
    _glColor3i(red, green, blue);
}

PFN_GLCOLOR3I _glColor3i = &_get_glColor3i;

static void APIENTRY _fail_glColor3iv(const GLint * v) {
    const char *_name = "glColor3iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3iv(const GLint * v) {
    PFN_GLCOLOR3IV _ptr;
    _ptr = (PFN_GLCOLOR3IV)_getPublicProcAddress("glColor3iv");
    if (!_ptr) {
        _ptr = &_fail_glColor3iv;
    }
    _glColor3iv = _ptr;
    _glColor3iv(v);
}

PFN_GLCOLOR3IV _glColor3iv = &_get_glColor3iv;

static void APIENTRY _fail_glColor3s(GLshort red, GLshort green, GLshort blue) {
    const char *_name = "glColor3s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3s(GLshort red, GLshort green, GLshort blue) {
    PFN_GLCOLOR3S _ptr;
    _ptr = (PFN_GLCOLOR3S)_getPublicProcAddress("glColor3s");
    if (!_ptr) {
        _ptr = &_fail_glColor3s;
    }
    _glColor3s = _ptr;
    _glColor3s(red, green, blue);
}

PFN_GLCOLOR3S _glColor3s = &_get_glColor3s;

static void APIENTRY _fail_glColor3sv(const GLshort * v) {
    const char *_name = "glColor3sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3sv(const GLshort * v) {
    PFN_GLCOLOR3SV _ptr;
    _ptr = (PFN_GLCOLOR3SV)_getPublicProcAddress("glColor3sv");
    if (!_ptr) {
        _ptr = &_fail_glColor3sv;
    }
    _glColor3sv = _ptr;
    _glColor3sv(v);
}

PFN_GLCOLOR3SV _glColor3sv = &_get_glColor3sv;

static void APIENTRY _fail_glColor3ub(GLubyte red, GLubyte green, GLubyte blue) {
    const char *_name = "glColor3ub";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3ub(GLubyte red, GLubyte green, GLubyte blue) {
    PFN_GLCOLOR3UB _ptr;
    _ptr = (PFN_GLCOLOR3UB)_getPublicProcAddress("glColor3ub");
    if (!_ptr) {
        _ptr = &_fail_glColor3ub;
    }
    _glColor3ub = _ptr;
    _glColor3ub(red, green, blue);
}

PFN_GLCOLOR3UB _glColor3ub = &_get_glColor3ub;

static void APIENTRY _fail_glColor3ubv(const GLubyte * v) {
    const char *_name = "glColor3ubv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3ubv(const GLubyte * v) {
    PFN_GLCOLOR3UBV _ptr;
    _ptr = (PFN_GLCOLOR3UBV)_getPublicProcAddress("glColor3ubv");
    if (!_ptr) {
        _ptr = &_fail_glColor3ubv;
    }
    _glColor3ubv = _ptr;
    _glColor3ubv(v);
}

PFN_GLCOLOR3UBV _glColor3ubv = &_get_glColor3ubv;

static void APIENTRY _fail_glColor3ui(GLuint red, GLuint green, GLuint blue) {
    const char *_name = "glColor3ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3ui(GLuint red, GLuint green, GLuint blue) {
    PFN_GLCOLOR3UI _ptr;
    _ptr = (PFN_GLCOLOR3UI)_getPublicProcAddress("glColor3ui");
    if (!_ptr) {
        _ptr = &_fail_glColor3ui;
    }
    _glColor3ui = _ptr;
    _glColor3ui(red, green, blue);
}

PFN_GLCOLOR3UI _glColor3ui = &_get_glColor3ui;

static void APIENTRY _fail_glColor3uiv(const GLuint * v) {
    const char *_name = "glColor3uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3uiv(const GLuint * v) {
    PFN_GLCOLOR3UIV _ptr;
    _ptr = (PFN_GLCOLOR3UIV)_getPublicProcAddress("glColor3uiv");
    if (!_ptr) {
        _ptr = &_fail_glColor3uiv;
    }
    _glColor3uiv = _ptr;
    _glColor3uiv(v);
}

PFN_GLCOLOR3UIV _glColor3uiv = &_get_glColor3uiv;

static void APIENTRY _fail_glColor3us(GLushort red, GLushort green, GLushort blue) {
    const char *_name = "glColor3us";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3us(GLushort red, GLushort green, GLushort blue) {
    PFN_GLCOLOR3US _ptr;
    _ptr = (PFN_GLCOLOR3US)_getPublicProcAddress("glColor3us");
    if (!_ptr) {
        _ptr = &_fail_glColor3us;
    }
    _glColor3us = _ptr;
    _glColor3us(red, green, blue);
}

PFN_GLCOLOR3US _glColor3us = &_get_glColor3us;

static void APIENTRY _fail_glColor3usv(const GLushort * v) {
    const char *_name = "glColor3usv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3usv(const GLushort * v) {
    PFN_GLCOLOR3USV _ptr;
    _ptr = (PFN_GLCOLOR3USV)_getPublicProcAddress("glColor3usv");
    if (!_ptr) {
        _ptr = &_fail_glColor3usv;
    }
    _glColor3usv = _ptr;
    _glColor3usv(v);
}

PFN_GLCOLOR3USV _glColor3usv = &_get_glColor3usv;

static void APIENTRY _fail_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) {
    const char *_name = "glColor4b";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) {
    PFN_GLCOLOR4B _ptr;
    _ptr = (PFN_GLCOLOR4B)_getPublicProcAddress("glColor4b");
    if (!_ptr) {
        _ptr = &_fail_glColor4b;
    }
    _glColor4b = _ptr;
    _glColor4b(red, green, blue, alpha);
}

PFN_GLCOLOR4B _glColor4b = &_get_glColor4b;

static void APIENTRY _fail_glColor4bv(const GLbyte * v) {
    const char *_name = "glColor4bv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4bv(const GLbyte * v) {
    PFN_GLCOLOR4BV _ptr;
    _ptr = (PFN_GLCOLOR4BV)_getPublicProcAddress("glColor4bv");
    if (!_ptr) {
        _ptr = &_fail_glColor4bv;
    }
    _glColor4bv = _ptr;
    _glColor4bv(v);
}

PFN_GLCOLOR4BV _glColor4bv = &_get_glColor4bv;

static void APIENTRY _fail_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) {
    const char *_name = "glColor4d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) {
    PFN_GLCOLOR4D _ptr;
    _ptr = (PFN_GLCOLOR4D)_getPublicProcAddress("glColor4d");
    if (!_ptr) {
        _ptr = &_fail_glColor4d;
    }
    _glColor4d = _ptr;
    _glColor4d(red, green, blue, alpha);
}

PFN_GLCOLOR4D _glColor4d = &_get_glColor4d;

static void APIENTRY _fail_glColor4dv(const GLdouble * v) {
    const char *_name = "glColor4dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4dv(const GLdouble * v) {
    PFN_GLCOLOR4DV _ptr;
    _ptr = (PFN_GLCOLOR4DV)_getPublicProcAddress("glColor4dv");
    if (!_ptr) {
        _ptr = &_fail_glColor4dv;
    }
    _glColor4dv = _ptr;
    _glColor4dv(v);
}

PFN_GLCOLOR4DV _glColor4dv = &_get_glColor4dv;

static void APIENTRY _fail_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    const char *_name = "glColor4f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    PFN_GLCOLOR4F _ptr;
    _ptr = (PFN_GLCOLOR4F)_getPublicProcAddress("glColor4f");
    if (!_ptr) {
        _ptr = &_fail_glColor4f;
    }
    _glColor4f = _ptr;
    _glColor4f(red, green, blue, alpha);
}

PFN_GLCOLOR4F _glColor4f = &_get_glColor4f;

static void APIENTRY _fail_glColor4fv(const GLfloat * v) {
    const char *_name = "glColor4fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4fv(const GLfloat * v) {
    PFN_GLCOLOR4FV _ptr;
    _ptr = (PFN_GLCOLOR4FV)_getPublicProcAddress("glColor4fv");
    if (!_ptr) {
        _ptr = &_fail_glColor4fv;
    }
    _glColor4fv = _ptr;
    _glColor4fv(v);
}

PFN_GLCOLOR4FV _glColor4fv = &_get_glColor4fv;

static void APIENTRY _fail_glColor4i(GLint red, GLint green, GLint blue, GLint alpha) {
    const char *_name = "glColor4i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4i(GLint red, GLint green, GLint blue, GLint alpha) {
    PFN_GLCOLOR4I _ptr;
    _ptr = (PFN_GLCOLOR4I)_getPublicProcAddress("glColor4i");
    if (!_ptr) {
        _ptr = &_fail_glColor4i;
    }
    _glColor4i = _ptr;
    _glColor4i(red, green, blue, alpha);
}

PFN_GLCOLOR4I _glColor4i = &_get_glColor4i;

static void APIENTRY _fail_glColor4iv(const GLint * v) {
    const char *_name = "glColor4iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4iv(const GLint * v) {
    PFN_GLCOLOR4IV _ptr;
    _ptr = (PFN_GLCOLOR4IV)_getPublicProcAddress("glColor4iv");
    if (!_ptr) {
        _ptr = &_fail_glColor4iv;
    }
    _glColor4iv = _ptr;
    _glColor4iv(v);
}

PFN_GLCOLOR4IV _glColor4iv = &_get_glColor4iv;

static void APIENTRY _fail_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha) {
    const char *_name = "glColor4s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha) {
    PFN_GLCOLOR4S _ptr;
    _ptr = (PFN_GLCOLOR4S)_getPublicProcAddress("glColor4s");
    if (!_ptr) {
        _ptr = &_fail_glColor4s;
    }
    _glColor4s = _ptr;
    _glColor4s(red, green, blue, alpha);
}

PFN_GLCOLOR4S _glColor4s = &_get_glColor4s;

static void APIENTRY _fail_glColor4sv(const GLshort * v) {
    const char *_name = "glColor4sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4sv(const GLshort * v) {
    PFN_GLCOLOR4SV _ptr;
    _ptr = (PFN_GLCOLOR4SV)_getPublicProcAddress("glColor4sv");
    if (!_ptr) {
        _ptr = &_fail_glColor4sv;
    }
    _glColor4sv = _ptr;
    _glColor4sv(v);
}

PFN_GLCOLOR4SV _glColor4sv = &_get_glColor4sv;

static void APIENTRY _fail_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) {
    const char *_name = "glColor4ub";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) {
    PFN_GLCOLOR4UB _ptr;
    _ptr = (PFN_GLCOLOR4UB)_getPublicProcAddress("glColor4ub");
    if (!_ptr) {
        _ptr = &_fail_glColor4ub;
    }
    _glColor4ub = _ptr;
    _glColor4ub(red, green, blue, alpha);
}

PFN_GLCOLOR4UB _glColor4ub = &_get_glColor4ub;

static void APIENTRY _fail_glColor4ubv(const GLubyte * v) {
    const char *_name = "glColor4ubv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4ubv(const GLubyte * v) {
    PFN_GLCOLOR4UBV _ptr;
    _ptr = (PFN_GLCOLOR4UBV)_getPublicProcAddress("glColor4ubv");
    if (!_ptr) {
        _ptr = &_fail_glColor4ubv;
    }
    _glColor4ubv = _ptr;
    _glColor4ubv(v);
}

PFN_GLCOLOR4UBV _glColor4ubv = &_get_glColor4ubv;

static void APIENTRY _fail_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha) {
    const char *_name = "glColor4ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha) {
    PFN_GLCOLOR4UI _ptr;
    _ptr = (PFN_GLCOLOR4UI)_getPublicProcAddress("glColor4ui");
    if (!_ptr) {
        _ptr = &_fail_glColor4ui;
    }
    _glColor4ui = _ptr;
    _glColor4ui(red, green, blue, alpha);
}

PFN_GLCOLOR4UI _glColor4ui = &_get_glColor4ui;

static void APIENTRY _fail_glColor4uiv(const GLuint * v) {
    const char *_name = "glColor4uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4uiv(const GLuint * v) {
    PFN_GLCOLOR4UIV _ptr;
    _ptr = (PFN_GLCOLOR4UIV)_getPublicProcAddress("glColor4uiv");
    if (!_ptr) {
        _ptr = &_fail_glColor4uiv;
    }
    _glColor4uiv = _ptr;
    _glColor4uiv(v);
}

PFN_GLCOLOR4UIV _glColor4uiv = &_get_glColor4uiv;

static void APIENTRY _fail_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha) {
    const char *_name = "glColor4us";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha) {
    PFN_GLCOLOR4US _ptr;
    _ptr = (PFN_GLCOLOR4US)_getPublicProcAddress("glColor4us");
    if (!_ptr) {
        _ptr = &_fail_glColor4us;
    }
    _glColor4us = _ptr;
    _glColor4us(red, green, blue, alpha);
}

PFN_GLCOLOR4US _glColor4us = &_get_glColor4us;

static void APIENTRY _fail_glColor4usv(const GLushort * v) {
    const char *_name = "glColor4usv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4usv(const GLushort * v) {
    PFN_GLCOLOR4USV _ptr;
    _ptr = (PFN_GLCOLOR4USV)_getPublicProcAddress("glColor4usv");
    if (!_ptr) {
        _ptr = &_fail_glColor4usv;
    }
    _glColor4usv = _ptr;
    _glColor4usv(v);
}

PFN_GLCOLOR4USV _glColor4usv = &_get_glColor4usv;

static void APIENTRY _fail_glEdgeFlag(GLboolean flag) {
    const char *_name = "glEdgeFlag";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEdgeFlag(GLboolean flag) {
    PFN_GLEDGEFLAG _ptr;
    _ptr = (PFN_GLEDGEFLAG)_getPublicProcAddress("glEdgeFlag");
    if (!_ptr) {
        _ptr = &_fail_glEdgeFlag;
    }
    _glEdgeFlag = _ptr;
    _glEdgeFlag(flag);
}

PFN_GLEDGEFLAG _glEdgeFlag = &_get_glEdgeFlag;

static void APIENTRY _fail_glEdgeFlagv(const GLboolean * flag) {
    const char *_name = "glEdgeFlagv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEdgeFlagv(const GLboolean * flag) {
    PFN_GLEDGEFLAGV _ptr;
    _ptr = (PFN_GLEDGEFLAGV)_getPublicProcAddress("glEdgeFlagv");
    if (!_ptr) {
        _ptr = &_fail_glEdgeFlagv;
    }
    _glEdgeFlagv = _ptr;
    _glEdgeFlagv(flag);
}

PFN_GLEDGEFLAGV _glEdgeFlagv = &_get_glEdgeFlagv;

static void APIENTRY _fail_glEnd(void) {
    const char *_name = "glEnd";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEnd(void) {
    PFN_GLEND _ptr;
    _ptr = (PFN_GLEND)_getPublicProcAddress("glEnd");
    if (!_ptr) {
        _ptr = &_fail_glEnd;
    }
    _glEnd = _ptr;
    _glEnd();
}

PFN_GLEND _glEnd = &_get_glEnd;

static void APIENTRY _fail_glIndexd(GLdouble c) {
    const char *_name = "glIndexd";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glIndexd(GLdouble c) {
    PFN_GLINDEXD _ptr;
    _ptr = (PFN_GLINDEXD)_getPublicProcAddress("glIndexd");
    if (!_ptr) {
        _ptr = &_fail_glIndexd;
    }
    _glIndexd = _ptr;
    _glIndexd(c);
}

PFN_GLINDEXD _glIndexd = &_get_glIndexd;

static void APIENTRY _fail_glIndexdv(const GLdouble * c) {
    const char *_name = "glIndexdv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glIndexdv(const GLdouble * c) {
    PFN_GLINDEXDV _ptr;
    _ptr = (PFN_GLINDEXDV)_getPublicProcAddress("glIndexdv");
    if (!_ptr) {
        _ptr = &_fail_glIndexdv;
    }
    _glIndexdv = _ptr;
    _glIndexdv(c);
}

PFN_GLINDEXDV _glIndexdv = &_get_glIndexdv;

static void APIENTRY _fail_glIndexf(GLfloat c) {
    const char *_name = "glIndexf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glIndexf(GLfloat c) {
    PFN_GLINDEXF _ptr;
    _ptr = (PFN_GLINDEXF)_getPublicProcAddress("glIndexf");
    if (!_ptr) {
        _ptr = &_fail_glIndexf;
    }
    _glIndexf = _ptr;
    _glIndexf(c);
}

PFN_GLINDEXF _glIndexf = &_get_glIndexf;

static void APIENTRY _fail_glIndexfv(const GLfloat * c) {
    const char *_name = "glIndexfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glIndexfv(const GLfloat * c) {
    PFN_GLINDEXFV _ptr;
    _ptr = (PFN_GLINDEXFV)_getPublicProcAddress("glIndexfv");
    if (!_ptr) {
        _ptr = &_fail_glIndexfv;
    }
    _glIndexfv = _ptr;
    _glIndexfv(c);
}

PFN_GLINDEXFV _glIndexfv = &_get_glIndexfv;

static void APIENTRY _fail_glIndexi(GLint c) {
    const char *_name = "glIndexi";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glIndexi(GLint c) {
    PFN_GLINDEXI _ptr;
    _ptr = (PFN_GLINDEXI)_getPublicProcAddress("glIndexi");
    if (!_ptr) {
        _ptr = &_fail_glIndexi;
    }
    _glIndexi = _ptr;
    _glIndexi(c);
}

PFN_GLINDEXI _glIndexi = &_get_glIndexi;

static void APIENTRY _fail_glIndexiv(const GLint * c) {
    const char *_name = "glIndexiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glIndexiv(const GLint * c) {
    PFN_GLINDEXIV _ptr;
    _ptr = (PFN_GLINDEXIV)_getPublicProcAddress("glIndexiv");
    if (!_ptr) {
        _ptr = &_fail_glIndexiv;
    }
    _glIndexiv = _ptr;
    _glIndexiv(c);
}

PFN_GLINDEXIV _glIndexiv = &_get_glIndexiv;

static void APIENTRY _fail_glIndexs(GLshort c) {
    const char *_name = "glIndexs";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glIndexs(GLshort c) {
    PFN_GLINDEXS _ptr;
    _ptr = (PFN_GLINDEXS)_getPublicProcAddress("glIndexs");
    if (!_ptr) {
        _ptr = &_fail_glIndexs;
    }
    _glIndexs = _ptr;
    _glIndexs(c);
}

PFN_GLINDEXS _glIndexs = &_get_glIndexs;

static void APIENTRY _fail_glIndexsv(const GLshort * c) {
    const char *_name = "glIndexsv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glIndexsv(const GLshort * c) {
    PFN_GLINDEXSV _ptr;
    _ptr = (PFN_GLINDEXSV)_getPublicProcAddress("glIndexsv");
    if (!_ptr) {
        _ptr = &_fail_glIndexsv;
    }
    _glIndexsv = _ptr;
    _glIndexsv(c);
}

PFN_GLINDEXSV _glIndexsv = &_get_glIndexsv;

static void APIENTRY _fail_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz) {
    const char *_name = "glNormal3b";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz) {
    PFN_GLNORMAL3B _ptr;
    _ptr = (PFN_GLNORMAL3B)_getPublicProcAddress("glNormal3b");
    if (!_ptr) {
        _ptr = &_fail_glNormal3b;
    }
    _glNormal3b = _ptr;
    _glNormal3b(nx, ny, nz);
}

PFN_GLNORMAL3B _glNormal3b = &_get_glNormal3b;

static void APIENTRY _fail_glNormal3bv(const GLbyte * v) {
    const char *_name = "glNormal3bv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormal3bv(const GLbyte * v) {
    PFN_GLNORMAL3BV _ptr;
    _ptr = (PFN_GLNORMAL3BV)_getPublicProcAddress("glNormal3bv");
    if (!_ptr) {
        _ptr = &_fail_glNormal3bv;
    }
    _glNormal3bv = _ptr;
    _glNormal3bv(v);
}

PFN_GLNORMAL3BV _glNormal3bv = &_get_glNormal3bv;

static void APIENTRY _fail_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz) {
    const char *_name = "glNormal3d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz) {
    PFN_GLNORMAL3D _ptr;
    _ptr = (PFN_GLNORMAL3D)_getPublicProcAddress("glNormal3d");
    if (!_ptr) {
        _ptr = &_fail_glNormal3d;
    }
    _glNormal3d = _ptr;
    _glNormal3d(nx, ny, nz);
}

PFN_GLNORMAL3D _glNormal3d = &_get_glNormal3d;

static void APIENTRY _fail_glNormal3dv(const GLdouble * v) {
    const char *_name = "glNormal3dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormal3dv(const GLdouble * v) {
    PFN_GLNORMAL3DV _ptr;
    _ptr = (PFN_GLNORMAL3DV)_getPublicProcAddress("glNormal3dv");
    if (!_ptr) {
        _ptr = &_fail_glNormal3dv;
    }
    _glNormal3dv = _ptr;
    _glNormal3dv(v);
}

PFN_GLNORMAL3DV _glNormal3dv = &_get_glNormal3dv;

static void APIENTRY _fail_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz) {
    const char *_name = "glNormal3f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz) {
    PFN_GLNORMAL3F _ptr;
    _ptr = (PFN_GLNORMAL3F)_getPublicProcAddress("glNormal3f");
    if (!_ptr) {
        _ptr = &_fail_glNormal3f;
    }
    _glNormal3f = _ptr;
    _glNormal3f(nx, ny, nz);
}

PFN_GLNORMAL3F _glNormal3f = &_get_glNormal3f;

static void APIENTRY _fail_glNormal3fv(const GLfloat * v) {
    const char *_name = "glNormal3fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormal3fv(const GLfloat * v) {
    PFN_GLNORMAL3FV _ptr;
    _ptr = (PFN_GLNORMAL3FV)_getPublicProcAddress("glNormal3fv");
    if (!_ptr) {
        _ptr = &_fail_glNormal3fv;
    }
    _glNormal3fv = _ptr;
    _glNormal3fv(v);
}

PFN_GLNORMAL3FV _glNormal3fv = &_get_glNormal3fv;

static void APIENTRY _fail_glNormal3i(GLint nx, GLint ny, GLint nz) {
    const char *_name = "glNormal3i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormal3i(GLint nx, GLint ny, GLint nz) {
    PFN_GLNORMAL3I _ptr;
    _ptr = (PFN_GLNORMAL3I)_getPublicProcAddress("glNormal3i");
    if (!_ptr) {
        _ptr = &_fail_glNormal3i;
    }
    _glNormal3i = _ptr;
    _glNormal3i(nx, ny, nz);
}

PFN_GLNORMAL3I _glNormal3i = &_get_glNormal3i;

static void APIENTRY _fail_glNormal3iv(const GLint * v) {
    const char *_name = "glNormal3iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormal3iv(const GLint * v) {
    PFN_GLNORMAL3IV _ptr;
    _ptr = (PFN_GLNORMAL3IV)_getPublicProcAddress("glNormal3iv");
    if (!_ptr) {
        _ptr = &_fail_glNormal3iv;
    }
    _glNormal3iv = _ptr;
    _glNormal3iv(v);
}

PFN_GLNORMAL3IV _glNormal3iv = &_get_glNormal3iv;

static void APIENTRY _fail_glNormal3s(GLshort nx, GLshort ny, GLshort nz) {
    const char *_name = "glNormal3s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormal3s(GLshort nx, GLshort ny, GLshort nz) {
    PFN_GLNORMAL3S _ptr;
    _ptr = (PFN_GLNORMAL3S)_getPublicProcAddress("glNormal3s");
    if (!_ptr) {
        _ptr = &_fail_glNormal3s;
    }
    _glNormal3s = _ptr;
    _glNormal3s(nx, ny, nz);
}

PFN_GLNORMAL3S _glNormal3s = &_get_glNormal3s;

static void APIENTRY _fail_glNormal3sv(const GLshort * v) {
    const char *_name = "glNormal3sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormal3sv(const GLshort * v) {
    PFN_GLNORMAL3SV _ptr;
    _ptr = (PFN_GLNORMAL3SV)_getPublicProcAddress("glNormal3sv");
    if (!_ptr) {
        _ptr = &_fail_glNormal3sv;
    }
    _glNormal3sv = _ptr;
    _glNormal3sv(v);
}

PFN_GLNORMAL3SV _glNormal3sv = &_get_glNormal3sv;

static void APIENTRY _fail_glRasterPos2d(GLdouble x, GLdouble y) {
    const char *_name = "glRasterPos2d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos2d(GLdouble x, GLdouble y) {
    PFN_GLRASTERPOS2D _ptr;
    _ptr = (PFN_GLRASTERPOS2D)_getPublicProcAddress("glRasterPos2d");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos2d;
    }
    _glRasterPos2d = _ptr;
    _glRasterPos2d(x, y);
}

PFN_GLRASTERPOS2D _glRasterPos2d = &_get_glRasterPos2d;

static void APIENTRY _fail_glRasterPos2dv(const GLdouble * v) {
    const char *_name = "glRasterPos2dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos2dv(const GLdouble * v) {
    PFN_GLRASTERPOS2DV _ptr;
    _ptr = (PFN_GLRASTERPOS2DV)_getPublicProcAddress("glRasterPos2dv");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos2dv;
    }
    _glRasterPos2dv = _ptr;
    _glRasterPos2dv(v);
}

PFN_GLRASTERPOS2DV _glRasterPos2dv = &_get_glRasterPos2dv;

static void APIENTRY _fail_glRasterPos2f(GLfloat x, GLfloat y) {
    const char *_name = "glRasterPos2f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos2f(GLfloat x, GLfloat y) {
    PFN_GLRASTERPOS2F _ptr;
    _ptr = (PFN_GLRASTERPOS2F)_getPublicProcAddress("glRasterPos2f");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos2f;
    }
    _glRasterPos2f = _ptr;
    _glRasterPos2f(x, y);
}

PFN_GLRASTERPOS2F _glRasterPos2f = &_get_glRasterPos2f;

static void APIENTRY _fail_glRasterPos2fv(const GLfloat * v) {
    const char *_name = "glRasterPos2fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos2fv(const GLfloat * v) {
    PFN_GLRASTERPOS2FV _ptr;
    _ptr = (PFN_GLRASTERPOS2FV)_getPublicProcAddress("glRasterPos2fv");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos2fv;
    }
    _glRasterPos2fv = _ptr;
    _glRasterPos2fv(v);
}

PFN_GLRASTERPOS2FV _glRasterPos2fv = &_get_glRasterPos2fv;

static void APIENTRY _fail_glRasterPos2i(GLint x, GLint y) {
    const char *_name = "glRasterPos2i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos2i(GLint x, GLint y) {
    PFN_GLRASTERPOS2I _ptr;
    _ptr = (PFN_GLRASTERPOS2I)_getPublicProcAddress("glRasterPos2i");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos2i;
    }
    _glRasterPos2i = _ptr;
    _glRasterPos2i(x, y);
}

PFN_GLRASTERPOS2I _glRasterPos2i = &_get_glRasterPos2i;

static void APIENTRY _fail_glRasterPos2iv(const GLint * v) {
    const char *_name = "glRasterPos2iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos2iv(const GLint * v) {
    PFN_GLRASTERPOS2IV _ptr;
    _ptr = (PFN_GLRASTERPOS2IV)_getPublicProcAddress("glRasterPos2iv");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos2iv;
    }
    _glRasterPos2iv = _ptr;
    _glRasterPos2iv(v);
}

PFN_GLRASTERPOS2IV _glRasterPos2iv = &_get_glRasterPos2iv;

static void APIENTRY _fail_glRasterPos2s(GLshort x, GLshort y) {
    const char *_name = "glRasterPos2s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos2s(GLshort x, GLshort y) {
    PFN_GLRASTERPOS2S _ptr;
    _ptr = (PFN_GLRASTERPOS2S)_getPublicProcAddress("glRasterPos2s");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos2s;
    }
    _glRasterPos2s = _ptr;
    _glRasterPos2s(x, y);
}

PFN_GLRASTERPOS2S _glRasterPos2s = &_get_glRasterPos2s;

static void APIENTRY _fail_glRasterPos2sv(const GLshort * v) {
    const char *_name = "glRasterPos2sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos2sv(const GLshort * v) {
    PFN_GLRASTERPOS2SV _ptr;
    _ptr = (PFN_GLRASTERPOS2SV)_getPublicProcAddress("glRasterPos2sv");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos2sv;
    }
    _glRasterPos2sv = _ptr;
    _glRasterPos2sv(v);
}

PFN_GLRASTERPOS2SV _glRasterPos2sv = &_get_glRasterPos2sv;

static void APIENTRY _fail_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glRasterPos3d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLRASTERPOS3D _ptr;
    _ptr = (PFN_GLRASTERPOS3D)_getPublicProcAddress("glRasterPos3d");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos3d;
    }
    _glRasterPos3d = _ptr;
    _glRasterPos3d(x, y, z);
}

PFN_GLRASTERPOS3D _glRasterPos3d = &_get_glRasterPos3d;

static void APIENTRY _fail_glRasterPos3dv(const GLdouble * v) {
    const char *_name = "glRasterPos3dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos3dv(const GLdouble * v) {
    PFN_GLRASTERPOS3DV _ptr;
    _ptr = (PFN_GLRASTERPOS3DV)_getPublicProcAddress("glRasterPos3dv");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos3dv;
    }
    _glRasterPos3dv = _ptr;
    _glRasterPos3dv(v);
}

PFN_GLRASTERPOS3DV _glRasterPos3dv = &_get_glRasterPos3dv;

static void APIENTRY _fail_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glRasterPos3f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLRASTERPOS3F _ptr;
    _ptr = (PFN_GLRASTERPOS3F)_getPublicProcAddress("glRasterPos3f");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos3f;
    }
    _glRasterPos3f = _ptr;
    _glRasterPos3f(x, y, z);
}

PFN_GLRASTERPOS3F _glRasterPos3f = &_get_glRasterPos3f;

static void APIENTRY _fail_glRasterPos3fv(const GLfloat * v) {
    const char *_name = "glRasterPos3fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos3fv(const GLfloat * v) {
    PFN_GLRASTERPOS3FV _ptr;
    _ptr = (PFN_GLRASTERPOS3FV)_getPublicProcAddress("glRasterPos3fv");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos3fv;
    }
    _glRasterPos3fv = _ptr;
    _glRasterPos3fv(v);
}

PFN_GLRASTERPOS3FV _glRasterPos3fv = &_get_glRasterPos3fv;

static void APIENTRY _fail_glRasterPos3i(GLint x, GLint y, GLint z) {
    const char *_name = "glRasterPos3i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos3i(GLint x, GLint y, GLint z) {
    PFN_GLRASTERPOS3I _ptr;
    _ptr = (PFN_GLRASTERPOS3I)_getPublicProcAddress("glRasterPos3i");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos3i;
    }
    _glRasterPos3i = _ptr;
    _glRasterPos3i(x, y, z);
}

PFN_GLRASTERPOS3I _glRasterPos3i = &_get_glRasterPos3i;

static void APIENTRY _fail_glRasterPos3iv(const GLint * v) {
    const char *_name = "glRasterPos3iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos3iv(const GLint * v) {
    PFN_GLRASTERPOS3IV _ptr;
    _ptr = (PFN_GLRASTERPOS3IV)_getPublicProcAddress("glRasterPos3iv");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos3iv;
    }
    _glRasterPos3iv = _ptr;
    _glRasterPos3iv(v);
}

PFN_GLRASTERPOS3IV _glRasterPos3iv = &_get_glRasterPos3iv;

static void APIENTRY _fail_glRasterPos3s(GLshort x, GLshort y, GLshort z) {
    const char *_name = "glRasterPos3s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos3s(GLshort x, GLshort y, GLshort z) {
    PFN_GLRASTERPOS3S _ptr;
    _ptr = (PFN_GLRASTERPOS3S)_getPublicProcAddress("glRasterPos3s");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos3s;
    }
    _glRasterPos3s = _ptr;
    _glRasterPos3s(x, y, z);
}

PFN_GLRASTERPOS3S _glRasterPos3s = &_get_glRasterPos3s;

static void APIENTRY _fail_glRasterPos3sv(const GLshort * v) {
    const char *_name = "glRasterPos3sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos3sv(const GLshort * v) {
    PFN_GLRASTERPOS3SV _ptr;
    _ptr = (PFN_GLRASTERPOS3SV)_getPublicProcAddress("glRasterPos3sv");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos3sv;
    }
    _glRasterPos3sv = _ptr;
    _glRasterPos3sv(v);
}

PFN_GLRASTERPOS3SV _glRasterPos3sv = &_get_glRasterPos3sv;

static void APIENTRY _fail_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glRasterPos4d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    PFN_GLRASTERPOS4D _ptr;
    _ptr = (PFN_GLRASTERPOS4D)_getPublicProcAddress("glRasterPos4d");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos4d;
    }
    _glRasterPos4d = _ptr;
    _glRasterPos4d(x, y, z, w);
}

PFN_GLRASTERPOS4D _glRasterPos4d = &_get_glRasterPos4d;

static void APIENTRY _fail_glRasterPos4dv(const GLdouble * v) {
    const char *_name = "glRasterPos4dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos4dv(const GLdouble * v) {
    PFN_GLRASTERPOS4DV _ptr;
    _ptr = (PFN_GLRASTERPOS4DV)_getPublicProcAddress("glRasterPos4dv");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos4dv;
    }
    _glRasterPos4dv = _ptr;
    _glRasterPos4dv(v);
}

PFN_GLRASTERPOS4DV _glRasterPos4dv = &_get_glRasterPos4dv;

static void APIENTRY _fail_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glRasterPos4f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    PFN_GLRASTERPOS4F _ptr;
    _ptr = (PFN_GLRASTERPOS4F)_getPublicProcAddress("glRasterPos4f");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos4f;
    }
    _glRasterPos4f = _ptr;
    _glRasterPos4f(x, y, z, w);
}

PFN_GLRASTERPOS4F _glRasterPos4f = &_get_glRasterPos4f;

static void APIENTRY _fail_glRasterPos4fv(const GLfloat * v) {
    const char *_name = "glRasterPos4fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos4fv(const GLfloat * v) {
    PFN_GLRASTERPOS4FV _ptr;
    _ptr = (PFN_GLRASTERPOS4FV)_getPublicProcAddress("glRasterPos4fv");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos4fv;
    }
    _glRasterPos4fv = _ptr;
    _glRasterPos4fv(v);
}

PFN_GLRASTERPOS4FV _glRasterPos4fv = &_get_glRasterPos4fv;

static void APIENTRY _fail_glRasterPos4i(GLint x, GLint y, GLint z, GLint w) {
    const char *_name = "glRasterPos4i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos4i(GLint x, GLint y, GLint z, GLint w) {
    PFN_GLRASTERPOS4I _ptr;
    _ptr = (PFN_GLRASTERPOS4I)_getPublicProcAddress("glRasterPos4i");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos4i;
    }
    _glRasterPos4i = _ptr;
    _glRasterPos4i(x, y, z, w);
}

PFN_GLRASTERPOS4I _glRasterPos4i = &_get_glRasterPos4i;

static void APIENTRY _fail_glRasterPos4iv(const GLint * v) {
    const char *_name = "glRasterPos4iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos4iv(const GLint * v) {
    PFN_GLRASTERPOS4IV _ptr;
    _ptr = (PFN_GLRASTERPOS4IV)_getPublicProcAddress("glRasterPos4iv");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos4iv;
    }
    _glRasterPos4iv = _ptr;
    _glRasterPos4iv(v);
}

PFN_GLRASTERPOS4IV _glRasterPos4iv = &_get_glRasterPos4iv;

static void APIENTRY _fail_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w) {
    const char *_name = "glRasterPos4s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w) {
    PFN_GLRASTERPOS4S _ptr;
    _ptr = (PFN_GLRASTERPOS4S)_getPublicProcAddress("glRasterPos4s");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos4s;
    }
    _glRasterPos4s = _ptr;
    _glRasterPos4s(x, y, z, w);
}

PFN_GLRASTERPOS4S _glRasterPos4s = &_get_glRasterPos4s;

static void APIENTRY _fail_glRasterPos4sv(const GLshort * v) {
    const char *_name = "glRasterPos4sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterPos4sv(const GLshort * v) {
    PFN_GLRASTERPOS4SV _ptr;
    _ptr = (PFN_GLRASTERPOS4SV)_getPublicProcAddress("glRasterPos4sv");
    if (!_ptr) {
        _ptr = &_fail_glRasterPos4sv;
    }
    _glRasterPos4sv = _ptr;
    _glRasterPos4sv(v);
}

PFN_GLRASTERPOS4SV _glRasterPos4sv = &_get_glRasterPos4sv;

static void APIENTRY _fail_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) {
    const char *_name = "glRectd";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) {
    PFN_GLRECTD _ptr;
    _ptr = (PFN_GLRECTD)_getPublicProcAddress("glRectd");
    if (!_ptr) {
        _ptr = &_fail_glRectd;
    }
    _glRectd = _ptr;
    _glRectd(x1, y1, x2, y2);
}

PFN_GLRECTD _glRectd = &_get_glRectd;

static void APIENTRY _fail_glRectdv(const GLdouble * v1, const GLdouble * v2) {
    const char *_name = "glRectdv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRectdv(const GLdouble * v1, const GLdouble * v2) {
    PFN_GLRECTDV _ptr;
    _ptr = (PFN_GLRECTDV)_getPublicProcAddress("glRectdv");
    if (!_ptr) {
        _ptr = &_fail_glRectdv;
    }
    _glRectdv = _ptr;
    _glRectdv(v1, v2);
}

PFN_GLRECTDV _glRectdv = &_get_glRectdv;

static void APIENTRY _fail_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) {
    const char *_name = "glRectf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) {
    PFN_GLRECTF _ptr;
    _ptr = (PFN_GLRECTF)_getPublicProcAddress("glRectf");
    if (!_ptr) {
        _ptr = &_fail_glRectf;
    }
    _glRectf = _ptr;
    _glRectf(x1, y1, x2, y2);
}

PFN_GLRECTF _glRectf = &_get_glRectf;

static void APIENTRY _fail_glRectfv(const GLfloat * v1, const GLfloat * v2) {
    const char *_name = "glRectfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRectfv(const GLfloat * v1, const GLfloat * v2) {
    PFN_GLRECTFV _ptr;
    _ptr = (PFN_GLRECTFV)_getPublicProcAddress("glRectfv");
    if (!_ptr) {
        _ptr = &_fail_glRectfv;
    }
    _glRectfv = _ptr;
    _glRectfv(v1, v2);
}

PFN_GLRECTFV _glRectfv = &_get_glRectfv;

static void APIENTRY _fail_glRecti(GLint x1, GLint y1, GLint x2, GLint y2) {
    const char *_name = "glRecti";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRecti(GLint x1, GLint y1, GLint x2, GLint y2) {
    PFN_GLRECTI _ptr;
    _ptr = (PFN_GLRECTI)_getPublicProcAddress("glRecti");
    if (!_ptr) {
        _ptr = &_fail_glRecti;
    }
    _glRecti = _ptr;
    _glRecti(x1, y1, x2, y2);
}

PFN_GLRECTI _glRecti = &_get_glRecti;

static void APIENTRY _fail_glRectiv(const GLint * v1, const GLint * v2) {
    const char *_name = "glRectiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRectiv(const GLint * v1, const GLint * v2) {
    PFN_GLRECTIV _ptr;
    _ptr = (PFN_GLRECTIV)_getPublicProcAddress("glRectiv");
    if (!_ptr) {
        _ptr = &_fail_glRectiv;
    }
    _glRectiv = _ptr;
    _glRectiv(v1, v2);
}

PFN_GLRECTIV _glRectiv = &_get_glRectiv;

static void APIENTRY _fail_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2) {
    const char *_name = "glRects";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2) {
    PFN_GLRECTS _ptr;
    _ptr = (PFN_GLRECTS)_getPublicProcAddress("glRects");
    if (!_ptr) {
        _ptr = &_fail_glRects;
    }
    _glRects = _ptr;
    _glRects(x1, y1, x2, y2);
}

PFN_GLRECTS _glRects = &_get_glRects;

static void APIENTRY _fail_glRectsv(const GLshort * v1, const GLshort * v2) {
    const char *_name = "glRectsv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRectsv(const GLshort * v1, const GLshort * v2) {
    PFN_GLRECTSV _ptr;
    _ptr = (PFN_GLRECTSV)_getPublicProcAddress("glRectsv");
    if (!_ptr) {
        _ptr = &_fail_glRectsv;
    }
    _glRectsv = _ptr;
    _glRectsv(v1, v2);
}

PFN_GLRECTSV _glRectsv = &_get_glRectsv;

static void APIENTRY _fail_glTexCoord1d(GLdouble s) {
    const char *_name = "glTexCoord1d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord1d(GLdouble s) {
    PFN_GLTEXCOORD1D _ptr;
    _ptr = (PFN_GLTEXCOORD1D)_getPublicProcAddress("glTexCoord1d");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord1d;
    }
    _glTexCoord1d = _ptr;
    _glTexCoord1d(s);
}

PFN_GLTEXCOORD1D _glTexCoord1d = &_get_glTexCoord1d;

static void APIENTRY _fail_glTexCoord1dv(const GLdouble * v) {
    const char *_name = "glTexCoord1dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord1dv(const GLdouble * v) {
    PFN_GLTEXCOORD1DV _ptr;
    _ptr = (PFN_GLTEXCOORD1DV)_getPublicProcAddress("glTexCoord1dv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord1dv;
    }
    _glTexCoord1dv = _ptr;
    _glTexCoord1dv(v);
}

PFN_GLTEXCOORD1DV _glTexCoord1dv = &_get_glTexCoord1dv;

static void APIENTRY _fail_glTexCoord1f(GLfloat s) {
    const char *_name = "glTexCoord1f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord1f(GLfloat s) {
    PFN_GLTEXCOORD1F _ptr;
    _ptr = (PFN_GLTEXCOORD1F)_getPublicProcAddress("glTexCoord1f");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord1f;
    }
    _glTexCoord1f = _ptr;
    _glTexCoord1f(s);
}

PFN_GLTEXCOORD1F _glTexCoord1f = &_get_glTexCoord1f;

static void APIENTRY _fail_glTexCoord1fv(const GLfloat * v) {
    const char *_name = "glTexCoord1fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord1fv(const GLfloat * v) {
    PFN_GLTEXCOORD1FV _ptr;
    _ptr = (PFN_GLTEXCOORD1FV)_getPublicProcAddress("glTexCoord1fv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord1fv;
    }
    _glTexCoord1fv = _ptr;
    _glTexCoord1fv(v);
}

PFN_GLTEXCOORD1FV _glTexCoord1fv = &_get_glTexCoord1fv;

static void APIENTRY _fail_glTexCoord1i(GLint s) {
    const char *_name = "glTexCoord1i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord1i(GLint s) {
    PFN_GLTEXCOORD1I _ptr;
    _ptr = (PFN_GLTEXCOORD1I)_getPublicProcAddress("glTexCoord1i");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord1i;
    }
    _glTexCoord1i = _ptr;
    _glTexCoord1i(s);
}

PFN_GLTEXCOORD1I _glTexCoord1i = &_get_glTexCoord1i;

static void APIENTRY _fail_glTexCoord1iv(const GLint * v) {
    const char *_name = "glTexCoord1iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord1iv(const GLint * v) {
    PFN_GLTEXCOORD1IV _ptr;
    _ptr = (PFN_GLTEXCOORD1IV)_getPublicProcAddress("glTexCoord1iv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord1iv;
    }
    _glTexCoord1iv = _ptr;
    _glTexCoord1iv(v);
}

PFN_GLTEXCOORD1IV _glTexCoord1iv = &_get_glTexCoord1iv;

static void APIENTRY _fail_glTexCoord1s(GLshort s) {
    const char *_name = "glTexCoord1s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord1s(GLshort s) {
    PFN_GLTEXCOORD1S _ptr;
    _ptr = (PFN_GLTEXCOORD1S)_getPublicProcAddress("glTexCoord1s");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord1s;
    }
    _glTexCoord1s = _ptr;
    _glTexCoord1s(s);
}

PFN_GLTEXCOORD1S _glTexCoord1s = &_get_glTexCoord1s;

static void APIENTRY _fail_glTexCoord1sv(const GLshort * v) {
    const char *_name = "glTexCoord1sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord1sv(const GLshort * v) {
    PFN_GLTEXCOORD1SV _ptr;
    _ptr = (PFN_GLTEXCOORD1SV)_getPublicProcAddress("glTexCoord1sv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord1sv;
    }
    _glTexCoord1sv = _ptr;
    _glTexCoord1sv(v);
}

PFN_GLTEXCOORD1SV _glTexCoord1sv = &_get_glTexCoord1sv;

static void APIENTRY _fail_glTexCoord2d(GLdouble s, GLdouble t) {
    const char *_name = "glTexCoord2d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2d(GLdouble s, GLdouble t) {
    PFN_GLTEXCOORD2D _ptr;
    _ptr = (PFN_GLTEXCOORD2D)_getPublicProcAddress("glTexCoord2d");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2d;
    }
    _glTexCoord2d = _ptr;
    _glTexCoord2d(s, t);
}

PFN_GLTEXCOORD2D _glTexCoord2d = &_get_glTexCoord2d;

static void APIENTRY _fail_glTexCoord2dv(const GLdouble * v) {
    const char *_name = "glTexCoord2dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2dv(const GLdouble * v) {
    PFN_GLTEXCOORD2DV _ptr;
    _ptr = (PFN_GLTEXCOORD2DV)_getPublicProcAddress("glTexCoord2dv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2dv;
    }
    _glTexCoord2dv = _ptr;
    _glTexCoord2dv(v);
}

PFN_GLTEXCOORD2DV _glTexCoord2dv = &_get_glTexCoord2dv;

static void APIENTRY _fail_glTexCoord2f(GLfloat s, GLfloat t) {
    const char *_name = "glTexCoord2f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2f(GLfloat s, GLfloat t) {
    PFN_GLTEXCOORD2F _ptr;
    _ptr = (PFN_GLTEXCOORD2F)_getPublicProcAddress("glTexCoord2f");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2f;
    }
    _glTexCoord2f = _ptr;
    _glTexCoord2f(s, t);
}

PFN_GLTEXCOORD2F _glTexCoord2f = &_get_glTexCoord2f;

static void APIENTRY _fail_glTexCoord2fv(const GLfloat * v) {
    const char *_name = "glTexCoord2fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2fv(const GLfloat * v) {
    PFN_GLTEXCOORD2FV _ptr;
    _ptr = (PFN_GLTEXCOORD2FV)_getPublicProcAddress("glTexCoord2fv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2fv;
    }
    _glTexCoord2fv = _ptr;
    _glTexCoord2fv(v);
}

PFN_GLTEXCOORD2FV _glTexCoord2fv = &_get_glTexCoord2fv;

static void APIENTRY _fail_glTexCoord2i(GLint s, GLint t) {
    const char *_name = "glTexCoord2i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2i(GLint s, GLint t) {
    PFN_GLTEXCOORD2I _ptr;
    _ptr = (PFN_GLTEXCOORD2I)_getPublicProcAddress("glTexCoord2i");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2i;
    }
    _glTexCoord2i = _ptr;
    _glTexCoord2i(s, t);
}

PFN_GLTEXCOORD2I _glTexCoord2i = &_get_glTexCoord2i;

static void APIENTRY _fail_glTexCoord2iv(const GLint * v) {
    const char *_name = "glTexCoord2iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2iv(const GLint * v) {
    PFN_GLTEXCOORD2IV _ptr;
    _ptr = (PFN_GLTEXCOORD2IV)_getPublicProcAddress("glTexCoord2iv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2iv;
    }
    _glTexCoord2iv = _ptr;
    _glTexCoord2iv(v);
}

PFN_GLTEXCOORD2IV _glTexCoord2iv = &_get_glTexCoord2iv;

static void APIENTRY _fail_glTexCoord2s(GLshort s, GLshort t) {
    const char *_name = "glTexCoord2s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2s(GLshort s, GLshort t) {
    PFN_GLTEXCOORD2S _ptr;
    _ptr = (PFN_GLTEXCOORD2S)_getPublicProcAddress("glTexCoord2s");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2s;
    }
    _glTexCoord2s = _ptr;
    _glTexCoord2s(s, t);
}

PFN_GLTEXCOORD2S _glTexCoord2s = &_get_glTexCoord2s;

static void APIENTRY _fail_glTexCoord2sv(const GLshort * v) {
    const char *_name = "glTexCoord2sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2sv(const GLshort * v) {
    PFN_GLTEXCOORD2SV _ptr;
    _ptr = (PFN_GLTEXCOORD2SV)_getPublicProcAddress("glTexCoord2sv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2sv;
    }
    _glTexCoord2sv = _ptr;
    _glTexCoord2sv(v);
}

PFN_GLTEXCOORD2SV _glTexCoord2sv = &_get_glTexCoord2sv;

static void APIENTRY _fail_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r) {
    const char *_name = "glTexCoord3d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r) {
    PFN_GLTEXCOORD3D _ptr;
    _ptr = (PFN_GLTEXCOORD3D)_getPublicProcAddress("glTexCoord3d");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord3d;
    }
    _glTexCoord3d = _ptr;
    _glTexCoord3d(s, t, r);
}

PFN_GLTEXCOORD3D _glTexCoord3d = &_get_glTexCoord3d;

static void APIENTRY _fail_glTexCoord3dv(const GLdouble * v) {
    const char *_name = "glTexCoord3dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord3dv(const GLdouble * v) {
    PFN_GLTEXCOORD3DV _ptr;
    _ptr = (PFN_GLTEXCOORD3DV)_getPublicProcAddress("glTexCoord3dv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord3dv;
    }
    _glTexCoord3dv = _ptr;
    _glTexCoord3dv(v);
}

PFN_GLTEXCOORD3DV _glTexCoord3dv = &_get_glTexCoord3dv;

static void APIENTRY _fail_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r) {
    const char *_name = "glTexCoord3f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r) {
    PFN_GLTEXCOORD3F _ptr;
    _ptr = (PFN_GLTEXCOORD3F)_getPublicProcAddress("glTexCoord3f");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord3f;
    }
    _glTexCoord3f = _ptr;
    _glTexCoord3f(s, t, r);
}

PFN_GLTEXCOORD3F _glTexCoord3f = &_get_glTexCoord3f;

static void APIENTRY _fail_glTexCoord3fv(const GLfloat * v) {
    const char *_name = "glTexCoord3fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord3fv(const GLfloat * v) {
    PFN_GLTEXCOORD3FV _ptr;
    _ptr = (PFN_GLTEXCOORD3FV)_getPublicProcAddress("glTexCoord3fv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord3fv;
    }
    _glTexCoord3fv = _ptr;
    _glTexCoord3fv(v);
}

PFN_GLTEXCOORD3FV _glTexCoord3fv = &_get_glTexCoord3fv;

static void APIENTRY _fail_glTexCoord3i(GLint s, GLint t, GLint r) {
    const char *_name = "glTexCoord3i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord3i(GLint s, GLint t, GLint r) {
    PFN_GLTEXCOORD3I _ptr;
    _ptr = (PFN_GLTEXCOORD3I)_getPublicProcAddress("glTexCoord3i");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord3i;
    }
    _glTexCoord3i = _ptr;
    _glTexCoord3i(s, t, r);
}

PFN_GLTEXCOORD3I _glTexCoord3i = &_get_glTexCoord3i;

static void APIENTRY _fail_glTexCoord3iv(const GLint * v) {
    const char *_name = "glTexCoord3iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord3iv(const GLint * v) {
    PFN_GLTEXCOORD3IV _ptr;
    _ptr = (PFN_GLTEXCOORD3IV)_getPublicProcAddress("glTexCoord3iv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord3iv;
    }
    _glTexCoord3iv = _ptr;
    _glTexCoord3iv(v);
}

PFN_GLTEXCOORD3IV _glTexCoord3iv = &_get_glTexCoord3iv;

static void APIENTRY _fail_glTexCoord3s(GLshort s, GLshort t, GLshort r) {
    const char *_name = "glTexCoord3s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord3s(GLshort s, GLshort t, GLshort r) {
    PFN_GLTEXCOORD3S _ptr;
    _ptr = (PFN_GLTEXCOORD3S)_getPublicProcAddress("glTexCoord3s");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord3s;
    }
    _glTexCoord3s = _ptr;
    _glTexCoord3s(s, t, r);
}

PFN_GLTEXCOORD3S _glTexCoord3s = &_get_glTexCoord3s;

static void APIENTRY _fail_glTexCoord3sv(const GLshort * v) {
    const char *_name = "glTexCoord3sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord3sv(const GLshort * v) {
    PFN_GLTEXCOORD3SV _ptr;
    _ptr = (PFN_GLTEXCOORD3SV)_getPublicProcAddress("glTexCoord3sv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord3sv;
    }
    _glTexCoord3sv = _ptr;
    _glTexCoord3sv(v);
}

PFN_GLTEXCOORD3SV _glTexCoord3sv = &_get_glTexCoord3sv;

static void APIENTRY _fail_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q) {
    const char *_name = "glTexCoord4d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q) {
    PFN_GLTEXCOORD4D _ptr;
    _ptr = (PFN_GLTEXCOORD4D)_getPublicProcAddress("glTexCoord4d");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord4d;
    }
    _glTexCoord4d = _ptr;
    _glTexCoord4d(s, t, r, q);
}

PFN_GLTEXCOORD4D _glTexCoord4d = &_get_glTexCoord4d;

static void APIENTRY _fail_glTexCoord4dv(const GLdouble * v) {
    const char *_name = "glTexCoord4dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord4dv(const GLdouble * v) {
    PFN_GLTEXCOORD4DV _ptr;
    _ptr = (PFN_GLTEXCOORD4DV)_getPublicProcAddress("glTexCoord4dv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord4dv;
    }
    _glTexCoord4dv = _ptr;
    _glTexCoord4dv(v);
}

PFN_GLTEXCOORD4DV _glTexCoord4dv = &_get_glTexCoord4dv;

static void APIENTRY _fail_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
    const char *_name = "glTexCoord4f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
    PFN_GLTEXCOORD4F _ptr;
    _ptr = (PFN_GLTEXCOORD4F)_getPublicProcAddress("glTexCoord4f");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord4f;
    }
    _glTexCoord4f = _ptr;
    _glTexCoord4f(s, t, r, q);
}

PFN_GLTEXCOORD4F _glTexCoord4f = &_get_glTexCoord4f;

static void APIENTRY _fail_glTexCoord4fv(const GLfloat * v) {
    const char *_name = "glTexCoord4fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord4fv(const GLfloat * v) {
    PFN_GLTEXCOORD4FV _ptr;
    _ptr = (PFN_GLTEXCOORD4FV)_getPublicProcAddress("glTexCoord4fv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord4fv;
    }
    _glTexCoord4fv = _ptr;
    _glTexCoord4fv(v);
}

PFN_GLTEXCOORD4FV _glTexCoord4fv = &_get_glTexCoord4fv;

static void APIENTRY _fail_glTexCoord4i(GLint s, GLint t, GLint r, GLint q) {
    const char *_name = "glTexCoord4i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord4i(GLint s, GLint t, GLint r, GLint q) {
    PFN_GLTEXCOORD4I _ptr;
    _ptr = (PFN_GLTEXCOORD4I)_getPublicProcAddress("glTexCoord4i");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord4i;
    }
    _glTexCoord4i = _ptr;
    _glTexCoord4i(s, t, r, q);
}

PFN_GLTEXCOORD4I _glTexCoord4i = &_get_glTexCoord4i;

static void APIENTRY _fail_glTexCoord4iv(const GLint * v) {
    const char *_name = "glTexCoord4iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord4iv(const GLint * v) {
    PFN_GLTEXCOORD4IV _ptr;
    _ptr = (PFN_GLTEXCOORD4IV)_getPublicProcAddress("glTexCoord4iv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord4iv;
    }
    _glTexCoord4iv = _ptr;
    _glTexCoord4iv(v);
}

PFN_GLTEXCOORD4IV _glTexCoord4iv = &_get_glTexCoord4iv;

static void APIENTRY _fail_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q) {
    const char *_name = "glTexCoord4s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q) {
    PFN_GLTEXCOORD4S _ptr;
    _ptr = (PFN_GLTEXCOORD4S)_getPublicProcAddress("glTexCoord4s");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord4s;
    }
    _glTexCoord4s = _ptr;
    _glTexCoord4s(s, t, r, q);
}

PFN_GLTEXCOORD4S _glTexCoord4s = &_get_glTexCoord4s;

static void APIENTRY _fail_glTexCoord4sv(const GLshort * v) {
    const char *_name = "glTexCoord4sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord4sv(const GLshort * v) {
    PFN_GLTEXCOORD4SV _ptr;
    _ptr = (PFN_GLTEXCOORD4SV)_getPublicProcAddress("glTexCoord4sv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord4sv;
    }
    _glTexCoord4sv = _ptr;
    _glTexCoord4sv(v);
}

PFN_GLTEXCOORD4SV _glTexCoord4sv = &_get_glTexCoord4sv;

static void APIENTRY _fail_glVertex2d(GLdouble x, GLdouble y) {
    const char *_name = "glVertex2d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex2d(GLdouble x, GLdouble y) {
    PFN_GLVERTEX2D _ptr;
    _ptr = (PFN_GLVERTEX2D)_getPublicProcAddress("glVertex2d");
    if (!_ptr) {
        _ptr = &_fail_glVertex2d;
    }
    _glVertex2d = _ptr;
    _glVertex2d(x, y);
}

PFN_GLVERTEX2D _glVertex2d = &_get_glVertex2d;

static void APIENTRY _fail_glVertex2dv(const GLdouble * v) {
    const char *_name = "glVertex2dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex2dv(const GLdouble * v) {
    PFN_GLVERTEX2DV _ptr;
    _ptr = (PFN_GLVERTEX2DV)_getPublicProcAddress("glVertex2dv");
    if (!_ptr) {
        _ptr = &_fail_glVertex2dv;
    }
    _glVertex2dv = _ptr;
    _glVertex2dv(v);
}

PFN_GLVERTEX2DV _glVertex2dv = &_get_glVertex2dv;

static void APIENTRY _fail_glVertex2f(GLfloat x, GLfloat y) {
    const char *_name = "glVertex2f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex2f(GLfloat x, GLfloat y) {
    PFN_GLVERTEX2F _ptr;
    _ptr = (PFN_GLVERTEX2F)_getPublicProcAddress("glVertex2f");
    if (!_ptr) {
        _ptr = &_fail_glVertex2f;
    }
    _glVertex2f = _ptr;
    _glVertex2f(x, y);
}

PFN_GLVERTEX2F _glVertex2f = &_get_glVertex2f;

static void APIENTRY _fail_glVertex2fv(const GLfloat * v) {
    const char *_name = "glVertex2fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex2fv(const GLfloat * v) {
    PFN_GLVERTEX2FV _ptr;
    _ptr = (PFN_GLVERTEX2FV)_getPublicProcAddress("glVertex2fv");
    if (!_ptr) {
        _ptr = &_fail_glVertex2fv;
    }
    _glVertex2fv = _ptr;
    _glVertex2fv(v);
}

PFN_GLVERTEX2FV _glVertex2fv = &_get_glVertex2fv;

static void APIENTRY _fail_glVertex2i(GLint x, GLint y) {
    const char *_name = "glVertex2i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex2i(GLint x, GLint y) {
    PFN_GLVERTEX2I _ptr;
    _ptr = (PFN_GLVERTEX2I)_getPublicProcAddress("glVertex2i");
    if (!_ptr) {
        _ptr = &_fail_glVertex2i;
    }
    _glVertex2i = _ptr;
    _glVertex2i(x, y);
}

PFN_GLVERTEX2I _glVertex2i = &_get_glVertex2i;

static void APIENTRY _fail_glVertex2iv(const GLint * v) {
    const char *_name = "glVertex2iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex2iv(const GLint * v) {
    PFN_GLVERTEX2IV _ptr;
    _ptr = (PFN_GLVERTEX2IV)_getPublicProcAddress("glVertex2iv");
    if (!_ptr) {
        _ptr = &_fail_glVertex2iv;
    }
    _glVertex2iv = _ptr;
    _glVertex2iv(v);
}

PFN_GLVERTEX2IV _glVertex2iv = &_get_glVertex2iv;

static void APIENTRY _fail_glVertex2s(GLshort x, GLshort y) {
    const char *_name = "glVertex2s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex2s(GLshort x, GLshort y) {
    PFN_GLVERTEX2S _ptr;
    _ptr = (PFN_GLVERTEX2S)_getPublicProcAddress("glVertex2s");
    if (!_ptr) {
        _ptr = &_fail_glVertex2s;
    }
    _glVertex2s = _ptr;
    _glVertex2s(x, y);
}

PFN_GLVERTEX2S _glVertex2s = &_get_glVertex2s;

static void APIENTRY _fail_glVertex2sv(const GLshort * v) {
    const char *_name = "glVertex2sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex2sv(const GLshort * v) {
    PFN_GLVERTEX2SV _ptr;
    _ptr = (PFN_GLVERTEX2SV)_getPublicProcAddress("glVertex2sv");
    if (!_ptr) {
        _ptr = &_fail_glVertex2sv;
    }
    _glVertex2sv = _ptr;
    _glVertex2sv(v);
}

PFN_GLVERTEX2SV _glVertex2sv = &_get_glVertex2sv;

static void APIENTRY _fail_glVertex3d(GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glVertex3d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex3d(GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLVERTEX3D _ptr;
    _ptr = (PFN_GLVERTEX3D)_getPublicProcAddress("glVertex3d");
    if (!_ptr) {
        _ptr = &_fail_glVertex3d;
    }
    _glVertex3d = _ptr;
    _glVertex3d(x, y, z);
}

PFN_GLVERTEX3D _glVertex3d = &_get_glVertex3d;

static void APIENTRY _fail_glVertex3dv(const GLdouble * v) {
    const char *_name = "glVertex3dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex3dv(const GLdouble * v) {
    PFN_GLVERTEX3DV _ptr;
    _ptr = (PFN_GLVERTEX3DV)_getPublicProcAddress("glVertex3dv");
    if (!_ptr) {
        _ptr = &_fail_glVertex3dv;
    }
    _glVertex3dv = _ptr;
    _glVertex3dv(v);
}

PFN_GLVERTEX3DV _glVertex3dv = &_get_glVertex3dv;

static void APIENTRY _fail_glVertex3f(GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glVertex3f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex3f(GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLVERTEX3F _ptr;
    _ptr = (PFN_GLVERTEX3F)_getPublicProcAddress("glVertex3f");
    if (!_ptr) {
        _ptr = &_fail_glVertex3f;
    }
    _glVertex3f = _ptr;
    _glVertex3f(x, y, z);
}

PFN_GLVERTEX3F _glVertex3f = &_get_glVertex3f;

static void APIENTRY _fail_glVertex3fv(const GLfloat * v) {
    const char *_name = "glVertex3fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex3fv(const GLfloat * v) {
    PFN_GLVERTEX3FV _ptr;
    _ptr = (PFN_GLVERTEX3FV)_getPublicProcAddress("glVertex3fv");
    if (!_ptr) {
        _ptr = &_fail_glVertex3fv;
    }
    _glVertex3fv = _ptr;
    _glVertex3fv(v);
}

PFN_GLVERTEX3FV _glVertex3fv = &_get_glVertex3fv;

static void APIENTRY _fail_glVertex3i(GLint x, GLint y, GLint z) {
    const char *_name = "glVertex3i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex3i(GLint x, GLint y, GLint z) {
    PFN_GLVERTEX3I _ptr;
    _ptr = (PFN_GLVERTEX3I)_getPublicProcAddress("glVertex3i");
    if (!_ptr) {
        _ptr = &_fail_glVertex3i;
    }
    _glVertex3i = _ptr;
    _glVertex3i(x, y, z);
}

PFN_GLVERTEX3I _glVertex3i = &_get_glVertex3i;

static void APIENTRY _fail_glVertex3iv(const GLint * v) {
    const char *_name = "glVertex3iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex3iv(const GLint * v) {
    PFN_GLVERTEX3IV _ptr;
    _ptr = (PFN_GLVERTEX3IV)_getPublicProcAddress("glVertex3iv");
    if (!_ptr) {
        _ptr = &_fail_glVertex3iv;
    }
    _glVertex3iv = _ptr;
    _glVertex3iv(v);
}

PFN_GLVERTEX3IV _glVertex3iv = &_get_glVertex3iv;

static void APIENTRY _fail_glVertex3s(GLshort x, GLshort y, GLshort z) {
    const char *_name = "glVertex3s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex3s(GLshort x, GLshort y, GLshort z) {
    PFN_GLVERTEX3S _ptr;
    _ptr = (PFN_GLVERTEX3S)_getPublicProcAddress("glVertex3s");
    if (!_ptr) {
        _ptr = &_fail_glVertex3s;
    }
    _glVertex3s = _ptr;
    _glVertex3s(x, y, z);
}

PFN_GLVERTEX3S _glVertex3s = &_get_glVertex3s;

static void APIENTRY _fail_glVertex3sv(const GLshort * v) {
    const char *_name = "glVertex3sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex3sv(const GLshort * v) {
    PFN_GLVERTEX3SV _ptr;
    _ptr = (PFN_GLVERTEX3SV)_getPublicProcAddress("glVertex3sv");
    if (!_ptr) {
        _ptr = &_fail_glVertex3sv;
    }
    _glVertex3sv = _ptr;
    _glVertex3sv(v);
}

PFN_GLVERTEX3SV _glVertex3sv = &_get_glVertex3sv;

static void APIENTRY _fail_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glVertex4d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    PFN_GLVERTEX4D _ptr;
    _ptr = (PFN_GLVERTEX4D)_getPublicProcAddress("glVertex4d");
    if (!_ptr) {
        _ptr = &_fail_glVertex4d;
    }
    _glVertex4d = _ptr;
    _glVertex4d(x, y, z, w);
}

PFN_GLVERTEX4D _glVertex4d = &_get_glVertex4d;

static void APIENTRY _fail_glVertex4dv(const GLdouble * v) {
    const char *_name = "glVertex4dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex4dv(const GLdouble * v) {
    PFN_GLVERTEX4DV _ptr;
    _ptr = (PFN_GLVERTEX4DV)_getPublicProcAddress("glVertex4dv");
    if (!_ptr) {
        _ptr = &_fail_glVertex4dv;
    }
    _glVertex4dv = _ptr;
    _glVertex4dv(v);
}

PFN_GLVERTEX4DV _glVertex4dv = &_get_glVertex4dv;

static void APIENTRY _fail_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glVertex4f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    PFN_GLVERTEX4F _ptr;
    _ptr = (PFN_GLVERTEX4F)_getPublicProcAddress("glVertex4f");
    if (!_ptr) {
        _ptr = &_fail_glVertex4f;
    }
    _glVertex4f = _ptr;
    _glVertex4f(x, y, z, w);
}

PFN_GLVERTEX4F _glVertex4f = &_get_glVertex4f;

static void APIENTRY _fail_glVertex4fv(const GLfloat * v) {
    const char *_name = "glVertex4fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex4fv(const GLfloat * v) {
    PFN_GLVERTEX4FV _ptr;
    _ptr = (PFN_GLVERTEX4FV)_getPublicProcAddress("glVertex4fv");
    if (!_ptr) {
        _ptr = &_fail_glVertex4fv;
    }
    _glVertex4fv = _ptr;
    _glVertex4fv(v);
}

PFN_GLVERTEX4FV _glVertex4fv = &_get_glVertex4fv;

static void APIENTRY _fail_glVertex4i(GLint x, GLint y, GLint z, GLint w) {
    const char *_name = "glVertex4i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex4i(GLint x, GLint y, GLint z, GLint w) {
    PFN_GLVERTEX4I _ptr;
    _ptr = (PFN_GLVERTEX4I)_getPublicProcAddress("glVertex4i");
    if (!_ptr) {
        _ptr = &_fail_glVertex4i;
    }
    _glVertex4i = _ptr;
    _glVertex4i(x, y, z, w);
}

PFN_GLVERTEX4I _glVertex4i = &_get_glVertex4i;

static void APIENTRY _fail_glVertex4iv(const GLint * v) {
    const char *_name = "glVertex4iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex4iv(const GLint * v) {
    PFN_GLVERTEX4IV _ptr;
    _ptr = (PFN_GLVERTEX4IV)_getPublicProcAddress("glVertex4iv");
    if (!_ptr) {
        _ptr = &_fail_glVertex4iv;
    }
    _glVertex4iv = _ptr;
    _glVertex4iv(v);
}

PFN_GLVERTEX4IV _glVertex4iv = &_get_glVertex4iv;

static void APIENTRY _fail_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w) {
    const char *_name = "glVertex4s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w) {
    PFN_GLVERTEX4S _ptr;
    _ptr = (PFN_GLVERTEX4S)_getPublicProcAddress("glVertex4s");
    if (!_ptr) {
        _ptr = &_fail_glVertex4s;
    }
    _glVertex4s = _ptr;
    _glVertex4s(x, y, z, w);
}

PFN_GLVERTEX4S _glVertex4s = &_get_glVertex4s;

static void APIENTRY _fail_glVertex4sv(const GLshort * v) {
    const char *_name = "glVertex4sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex4sv(const GLshort * v) {
    PFN_GLVERTEX4SV _ptr;
    _ptr = (PFN_GLVERTEX4SV)_getPublicProcAddress("glVertex4sv");
    if (!_ptr) {
        _ptr = &_fail_glVertex4sv;
    }
    _glVertex4sv = _ptr;
    _glVertex4sv(v);
}

PFN_GLVERTEX4SV _glVertex4sv = &_get_glVertex4sv;

static void APIENTRY _fail_glClipPlane(GLenum plane, const GLdouble * equation) {
    const char *_name = "glClipPlane";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClipPlane(GLenum plane, const GLdouble * equation) {
    PFN_GLCLIPPLANE _ptr;
    _ptr = (PFN_GLCLIPPLANE)_getPublicProcAddress("glClipPlane");
    if (!_ptr) {
        _ptr = &_fail_glClipPlane;
    }
    _glClipPlane = _ptr;
    _glClipPlane(plane, equation);
}

PFN_GLCLIPPLANE _glClipPlane = &_get_glClipPlane;

static void APIENTRY _fail_glColorMaterial(GLenum face, GLenum mode) {
    const char *_name = "glColorMaterial";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorMaterial(GLenum face, GLenum mode) {
    PFN_GLCOLORMATERIAL _ptr;
    _ptr = (PFN_GLCOLORMATERIAL)_getPublicProcAddress("glColorMaterial");
    if (!_ptr) {
        _ptr = &_fail_glColorMaterial;
    }
    _glColorMaterial = _ptr;
    _glColorMaterial(face, mode);
}

PFN_GLCOLORMATERIAL _glColorMaterial = &_get_glColorMaterial;

static void APIENTRY _fail_glFogf(GLenum pname, GLfloat param) {
    const char *_name = "glFogf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogf(GLenum pname, GLfloat param) {
    PFN_GLFOGF _ptr;
    _ptr = (PFN_GLFOGF)_getPublicProcAddress("glFogf");
    if (!_ptr) {
        _ptr = &_fail_glFogf;
    }
    _glFogf = _ptr;
    _glFogf(pname, param);
}

PFN_GLFOGF _glFogf = &_get_glFogf;

static void APIENTRY _fail_glFogfv(GLenum pname, const GLfloat * params) {
    const char *_name = "glFogfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogfv(GLenum pname, const GLfloat * params) {
    PFN_GLFOGFV _ptr;
    _ptr = (PFN_GLFOGFV)_getPublicProcAddress("glFogfv");
    if (!_ptr) {
        _ptr = &_fail_glFogfv;
    }
    _glFogfv = _ptr;
    _glFogfv(pname, params);
}

PFN_GLFOGFV _glFogfv = &_get_glFogfv;

static void APIENTRY _fail_glFogi(GLenum pname, GLint param) {
    const char *_name = "glFogi";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogi(GLenum pname, GLint param) {
    PFN_GLFOGI _ptr;
    _ptr = (PFN_GLFOGI)_getPublicProcAddress("glFogi");
    if (!_ptr) {
        _ptr = &_fail_glFogi;
    }
    _glFogi = _ptr;
    _glFogi(pname, param);
}

PFN_GLFOGI _glFogi = &_get_glFogi;

static void APIENTRY _fail_glFogiv(GLenum pname, const GLint * params) {
    const char *_name = "glFogiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogiv(GLenum pname, const GLint * params) {
    PFN_GLFOGIV _ptr;
    _ptr = (PFN_GLFOGIV)_getPublicProcAddress("glFogiv");
    if (!_ptr) {
        _ptr = &_fail_glFogiv;
    }
    _glFogiv = _ptr;
    _glFogiv(pname, params);
}

PFN_GLFOGIV _glFogiv = &_get_glFogiv;

static void APIENTRY _fail_glLightf(GLenum light, GLenum pname, GLfloat param) {
    const char *_name = "glLightf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLightf(GLenum light, GLenum pname, GLfloat param) {
    PFN_GLLIGHTF _ptr;
    _ptr = (PFN_GLLIGHTF)_getPublicProcAddress("glLightf");
    if (!_ptr) {
        _ptr = &_fail_glLightf;
    }
    _glLightf = _ptr;
    _glLightf(light, pname, param);
}

PFN_GLLIGHTF _glLightf = &_get_glLightf;

static void APIENTRY _fail_glLightfv(GLenum light, GLenum pname, const GLfloat * params) {
    const char *_name = "glLightfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLightfv(GLenum light, GLenum pname, const GLfloat * params) {
    PFN_GLLIGHTFV _ptr;
    _ptr = (PFN_GLLIGHTFV)_getPublicProcAddress("glLightfv");
    if (!_ptr) {
        _ptr = &_fail_glLightfv;
    }
    _glLightfv = _ptr;
    _glLightfv(light, pname, params);
}

PFN_GLLIGHTFV _glLightfv = &_get_glLightfv;

static void APIENTRY _fail_glLighti(GLenum light, GLenum pname, GLint param) {
    const char *_name = "glLighti";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLighti(GLenum light, GLenum pname, GLint param) {
    PFN_GLLIGHTI _ptr;
    _ptr = (PFN_GLLIGHTI)_getPublicProcAddress("glLighti");
    if (!_ptr) {
        _ptr = &_fail_glLighti;
    }
    _glLighti = _ptr;
    _glLighti(light, pname, param);
}

PFN_GLLIGHTI _glLighti = &_get_glLighti;

static void APIENTRY _fail_glLightiv(GLenum light, GLenum pname, const GLint * params) {
    const char *_name = "glLightiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLightiv(GLenum light, GLenum pname, const GLint * params) {
    PFN_GLLIGHTIV _ptr;
    _ptr = (PFN_GLLIGHTIV)_getPublicProcAddress("glLightiv");
    if (!_ptr) {
        _ptr = &_fail_glLightiv;
    }
    _glLightiv = _ptr;
    _glLightiv(light, pname, params);
}

PFN_GLLIGHTIV _glLightiv = &_get_glLightiv;

static void APIENTRY _fail_glLightModelf(GLenum pname, GLfloat param) {
    const char *_name = "glLightModelf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLightModelf(GLenum pname, GLfloat param) {
    PFN_GLLIGHTMODELF _ptr;
    _ptr = (PFN_GLLIGHTMODELF)_getPublicProcAddress("glLightModelf");
    if (!_ptr) {
        _ptr = &_fail_glLightModelf;
    }
    _glLightModelf = _ptr;
    _glLightModelf(pname, param);
}

PFN_GLLIGHTMODELF _glLightModelf = &_get_glLightModelf;

static void APIENTRY _fail_glLightModelfv(GLenum pname, const GLfloat * params) {
    const char *_name = "glLightModelfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLightModelfv(GLenum pname, const GLfloat * params) {
    PFN_GLLIGHTMODELFV _ptr;
    _ptr = (PFN_GLLIGHTMODELFV)_getPublicProcAddress("glLightModelfv");
    if (!_ptr) {
        _ptr = &_fail_glLightModelfv;
    }
    _glLightModelfv = _ptr;
    _glLightModelfv(pname, params);
}

PFN_GLLIGHTMODELFV _glLightModelfv = &_get_glLightModelfv;

static void APIENTRY _fail_glLightModeli(GLenum pname, GLint param) {
    const char *_name = "glLightModeli";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLightModeli(GLenum pname, GLint param) {
    PFN_GLLIGHTMODELI _ptr;
    _ptr = (PFN_GLLIGHTMODELI)_getPublicProcAddress("glLightModeli");
    if (!_ptr) {
        _ptr = &_fail_glLightModeli;
    }
    _glLightModeli = _ptr;
    _glLightModeli(pname, param);
}

PFN_GLLIGHTMODELI _glLightModeli = &_get_glLightModeli;

static void APIENTRY _fail_glLightModeliv(GLenum pname, const GLint * params) {
    const char *_name = "glLightModeliv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLightModeliv(GLenum pname, const GLint * params) {
    PFN_GLLIGHTMODELIV _ptr;
    _ptr = (PFN_GLLIGHTMODELIV)_getPublicProcAddress("glLightModeliv");
    if (!_ptr) {
        _ptr = &_fail_glLightModeliv;
    }
    _glLightModeliv = _ptr;
    _glLightModeliv(pname, params);
}

PFN_GLLIGHTMODELIV _glLightModeliv = &_get_glLightModeliv;

static void APIENTRY _fail_glLineStipple(GLint factor, GLushort pattern) {
    const char *_name = "glLineStipple";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLineStipple(GLint factor, GLushort pattern) {
    PFN_GLLINESTIPPLE _ptr;
    _ptr = (PFN_GLLINESTIPPLE)_getPublicProcAddress("glLineStipple");
    if (!_ptr) {
        _ptr = &_fail_glLineStipple;
    }
    _glLineStipple = _ptr;
    _glLineStipple(factor, pattern);
}

PFN_GLLINESTIPPLE _glLineStipple = &_get_glLineStipple;

static void APIENTRY _fail_glMaterialf(GLenum face, GLenum pname, GLfloat param) {
    const char *_name = "glMaterialf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMaterialf(GLenum face, GLenum pname, GLfloat param) {
    PFN_GLMATERIALF _ptr;
    _ptr = (PFN_GLMATERIALF)_getPublicProcAddress("glMaterialf");
    if (!_ptr) {
        _ptr = &_fail_glMaterialf;
    }
    _glMaterialf = _ptr;
    _glMaterialf(face, pname, param);
}

PFN_GLMATERIALF _glMaterialf = &_get_glMaterialf;

static void APIENTRY _fail_glMaterialfv(GLenum face, GLenum pname, const GLfloat * params) {
    const char *_name = "glMaterialfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMaterialfv(GLenum face, GLenum pname, const GLfloat * params) {
    PFN_GLMATERIALFV _ptr;
    _ptr = (PFN_GLMATERIALFV)_getPublicProcAddress("glMaterialfv");
    if (!_ptr) {
        _ptr = &_fail_glMaterialfv;
    }
    _glMaterialfv = _ptr;
    _glMaterialfv(face, pname, params);
}

PFN_GLMATERIALFV _glMaterialfv = &_get_glMaterialfv;

static void APIENTRY _fail_glMateriali(GLenum face, GLenum pname, GLint param) {
    const char *_name = "glMateriali";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMateriali(GLenum face, GLenum pname, GLint param) {
    PFN_GLMATERIALI _ptr;
    _ptr = (PFN_GLMATERIALI)_getPublicProcAddress("glMateriali");
    if (!_ptr) {
        _ptr = &_fail_glMateriali;
    }
    _glMateriali = _ptr;
    _glMateriali(face, pname, param);
}

PFN_GLMATERIALI _glMateriali = &_get_glMateriali;

static void APIENTRY _fail_glMaterialiv(GLenum face, GLenum pname, const GLint * params) {
    const char *_name = "glMaterialiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMaterialiv(GLenum face, GLenum pname, const GLint * params) {
    PFN_GLMATERIALIV _ptr;
    _ptr = (PFN_GLMATERIALIV)_getPublicProcAddress("glMaterialiv");
    if (!_ptr) {
        _ptr = &_fail_glMaterialiv;
    }
    _glMaterialiv = _ptr;
    _glMaterialiv(face, pname, params);
}

PFN_GLMATERIALIV _glMaterialiv = &_get_glMaterialiv;

static void APIENTRY _fail_glPolygonStipple(const GLubyte * mask) {
    const char *_name = "glPolygonStipple";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPolygonStipple(const GLubyte * mask) {
    PFN_GLPOLYGONSTIPPLE _ptr;
    _ptr = (PFN_GLPOLYGONSTIPPLE)_getPublicProcAddress("glPolygonStipple");
    if (!_ptr) {
        _ptr = &_fail_glPolygonStipple;
    }
    _glPolygonStipple = _ptr;
    _glPolygonStipple(mask);
}

PFN_GLPOLYGONSTIPPLE _glPolygonStipple = &_get_glPolygonStipple;

static void APIENTRY _fail_glShadeModel(GLenum mode) {
    const char *_name = "glShadeModel";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glShadeModel(GLenum mode) {
    PFN_GLSHADEMODEL _ptr;
    _ptr = (PFN_GLSHADEMODEL)_getPublicProcAddress("glShadeModel");
    if (!_ptr) {
        _ptr = &_fail_glShadeModel;
    }
    _glShadeModel = _ptr;
    _glShadeModel(mode);
}

PFN_GLSHADEMODEL _glShadeModel = &_get_glShadeModel;

static void APIENTRY _fail_glTexEnvf(GLenum target, GLenum pname, GLfloat param) {
    const char *_name = "glTexEnvf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexEnvf(GLenum target, GLenum pname, GLfloat param) {
    PFN_GLTEXENVF _ptr;
    _ptr = (PFN_GLTEXENVF)_getPublicProcAddress("glTexEnvf");
    if (!_ptr) {
        _ptr = &_fail_glTexEnvf;
    }
    _glTexEnvf = _ptr;
    _glTexEnvf(target, pname, param);
}

PFN_GLTEXENVF _glTexEnvf = &_get_glTexEnvf;

static void APIENTRY _fail_glTexEnvfv(GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glTexEnvfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexEnvfv(GLenum target, GLenum pname, const GLfloat * params) {
    PFN_GLTEXENVFV _ptr;
    _ptr = (PFN_GLTEXENVFV)_getPublicProcAddress("glTexEnvfv");
    if (!_ptr) {
        _ptr = &_fail_glTexEnvfv;
    }
    _glTexEnvfv = _ptr;
    _glTexEnvfv(target, pname, params);
}

PFN_GLTEXENVFV _glTexEnvfv = &_get_glTexEnvfv;

static void APIENTRY _fail_glTexEnvi(GLenum target, GLenum pname, GLint param) {
    const char *_name = "glTexEnvi";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexEnvi(GLenum target, GLenum pname, GLint param) {
    PFN_GLTEXENVI _ptr;
    _ptr = (PFN_GLTEXENVI)_getPublicProcAddress("glTexEnvi");
    if (!_ptr) {
        _ptr = &_fail_glTexEnvi;
    }
    _glTexEnvi = _ptr;
    _glTexEnvi(target, pname, param);
}

PFN_GLTEXENVI _glTexEnvi = &_get_glTexEnvi;

static void APIENTRY _fail_glTexEnviv(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glTexEnviv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexEnviv(GLenum target, GLenum pname, const GLint * params) {
    PFN_GLTEXENVIV _ptr;
    _ptr = (PFN_GLTEXENVIV)_getPublicProcAddress("glTexEnviv");
    if (!_ptr) {
        _ptr = &_fail_glTexEnviv;
    }
    _glTexEnviv = _ptr;
    _glTexEnviv(target, pname, params);
}

PFN_GLTEXENVIV _glTexEnviv = &_get_glTexEnviv;

static void APIENTRY _fail_glTexGend(GLenum coord, GLenum pname, GLdouble param) {
    const char *_name = "glTexGend";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexGend(GLenum coord, GLenum pname, GLdouble param) {
    PFN_GLTEXGEND _ptr;
    _ptr = (PFN_GLTEXGEND)_getPublicProcAddress("glTexGend");
    if (!_ptr) {
        _ptr = &_fail_glTexGend;
    }
    _glTexGend = _ptr;
    _glTexGend(coord, pname, param);
}

PFN_GLTEXGEND _glTexGend = &_get_glTexGend;

static void APIENTRY _fail_glTexGendv(GLenum coord, GLenum pname, const GLdouble * params) {
    const char *_name = "glTexGendv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexGendv(GLenum coord, GLenum pname, const GLdouble * params) {
    PFN_GLTEXGENDV _ptr;
    _ptr = (PFN_GLTEXGENDV)_getPublicProcAddress("glTexGendv");
    if (!_ptr) {
        _ptr = &_fail_glTexGendv;
    }
    _glTexGendv = _ptr;
    _glTexGendv(coord, pname, params);
}

PFN_GLTEXGENDV _glTexGendv = &_get_glTexGendv;

static void APIENTRY _fail_glTexGenf(GLenum coord, GLenum pname, GLfloat param) {
    const char *_name = "glTexGenf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexGenf(GLenum coord, GLenum pname, GLfloat param) {
    PFN_GLTEXGENF _ptr;
    _ptr = (PFN_GLTEXGENF)_getPublicProcAddress("glTexGenf");
    if (!_ptr) {
        _ptr = &_fail_glTexGenf;
    }
    _glTexGenf = _ptr;
    _glTexGenf(coord, pname, param);
}

PFN_GLTEXGENF _glTexGenf = &_get_glTexGenf;

static void APIENTRY _fail_glTexGenfv(GLenum coord, GLenum pname, const GLfloat * params) {
    const char *_name = "glTexGenfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexGenfv(GLenum coord, GLenum pname, const GLfloat * params) {
    PFN_GLTEXGENFV _ptr;
    _ptr = (PFN_GLTEXGENFV)_getPublicProcAddress("glTexGenfv");
    if (!_ptr) {
        _ptr = &_fail_glTexGenfv;
    }
    _glTexGenfv = _ptr;
    _glTexGenfv(coord, pname, params);
}

PFN_GLTEXGENFV _glTexGenfv = &_get_glTexGenfv;

static void APIENTRY _fail_glTexGeni(GLenum coord, GLenum pname, GLint param) {
    const char *_name = "glTexGeni";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexGeni(GLenum coord, GLenum pname, GLint param) {
    PFN_GLTEXGENI _ptr;
    _ptr = (PFN_GLTEXGENI)_getPublicProcAddress("glTexGeni");
    if (!_ptr) {
        _ptr = &_fail_glTexGeni;
    }
    _glTexGeni = _ptr;
    _glTexGeni(coord, pname, param);
}

PFN_GLTEXGENI _glTexGeni = &_get_glTexGeni;

static void APIENTRY _fail_glTexGeniv(GLenum coord, GLenum pname, const GLint * params) {
    const char *_name = "glTexGeniv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexGeniv(GLenum coord, GLenum pname, const GLint * params) {
    PFN_GLTEXGENIV _ptr;
    _ptr = (PFN_GLTEXGENIV)_getPublicProcAddress("glTexGeniv");
    if (!_ptr) {
        _ptr = &_fail_glTexGeniv;
    }
    _glTexGeniv = _ptr;
    _glTexGeniv(coord, pname, params);
}

PFN_GLTEXGENIV _glTexGeniv = &_get_glTexGeniv;

static void APIENTRY _fail_glFeedbackBuffer(GLsizei size, GLenum type, GLfloat * buffer) {
    const char *_name = "glFeedbackBuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFeedbackBuffer(GLsizei size, GLenum type, GLfloat * buffer) {
    PFN_GLFEEDBACKBUFFER _ptr;
    _ptr = (PFN_GLFEEDBACKBUFFER)_getPublicProcAddress("glFeedbackBuffer");
    if (!_ptr) {
        _ptr = &_fail_glFeedbackBuffer;
    }
    _glFeedbackBuffer = _ptr;
    _glFeedbackBuffer(size, type, buffer);
}

PFN_GLFEEDBACKBUFFER _glFeedbackBuffer = &_get_glFeedbackBuffer;

static void APIENTRY _fail_glSelectBuffer(GLsizei size, GLuint * buffer) {
    const char *_name = "glSelectBuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSelectBuffer(GLsizei size, GLuint * buffer) {
    PFN_GLSELECTBUFFER _ptr;
    _ptr = (PFN_GLSELECTBUFFER)_getPublicProcAddress("glSelectBuffer");
    if (!_ptr) {
        _ptr = &_fail_glSelectBuffer;
    }
    _glSelectBuffer = _ptr;
    _glSelectBuffer(size, buffer);
}

PFN_GLSELECTBUFFER _glSelectBuffer = &_get_glSelectBuffer;

static GLint APIENTRY _fail_glRenderMode(GLenum mode) {
    const char *_name = "glRenderMode";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLint APIENTRY _get_glRenderMode(GLenum mode) {
    PFN_GLRENDERMODE _ptr;
    _ptr = (PFN_GLRENDERMODE)_getPublicProcAddress("glRenderMode");
    if (!_ptr) {
        _ptr = &_fail_glRenderMode;
    }
    _glRenderMode = _ptr;
    return _glRenderMode(mode);
}

PFN_GLRENDERMODE _glRenderMode = &_get_glRenderMode;

static void APIENTRY _fail_glInitNames(void) {
    const char *_name = "glInitNames";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glInitNames(void) {
    PFN_GLINITNAMES _ptr;
    _ptr = (PFN_GLINITNAMES)_getPublicProcAddress("glInitNames");
    if (!_ptr) {
        _ptr = &_fail_glInitNames;
    }
    _glInitNames = _ptr;
    _glInitNames();
}

PFN_GLINITNAMES _glInitNames = &_get_glInitNames;

static void APIENTRY _fail_glLoadName(GLuint name) {
    const char *_name = "glLoadName";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLoadName(GLuint name) {
    PFN_GLLOADNAME _ptr;
    _ptr = (PFN_GLLOADNAME)_getPublicProcAddress("glLoadName");
    if (!_ptr) {
        _ptr = &_fail_glLoadName;
    }
    _glLoadName = _ptr;
    _glLoadName(name);
}

PFN_GLLOADNAME _glLoadName = &_get_glLoadName;

static void APIENTRY _fail_glPassThrough(GLfloat token) {
    const char *_name = "glPassThrough";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPassThrough(GLfloat token) {
    PFN_GLPASSTHROUGH _ptr;
    _ptr = (PFN_GLPASSTHROUGH)_getPublicProcAddress("glPassThrough");
    if (!_ptr) {
        _ptr = &_fail_glPassThrough;
    }
    _glPassThrough = _ptr;
    _glPassThrough(token);
}

PFN_GLPASSTHROUGH _glPassThrough = &_get_glPassThrough;

static void APIENTRY _fail_glPopName(void) {
    const char *_name = "glPopName";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPopName(void) {
    PFN_GLPOPNAME _ptr;
    _ptr = (PFN_GLPOPNAME)_getPublicProcAddress("glPopName");
    if (!_ptr) {
        _ptr = &_fail_glPopName;
    }
    _glPopName = _ptr;
    _glPopName();
}

PFN_GLPOPNAME _glPopName = &_get_glPopName;

static void APIENTRY _fail_glPushName(GLuint name) {
    const char *_name = "glPushName";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPushName(GLuint name) {
    PFN_GLPUSHNAME _ptr;
    _ptr = (PFN_GLPUSHNAME)_getPublicProcAddress("glPushName");
    if (!_ptr) {
        _ptr = &_fail_glPushName;
    }
    _glPushName = _ptr;
    _glPushName(name);
}

PFN_GLPUSHNAME _glPushName = &_get_glPushName;

static void APIENTRY _fail_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    const char *_name = "glClearAccum";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    PFN_GLCLEARACCUM _ptr;
    _ptr = (PFN_GLCLEARACCUM)_getPublicProcAddress("glClearAccum");
    if (!_ptr) {
        _ptr = &_fail_glClearAccum;
    }
    _glClearAccum = _ptr;
    _glClearAccum(red, green, blue, alpha);
}

PFN_GLCLEARACCUM _glClearAccum = &_get_glClearAccum;

static void APIENTRY _fail_glClearIndex(GLfloat c) {
    const char *_name = "glClearIndex";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearIndex(GLfloat c) {
    PFN_GLCLEARINDEX _ptr;
    _ptr = (PFN_GLCLEARINDEX)_getPublicProcAddress("glClearIndex");
    if (!_ptr) {
        _ptr = &_fail_glClearIndex;
    }
    _glClearIndex = _ptr;
    _glClearIndex(c);
}

PFN_GLCLEARINDEX _glClearIndex = &_get_glClearIndex;

static void APIENTRY _fail_glIndexMask(GLuint mask) {
    const char *_name = "glIndexMask";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glIndexMask(GLuint mask) {
    PFN_GLINDEXMASK _ptr;
    _ptr = (PFN_GLINDEXMASK)_getPublicProcAddress("glIndexMask");
    if (!_ptr) {
        _ptr = &_fail_glIndexMask;
    }
    _glIndexMask = _ptr;
    _glIndexMask(mask);
}

PFN_GLINDEXMASK _glIndexMask = &_get_glIndexMask;

static void APIENTRY _fail_glAccum(GLenum op, GLfloat value) {
    const char *_name = "glAccum";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glAccum(GLenum op, GLfloat value) {
    PFN_GLACCUM _ptr;
    _ptr = (PFN_GLACCUM)_getPublicProcAddress("glAccum");
    if (!_ptr) {
        _ptr = &_fail_glAccum;
    }
    _glAccum = _ptr;
    _glAccum(op, value);
}

PFN_GLACCUM _glAccum = &_get_glAccum;

static void APIENTRY _fail_glPopAttrib(void) {
    const char *_name = "glPopAttrib";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPopAttrib(void) {
    PFN_GLPOPATTRIB _ptr;
    _ptr = (PFN_GLPOPATTRIB)_getPublicProcAddress("glPopAttrib");
    if (!_ptr) {
        _ptr = &_fail_glPopAttrib;
    }
    _glPopAttrib = _ptr;
    _glPopAttrib();
}

PFN_GLPOPATTRIB _glPopAttrib = &_get_glPopAttrib;

static void APIENTRY _fail_glPushAttrib(GLbitfield mask) {
    const char *_name = "glPushAttrib";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPushAttrib(GLbitfield mask) {
    PFN_GLPUSHATTRIB _ptr;
    _ptr = (PFN_GLPUSHATTRIB)_getPublicProcAddress("glPushAttrib");
    if (!_ptr) {
        _ptr = &_fail_glPushAttrib;
    }
    _glPushAttrib = _ptr;
    _glPushAttrib(mask);
}

PFN_GLPUSHATTRIB _glPushAttrib = &_get_glPushAttrib;

static void APIENTRY _fail_glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points) {
    const char *_name = "glMap1d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points) {
    PFN_GLMAP1D _ptr;
    _ptr = (PFN_GLMAP1D)_getPublicProcAddress("glMap1d");
    if (!_ptr) {
        _ptr = &_fail_glMap1d;
    }
    _glMap1d = _ptr;
    _glMap1d(target, u1, u2, stride, order, points);
}

PFN_GLMAP1D _glMap1d = &_get_glMap1d;

static void APIENTRY _fail_glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points) {
    const char *_name = "glMap1f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points) {
    PFN_GLMAP1F _ptr;
    _ptr = (PFN_GLMAP1F)_getPublicProcAddress("glMap1f");
    if (!_ptr) {
        _ptr = &_fail_glMap1f;
    }
    _glMap1f = _ptr;
    _glMap1f(target, u1, u2, stride, order, points);
}

PFN_GLMAP1F _glMap1f = &_get_glMap1f;

static void APIENTRY _fail_glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points) {
    const char *_name = "glMap2d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points) {
    PFN_GLMAP2D _ptr;
    _ptr = (PFN_GLMAP2D)_getPublicProcAddress("glMap2d");
    if (!_ptr) {
        _ptr = &_fail_glMap2d;
    }
    _glMap2d = _ptr;
    _glMap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

PFN_GLMAP2D _glMap2d = &_get_glMap2d;

static void APIENTRY _fail_glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points) {
    const char *_name = "glMap2f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points) {
    PFN_GLMAP2F _ptr;
    _ptr = (PFN_GLMAP2F)_getPublicProcAddress("glMap2f");
    if (!_ptr) {
        _ptr = &_fail_glMap2f;
    }
    _glMap2f = _ptr;
    _glMap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

PFN_GLMAP2F _glMap2f = &_get_glMap2f;

static void APIENTRY _fail_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2) {
    const char *_name = "glMapGrid1d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2) {
    PFN_GLMAPGRID1D _ptr;
    _ptr = (PFN_GLMAPGRID1D)_getPublicProcAddress("glMapGrid1d");
    if (!_ptr) {
        _ptr = &_fail_glMapGrid1d;
    }
    _glMapGrid1d = _ptr;
    _glMapGrid1d(un, u1, u2);
}

PFN_GLMAPGRID1D _glMapGrid1d = &_get_glMapGrid1d;

static void APIENTRY _fail_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2) {
    const char *_name = "glMapGrid1f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2) {
    PFN_GLMAPGRID1F _ptr;
    _ptr = (PFN_GLMAPGRID1F)_getPublicProcAddress("glMapGrid1f");
    if (!_ptr) {
        _ptr = &_fail_glMapGrid1f;
    }
    _glMapGrid1f = _ptr;
    _glMapGrid1f(un, u1, u2);
}

PFN_GLMAPGRID1F _glMapGrid1f = &_get_glMapGrid1f;

static void APIENTRY _fail_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) {
    const char *_name = "glMapGrid2d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) {
    PFN_GLMAPGRID2D _ptr;
    _ptr = (PFN_GLMAPGRID2D)_getPublicProcAddress("glMapGrid2d");
    if (!_ptr) {
        _ptr = &_fail_glMapGrid2d;
    }
    _glMapGrid2d = _ptr;
    _glMapGrid2d(un, u1, u2, vn, v1, v2);
}

PFN_GLMAPGRID2D _glMapGrid2d = &_get_glMapGrid2d;

static void APIENTRY _fail_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) {
    const char *_name = "glMapGrid2f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) {
    PFN_GLMAPGRID2F _ptr;
    _ptr = (PFN_GLMAPGRID2F)_getPublicProcAddress("glMapGrid2f");
    if (!_ptr) {
        _ptr = &_fail_glMapGrid2f;
    }
    _glMapGrid2f = _ptr;
    _glMapGrid2f(un, u1, u2, vn, v1, v2);
}

PFN_GLMAPGRID2F _glMapGrid2f = &_get_glMapGrid2f;

static void APIENTRY _fail_glEvalCoord1d(GLdouble u) {
    const char *_name = "glEvalCoord1d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEvalCoord1d(GLdouble u) {
    PFN_GLEVALCOORD1D _ptr;
    _ptr = (PFN_GLEVALCOORD1D)_getPublicProcAddress("glEvalCoord1d");
    if (!_ptr) {
        _ptr = &_fail_glEvalCoord1d;
    }
    _glEvalCoord1d = _ptr;
    _glEvalCoord1d(u);
}

PFN_GLEVALCOORD1D _glEvalCoord1d = &_get_glEvalCoord1d;

static void APIENTRY _fail_glEvalCoord1dv(const GLdouble * u) {
    const char *_name = "glEvalCoord1dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEvalCoord1dv(const GLdouble * u) {
    PFN_GLEVALCOORD1DV _ptr;
    _ptr = (PFN_GLEVALCOORD1DV)_getPublicProcAddress("glEvalCoord1dv");
    if (!_ptr) {
        _ptr = &_fail_glEvalCoord1dv;
    }
    _glEvalCoord1dv = _ptr;
    _glEvalCoord1dv(u);
}

PFN_GLEVALCOORD1DV _glEvalCoord1dv = &_get_glEvalCoord1dv;

static void APIENTRY _fail_glEvalCoord1f(GLfloat u) {
    const char *_name = "glEvalCoord1f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEvalCoord1f(GLfloat u) {
    PFN_GLEVALCOORD1F _ptr;
    _ptr = (PFN_GLEVALCOORD1F)_getPublicProcAddress("glEvalCoord1f");
    if (!_ptr) {
        _ptr = &_fail_glEvalCoord1f;
    }
    _glEvalCoord1f = _ptr;
    _glEvalCoord1f(u);
}

PFN_GLEVALCOORD1F _glEvalCoord1f = &_get_glEvalCoord1f;

static void APIENTRY _fail_glEvalCoord1fv(const GLfloat * u) {
    const char *_name = "glEvalCoord1fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEvalCoord1fv(const GLfloat * u) {
    PFN_GLEVALCOORD1FV _ptr;
    _ptr = (PFN_GLEVALCOORD1FV)_getPublicProcAddress("glEvalCoord1fv");
    if (!_ptr) {
        _ptr = &_fail_glEvalCoord1fv;
    }
    _glEvalCoord1fv = _ptr;
    _glEvalCoord1fv(u);
}

PFN_GLEVALCOORD1FV _glEvalCoord1fv = &_get_glEvalCoord1fv;

static void APIENTRY _fail_glEvalCoord2d(GLdouble u, GLdouble v) {
    const char *_name = "glEvalCoord2d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEvalCoord2d(GLdouble u, GLdouble v) {
    PFN_GLEVALCOORD2D _ptr;
    _ptr = (PFN_GLEVALCOORD2D)_getPublicProcAddress("glEvalCoord2d");
    if (!_ptr) {
        _ptr = &_fail_glEvalCoord2d;
    }
    _glEvalCoord2d = _ptr;
    _glEvalCoord2d(u, v);
}

PFN_GLEVALCOORD2D _glEvalCoord2d = &_get_glEvalCoord2d;

static void APIENTRY _fail_glEvalCoord2dv(const GLdouble * u) {
    const char *_name = "glEvalCoord2dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEvalCoord2dv(const GLdouble * u) {
    PFN_GLEVALCOORD2DV _ptr;
    _ptr = (PFN_GLEVALCOORD2DV)_getPublicProcAddress("glEvalCoord2dv");
    if (!_ptr) {
        _ptr = &_fail_glEvalCoord2dv;
    }
    _glEvalCoord2dv = _ptr;
    _glEvalCoord2dv(u);
}

PFN_GLEVALCOORD2DV _glEvalCoord2dv = &_get_glEvalCoord2dv;

static void APIENTRY _fail_glEvalCoord2f(GLfloat u, GLfloat v) {
    const char *_name = "glEvalCoord2f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEvalCoord2f(GLfloat u, GLfloat v) {
    PFN_GLEVALCOORD2F _ptr;
    _ptr = (PFN_GLEVALCOORD2F)_getPublicProcAddress("glEvalCoord2f");
    if (!_ptr) {
        _ptr = &_fail_glEvalCoord2f;
    }
    _glEvalCoord2f = _ptr;
    _glEvalCoord2f(u, v);
}

PFN_GLEVALCOORD2F _glEvalCoord2f = &_get_glEvalCoord2f;

static void APIENTRY _fail_glEvalCoord2fv(const GLfloat * u) {
    const char *_name = "glEvalCoord2fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEvalCoord2fv(const GLfloat * u) {
    PFN_GLEVALCOORD2FV _ptr;
    _ptr = (PFN_GLEVALCOORD2FV)_getPublicProcAddress("glEvalCoord2fv");
    if (!_ptr) {
        _ptr = &_fail_glEvalCoord2fv;
    }
    _glEvalCoord2fv = _ptr;
    _glEvalCoord2fv(u);
}

PFN_GLEVALCOORD2FV _glEvalCoord2fv = &_get_glEvalCoord2fv;

static void APIENTRY _fail_glEvalMesh1(GLenum mode, GLint i1, GLint i2) {
    const char *_name = "glEvalMesh1";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEvalMesh1(GLenum mode, GLint i1, GLint i2) {
    PFN_GLEVALMESH1 _ptr;
    _ptr = (PFN_GLEVALMESH1)_getPublicProcAddress("glEvalMesh1");
    if (!_ptr) {
        _ptr = &_fail_glEvalMesh1;
    }
    _glEvalMesh1 = _ptr;
    _glEvalMesh1(mode, i1, i2);
}

PFN_GLEVALMESH1 _glEvalMesh1 = &_get_glEvalMesh1;

static void APIENTRY _fail_glEvalPoint1(GLint i) {
    const char *_name = "glEvalPoint1";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEvalPoint1(GLint i) {
    PFN_GLEVALPOINT1 _ptr;
    _ptr = (PFN_GLEVALPOINT1)_getPublicProcAddress("glEvalPoint1");
    if (!_ptr) {
        _ptr = &_fail_glEvalPoint1;
    }
    _glEvalPoint1 = _ptr;
    _glEvalPoint1(i);
}

PFN_GLEVALPOINT1 _glEvalPoint1 = &_get_glEvalPoint1;

static void APIENTRY _fail_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2) {
    const char *_name = "glEvalMesh2";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2) {
    PFN_GLEVALMESH2 _ptr;
    _ptr = (PFN_GLEVALMESH2)_getPublicProcAddress("glEvalMesh2");
    if (!_ptr) {
        _ptr = &_fail_glEvalMesh2;
    }
    _glEvalMesh2 = _ptr;
    _glEvalMesh2(mode, i1, i2, j1, j2);
}

PFN_GLEVALMESH2 _glEvalMesh2 = &_get_glEvalMesh2;

static void APIENTRY _fail_glEvalPoint2(GLint i, GLint j) {
    const char *_name = "glEvalPoint2";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEvalPoint2(GLint i, GLint j) {
    PFN_GLEVALPOINT2 _ptr;
    _ptr = (PFN_GLEVALPOINT2)_getPublicProcAddress("glEvalPoint2");
    if (!_ptr) {
        _ptr = &_fail_glEvalPoint2;
    }
    _glEvalPoint2 = _ptr;
    _glEvalPoint2(i, j);
}

PFN_GLEVALPOINT2 _glEvalPoint2 = &_get_glEvalPoint2;

static void APIENTRY _fail_glAlphaFunc(GLenum func, GLfloat ref) {
    const char *_name = "glAlphaFunc";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glAlphaFunc(GLenum func, GLfloat ref) {
    PFN_GLALPHAFUNC _ptr;
    _ptr = (PFN_GLALPHAFUNC)_getPublicProcAddress("glAlphaFunc");
    if (!_ptr) {
        _ptr = &_fail_glAlphaFunc;
    }
    _glAlphaFunc = _ptr;
    _glAlphaFunc(func, ref);
}

PFN_GLALPHAFUNC _glAlphaFunc = &_get_glAlphaFunc;

static void APIENTRY _fail_glPixelZoom(GLfloat xfactor, GLfloat yfactor) {
    const char *_name = "glPixelZoom";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPixelZoom(GLfloat xfactor, GLfloat yfactor) {
    PFN_GLPIXELZOOM _ptr;
    _ptr = (PFN_GLPIXELZOOM)_getPublicProcAddress("glPixelZoom");
    if (!_ptr) {
        _ptr = &_fail_glPixelZoom;
    }
    _glPixelZoom = _ptr;
    _glPixelZoom(xfactor, yfactor);
}

PFN_GLPIXELZOOM _glPixelZoom = &_get_glPixelZoom;

static void APIENTRY _fail_glPixelTransferf(GLenum pname, GLfloat param) {
    const char *_name = "glPixelTransferf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPixelTransferf(GLenum pname, GLfloat param) {
    PFN_GLPIXELTRANSFERF _ptr;
    _ptr = (PFN_GLPIXELTRANSFERF)_getPublicProcAddress("glPixelTransferf");
    if (!_ptr) {
        _ptr = &_fail_glPixelTransferf;
    }
    _glPixelTransferf = _ptr;
    _glPixelTransferf(pname, param);
}

PFN_GLPIXELTRANSFERF _glPixelTransferf = &_get_glPixelTransferf;

static void APIENTRY _fail_glPixelTransferi(GLenum pname, GLint param) {
    const char *_name = "glPixelTransferi";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPixelTransferi(GLenum pname, GLint param) {
    PFN_GLPIXELTRANSFERI _ptr;
    _ptr = (PFN_GLPIXELTRANSFERI)_getPublicProcAddress("glPixelTransferi");
    if (!_ptr) {
        _ptr = &_fail_glPixelTransferi;
    }
    _glPixelTransferi = _ptr;
    _glPixelTransferi(pname, param);
}

PFN_GLPIXELTRANSFERI _glPixelTransferi = &_get_glPixelTransferi;

static void APIENTRY _fail_glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat * values) {
    const char *_name = "glPixelMapfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat * values) {
    PFN_GLPIXELMAPFV _ptr;
    _ptr = (PFN_GLPIXELMAPFV)_getPublicProcAddress("glPixelMapfv");
    if (!_ptr) {
        _ptr = &_fail_glPixelMapfv;
    }
    _glPixelMapfv = _ptr;
    _glPixelMapfv(map, mapsize, values);
}

PFN_GLPIXELMAPFV _glPixelMapfv = &_get_glPixelMapfv;

static void APIENTRY _fail_glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint * values) {
    const char *_name = "glPixelMapuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint * values) {
    PFN_GLPIXELMAPUIV _ptr;
    _ptr = (PFN_GLPIXELMAPUIV)_getPublicProcAddress("glPixelMapuiv");
    if (!_ptr) {
        _ptr = &_fail_glPixelMapuiv;
    }
    _glPixelMapuiv = _ptr;
    _glPixelMapuiv(map, mapsize, values);
}

PFN_GLPIXELMAPUIV _glPixelMapuiv = &_get_glPixelMapuiv;

static void APIENTRY _fail_glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort * values) {
    const char *_name = "glPixelMapusv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort * values) {
    PFN_GLPIXELMAPUSV _ptr;
    _ptr = (PFN_GLPIXELMAPUSV)_getPublicProcAddress("glPixelMapusv");
    if (!_ptr) {
        _ptr = &_fail_glPixelMapusv;
    }
    _glPixelMapusv = _ptr;
    _glPixelMapusv(map, mapsize, values);
}

PFN_GLPIXELMAPUSV _glPixelMapusv = &_get_glPixelMapusv;

static void APIENTRY _fail_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type) {
    const char *_name = "glCopyPixels";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type) {
    PFN_GLCOPYPIXELS _ptr;
    _ptr = (PFN_GLCOPYPIXELS)_getPublicProcAddress("glCopyPixels");
    if (!_ptr) {
        _ptr = &_fail_glCopyPixels;
    }
    _glCopyPixels = _ptr;
    _glCopyPixels(x, y, width, height, type);
}

PFN_GLCOPYPIXELS _glCopyPixels = &_get_glCopyPixels;

static void APIENTRY _fail_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glDrawPixels";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLDRAWPIXELS _ptr;
    _ptr = (PFN_GLDRAWPIXELS)_getPublicProcAddress("glDrawPixels");
    if (!_ptr) {
        _ptr = &_fail_glDrawPixels;
    }
    _glDrawPixels = _ptr;
    _glDrawPixels(width, height, format, type, pixels);
}

PFN_GLDRAWPIXELS _glDrawPixels = &_get_glDrawPixels;

static void APIENTRY _fail_glGetClipPlane(GLenum plane, GLdouble * equation) {
    const char *_name = "glGetClipPlane";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetClipPlane(GLenum plane, GLdouble * equation) {
    PFN_GLGETCLIPPLANE _ptr;
    _ptr = (PFN_GLGETCLIPPLANE)_getPublicProcAddress("glGetClipPlane");
    if (!_ptr) {
        _ptr = &_fail_glGetClipPlane;
    }
    _glGetClipPlane = _ptr;
    _glGetClipPlane(plane, equation);
}

PFN_GLGETCLIPPLANE _glGetClipPlane = &_get_glGetClipPlane;

static void APIENTRY _fail_glGetLightfv(GLenum light, GLenum pname, GLfloat * params) {
    const char *_name = "glGetLightfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetLightfv(GLenum light, GLenum pname, GLfloat * params) {
    PFN_GLGETLIGHTFV _ptr;
    _ptr = (PFN_GLGETLIGHTFV)_getPublicProcAddress("glGetLightfv");
    if (!_ptr) {
        _ptr = &_fail_glGetLightfv;
    }
    _glGetLightfv = _ptr;
    _glGetLightfv(light, pname, params);
}

PFN_GLGETLIGHTFV _glGetLightfv = &_get_glGetLightfv;

static void APIENTRY _fail_glGetLightiv(GLenum light, GLenum pname, GLint * params) {
    const char *_name = "glGetLightiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetLightiv(GLenum light, GLenum pname, GLint * params) {
    PFN_GLGETLIGHTIV _ptr;
    _ptr = (PFN_GLGETLIGHTIV)_getPublicProcAddress("glGetLightiv");
    if (!_ptr) {
        _ptr = &_fail_glGetLightiv;
    }
    _glGetLightiv = _ptr;
    _glGetLightiv(light, pname, params);
}

PFN_GLGETLIGHTIV _glGetLightiv = &_get_glGetLightiv;

static void APIENTRY _fail_glGetMapdv(GLenum target, GLenum query, GLdouble * v) {
    const char *_name = "glGetMapdv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMapdv(GLenum target, GLenum query, GLdouble * v) {
    PFN_GLGETMAPDV _ptr;
    _ptr = (PFN_GLGETMAPDV)_getPublicProcAddress("glGetMapdv");
    if (!_ptr) {
        _ptr = &_fail_glGetMapdv;
    }
    _glGetMapdv = _ptr;
    _glGetMapdv(target, query, v);
}

PFN_GLGETMAPDV _glGetMapdv = &_get_glGetMapdv;

static void APIENTRY _fail_glGetMapfv(GLenum target, GLenum query, GLfloat * v) {
    const char *_name = "glGetMapfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMapfv(GLenum target, GLenum query, GLfloat * v) {
    PFN_GLGETMAPFV _ptr;
    _ptr = (PFN_GLGETMAPFV)_getPublicProcAddress("glGetMapfv");
    if (!_ptr) {
        _ptr = &_fail_glGetMapfv;
    }
    _glGetMapfv = _ptr;
    _glGetMapfv(target, query, v);
}

PFN_GLGETMAPFV _glGetMapfv = &_get_glGetMapfv;

static void APIENTRY _fail_glGetMapiv(GLenum target, GLenum query, GLint * v) {
    const char *_name = "glGetMapiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMapiv(GLenum target, GLenum query, GLint * v) {
    PFN_GLGETMAPIV _ptr;
    _ptr = (PFN_GLGETMAPIV)_getPublicProcAddress("glGetMapiv");
    if (!_ptr) {
        _ptr = &_fail_glGetMapiv;
    }
    _glGetMapiv = _ptr;
    _glGetMapiv(target, query, v);
}

PFN_GLGETMAPIV _glGetMapiv = &_get_glGetMapiv;

static void APIENTRY _fail_glGetMaterialfv(GLenum face, GLenum pname, GLfloat * params) {
    const char *_name = "glGetMaterialfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMaterialfv(GLenum face, GLenum pname, GLfloat * params) {
    PFN_GLGETMATERIALFV _ptr;
    _ptr = (PFN_GLGETMATERIALFV)_getPublicProcAddress("glGetMaterialfv");
    if (!_ptr) {
        _ptr = &_fail_glGetMaterialfv;
    }
    _glGetMaterialfv = _ptr;
    _glGetMaterialfv(face, pname, params);
}

PFN_GLGETMATERIALFV _glGetMaterialfv = &_get_glGetMaterialfv;

static void APIENTRY _fail_glGetMaterialiv(GLenum face, GLenum pname, GLint * params) {
    const char *_name = "glGetMaterialiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMaterialiv(GLenum face, GLenum pname, GLint * params) {
    PFN_GLGETMATERIALIV _ptr;
    _ptr = (PFN_GLGETMATERIALIV)_getPublicProcAddress("glGetMaterialiv");
    if (!_ptr) {
        _ptr = &_fail_glGetMaterialiv;
    }
    _glGetMaterialiv = _ptr;
    _glGetMaterialiv(face, pname, params);
}

PFN_GLGETMATERIALIV _glGetMaterialiv = &_get_glGetMaterialiv;

static void APIENTRY _fail_glGetPixelMapfv(GLenum map, GLfloat * values) {
    const char *_name = "glGetPixelMapfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPixelMapfv(GLenum map, GLfloat * values) {
    PFN_GLGETPIXELMAPFV _ptr;
    _ptr = (PFN_GLGETPIXELMAPFV)_getPublicProcAddress("glGetPixelMapfv");
    if (!_ptr) {
        _ptr = &_fail_glGetPixelMapfv;
    }
    _glGetPixelMapfv = _ptr;
    _glGetPixelMapfv(map, values);
}

PFN_GLGETPIXELMAPFV _glGetPixelMapfv = &_get_glGetPixelMapfv;

static void APIENTRY _fail_glGetPixelMapuiv(GLenum map, GLuint * values) {
    const char *_name = "glGetPixelMapuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPixelMapuiv(GLenum map, GLuint * values) {
    PFN_GLGETPIXELMAPUIV _ptr;
    _ptr = (PFN_GLGETPIXELMAPUIV)_getPublicProcAddress("glGetPixelMapuiv");
    if (!_ptr) {
        _ptr = &_fail_glGetPixelMapuiv;
    }
    _glGetPixelMapuiv = _ptr;
    _glGetPixelMapuiv(map, values);
}

PFN_GLGETPIXELMAPUIV _glGetPixelMapuiv = &_get_glGetPixelMapuiv;

static void APIENTRY _fail_glGetPixelMapusv(GLenum map, GLushort * values) {
    const char *_name = "glGetPixelMapusv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPixelMapusv(GLenum map, GLushort * values) {
    PFN_GLGETPIXELMAPUSV _ptr;
    _ptr = (PFN_GLGETPIXELMAPUSV)_getPublicProcAddress("glGetPixelMapusv");
    if (!_ptr) {
        _ptr = &_fail_glGetPixelMapusv;
    }
    _glGetPixelMapusv = _ptr;
    _glGetPixelMapusv(map, values);
}

PFN_GLGETPIXELMAPUSV _glGetPixelMapusv = &_get_glGetPixelMapusv;

static void APIENTRY _fail_glGetPolygonStipple(GLubyte * mask) {
    const char *_name = "glGetPolygonStipple";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPolygonStipple(GLubyte * mask) {
    PFN_GLGETPOLYGONSTIPPLE _ptr;
    _ptr = (PFN_GLGETPOLYGONSTIPPLE)_getPublicProcAddress("glGetPolygonStipple");
    if (!_ptr) {
        _ptr = &_fail_glGetPolygonStipple;
    }
    _glGetPolygonStipple = _ptr;
    _glGetPolygonStipple(mask);
}

PFN_GLGETPOLYGONSTIPPLE _glGetPolygonStipple = &_get_glGetPolygonStipple;

static void APIENTRY _fail_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetTexEnvfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat * params) {
    PFN_GLGETTEXENVFV _ptr;
    _ptr = (PFN_GLGETTEXENVFV)_getPublicProcAddress("glGetTexEnvfv");
    if (!_ptr) {
        _ptr = &_fail_glGetTexEnvfv;
    }
    _glGetTexEnvfv = _ptr;
    _glGetTexEnvfv(target, pname, params);
}

PFN_GLGETTEXENVFV _glGetTexEnvfv = &_get_glGetTexEnvfv;

static void APIENTRY _fail_glGetTexEnviv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetTexEnviv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexEnviv(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETTEXENVIV _ptr;
    _ptr = (PFN_GLGETTEXENVIV)_getPublicProcAddress("glGetTexEnviv");
    if (!_ptr) {
        _ptr = &_fail_glGetTexEnviv;
    }
    _glGetTexEnviv = _ptr;
    _glGetTexEnviv(target, pname, params);
}

PFN_GLGETTEXENVIV _glGetTexEnviv = &_get_glGetTexEnviv;

static void APIENTRY _fail_glGetTexGendv(GLenum coord, GLenum pname, GLdouble * params) {
    const char *_name = "glGetTexGendv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexGendv(GLenum coord, GLenum pname, GLdouble * params) {
    PFN_GLGETTEXGENDV _ptr;
    _ptr = (PFN_GLGETTEXGENDV)_getPublicProcAddress("glGetTexGendv");
    if (!_ptr) {
        _ptr = &_fail_glGetTexGendv;
    }
    _glGetTexGendv = _ptr;
    _glGetTexGendv(coord, pname, params);
}

PFN_GLGETTEXGENDV _glGetTexGendv = &_get_glGetTexGendv;

static void APIENTRY _fail_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat * params) {
    const char *_name = "glGetTexGenfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat * params) {
    PFN_GLGETTEXGENFV _ptr;
    _ptr = (PFN_GLGETTEXGENFV)_getPublicProcAddress("glGetTexGenfv");
    if (!_ptr) {
        _ptr = &_fail_glGetTexGenfv;
    }
    _glGetTexGenfv = _ptr;
    _glGetTexGenfv(coord, pname, params);
}

PFN_GLGETTEXGENFV _glGetTexGenfv = &_get_glGetTexGenfv;

static void APIENTRY _fail_glGetTexGeniv(GLenum coord, GLenum pname, GLint * params) {
    const char *_name = "glGetTexGeniv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexGeniv(GLenum coord, GLenum pname, GLint * params) {
    PFN_GLGETTEXGENIV _ptr;
    _ptr = (PFN_GLGETTEXGENIV)_getPublicProcAddress("glGetTexGeniv");
    if (!_ptr) {
        _ptr = &_fail_glGetTexGeniv;
    }
    _glGetTexGeniv = _ptr;
    _glGetTexGeniv(coord, pname, params);
}

PFN_GLGETTEXGENIV _glGetTexGeniv = &_get_glGetTexGeniv;

static GLboolean APIENTRY _fail_glIsList(GLuint list) {
    const char *_name = "glIsList";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsList(GLuint list) {
    PFN_GLISLIST _ptr;
    _ptr = (PFN_GLISLIST)_getPublicProcAddress("glIsList");
    if (!_ptr) {
        _ptr = &_fail_glIsList;
    }
    _glIsList = _ptr;
    return _glIsList(list);
}

PFN_GLISLIST _glIsList = &_get_glIsList;

static void APIENTRY _fail_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    const char *_name = "glFrustum";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    PFN_GLFRUSTUM _ptr;
    _ptr = (PFN_GLFRUSTUM)_getPublicProcAddress("glFrustum");
    if (!_ptr) {
        _ptr = &_fail_glFrustum;
    }
    _glFrustum = _ptr;
    _glFrustum(left, right, bottom, top, zNear, zFar);
}

PFN_GLFRUSTUM _glFrustum = &_get_glFrustum;

static void APIENTRY _fail_glLoadIdentity(void) {
    const char *_name = "glLoadIdentity";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLoadIdentity(void) {
    PFN_GLLOADIDENTITY _ptr;
    _ptr = (PFN_GLLOADIDENTITY)_getPublicProcAddress("glLoadIdentity");
    if (!_ptr) {
        _ptr = &_fail_glLoadIdentity;
    }
    _glLoadIdentity = _ptr;
    _glLoadIdentity();
}

PFN_GLLOADIDENTITY _glLoadIdentity = &_get_glLoadIdentity;

static void APIENTRY _fail_glLoadMatrixf(const GLfloat * m) {
    const char *_name = "glLoadMatrixf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLoadMatrixf(const GLfloat * m) {
    PFN_GLLOADMATRIXF _ptr;
    _ptr = (PFN_GLLOADMATRIXF)_getPublicProcAddress("glLoadMatrixf");
    if (!_ptr) {
        _ptr = &_fail_glLoadMatrixf;
    }
    _glLoadMatrixf = _ptr;
    _glLoadMatrixf(m);
}

PFN_GLLOADMATRIXF _glLoadMatrixf = &_get_glLoadMatrixf;

static void APIENTRY _fail_glLoadMatrixd(const GLdouble * m) {
    const char *_name = "glLoadMatrixd";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLoadMatrixd(const GLdouble * m) {
    PFN_GLLOADMATRIXD _ptr;
    _ptr = (PFN_GLLOADMATRIXD)_getPublicProcAddress("glLoadMatrixd");
    if (!_ptr) {
        _ptr = &_fail_glLoadMatrixd;
    }
    _glLoadMatrixd = _ptr;
    _glLoadMatrixd(m);
}

PFN_GLLOADMATRIXD _glLoadMatrixd = &_get_glLoadMatrixd;

static void APIENTRY _fail_glMatrixMode(GLenum mode) {
    const char *_name = "glMatrixMode";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixMode(GLenum mode) {
    PFN_GLMATRIXMODE _ptr;
    _ptr = (PFN_GLMATRIXMODE)_getPublicProcAddress("glMatrixMode");
    if (!_ptr) {
        _ptr = &_fail_glMatrixMode;
    }
    _glMatrixMode = _ptr;
    _glMatrixMode(mode);
}

PFN_GLMATRIXMODE _glMatrixMode = &_get_glMatrixMode;

static void APIENTRY _fail_glMultMatrixf(const GLfloat * m) {
    const char *_name = "glMultMatrixf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultMatrixf(const GLfloat * m) {
    PFN_GLMULTMATRIXF _ptr;
    _ptr = (PFN_GLMULTMATRIXF)_getPublicProcAddress("glMultMatrixf");
    if (!_ptr) {
        _ptr = &_fail_glMultMatrixf;
    }
    _glMultMatrixf = _ptr;
    _glMultMatrixf(m);
}

PFN_GLMULTMATRIXF _glMultMatrixf = &_get_glMultMatrixf;

static void APIENTRY _fail_glMultMatrixd(const GLdouble * m) {
    const char *_name = "glMultMatrixd";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultMatrixd(const GLdouble * m) {
    PFN_GLMULTMATRIXD _ptr;
    _ptr = (PFN_GLMULTMATRIXD)_getPublicProcAddress("glMultMatrixd");
    if (!_ptr) {
        _ptr = &_fail_glMultMatrixd;
    }
    _glMultMatrixd = _ptr;
    _glMultMatrixd(m);
}

PFN_GLMULTMATRIXD _glMultMatrixd = &_get_glMultMatrixd;

static void APIENTRY _fail_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    const char *_name = "glOrtho";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    PFN_GLORTHO _ptr;
    _ptr = (PFN_GLORTHO)_getPublicProcAddress("glOrtho");
    if (!_ptr) {
        _ptr = &_fail_glOrtho;
    }
    _glOrtho = _ptr;
    _glOrtho(left, right, bottom, top, zNear, zFar);
}

PFN_GLORTHO _glOrtho = &_get_glOrtho;

static void APIENTRY _fail_glPopMatrix(void) {
    const char *_name = "glPopMatrix";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPopMatrix(void) {
    PFN_GLPOPMATRIX _ptr;
    _ptr = (PFN_GLPOPMATRIX)_getPublicProcAddress("glPopMatrix");
    if (!_ptr) {
        _ptr = &_fail_glPopMatrix;
    }
    _glPopMatrix = _ptr;
    _glPopMatrix();
}

PFN_GLPOPMATRIX _glPopMatrix = &_get_glPopMatrix;

static void APIENTRY _fail_glPushMatrix(void) {
    const char *_name = "glPushMatrix";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPushMatrix(void) {
    PFN_GLPUSHMATRIX _ptr;
    _ptr = (PFN_GLPUSHMATRIX)_getPublicProcAddress("glPushMatrix");
    if (!_ptr) {
        _ptr = &_fail_glPushMatrix;
    }
    _glPushMatrix = _ptr;
    _glPushMatrix();
}

PFN_GLPUSHMATRIX _glPushMatrix = &_get_glPushMatrix;

static void APIENTRY _fail_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glRotated";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLROTATED _ptr;
    _ptr = (PFN_GLROTATED)_getPublicProcAddress("glRotated");
    if (!_ptr) {
        _ptr = &_fail_glRotated;
    }
    _glRotated = _ptr;
    _glRotated(angle, x, y, z);
}

PFN_GLROTATED _glRotated = &_get_glRotated;

static void APIENTRY _fail_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glRotatef";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLROTATEF _ptr;
    _ptr = (PFN_GLROTATEF)_getPublicProcAddress("glRotatef");
    if (!_ptr) {
        _ptr = &_fail_glRotatef;
    }
    _glRotatef = _ptr;
    _glRotatef(angle, x, y, z);
}

PFN_GLROTATEF _glRotatef = &_get_glRotatef;

static void APIENTRY _fail_glScaled(GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glScaled";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glScaled(GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLSCALED _ptr;
    _ptr = (PFN_GLSCALED)_getPublicProcAddress("glScaled");
    if (!_ptr) {
        _ptr = &_fail_glScaled;
    }
    _glScaled = _ptr;
    _glScaled(x, y, z);
}

PFN_GLSCALED _glScaled = &_get_glScaled;

static void APIENTRY _fail_glScalef(GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glScalef";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glScalef(GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLSCALEF _ptr;
    _ptr = (PFN_GLSCALEF)_getPublicProcAddress("glScalef");
    if (!_ptr) {
        _ptr = &_fail_glScalef;
    }
    _glScalef = _ptr;
    _glScalef(x, y, z);
}

PFN_GLSCALEF _glScalef = &_get_glScalef;

static void APIENTRY _fail_glTranslated(GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glTranslated";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTranslated(GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLTRANSLATED _ptr;
    _ptr = (PFN_GLTRANSLATED)_getPublicProcAddress("glTranslated");
    if (!_ptr) {
        _ptr = &_fail_glTranslated;
    }
    _glTranslated = _ptr;
    _glTranslated(x, y, z);
}

PFN_GLTRANSLATED _glTranslated = &_get_glTranslated;

static void APIENTRY _fail_glTranslatef(GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glTranslatef";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTranslatef(GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLTRANSLATEF _ptr;
    _ptr = (PFN_GLTRANSLATEF)_getPublicProcAddress("glTranslatef");
    if (!_ptr) {
        _ptr = &_fail_glTranslatef;
    }
    _glTranslatef = _ptr;
    _glTranslatef(x, y, z);
}

PFN_GLTRANSLATEF _glTranslatef = &_get_glTranslatef;

static void APIENTRY _fail_glDrawArrays(GLenum mode, GLint first, GLsizei count) {
    const char *_name = "glDrawArrays";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawArrays(GLenum mode, GLint first, GLsizei count) {
    PFN_GLDRAWARRAYS _ptr;
    _ptr = (PFN_GLDRAWARRAYS)_getPublicProcAddress("glDrawArrays");
    if (!_ptr) {
        _ptr = &_fail_glDrawArrays;
    }
    _glDrawArrays = _ptr;
    _glDrawArrays(mode, first, count);
}

PFN_GLDRAWARRAYS _glDrawArrays = &_get_glDrawArrays;

static void APIENTRY _fail_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices) {
    const char *_name = "glDrawElements";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices) {
    PFN_GLDRAWELEMENTS _ptr;
    _ptr = (PFN_GLDRAWELEMENTS)_getPublicProcAddress("glDrawElements");
    if (!_ptr) {
        _ptr = &_fail_glDrawElements;
    }
    _glDrawElements = _ptr;
    _glDrawElements(mode, count, type, indices);
}

PFN_GLDRAWELEMENTS _glDrawElements = &_get_glDrawElements;

static void APIENTRY _fail_glGetPointerv(GLenum pname, GLvoid * * params) {
    const char *_name = "glGetPointerv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPointerv(GLenum pname, GLvoid * * params) {
    PFN_GLGETPOINTERV _ptr;
    _ptr = (PFN_GLGETPOINTERV)_getPublicProcAddress("glGetPointerv");
    if (!_ptr) {
        _ptr = &_fail_glGetPointerv;
    }
    _glGetPointerv = _ptr;
    _glGetPointerv(pname, params);
}

PFN_GLGETPOINTERV _glGetPointerv = &_get_glGetPointerv;

static void APIENTRY _fail_glPolygonOffset(GLfloat factor, GLfloat units) {
    const char *_name = "glPolygonOffset";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPolygonOffset(GLfloat factor, GLfloat units) {
    PFN_GLPOLYGONOFFSET _ptr;
    _ptr = (PFN_GLPOLYGONOFFSET)_getPublicProcAddress("glPolygonOffset");
    if (!_ptr) {
        _ptr = &_fail_glPolygonOffset;
    }
    _glPolygonOffset = _ptr;
    _glPolygonOffset(factor, units);
}

PFN_GLPOLYGONOFFSET _glPolygonOffset = &_get_glPolygonOffset;

static void APIENTRY _fail_glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    const char *_name = "glCopyTexImage1D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    PFN_GLCOPYTEXIMAGE1D _ptr;
    _ptr = (PFN_GLCOPYTEXIMAGE1D)_getPublicProcAddress("glCopyTexImage1D");
    if (!_ptr) {
        _ptr = &_fail_glCopyTexImage1D;
    }
    _glCopyTexImage1D = _ptr;
    _glCopyTexImage1D(target, level, internalformat, x, y, width, border);
}

PFN_GLCOPYTEXIMAGE1D _glCopyTexImage1D = &_get_glCopyTexImage1D;

static void APIENTRY _fail_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    const char *_name = "glCopyTexImage2D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    PFN_GLCOPYTEXIMAGE2D _ptr;
    _ptr = (PFN_GLCOPYTEXIMAGE2D)_getPublicProcAddress("glCopyTexImage2D");
    if (!_ptr) {
        _ptr = &_fail_glCopyTexImage2D;
    }
    _glCopyTexImage2D = _ptr;
    _glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
}

PFN_GLCOPYTEXIMAGE2D _glCopyTexImage2D = &_get_glCopyTexImage2D;

static void APIENTRY _fail_glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyTexSubImage1D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    PFN_GLCOPYTEXSUBIMAGE1D _ptr;
    _ptr = (PFN_GLCOPYTEXSUBIMAGE1D)_getPublicProcAddress("glCopyTexSubImage1D");
    if (!_ptr) {
        _ptr = &_fail_glCopyTexSubImage1D;
    }
    _glCopyTexSubImage1D = _ptr;
    _glCopyTexSubImage1D(target, level, xoffset, x, y, width);
}

PFN_GLCOPYTEXSUBIMAGE1D _glCopyTexSubImage1D = &_get_glCopyTexSubImage1D;

static void APIENTRY _fail_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyTexSubImage2D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLCOPYTEXSUBIMAGE2D _ptr;
    _ptr = (PFN_GLCOPYTEXSUBIMAGE2D)_getPublicProcAddress("glCopyTexSubImage2D");
    if (!_ptr) {
        _ptr = &_fail_glCopyTexSubImage2D;
    }
    _glCopyTexSubImage2D = _ptr;
    _glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
}

PFN_GLCOPYTEXSUBIMAGE2D _glCopyTexSubImage2D = &_get_glCopyTexSubImage2D;

static void APIENTRY _fail_glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexSubImage1D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXSUBIMAGE1D _ptr;
    _ptr = (PFN_GLTEXSUBIMAGE1D)_getPublicProcAddress("glTexSubImage1D");
    if (!_ptr) {
        _ptr = &_fail_glTexSubImage1D;
    }
    _glTexSubImage1D = _ptr;
    _glTexSubImage1D(target, level, xoffset, width, format, type, pixels);
}

PFN_GLTEXSUBIMAGE1D _glTexSubImage1D = &_get_glTexSubImage1D;

static void APIENTRY _fail_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexSubImage2D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXSUBIMAGE2D _ptr;
    _ptr = (PFN_GLTEXSUBIMAGE2D)_getPublicProcAddress("glTexSubImage2D");
    if (!_ptr) {
        _ptr = &_fail_glTexSubImage2D;
    }
    _glTexSubImage2D = _ptr;
    _glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

PFN_GLTEXSUBIMAGE2D _glTexSubImage2D = &_get_glTexSubImage2D;

static void APIENTRY _fail_glBindTexture(GLenum target, GLuint texture) {
    const char *_name = "glBindTexture";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindTexture(GLenum target, GLuint texture) {
    PFN_GLBINDTEXTURE _ptr;
    _ptr = (PFN_GLBINDTEXTURE)_getPublicProcAddress("glBindTexture");
    if (!_ptr) {
        _ptr = &_fail_glBindTexture;
    }
    _glBindTexture = _ptr;
    _glBindTexture(target, texture);
}

PFN_GLBINDTEXTURE _glBindTexture = &_get_glBindTexture;

static void APIENTRY _fail_glDeleteTextures(GLsizei n, const GLuint * textures) {
    const char *_name = "glDeleteTextures";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteTextures(GLsizei n, const GLuint * textures) {
    PFN_GLDELETETEXTURES _ptr;
    _ptr = (PFN_GLDELETETEXTURES)_getPublicProcAddress("glDeleteTextures");
    if (!_ptr) {
        _ptr = &_fail_glDeleteTextures;
    }
    _glDeleteTextures = _ptr;
    _glDeleteTextures(n, textures);
}

PFN_GLDELETETEXTURES _glDeleteTextures = &_get_glDeleteTextures;

static void APIENTRY _fail_glGenTextures(GLsizei n, GLuint * textures) {
    const char *_name = "glGenTextures";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenTextures(GLsizei n, GLuint * textures) {
    PFN_GLGENTEXTURES _ptr;
    _ptr = (PFN_GLGENTEXTURES)_getPublicProcAddress("glGenTextures");
    if (!_ptr) {
        _ptr = &_fail_glGenTextures;
    }
    _glGenTextures = _ptr;
    _glGenTextures(n, textures);
}

PFN_GLGENTEXTURES _glGenTextures = &_get_glGenTextures;

static GLboolean APIENTRY _fail_glIsTexture(GLuint texture) {
    const char *_name = "glIsTexture";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsTexture(GLuint texture) {
    PFN_GLISTEXTURE _ptr;
    _ptr = (PFN_GLISTEXTURE)_getPublicProcAddress("glIsTexture");
    if (!_ptr) {
        _ptr = &_fail_glIsTexture;
    }
    _glIsTexture = _ptr;
    return _glIsTexture(texture);
}

PFN_GLISTEXTURE _glIsTexture = &_get_glIsTexture;

static void APIENTRY _fail_glArrayElement(GLint i) {
    const char *_name = "glArrayElement";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glArrayElement(GLint i) {
    PFN_GLARRAYELEMENT _ptr;
    _ptr = (PFN_GLARRAYELEMENT)_getPublicProcAddress("glArrayElement");
    if (!_ptr) {
        _ptr = &_fail_glArrayElement;
    }
    _glArrayElement = _ptr;
    _glArrayElement(i);
}

PFN_GLARRAYELEMENT _glArrayElement = &_get_glArrayElement;

static void APIENTRY _fail_glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glColorPointer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLCOLORPOINTER _ptr;
    _ptr = (PFN_GLCOLORPOINTER)_getPublicProcAddress("glColorPointer");
    if (!_ptr) {
        _ptr = &_fail_glColorPointer;
    }
    _glColorPointer = _ptr;
    _glColorPointer(size, type, stride, pointer);
}

PFN_GLCOLORPOINTER _glColorPointer = &_get_glColorPointer;

static void APIENTRY _fail_glDisableClientState(GLenum array) {
    const char *_name = "glDisableClientState";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDisableClientState(GLenum array) {
    PFN_GLDISABLECLIENTSTATE _ptr;
    _ptr = (PFN_GLDISABLECLIENTSTATE)_getPublicProcAddress("glDisableClientState");
    if (!_ptr) {
        _ptr = &_fail_glDisableClientState;
    }
    _glDisableClientState = _ptr;
    _glDisableClientState(array);
}

PFN_GLDISABLECLIENTSTATE _glDisableClientState = &_get_glDisableClientState;

static void APIENTRY _fail_glEdgeFlagPointer(GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glEdgeFlagPointer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEdgeFlagPointer(GLsizei stride, const GLvoid * pointer) {
    PFN_GLEDGEFLAGPOINTER _ptr;
    _ptr = (PFN_GLEDGEFLAGPOINTER)_getPublicProcAddress("glEdgeFlagPointer");
    if (!_ptr) {
        _ptr = &_fail_glEdgeFlagPointer;
    }
    _glEdgeFlagPointer = _ptr;
    _glEdgeFlagPointer(stride, pointer);
}

PFN_GLEDGEFLAGPOINTER _glEdgeFlagPointer = &_get_glEdgeFlagPointer;

static void APIENTRY _fail_glEnableClientState(GLenum array) {
    const char *_name = "glEnableClientState";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEnableClientState(GLenum array) {
    PFN_GLENABLECLIENTSTATE _ptr;
    _ptr = (PFN_GLENABLECLIENTSTATE)_getPublicProcAddress("glEnableClientState");
    if (!_ptr) {
        _ptr = &_fail_glEnableClientState;
    }
    _glEnableClientState = _ptr;
    _glEnableClientState(array);
}

PFN_GLENABLECLIENTSTATE _glEnableClientState = &_get_glEnableClientState;

static void APIENTRY _fail_glIndexPointer(GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glIndexPointer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glIndexPointer(GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLINDEXPOINTER _ptr;
    _ptr = (PFN_GLINDEXPOINTER)_getPublicProcAddress("glIndexPointer");
    if (!_ptr) {
        _ptr = &_fail_glIndexPointer;
    }
    _glIndexPointer = _ptr;
    _glIndexPointer(type, stride, pointer);
}

PFN_GLINDEXPOINTER _glIndexPointer = &_get_glIndexPointer;

static void APIENTRY _fail_glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glInterleavedArrays";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid * pointer) {
    PFN_GLINTERLEAVEDARRAYS _ptr;
    _ptr = (PFN_GLINTERLEAVEDARRAYS)_getPublicProcAddress("glInterleavedArrays");
    if (!_ptr) {
        _ptr = &_fail_glInterleavedArrays;
    }
    _glInterleavedArrays = _ptr;
    _glInterleavedArrays(format, stride, pointer);
}

PFN_GLINTERLEAVEDARRAYS _glInterleavedArrays = &_get_glInterleavedArrays;

static void APIENTRY _fail_glNormalPointer(GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glNormalPointer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormalPointer(GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLNORMALPOINTER _ptr;
    _ptr = (PFN_GLNORMALPOINTER)_getPublicProcAddress("glNormalPointer");
    if (!_ptr) {
        _ptr = &_fail_glNormalPointer;
    }
    _glNormalPointer = _ptr;
    _glNormalPointer(type, stride, pointer);
}

PFN_GLNORMALPOINTER _glNormalPointer = &_get_glNormalPointer;

static void APIENTRY _fail_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glTexCoordPointer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLTEXCOORDPOINTER _ptr;
    _ptr = (PFN_GLTEXCOORDPOINTER)_getPublicProcAddress("glTexCoordPointer");
    if (!_ptr) {
        _ptr = &_fail_glTexCoordPointer;
    }
    _glTexCoordPointer = _ptr;
    _glTexCoordPointer(size, type, stride, pointer);
}

PFN_GLTEXCOORDPOINTER _glTexCoordPointer = &_get_glTexCoordPointer;

static void APIENTRY _fail_glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glVertexPointer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLVERTEXPOINTER _ptr;
    _ptr = (PFN_GLVERTEXPOINTER)_getPublicProcAddress("glVertexPointer");
    if (!_ptr) {
        _ptr = &_fail_glVertexPointer;
    }
    _glVertexPointer = _ptr;
    _glVertexPointer(size, type, stride, pointer);
}

PFN_GLVERTEXPOINTER _glVertexPointer = &_get_glVertexPointer;

static GLboolean APIENTRY _fail_glAreTexturesResident(GLsizei n, const GLuint * textures, GLboolean * residences) {
    const char *_name = "glAreTexturesResident";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glAreTexturesResident(GLsizei n, const GLuint * textures, GLboolean * residences) {
    PFN_GLARETEXTURESRESIDENT _ptr;
    _ptr = (PFN_GLARETEXTURESRESIDENT)_getPublicProcAddress("glAreTexturesResident");
    if (!_ptr) {
        _ptr = &_fail_glAreTexturesResident;
    }
    _glAreTexturesResident = _ptr;
    return _glAreTexturesResident(n, textures, residences);
}

PFN_GLARETEXTURESRESIDENT _glAreTexturesResident = &_get_glAreTexturesResident;

static void APIENTRY _fail_glPrioritizeTextures(GLsizei n, const GLuint * textures, const GLclampf * priorities) {
    const char *_name = "glPrioritizeTextures";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPrioritizeTextures(GLsizei n, const GLuint * textures, const GLclampf * priorities) {
    PFN_GLPRIORITIZETEXTURES _ptr;
    _ptr = (PFN_GLPRIORITIZETEXTURES)_getPublicProcAddress("glPrioritizeTextures");
    if (!_ptr) {
        _ptr = &_fail_glPrioritizeTextures;
    }
    _glPrioritizeTextures = _ptr;
    _glPrioritizeTextures(n, textures, priorities);
}

PFN_GLPRIORITIZETEXTURES _glPrioritizeTextures = &_get_glPrioritizeTextures;

static void APIENTRY _fail_glIndexub(GLubyte c) {
    const char *_name = "glIndexub";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glIndexub(GLubyte c) {
    PFN_GLINDEXUB _ptr;
    _ptr = (PFN_GLINDEXUB)_getPublicProcAddress("glIndexub");
    if (!_ptr) {
        _ptr = &_fail_glIndexub;
    }
    _glIndexub = _ptr;
    _glIndexub(c);
}

PFN_GLINDEXUB _glIndexub = &_get_glIndexub;

static void APIENTRY _fail_glIndexubv(const GLubyte * c) {
    const char *_name = "glIndexubv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glIndexubv(const GLubyte * c) {
    PFN_GLINDEXUBV _ptr;
    _ptr = (PFN_GLINDEXUBV)_getPublicProcAddress("glIndexubv");
    if (!_ptr) {
        _ptr = &_fail_glIndexubv;
    }
    _glIndexubv = _ptr;
    _glIndexubv(c);
}

PFN_GLINDEXUBV _glIndexubv = &_get_glIndexubv;

static void APIENTRY _fail_glPopClientAttrib(void) {
    const char *_name = "glPopClientAttrib";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPopClientAttrib(void) {
    PFN_GLPOPCLIENTATTRIB _ptr;
    _ptr = (PFN_GLPOPCLIENTATTRIB)_getPublicProcAddress("glPopClientAttrib");
    if (!_ptr) {
        _ptr = &_fail_glPopClientAttrib;
    }
    _glPopClientAttrib = _ptr;
    _glPopClientAttrib();
}

PFN_GLPOPCLIENTATTRIB _glPopClientAttrib = &_get_glPopClientAttrib;

static void APIENTRY _fail_glPushClientAttrib(GLbitfield mask) {
    const char *_name = "glPushClientAttrib";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPushClientAttrib(GLbitfield mask) {
    PFN_GLPUSHCLIENTATTRIB _ptr;
    _ptr = (PFN_GLPUSHCLIENTATTRIB)_getPublicProcAddress("glPushClientAttrib");
    if (!_ptr) {
        _ptr = &_fail_glPushClientAttrib;
    }
    _glPushClientAttrib = _ptr;
    _glPushClientAttrib(mask);
}

PFN_GLPUSHCLIENTATTRIB _glPushClientAttrib = &_get_glPushClientAttrib;

static void APIENTRY _fail_glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    const char *_name = "glBlendColor";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    PFN_GLBLENDCOLOR _ptr;
    _ptr = (PFN_GLBLENDCOLOR)_getPrivateProcAddress("glBlendColor");
    if (!_ptr) {
        _ptr = &_fail_glBlendColor;
    }
    _glBlendColor = _ptr;
    _glBlendColor(red, green, blue, alpha);
}

PFN_GLBLENDCOLOR _glBlendColor = &_get_glBlendColor;

static void APIENTRY _fail_glBlendEquation(GLenum mode) {
    const char *_name = "glBlendEquation";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendEquation(GLenum mode) {
    PFN_GLBLENDEQUATION _ptr;
    _ptr = (PFN_GLBLENDEQUATION)_getPrivateProcAddress("glBlendEquation");
    if (!_ptr) {
        _ptr = &_fail_glBlendEquation;
    }
    _glBlendEquation = _ptr;
    _glBlendEquation(mode);
}

PFN_GLBLENDEQUATION _glBlendEquation = &_get_glBlendEquation;

static void APIENTRY _fail_glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices) {
    const char *_name = "glDrawRangeElements";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices) {
    PFN_GLDRAWRANGEELEMENTS _ptr;
    _ptr = (PFN_GLDRAWRANGEELEMENTS)_getPrivateProcAddress("glDrawRangeElements");
    if (!_ptr) {
        _ptr = &_fail_glDrawRangeElements;
    }
    _glDrawRangeElements = _ptr;
    _glDrawRangeElements(mode, start, end, count, type, indices);
}

PFN_GLDRAWRANGEELEMENTS _glDrawRangeElements = &_get_glDrawRangeElements;

static void APIENTRY _fail_glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexImage3D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXIMAGE3D _ptr;
    _ptr = (PFN_GLTEXIMAGE3D)_getPrivateProcAddress("glTexImage3D");
    if (!_ptr) {
        _ptr = &_fail_glTexImage3D;
    }
    _glTexImage3D = _ptr;
    _glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels);
}

PFN_GLTEXIMAGE3D _glTexImage3D = &_get_glTexImage3D;

static void APIENTRY _fail_glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexSubImage3D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXSUBIMAGE3D _ptr;
    _ptr = (PFN_GLTEXSUBIMAGE3D)_getPrivateProcAddress("glTexSubImage3D");
    if (!_ptr) {
        _ptr = &_fail_glTexSubImage3D;
    }
    _glTexSubImage3D = _ptr;
    _glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

PFN_GLTEXSUBIMAGE3D _glTexSubImage3D = &_get_glTexSubImage3D;

static void APIENTRY _fail_glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyTexSubImage3D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLCOPYTEXSUBIMAGE3D _ptr;
    _ptr = (PFN_GLCOPYTEXSUBIMAGE3D)_getPrivateProcAddress("glCopyTexSubImage3D");
    if (!_ptr) {
        _ptr = &_fail_glCopyTexSubImage3D;
    }
    _glCopyTexSubImage3D = _ptr;
    _glCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

PFN_GLCOPYTEXSUBIMAGE3D _glCopyTexSubImage3D = &_get_glCopyTexSubImage3D;

static void APIENTRY _fail_glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table) {
    const char *_name = "glColorTable";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table) {
    PFN_GLCOLORTABLE _ptr;
    _ptr = (PFN_GLCOLORTABLE)_getPrivateProcAddress("glColorTable");
    if (!_ptr) {
        _ptr = &_fail_glColorTable;
    }
    _glColorTable = _ptr;
    _glColorTable(target, internalformat, width, format, type, table);
}

PFN_GLCOLORTABLE _glColorTable = &_get_glColorTable;

static void APIENTRY _fail_glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glColorTableParameterfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat * params) {
    PFN_GLCOLORTABLEPARAMETERFV _ptr;
    _ptr = (PFN_GLCOLORTABLEPARAMETERFV)_getPrivateProcAddress("glColorTableParameterfv");
    if (!_ptr) {
        _ptr = &_fail_glColorTableParameterfv;
    }
    _glColorTableParameterfv = _ptr;
    _glColorTableParameterfv(target, pname, params);
}

PFN_GLCOLORTABLEPARAMETERFV _glColorTableParameterfv = &_get_glColorTableParameterfv;

static void APIENTRY _fail_glColorTableParameteriv(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glColorTableParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorTableParameteriv(GLenum target, GLenum pname, const GLint * params) {
    PFN_GLCOLORTABLEPARAMETERIV _ptr;
    _ptr = (PFN_GLCOLORTABLEPARAMETERIV)_getPrivateProcAddress("glColorTableParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glColorTableParameteriv;
    }
    _glColorTableParameteriv = _ptr;
    _glColorTableParameteriv(target, pname, params);
}

PFN_GLCOLORTABLEPARAMETERIV _glColorTableParameteriv = &_get_glColorTableParameteriv;

static void APIENTRY _fail_glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyColorTable";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    PFN_GLCOPYCOLORTABLE _ptr;
    _ptr = (PFN_GLCOPYCOLORTABLE)_getPrivateProcAddress("glCopyColorTable");
    if (!_ptr) {
        _ptr = &_fail_glCopyColorTable;
    }
    _glCopyColorTable = _ptr;
    _glCopyColorTable(target, internalformat, x, y, width);
}

PFN_GLCOPYCOLORTABLE _glCopyColorTable = &_get_glCopyColorTable;

static void APIENTRY _fail_glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid * table) {
    const char *_name = "glGetColorTable";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid * table) {
    PFN_GLGETCOLORTABLE _ptr;
    _ptr = (PFN_GLGETCOLORTABLE)_getPrivateProcAddress("glGetColorTable");
    if (!_ptr) {
        _ptr = &_fail_glGetColorTable;
    }
    _glGetColorTable = _ptr;
    _glGetColorTable(target, format, type, table);
}

PFN_GLGETCOLORTABLE _glGetColorTable = &_get_glGetColorTable;

static void APIENTRY _fail_glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetColorTableParameterfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat * params) {
    PFN_GLGETCOLORTABLEPARAMETERFV _ptr;
    _ptr = (PFN_GLGETCOLORTABLEPARAMETERFV)_getPrivateProcAddress("glGetColorTableParameterfv");
    if (!_ptr) {
        _ptr = &_fail_glGetColorTableParameterfv;
    }
    _glGetColorTableParameterfv = _ptr;
    _glGetColorTableParameterfv(target, pname, params);
}

PFN_GLGETCOLORTABLEPARAMETERFV _glGetColorTableParameterfv = &_get_glGetColorTableParameterfv;

static void APIENTRY _fail_glGetColorTableParameteriv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetColorTableParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetColorTableParameteriv(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETCOLORTABLEPARAMETERIV _ptr;
    _ptr = (PFN_GLGETCOLORTABLEPARAMETERIV)_getPrivateProcAddress("glGetColorTableParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glGetColorTableParameteriv;
    }
    _glGetColorTableParameteriv = _ptr;
    _glGetColorTableParameteriv(target, pname, params);
}

PFN_GLGETCOLORTABLEPARAMETERIV _glGetColorTableParameteriv = &_get_glGetColorTableParameteriv;

static void APIENTRY _fail_glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data) {
    const char *_name = "glColorSubTable";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data) {
    PFN_GLCOLORSUBTABLE _ptr;
    _ptr = (PFN_GLCOLORSUBTABLE)_getPrivateProcAddress("glColorSubTable");
    if (!_ptr) {
        _ptr = &_fail_glColorSubTable;
    }
    _glColorSubTable = _ptr;
    _glColorSubTable(target, start, count, format, type, data);
}

PFN_GLCOLORSUBTABLE _glColorSubTable = &_get_glColorSubTable;

static void APIENTRY _fail_glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyColorSubTable";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width) {
    PFN_GLCOPYCOLORSUBTABLE _ptr;
    _ptr = (PFN_GLCOPYCOLORSUBTABLE)_getPrivateProcAddress("glCopyColorSubTable");
    if (!_ptr) {
        _ptr = &_fail_glCopyColorSubTable;
    }
    _glCopyColorSubTable = _ptr;
    _glCopyColorSubTable(target, start, x, y, width);
}

PFN_GLCOPYCOLORSUBTABLE _glCopyColorSubTable = &_get_glCopyColorSubTable;

static void APIENTRY _fail_glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image) {
    const char *_name = "glConvolutionFilter1D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image) {
    PFN_GLCONVOLUTIONFILTER1D _ptr;
    _ptr = (PFN_GLCONVOLUTIONFILTER1D)_getPrivateProcAddress("glConvolutionFilter1D");
    if (!_ptr) {
        _ptr = &_fail_glConvolutionFilter1D;
    }
    _glConvolutionFilter1D = _ptr;
    _glConvolutionFilter1D(target, internalformat, width, format, type, image);
}

PFN_GLCONVOLUTIONFILTER1D _glConvolutionFilter1D = &_get_glConvolutionFilter1D;

static void APIENTRY _fail_glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image) {
    const char *_name = "glConvolutionFilter2D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image) {
    PFN_GLCONVOLUTIONFILTER2D _ptr;
    _ptr = (PFN_GLCONVOLUTIONFILTER2D)_getPrivateProcAddress("glConvolutionFilter2D");
    if (!_ptr) {
        _ptr = &_fail_glConvolutionFilter2D;
    }
    _glConvolutionFilter2D = _ptr;
    _glConvolutionFilter2D(target, internalformat, width, height, format, type, image);
}

PFN_GLCONVOLUTIONFILTER2D _glConvolutionFilter2D = &_get_glConvolutionFilter2D;

static void APIENTRY _fail_glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params) {
    const char *_name = "glConvolutionParameterf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params) {
    PFN_GLCONVOLUTIONPARAMETERF _ptr;
    _ptr = (PFN_GLCONVOLUTIONPARAMETERF)_getPrivateProcAddress("glConvolutionParameterf");
    if (!_ptr) {
        _ptr = &_fail_glConvolutionParameterf;
    }
    _glConvolutionParameterf = _ptr;
    _glConvolutionParameterf(target, pname, params);
}

PFN_GLCONVOLUTIONPARAMETERF _glConvolutionParameterf = &_get_glConvolutionParameterf;

static void APIENTRY _fail_glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glConvolutionParameterfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat * params) {
    PFN_GLCONVOLUTIONPARAMETERFV _ptr;
    _ptr = (PFN_GLCONVOLUTIONPARAMETERFV)_getPrivateProcAddress("glConvolutionParameterfv");
    if (!_ptr) {
        _ptr = &_fail_glConvolutionParameterfv;
    }
    _glConvolutionParameterfv = _ptr;
    _glConvolutionParameterfv(target, pname, params);
}

PFN_GLCONVOLUTIONPARAMETERFV _glConvolutionParameterfv = &_get_glConvolutionParameterfv;

static void APIENTRY _fail_glConvolutionParameteri(GLenum target, GLenum pname, GLint params) {
    const char *_name = "glConvolutionParameteri";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glConvolutionParameteri(GLenum target, GLenum pname, GLint params) {
    PFN_GLCONVOLUTIONPARAMETERI _ptr;
    _ptr = (PFN_GLCONVOLUTIONPARAMETERI)_getPrivateProcAddress("glConvolutionParameteri");
    if (!_ptr) {
        _ptr = &_fail_glConvolutionParameteri;
    }
    _glConvolutionParameteri = _ptr;
    _glConvolutionParameteri(target, pname, params);
}

PFN_GLCONVOLUTIONPARAMETERI _glConvolutionParameteri = &_get_glConvolutionParameteri;

static void APIENTRY _fail_glConvolutionParameteriv(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glConvolutionParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glConvolutionParameteriv(GLenum target, GLenum pname, const GLint * params) {
    PFN_GLCONVOLUTIONPARAMETERIV _ptr;
    _ptr = (PFN_GLCONVOLUTIONPARAMETERIV)_getPrivateProcAddress("glConvolutionParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glConvolutionParameteriv;
    }
    _glConvolutionParameteriv = _ptr;
    _glConvolutionParameteriv(target, pname, params);
}

PFN_GLCONVOLUTIONPARAMETERIV _glConvolutionParameteriv = &_get_glConvolutionParameteriv;

static void APIENTRY _fail_glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyConvolutionFilter1D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    PFN_GLCOPYCONVOLUTIONFILTER1D _ptr;
    _ptr = (PFN_GLCOPYCONVOLUTIONFILTER1D)_getPrivateProcAddress("glCopyConvolutionFilter1D");
    if (!_ptr) {
        _ptr = &_fail_glCopyConvolutionFilter1D;
    }
    _glCopyConvolutionFilter1D = _ptr;
    _glCopyConvolutionFilter1D(target, internalformat, x, y, width);
}

PFN_GLCOPYCONVOLUTIONFILTER1D _glCopyConvolutionFilter1D = &_get_glCopyConvolutionFilter1D;

static void APIENTRY _fail_glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyConvolutionFilter2D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLCOPYCONVOLUTIONFILTER2D _ptr;
    _ptr = (PFN_GLCOPYCONVOLUTIONFILTER2D)_getPrivateProcAddress("glCopyConvolutionFilter2D");
    if (!_ptr) {
        _ptr = &_fail_glCopyConvolutionFilter2D;
    }
    _glCopyConvolutionFilter2D = _ptr;
    _glCopyConvolutionFilter2D(target, internalformat, x, y, width, height);
}

PFN_GLCOPYCONVOLUTIONFILTER2D _glCopyConvolutionFilter2D = &_get_glCopyConvolutionFilter2D;

static void APIENTRY _fail_glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid * image) {
    const char *_name = "glGetConvolutionFilter";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid * image) {
    PFN_GLGETCONVOLUTIONFILTER _ptr;
    _ptr = (PFN_GLGETCONVOLUTIONFILTER)_getPrivateProcAddress("glGetConvolutionFilter");
    if (!_ptr) {
        _ptr = &_fail_glGetConvolutionFilter;
    }
    _glGetConvolutionFilter = _ptr;
    _glGetConvolutionFilter(target, format, type, image);
}

PFN_GLGETCONVOLUTIONFILTER _glGetConvolutionFilter = &_get_glGetConvolutionFilter;

static void APIENTRY _fail_glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetConvolutionParameterfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat * params) {
    PFN_GLGETCONVOLUTIONPARAMETERFV _ptr;
    _ptr = (PFN_GLGETCONVOLUTIONPARAMETERFV)_getPrivateProcAddress("glGetConvolutionParameterfv");
    if (!_ptr) {
        _ptr = &_fail_glGetConvolutionParameterfv;
    }
    _glGetConvolutionParameterfv = _ptr;
    _glGetConvolutionParameterfv(target, pname, params);
}

PFN_GLGETCONVOLUTIONPARAMETERFV _glGetConvolutionParameterfv = &_get_glGetConvolutionParameterfv;

static void APIENTRY _fail_glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetConvolutionParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETCONVOLUTIONPARAMETERIV _ptr;
    _ptr = (PFN_GLGETCONVOLUTIONPARAMETERIV)_getPrivateProcAddress("glGetConvolutionParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glGetConvolutionParameteriv;
    }
    _glGetConvolutionParameteriv = _ptr;
    _glGetConvolutionParameteriv(target, pname, params);
}

PFN_GLGETCONVOLUTIONPARAMETERIV _glGetConvolutionParameteriv = &_get_glGetConvolutionParameteriv;

static void APIENTRY _fail_glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid * row, GLvoid * column, GLvoid * span) {
    const char *_name = "glGetSeparableFilter";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid * row, GLvoid * column, GLvoid * span) {
    PFN_GLGETSEPARABLEFILTER _ptr;
    _ptr = (PFN_GLGETSEPARABLEFILTER)_getPrivateProcAddress("glGetSeparableFilter");
    if (!_ptr) {
        _ptr = &_fail_glGetSeparableFilter;
    }
    _glGetSeparableFilter = _ptr;
    _glGetSeparableFilter(target, format, type, row, column, span);
}

PFN_GLGETSEPARABLEFILTER _glGetSeparableFilter = &_get_glGetSeparableFilter;

static void APIENTRY _fail_glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * row, const GLvoid * column) {
    const char *_name = "glSeparableFilter2D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * row, const GLvoid * column) {
    PFN_GLSEPARABLEFILTER2D _ptr;
    _ptr = (PFN_GLSEPARABLEFILTER2D)_getPrivateProcAddress("glSeparableFilter2D");
    if (!_ptr) {
        _ptr = &_fail_glSeparableFilter2D;
    }
    _glSeparableFilter2D = _ptr;
    _glSeparableFilter2D(target, internalformat, width, height, format, type, row, column);
}

PFN_GLSEPARABLEFILTER2D _glSeparableFilter2D = &_get_glSeparableFilter2D;

static void APIENTRY _fail_glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values) {
    const char *_name = "glGetHistogram";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values) {
    PFN_GLGETHISTOGRAM _ptr;
    _ptr = (PFN_GLGETHISTOGRAM)_getPrivateProcAddress("glGetHistogram");
    if (!_ptr) {
        _ptr = &_fail_glGetHistogram;
    }
    _glGetHistogram = _ptr;
    _glGetHistogram(target, reset, format, type, values);
}

PFN_GLGETHISTOGRAM _glGetHistogram = &_get_glGetHistogram;

static void APIENTRY _fail_glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetHistogramParameterfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat * params) {
    PFN_GLGETHISTOGRAMPARAMETERFV _ptr;
    _ptr = (PFN_GLGETHISTOGRAMPARAMETERFV)_getPrivateProcAddress("glGetHistogramParameterfv");
    if (!_ptr) {
        _ptr = &_fail_glGetHistogramParameterfv;
    }
    _glGetHistogramParameterfv = _ptr;
    _glGetHistogramParameterfv(target, pname, params);
}

PFN_GLGETHISTOGRAMPARAMETERFV _glGetHistogramParameterfv = &_get_glGetHistogramParameterfv;

static void APIENTRY _fail_glGetHistogramParameteriv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetHistogramParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetHistogramParameteriv(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETHISTOGRAMPARAMETERIV _ptr;
    _ptr = (PFN_GLGETHISTOGRAMPARAMETERIV)_getPrivateProcAddress("glGetHistogramParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glGetHistogramParameteriv;
    }
    _glGetHistogramParameteriv = _ptr;
    _glGetHistogramParameteriv(target, pname, params);
}

PFN_GLGETHISTOGRAMPARAMETERIV _glGetHistogramParameteriv = &_get_glGetHistogramParameteriv;

static void APIENTRY _fail_glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values) {
    const char *_name = "glGetMinmax";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values) {
    PFN_GLGETMINMAX _ptr;
    _ptr = (PFN_GLGETMINMAX)_getPrivateProcAddress("glGetMinmax");
    if (!_ptr) {
        _ptr = &_fail_glGetMinmax;
    }
    _glGetMinmax = _ptr;
    _glGetMinmax(target, reset, format, type, values);
}

PFN_GLGETMINMAX _glGetMinmax = &_get_glGetMinmax;

static void APIENTRY _fail_glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetMinmaxParameterfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat * params) {
    PFN_GLGETMINMAXPARAMETERFV _ptr;
    _ptr = (PFN_GLGETMINMAXPARAMETERFV)_getPrivateProcAddress("glGetMinmaxParameterfv");
    if (!_ptr) {
        _ptr = &_fail_glGetMinmaxParameterfv;
    }
    _glGetMinmaxParameterfv = _ptr;
    _glGetMinmaxParameterfv(target, pname, params);
}

PFN_GLGETMINMAXPARAMETERFV _glGetMinmaxParameterfv = &_get_glGetMinmaxParameterfv;

static void APIENTRY _fail_glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetMinmaxParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETMINMAXPARAMETERIV _ptr;
    _ptr = (PFN_GLGETMINMAXPARAMETERIV)_getPrivateProcAddress("glGetMinmaxParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glGetMinmaxParameteriv;
    }
    _glGetMinmaxParameteriv = _ptr;
    _glGetMinmaxParameteriv(target, pname, params);
}

PFN_GLGETMINMAXPARAMETERIV _glGetMinmaxParameteriv = &_get_glGetMinmaxParameteriv;

static void APIENTRY _fail_glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) {
    const char *_name = "glHistogram";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) {
    PFN_GLHISTOGRAM _ptr;
    _ptr = (PFN_GLHISTOGRAM)_getPrivateProcAddress("glHistogram");
    if (!_ptr) {
        _ptr = &_fail_glHistogram;
    }
    _glHistogram = _ptr;
    _glHistogram(target, width, internalformat, sink);
}

PFN_GLHISTOGRAM _glHistogram = &_get_glHistogram;

static void APIENTRY _fail_glMinmax(GLenum target, GLenum internalformat, GLboolean sink) {
    const char *_name = "glMinmax";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMinmax(GLenum target, GLenum internalformat, GLboolean sink) {
    PFN_GLMINMAX _ptr;
    _ptr = (PFN_GLMINMAX)_getPrivateProcAddress("glMinmax");
    if (!_ptr) {
        _ptr = &_fail_glMinmax;
    }
    _glMinmax = _ptr;
    _glMinmax(target, internalformat, sink);
}

PFN_GLMINMAX _glMinmax = &_get_glMinmax;

static void APIENTRY _fail_glResetHistogram(GLenum target) {
    const char *_name = "glResetHistogram";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glResetHistogram(GLenum target) {
    PFN_GLRESETHISTOGRAM _ptr;
    _ptr = (PFN_GLRESETHISTOGRAM)_getPrivateProcAddress("glResetHistogram");
    if (!_ptr) {
        _ptr = &_fail_glResetHistogram;
    }
    _glResetHistogram = _ptr;
    _glResetHistogram(target);
}

PFN_GLRESETHISTOGRAM _glResetHistogram = &_get_glResetHistogram;

static void APIENTRY _fail_glResetMinmax(GLenum target) {
    const char *_name = "glResetMinmax";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glResetMinmax(GLenum target) {
    PFN_GLRESETMINMAX _ptr;
    _ptr = (PFN_GLRESETMINMAX)_getPrivateProcAddress("glResetMinmax");
    if (!_ptr) {
        _ptr = &_fail_glResetMinmax;
    }
    _glResetMinmax = _ptr;
    _glResetMinmax(target);
}

PFN_GLRESETMINMAX _glResetMinmax = &_get_glResetMinmax;

static void APIENTRY _fail_glActiveTexture(GLenum texture) {
    const char *_name = "glActiveTexture";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glActiveTexture(GLenum texture) {
    PFN_GLACTIVETEXTURE _ptr;
    _ptr = (PFN_GLACTIVETEXTURE)_getPrivateProcAddress("glActiveTexture");
    if (!_ptr) {
        _ptr = &_fail_glActiveTexture;
    }
    _glActiveTexture = _ptr;
    _glActiveTexture(texture);
}

PFN_GLACTIVETEXTURE _glActiveTexture = &_get_glActiveTexture;

static void APIENTRY _fail_glSampleCoverage(GLfloat value, GLboolean invert) {
    const char *_name = "glSampleCoverage";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSampleCoverage(GLfloat value, GLboolean invert) {
    PFN_GLSAMPLECOVERAGE _ptr;
    _ptr = (PFN_GLSAMPLECOVERAGE)_getPrivateProcAddress("glSampleCoverage");
    if (!_ptr) {
        _ptr = &_fail_glSampleCoverage;
    }
    _glSampleCoverage = _ptr;
    _glSampleCoverage(value, invert);
}

PFN_GLSAMPLECOVERAGE _glSampleCoverage = &_get_glSampleCoverage;

static void APIENTRY _fail_glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexImage3D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data) {
    PFN_GLCOMPRESSEDTEXIMAGE3D _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXIMAGE3D)_getPrivateProcAddress("glCompressedTexImage3D");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTexImage3D;
    }
    _glCompressedTexImage3D = _ptr;
    _glCompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data);
}

PFN_GLCOMPRESSEDTEXIMAGE3D _glCompressedTexImage3D = &_get_glCompressedTexImage3D;

static void APIENTRY _fail_glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexImage2D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data) {
    PFN_GLCOMPRESSEDTEXIMAGE2D _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXIMAGE2D)_getPrivateProcAddress("glCompressedTexImage2D");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTexImage2D;
    }
    _glCompressedTexImage2D = _ptr;
    _glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
}

PFN_GLCOMPRESSEDTEXIMAGE2D _glCompressedTexImage2D = &_get_glCompressedTexImage2D;

static void APIENTRY _fail_glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexImage1D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data) {
    PFN_GLCOMPRESSEDTEXIMAGE1D _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXIMAGE1D)_getPrivateProcAddress("glCompressedTexImage1D");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTexImage1D;
    }
    _glCompressedTexImage1D = _ptr;
    _glCompressedTexImage1D(target, level, internalformat, width, border, imageSize, data);
}

PFN_GLCOMPRESSEDTEXIMAGE1D _glCompressedTexImage1D = &_get_glCompressedTexImage1D;

static void APIENTRY _fail_glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexSubImage3D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data) {
    PFN_GLCOMPRESSEDTEXSUBIMAGE3D _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXSUBIMAGE3D)_getPrivateProcAddress("glCompressedTexSubImage3D");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTexSubImage3D;
    }
    _glCompressedTexSubImage3D = _ptr;
    _glCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

PFN_GLCOMPRESSEDTEXSUBIMAGE3D _glCompressedTexSubImage3D = &_get_glCompressedTexSubImage3D;

static void APIENTRY _fail_glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexSubImage2D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data) {
    PFN_GLCOMPRESSEDTEXSUBIMAGE2D _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXSUBIMAGE2D)_getPrivateProcAddress("glCompressedTexSubImage2D");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTexSubImage2D;
    }
    _glCompressedTexSubImage2D = _ptr;
    _glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

PFN_GLCOMPRESSEDTEXSUBIMAGE2D _glCompressedTexSubImage2D = &_get_glCompressedTexSubImage2D;

static void APIENTRY _fail_glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexSubImage1D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data) {
    PFN_GLCOMPRESSEDTEXSUBIMAGE1D _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXSUBIMAGE1D)_getPrivateProcAddress("glCompressedTexSubImage1D");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTexSubImage1D;
    }
    _glCompressedTexSubImage1D = _ptr;
    _glCompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data);
}

PFN_GLCOMPRESSEDTEXSUBIMAGE1D _glCompressedTexSubImage1D = &_get_glCompressedTexSubImage1D;

static void APIENTRY _fail_glGetCompressedTexImage(GLenum target, GLint level, GLvoid * img) {
    const char *_name = "glGetCompressedTexImage";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetCompressedTexImage(GLenum target, GLint level, GLvoid * img) {
    PFN_GLGETCOMPRESSEDTEXIMAGE _ptr;
    _ptr = (PFN_GLGETCOMPRESSEDTEXIMAGE)_getPrivateProcAddress("glGetCompressedTexImage");
    if (!_ptr) {
        _ptr = &_fail_glGetCompressedTexImage;
    }
    _glGetCompressedTexImage = _ptr;
    _glGetCompressedTexImage(target, level, img);
}

PFN_GLGETCOMPRESSEDTEXIMAGE _glGetCompressedTexImage = &_get_glGetCompressedTexImage;

static void APIENTRY _fail_glClientActiveTexture(GLenum texture) {
    const char *_name = "glClientActiveTexture";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClientActiveTexture(GLenum texture) {
    PFN_GLCLIENTACTIVETEXTURE _ptr;
    _ptr = (PFN_GLCLIENTACTIVETEXTURE)_getPrivateProcAddress("glClientActiveTexture");
    if (!_ptr) {
        _ptr = &_fail_glClientActiveTexture;
    }
    _glClientActiveTexture = _ptr;
    _glClientActiveTexture(texture);
}

PFN_GLCLIENTACTIVETEXTURE _glClientActiveTexture = &_get_glClientActiveTexture;

static void APIENTRY _fail_glMultiTexCoord1d(GLenum target, GLdouble s) {
    const char *_name = "glMultiTexCoord1d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord1d(GLenum target, GLdouble s) {
    PFN_GLMULTITEXCOORD1D _ptr;
    _ptr = (PFN_GLMULTITEXCOORD1D)_getPrivateProcAddress("glMultiTexCoord1d");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord1d;
    }
    _glMultiTexCoord1d = _ptr;
    _glMultiTexCoord1d(target, s);
}

PFN_GLMULTITEXCOORD1D _glMultiTexCoord1d = &_get_glMultiTexCoord1d;

static void APIENTRY _fail_glMultiTexCoord1dv(GLenum target, const GLdouble * v) {
    const char *_name = "glMultiTexCoord1dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord1dv(GLenum target, const GLdouble * v) {
    PFN_GLMULTITEXCOORD1DV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD1DV)_getPrivateProcAddress("glMultiTexCoord1dv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord1dv;
    }
    _glMultiTexCoord1dv = _ptr;
    _glMultiTexCoord1dv(target, v);
}

PFN_GLMULTITEXCOORD1DV _glMultiTexCoord1dv = &_get_glMultiTexCoord1dv;

static void APIENTRY _fail_glMultiTexCoord1f(GLenum target, GLfloat s) {
    const char *_name = "glMultiTexCoord1f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord1f(GLenum target, GLfloat s) {
    PFN_GLMULTITEXCOORD1F _ptr;
    _ptr = (PFN_GLMULTITEXCOORD1F)_getPrivateProcAddress("glMultiTexCoord1f");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord1f;
    }
    _glMultiTexCoord1f = _ptr;
    _glMultiTexCoord1f(target, s);
}

PFN_GLMULTITEXCOORD1F _glMultiTexCoord1f = &_get_glMultiTexCoord1f;

static void APIENTRY _fail_glMultiTexCoord1fv(GLenum target, const GLfloat * v) {
    const char *_name = "glMultiTexCoord1fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord1fv(GLenum target, const GLfloat * v) {
    PFN_GLMULTITEXCOORD1FV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD1FV)_getPrivateProcAddress("glMultiTexCoord1fv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord1fv;
    }
    _glMultiTexCoord1fv = _ptr;
    _glMultiTexCoord1fv(target, v);
}

PFN_GLMULTITEXCOORD1FV _glMultiTexCoord1fv = &_get_glMultiTexCoord1fv;

static void APIENTRY _fail_glMultiTexCoord1i(GLenum target, GLint s) {
    const char *_name = "glMultiTexCoord1i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord1i(GLenum target, GLint s) {
    PFN_GLMULTITEXCOORD1I _ptr;
    _ptr = (PFN_GLMULTITEXCOORD1I)_getPrivateProcAddress("glMultiTexCoord1i");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord1i;
    }
    _glMultiTexCoord1i = _ptr;
    _glMultiTexCoord1i(target, s);
}

PFN_GLMULTITEXCOORD1I _glMultiTexCoord1i = &_get_glMultiTexCoord1i;

static void APIENTRY _fail_glMultiTexCoord1iv(GLenum target, const GLint * v) {
    const char *_name = "glMultiTexCoord1iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord1iv(GLenum target, const GLint * v) {
    PFN_GLMULTITEXCOORD1IV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD1IV)_getPrivateProcAddress("glMultiTexCoord1iv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord1iv;
    }
    _glMultiTexCoord1iv = _ptr;
    _glMultiTexCoord1iv(target, v);
}

PFN_GLMULTITEXCOORD1IV _glMultiTexCoord1iv = &_get_glMultiTexCoord1iv;

static void APIENTRY _fail_glMultiTexCoord1s(GLenum target, GLshort s) {
    const char *_name = "glMultiTexCoord1s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord1s(GLenum target, GLshort s) {
    PFN_GLMULTITEXCOORD1S _ptr;
    _ptr = (PFN_GLMULTITEXCOORD1S)_getPrivateProcAddress("glMultiTexCoord1s");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord1s;
    }
    _glMultiTexCoord1s = _ptr;
    _glMultiTexCoord1s(target, s);
}

PFN_GLMULTITEXCOORD1S _glMultiTexCoord1s = &_get_glMultiTexCoord1s;

static void APIENTRY _fail_glMultiTexCoord1sv(GLenum target, const GLshort * v) {
    const char *_name = "glMultiTexCoord1sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord1sv(GLenum target, const GLshort * v) {
    PFN_GLMULTITEXCOORD1SV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD1SV)_getPrivateProcAddress("glMultiTexCoord1sv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord1sv;
    }
    _glMultiTexCoord1sv = _ptr;
    _glMultiTexCoord1sv(target, v);
}

PFN_GLMULTITEXCOORD1SV _glMultiTexCoord1sv = &_get_glMultiTexCoord1sv;

static void APIENTRY _fail_glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t) {
    const char *_name = "glMultiTexCoord2d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t) {
    PFN_GLMULTITEXCOORD2D _ptr;
    _ptr = (PFN_GLMULTITEXCOORD2D)_getPrivateProcAddress("glMultiTexCoord2d");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord2d;
    }
    _glMultiTexCoord2d = _ptr;
    _glMultiTexCoord2d(target, s, t);
}

PFN_GLMULTITEXCOORD2D _glMultiTexCoord2d = &_get_glMultiTexCoord2d;

static void APIENTRY _fail_glMultiTexCoord2dv(GLenum target, const GLdouble * v) {
    const char *_name = "glMultiTexCoord2dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord2dv(GLenum target, const GLdouble * v) {
    PFN_GLMULTITEXCOORD2DV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD2DV)_getPrivateProcAddress("glMultiTexCoord2dv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord2dv;
    }
    _glMultiTexCoord2dv = _ptr;
    _glMultiTexCoord2dv(target, v);
}

PFN_GLMULTITEXCOORD2DV _glMultiTexCoord2dv = &_get_glMultiTexCoord2dv;

static void APIENTRY _fail_glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t) {
    const char *_name = "glMultiTexCoord2f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t) {
    PFN_GLMULTITEXCOORD2F _ptr;
    _ptr = (PFN_GLMULTITEXCOORD2F)_getPrivateProcAddress("glMultiTexCoord2f");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord2f;
    }
    _glMultiTexCoord2f = _ptr;
    _glMultiTexCoord2f(target, s, t);
}

PFN_GLMULTITEXCOORD2F _glMultiTexCoord2f = &_get_glMultiTexCoord2f;

static void APIENTRY _fail_glMultiTexCoord2fv(GLenum target, const GLfloat * v) {
    const char *_name = "glMultiTexCoord2fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord2fv(GLenum target, const GLfloat * v) {
    PFN_GLMULTITEXCOORD2FV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD2FV)_getPrivateProcAddress("glMultiTexCoord2fv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord2fv;
    }
    _glMultiTexCoord2fv = _ptr;
    _glMultiTexCoord2fv(target, v);
}

PFN_GLMULTITEXCOORD2FV _glMultiTexCoord2fv = &_get_glMultiTexCoord2fv;

static void APIENTRY _fail_glMultiTexCoord2i(GLenum target, GLint s, GLint t) {
    const char *_name = "glMultiTexCoord2i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord2i(GLenum target, GLint s, GLint t) {
    PFN_GLMULTITEXCOORD2I _ptr;
    _ptr = (PFN_GLMULTITEXCOORD2I)_getPrivateProcAddress("glMultiTexCoord2i");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord2i;
    }
    _glMultiTexCoord2i = _ptr;
    _glMultiTexCoord2i(target, s, t);
}

PFN_GLMULTITEXCOORD2I _glMultiTexCoord2i = &_get_glMultiTexCoord2i;

static void APIENTRY _fail_glMultiTexCoord2iv(GLenum target, const GLint * v) {
    const char *_name = "glMultiTexCoord2iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord2iv(GLenum target, const GLint * v) {
    PFN_GLMULTITEXCOORD2IV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD2IV)_getPrivateProcAddress("glMultiTexCoord2iv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord2iv;
    }
    _glMultiTexCoord2iv = _ptr;
    _glMultiTexCoord2iv(target, v);
}

PFN_GLMULTITEXCOORD2IV _glMultiTexCoord2iv = &_get_glMultiTexCoord2iv;

static void APIENTRY _fail_glMultiTexCoord2s(GLenum target, GLshort s, GLshort t) {
    const char *_name = "glMultiTexCoord2s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord2s(GLenum target, GLshort s, GLshort t) {
    PFN_GLMULTITEXCOORD2S _ptr;
    _ptr = (PFN_GLMULTITEXCOORD2S)_getPrivateProcAddress("glMultiTexCoord2s");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord2s;
    }
    _glMultiTexCoord2s = _ptr;
    _glMultiTexCoord2s(target, s, t);
}

PFN_GLMULTITEXCOORD2S _glMultiTexCoord2s = &_get_glMultiTexCoord2s;

static void APIENTRY _fail_glMultiTexCoord2sv(GLenum target, const GLshort * v) {
    const char *_name = "glMultiTexCoord2sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord2sv(GLenum target, const GLshort * v) {
    PFN_GLMULTITEXCOORD2SV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD2SV)_getPrivateProcAddress("glMultiTexCoord2sv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord2sv;
    }
    _glMultiTexCoord2sv = _ptr;
    _glMultiTexCoord2sv(target, v);
}

PFN_GLMULTITEXCOORD2SV _glMultiTexCoord2sv = &_get_glMultiTexCoord2sv;

static void APIENTRY _fail_glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r) {
    const char *_name = "glMultiTexCoord3d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r) {
    PFN_GLMULTITEXCOORD3D _ptr;
    _ptr = (PFN_GLMULTITEXCOORD3D)_getPrivateProcAddress("glMultiTexCoord3d");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord3d;
    }
    _glMultiTexCoord3d = _ptr;
    _glMultiTexCoord3d(target, s, t, r);
}

PFN_GLMULTITEXCOORD3D _glMultiTexCoord3d = &_get_glMultiTexCoord3d;

static void APIENTRY _fail_glMultiTexCoord3dv(GLenum target, const GLdouble * v) {
    const char *_name = "glMultiTexCoord3dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord3dv(GLenum target, const GLdouble * v) {
    PFN_GLMULTITEXCOORD3DV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD3DV)_getPrivateProcAddress("glMultiTexCoord3dv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord3dv;
    }
    _glMultiTexCoord3dv = _ptr;
    _glMultiTexCoord3dv(target, v);
}

PFN_GLMULTITEXCOORD3DV _glMultiTexCoord3dv = &_get_glMultiTexCoord3dv;

static void APIENTRY _fail_glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r) {
    const char *_name = "glMultiTexCoord3f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r) {
    PFN_GLMULTITEXCOORD3F _ptr;
    _ptr = (PFN_GLMULTITEXCOORD3F)_getPrivateProcAddress("glMultiTexCoord3f");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord3f;
    }
    _glMultiTexCoord3f = _ptr;
    _glMultiTexCoord3f(target, s, t, r);
}

PFN_GLMULTITEXCOORD3F _glMultiTexCoord3f = &_get_glMultiTexCoord3f;

static void APIENTRY _fail_glMultiTexCoord3fv(GLenum target, const GLfloat * v) {
    const char *_name = "glMultiTexCoord3fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord3fv(GLenum target, const GLfloat * v) {
    PFN_GLMULTITEXCOORD3FV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD3FV)_getPrivateProcAddress("glMultiTexCoord3fv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord3fv;
    }
    _glMultiTexCoord3fv = _ptr;
    _glMultiTexCoord3fv(target, v);
}

PFN_GLMULTITEXCOORD3FV _glMultiTexCoord3fv = &_get_glMultiTexCoord3fv;

static void APIENTRY _fail_glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r) {
    const char *_name = "glMultiTexCoord3i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r) {
    PFN_GLMULTITEXCOORD3I _ptr;
    _ptr = (PFN_GLMULTITEXCOORD3I)_getPrivateProcAddress("glMultiTexCoord3i");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord3i;
    }
    _glMultiTexCoord3i = _ptr;
    _glMultiTexCoord3i(target, s, t, r);
}

PFN_GLMULTITEXCOORD3I _glMultiTexCoord3i = &_get_glMultiTexCoord3i;

static void APIENTRY _fail_glMultiTexCoord3iv(GLenum target, const GLint * v) {
    const char *_name = "glMultiTexCoord3iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord3iv(GLenum target, const GLint * v) {
    PFN_GLMULTITEXCOORD3IV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD3IV)_getPrivateProcAddress("glMultiTexCoord3iv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord3iv;
    }
    _glMultiTexCoord3iv = _ptr;
    _glMultiTexCoord3iv(target, v);
}

PFN_GLMULTITEXCOORD3IV _glMultiTexCoord3iv = &_get_glMultiTexCoord3iv;

static void APIENTRY _fail_glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r) {
    const char *_name = "glMultiTexCoord3s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r) {
    PFN_GLMULTITEXCOORD3S _ptr;
    _ptr = (PFN_GLMULTITEXCOORD3S)_getPrivateProcAddress("glMultiTexCoord3s");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord3s;
    }
    _glMultiTexCoord3s = _ptr;
    _glMultiTexCoord3s(target, s, t, r);
}

PFN_GLMULTITEXCOORD3S _glMultiTexCoord3s = &_get_glMultiTexCoord3s;

static void APIENTRY _fail_glMultiTexCoord3sv(GLenum target, const GLshort * v) {
    const char *_name = "glMultiTexCoord3sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord3sv(GLenum target, const GLshort * v) {
    PFN_GLMULTITEXCOORD3SV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD3SV)_getPrivateProcAddress("glMultiTexCoord3sv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord3sv;
    }
    _glMultiTexCoord3sv = _ptr;
    _glMultiTexCoord3sv(target, v);
}

PFN_GLMULTITEXCOORD3SV _glMultiTexCoord3sv = &_get_glMultiTexCoord3sv;

static void APIENTRY _fail_glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q) {
    const char *_name = "glMultiTexCoord4d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q) {
    PFN_GLMULTITEXCOORD4D _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4D)_getPrivateProcAddress("glMultiTexCoord4d");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4d;
    }
    _glMultiTexCoord4d = _ptr;
    _glMultiTexCoord4d(target, s, t, r, q);
}

PFN_GLMULTITEXCOORD4D _glMultiTexCoord4d = &_get_glMultiTexCoord4d;

static void APIENTRY _fail_glMultiTexCoord4dv(GLenum target, const GLdouble * v) {
    const char *_name = "glMultiTexCoord4dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4dv(GLenum target, const GLdouble * v) {
    PFN_GLMULTITEXCOORD4DV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4DV)_getPrivateProcAddress("glMultiTexCoord4dv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4dv;
    }
    _glMultiTexCoord4dv = _ptr;
    _glMultiTexCoord4dv(target, v);
}

PFN_GLMULTITEXCOORD4DV _glMultiTexCoord4dv = &_get_glMultiTexCoord4dv;

static void APIENTRY _fail_glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
    const char *_name = "glMultiTexCoord4f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
    PFN_GLMULTITEXCOORD4F _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4F)_getPrivateProcAddress("glMultiTexCoord4f");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4f;
    }
    _glMultiTexCoord4f = _ptr;
    _glMultiTexCoord4f(target, s, t, r, q);
}

PFN_GLMULTITEXCOORD4F _glMultiTexCoord4f = &_get_glMultiTexCoord4f;

static void APIENTRY _fail_glMultiTexCoord4fv(GLenum target, const GLfloat * v) {
    const char *_name = "glMultiTexCoord4fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4fv(GLenum target, const GLfloat * v) {
    PFN_GLMULTITEXCOORD4FV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4FV)_getPrivateProcAddress("glMultiTexCoord4fv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4fv;
    }
    _glMultiTexCoord4fv = _ptr;
    _glMultiTexCoord4fv(target, v);
}

PFN_GLMULTITEXCOORD4FV _glMultiTexCoord4fv = &_get_glMultiTexCoord4fv;

static void APIENTRY _fail_glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q) {
    const char *_name = "glMultiTexCoord4i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q) {
    PFN_GLMULTITEXCOORD4I _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4I)_getPrivateProcAddress("glMultiTexCoord4i");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4i;
    }
    _glMultiTexCoord4i = _ptr;
    _glMultiTexCoord4i(target, s, t, r, q);
}

PFN_GLMULTITEXCOORD4I _glMultiTexCoord4i = &_get_glMultiTexCoord4i;

static void APIENTRY _fail_glMultiTexCoord4iv(GLenum target, const GLint * v) {
    const char *_name = "glMultiTexCoord4iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4iv(GLenum target, const GLint * v) {
    PFN_GLMULTITEXCOORD4IV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4IV)_getPrivateProcAddress("glMultiTexCoord4iv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4iv;
    }
    _glMultiTexCoord4iv = _ptr;
    _glMultiTexCoord4iv(target, v);
}

PFN_GLMULTITEXCOORD4IV _glMultiTexCoord4iv = &_get_glMultiTexCoord4iv;

static void APIENTRY _fail_glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q) {
    const char *_name = "glMultiTexCoord4s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q) {
    PFN_GLMULTITEXCOORD4S _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4S)_getPrivateProcAddress("glMultiTexCoord4s");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4s;
    }
    _glMultiTexCoord4s = _ptr;
    _glMultiTexCoord4s(target, s, t, r, q);
}

PFN_GLMULTITEXCOORD4S _glMultiTexCoord4s = &_get_glMultiTexCoord4s;

static void APIENTRY _fail_glMultiTexCoord4sv(GLenum target, const GLshort * v) {
    const char *_name = "glMultiTexCoord4sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4sv(GLenum target, const GLshort * v) {
    PFN_GLMULTITEXCOORD4SV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4SV)_getPrivateProcAddress("glMultiTexCoord4sv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4sv;
    }
    _glMultiTexCoord4sv = _ptr;
    _glMultiTexCoord4sv(target, v);
}

PFN_GLMULTITEXCOORD4SV _glMultiTexCoord4sv = &_get_glMultiTexCoord4sv;

static void APIENTRY _fail_glLoadTransposeMatrixf(const GLfloat * m) {
    const char *_name = "glLoadTransposeMatrixf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLoadTransposeMatrixf(const GLfloat * m) {
    PFN_GLLOADTRANSPOSEMATRIXF _ptr;
    _ptr = (PFN_GLLOADTRANSPOSEMATRIXF)_getPrivateProcAddress("glLoadTransposeMatrixf");
    if (!_ptr) {
        _ptr = &_fail_glLoadTransposeMatrixf;
    }
    _glLoadTransposeMatrixf = _ptr;
    _glLoadTransposeMatrixf(m);
}

PFN_GLLOADTRANSPOSEMATRIXF _glLoadTransposeMatrixf = &_get_glLoadTransposeMatrixf;

static void APIENTRY _fail_glLoadTransposeMatrixd(const GLdouble * m) {
    const char *_name = "glLoadTransposeMatrixd";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLoadTransposeMatrixd(const GLdouble * m) {
    PFN_GLLOADTRANSPOSEMATRIXD _ptr;
    _ptr = (PFN_GLLOADTRANSPOSEMATRIXD)_getPrivateProcAddress("glLoadTransposeMatrixd");
    if (!_ptr) {
        _ptr = &_fail_glLoadTransposeMatrixd;
    }
    _glLoadTransposeMatrixd = _ptr;
    _glLoadTransposeMatrixd(m);
}

PFN_GLLOADTRANSPOSEMATRIXD _glLoadTransposeMatrixd = &_get_glLoadTransposeMatrixd;

static void APIENTRY _fail_glMultTransposeMatrixf(const GLfloat * m) {
    const char *_name = "glMultTransposeMatrixf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultTransposeMatrixf(const GLfloat * m) {
    PFN_GLMULTTRANSPOSEMATRIXF _ptr;
    _ptr = (PFN_GLMULTTRANSPOSEMATRIXF)_getPrivateProcAddress("glMultTransposeMatrixf");
    if (!_ptr) {
        _ptr = &_fail_glMultTransposeMatrixf;
    }
    _glMultTransposeMatrixf = _ptr;
    _glMultTransposeMatrixf(m);
}

PFN_GLMULTTRANSPOSEMATRIXF _glMultTransposeMatrixf = &_get_glMultTransposeMatrixf;

static void APIENTRY _fail_glMultTransposeMatrixd(const GLdouble * m) {
    const char *_name = "glMultTransposeMatrixd";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultTransposeMatrixd(const GLdouble * m) {
    PFN_GLMULTTRANSPOSEMATRIXD _ptr;
    _ptr = (PFN_GLMULTTRANSPOSEMATRIXD)_getPrivateProcAddress("glMultTransposeMatrixd");
    if (!_ptr) {
        _ptr = &_fail_glMultTransposeMatrixd;
    }
    _glMultTransposeMatrixd = _ptr;
    _glMultTransposeMatrixd(m);
}

PFN_GLMULTTRANSPOSEMATRIXD _glMultTransposeMatrixd = &_get_glMultTransposeMatrixd;

static void APIENTRY _fail_glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) {
    const char *_name = "glBlendFuncSeparate";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) {
    PFN_GLBLENDFUNCSEPARATE _ptr;
    _ptr = (PFN_GLBLENDFUNCSEPARATE)_getPrivateProcAddress("glBlendFuncSeparate");
    if (!_ptr) {
        _ptr = &_fail_glBlendFuncSeparate;
    }
    _glBlendFuncSeparate = _ptr;
    _glBlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

PFN_GLBLENDFUNCSEPARATE _glBlendFuncSeparate = &_get_glBlendFuncSeparate;

static void APIENTRY _fail_glMultiDrawArrays(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount) {
    const char *_name = "glMultiDrawArrays";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiDrawArrays(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount) {
    PFN_GLMULTIDRAWARRAYS _ptr;
    _ptr = (PFN_GLMULTIDRAWARRAYS)_getPrivateProcAddress("glMultiDrawArrays");
    if (!_ptr) {
        _ptr = &_fail_glMultiDrawArrays;
    }
    _glMultiDrawArrays = _ptr;
    _glMultiDrawArrays(mode, first, count, drawcount);
}

PFN_GLMULTIDRAWARRAYS _glMultiDrawArrays = &_get_glMultiDrawArrays;

static void APIENTRY _fail_glMultiDrawElements(GLenum mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei drawcount) {
    const char *_name = "glMultiDrawElements";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiDrawElements(GLenum mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei drawcount) {
    PFN_GLMULTIDRAWELEMENTS _ptr;
    _ptr = (PFN_GLMULTIDRAWELEMENTS)_getPrivateProcAddress("glMultiDrawElements");
    if (!_ptr) {
        _ptr = &_fail_glMultiDrawElements;
    }
    _glMultiDrawElements = _ptr;
    _glMultiDrawElements(mode, count, type, indices, drawcount);
}

PFN_GLMULTIDRAWELEMENTS _glMultiDrawElements = &_get_glMultiDrawElements;

static void APIENTRY _fail_glPointParameterf(GLenum pname, GLfloat param) {
    const char *_name = "glPointParameterf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPointParameterf(GLenum pname, GLfloat param) {
    PFN_GLPOINTPARAMETERF _ptr;
    _ptr = (PFN_GLPOINTPARAMETERF)_getPrivateProcAddress("glPointParameterf");
    if (!_ptr) {
        _ptr = &_fail_glPointParameterf;
    }
    _glPointParameterf = _ptr;
    _glPointParameterf(pname, param);
}

PFN_GLPOINTPARAMETERF _glPointParameterf = &_get_glPointParameterf;

static void APIENTRY _fail_glPointParameterfv(GLenum pname, const GLfloat * params) {
    const char *_name = "glPointParameterfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPointParameterfv(GLenum pname, const GLfloat * params) {
    PFN_GLPOINTPARAMETERFV _ptr;
    _ptr = (PFN_GLPOINTPARAMETERFV)_getPrivateProcAddress("glPointParameterfv");
    if (!_ptr) {
        _ptr = &_fail_glPointParameterfv;
    }
    _glPointParameterfv = _ptr;
    _glPointParameterfv(pname, params);
}

PFN_GLPOINTPARAMETERFV _glPointParameterfv = &_get_glPointParameterfv;

static void APIENTRY _fail_glPointParameteri(GLenum pname, GLint param) {
    const char *_name = "glPointParameteri";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPointParameteri(GLenum pname, GLint param) {
    PFN_GLPOINTPARAMETERI _ptr;
    _ptr = (PFN_GLPOINTPARAMETERI)_getPrivateProcAddress("glPointParameteri");
    if (!_ptr) {
        _ptr = &_fail_glPointParameteri;
    }
    _glPointParameteri = _ptr;
    _glPointParameteri(pname, param);
}

PFN_GLPOINTPARAMETERI _glPointParameteri = &_get_glPointParameteri;

static void APIENTRY _fail_glPointParameteriv(GLenum pname, const GLint * params) {
    const char *_name = "glPointParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPointParameteriv(GLenum pname, const GLint * params) {
    PFN_GLPOINTPARAMETERIV _ptr;
    _ptr = (PFN_GLPOINTPARAMETERIV)_getPrivateProcAddress("glPointParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glPointParameteriv;
    }
    _glPointParameteriv = _ptr;
    _glPointParameteriv(pname, params);
}

PFN_GLPOINTPARAMETERIV _glPointParameteriv = &_get_glPointParameteriv;

static void APIENTRY _fail_glFogCoordf(GLfloat coord) {
    const char *_name = "glFogCoordf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogCoordf(GLfloat coord) {
    PFN_GLFOGCOORDF _ptr;
    _ptr = (PFN_GLFOGCOORDF)_getPrivateProcAddress("glFogCoordf");
    if (!_ptr) {
        _ptr = &_fail_glFogCoordf;
    }
    _glFogCoordf = _ptr;
    _glFogCoordf(coord);
}

PFN_GLFOGCOORDF _glFogCoordf = &_get_glFogCoordf;

static void APIENTRY _fail_glFogCoordfv(const GLfloat * coord) {
    const char *_name = "glFogCoordfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogCoordfv(const GLfloat * coord) {
    PFN_GLFOGCOORDFV _ptr;
    _ptr = (PFN_GLFOGCOORDFV)_getPrivateProcAddress("glFogCoordfv");
    if (!_ptr) {
        _ptr = &_fail_glFogCoordfv;
    }
    _glFogCoordfv = _ptr;
    _glFogCoordfv(coord);
}

PFN_GLFOGCOORDFV _glFogCoordfv = &_get_glFogCoordfv;

static void APIENTRY _fail_glFogCoordd(GLdouble coord) {
    const char *_name = "glFogCoordd";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogCoordd(GLdouble coord) {
    PFN_GLFOGCOORDD _ptr;
    _ptr = (PFN_GLFOGCOORDD)_getPrivateProcAddress("glFogCoordd");
    if (!_ptr) {
        _ptr = &_fail_glFogCoordd;
    }
    _glFogCoordd = _ptr;
    _glFogCoordd(coord);
}

PFN_GLFOGCOORDD _glFogCoordd = &_get_glFogCoordd;

static void APIENTRY _fail_glFogCoorddv(const GLdouble * coord) {
    const char *_name = "glFogCoorddv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogCoorddv(const GLdouble * coord) {
    PFN_GLFOGCOORDDV _ptr;
    _ptr = (PFN_GLFOGCOORDDV)_getPrivateProcAddress("glFogCoorddv");
    if (!_ptr) {
        _ptr = &_fail_glFogCoorddv;
    }
    _glFogCoorddv = _ptr;
    _glFogCoorddv(coord);
}

PFN_GLFOGCOORDDV _glFogCoorddv = &_get_glFogCoorddv;

static void APIENTRY _fail_glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glFogCoordPointer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLFOGCOORDPOINTER _ptr;
    _ptr = (PFN_GLFOGCOORDPOINTER)_getPrivateProcAddress("glFogCoordPointer");
    if (!_ptr) {
        _ptr = &_fail_glFogCoordPointer;
    }
    _glFogCoordPointer = _ptr;
    _glFogCoordPointer(type, stride, pointer);
}

PFN_GLFOGCOORDPOINTER _glFogCoordPointer = &_get_glFogCoordPointer;

static void APIENTRY _fail_glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue) {
    const char *_name = "glSecondaryColor3b";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue) {
    PFN_GLSECONDARYCOLOR3B _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3B)_getPrivateProcAddress("glSecondaryColor3b");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3b;
    }
    _glSecondaryColor3b = _ptr;
    _glSecondaryColor3b(red, green, blue);
}

PFN_GLSECONDARYCOLOR3B _glSecondaryColor3b = &_get_glSecondaryColor3b;

static void APIENTRY _fail_glSecondaryColor3bv(const GLbyte * v) {
    const char *_name = "glSecondaryColor3bv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3bv(const GLbyte * v) {
    PFN_GLSECONDARYCOLOR3BV _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3BV)_getPrivateProcAddress("glSecondaryColor3bv");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3bv;
    }
    _glSecondaryColor3bv = _ptr;
    _glSecondaryColor3bv(v);
}

PFN_GLSECONDARYCOLOR3BV _glSecondaryColor3bv = &_get_glSecondaryColor3bv;

static void APIENTRY _fail_glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue) {
    const char *_name = "glSecondaryColor3d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue) {
    PFN_GLSECONDARYCOLOR3D _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3D)_getPrivateProcAddress("glSecondaryColor3d");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3d;
    }
    _glSecondaryColor3d = _ptr;
    _glSecondaryColor3d(red, green, blue);
}

PFN_GLSECONDARYCOLOR3D _glSecondaryColor3d = &_get_glSecondaryColor3d;

static void APIENTRY _fail_glSecondaryColor3dv(const GLdouble * v) {
    const char *_name = "glSecondaryColor3dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3dv(const GLdouble * v) {
    PFN_GLSECONDARYCOLOR3DV _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3DV)_getPrivateProcAddress("glSecondaryColor3dv");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3dv;
    }
    _glSecondaryColor3dv = _ptr;
    _glSecondaryColor3dv(v);
}

PFN_GLSECONDARYCOLOR3DV _glSecondaryColor3dv = &_get_glSecondaryColor3dv;

static void APIENTRY _fail_glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue) {
    const char *_name = "glSecondaryColor3f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue) {
    PFN_GLSECONDARYCOLOR3F _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3F)_getPrivateProcAddress("glSecondaryColor3f");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3f;
    }
    _glSecondaryColor3f = _ptr;
    _glSecondaryColor3f(red, green, blue);
}

PFN_GLSECONDARYCOLOR3F _glSecondaryColor3f = &_get_glSecondaryColor3f;

static void APIENTRY _fail_glSecondaryColor3fv(const GLfloat * v) {
    const char *_name = "glSecondaryColor3fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3fv(const GLfloat * v) {
    PFN_GLSECONDARYCOLOR3FV _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3FV)_getPrivateProcAddress("glSecondaryColor3fv");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3fv;
    }
    _glSecondaryColor3fv = _ptr;
    _glSecondaryColor3fv(v);
}

PFN_GLSECONDARYCOLOR3FV _glSecondaryColor3fv = &_get_glSecondaryColor3fv;

static void APIENTRY _fail_glSecondaryColor3i(GLint red, GLint green, GLint blue) {
    const char *_name = "glSecondaryColor3i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3i(GLint red, GLint green, GLint blue) {
    PFN_GLSECONDARYCOLOR3I _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3I)_getPrivateProcAddress("glSecondaryColor3i");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3i;
    }
    _glSecondaryColor3i = _ptr;
    _glSecondaryColor3i(red, green, blue);
}

PFN_GLSECONDARYCOLOR3I _glSecondaryColor3i = &_get_glSecondaryColor3i;

static void APIENTRY _fail_glSecondaryColor3iv(const GLint * v) {
    const char *_name = "glSecondaryColor3iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3iv(const GLint * v) {
    PFN_GLSECONDARYCOLOR3IV _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3IV)_getPrivateProcAddress("glSecondaryColor3iv");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3iv;
    }
    _glSecondaryColor3iv = _ptr;
    _glSecondaryColor3iv(v);
}

PFN_GLSECONDARYCOLOR3IV _glSecondaryColor3iv = &_get_glSecondaryColor3iv;

static void APIENTRY _fail_glSecondaryColor3s(GLshort red, GLshort green, GLshort blue) {
    const char *_name = "glSecondaryColor3s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3s(GLshort red, GLshort green, GLshort blue) {
    PFN_GLSECONDARYCOLOR3S _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3S)_getPrivateProcAddress("glSecondaryColor3s");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3s;
    }
    _glSecondaryColor3s = _ptr;
    _glSecondaryColor3s(red, green, blue);
}

PFN_GLSECONDARYCOLOR3S _glSecondaryColor3s = &_get_glSecondaryColor3s;

static void APIENTRY _fail_glSecondaryColor3sv(const GLshort * v) {
    const char *_name = "glSecondaryColor3sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3sv(const GLshort * v) {
    PFN_GLSECONDARYCOLOR3SV _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3SV)_getPrivateProcAddress("glSecondaryColor3sv");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3sv;
    }
    _glSecondaryColor3sv = _ptr;
    _glSecondaryColor3sv(v);
}

PFN_GLSECONDARYCOLOR3SV _glSecondaryColor3sv = &_get_glSecondaryColor3sv;

static void APIENTRY _fail_glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue) {
    const char *_name = "glSecondaryColor3ub";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue) {
    PFN_GLSECONDARYCOLOR3UB _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3UB)_getPrivateProcAddress("glSecondaryColor3ub");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3ub;
    }
    _glSecondaryColor3ub = _ptr;
    _glSecondaryColor3ub(red, green, blue);
}

PFN_GLSECONDARYCOLOR3UB _glSecondaryColor3ub = &_get_glSecondaryColor3ub;

static void APIENTRY _fail_glSecondaryColor3ubv(const GLubyte * v) {
    const char *_name = "glSecondaryColor3ubv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3ubv(const GLubyte * v) {
    PFN_GLSECONDARYCOLOR3UBV _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3UBV)_getPrivateProcAddress("glSecondaryColor3ubv");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3ubv;
    }
    _glSecondaryColor3ubv = _ptr;
    _glSecondaryColor3ubv(v);
}

PFN_GLSECONDARYCOLOR3UBV _glSecondaryColor3ubv = &_get_glSecondaryColor3ubv;

static void APIENTRY _fail_glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue) {
    const char *_name = "glSecondaryColor3ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue) {
    PFN_GLSECONDARYCOLOR3UI _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3UI)_getPrivateProcAddress("glSecondaryColor3ui");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3ui;
    }
    _glSecondaryColor3ui = _ptr;
    _glSecondaryColor3ui(red, green, blue);
}

PFN_GLSECONDARYCOLOR3UI _glSecondaryColor3ui = &_get_glSecondaryColor3ui;

static void APIENTRY _fail_glSecondaryColor3uiv(const GLuint * v) {
    const char *_name = "glSecondaryColor3uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3uiv(const GLuint * v) {
    PFN_GLSECONDARYCOLOR3UIV _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3UIV)_getPrivateProcAddress("glSecondaryColor3uiv");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3uiv;
    }
    _glSecondaryColor3uiv = _ptr;
    _glSecondaryColor3uiv(v);
}

PFN_GLSECONDARYCOLOR3UIV _glSecondaryColor3uiv = &_get_glSecondaryColor3uiv;

static void APIENTRY _fail_glSecondaryColor3us(GLushort red, GLushort green, GLushort blue) {
    const char *_name = "glSecondaryColor3us";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3us(GLushort red, GLushort green, GLushort blue) {
    PFN_GLSECONDARYCOLOR3US _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3US)_getPrivateProcAddress("glSecondaryColor3us");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3us;
    }
    _glSecondaryColor3us = _ptr;
    _glSecondaryColor3us(red, green, blue);
}

PFN_GLSECONDARYCOLOR3US _glSecondaryColor3us = &_get_glSecondaryColor3us;

static void APIENTRY _fail_glSecondaryColor3usv(const GLushort * v) {
    const char *_name = "glSecondaryColor3usv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3usv(const GLushort * v) {
    PFN_GLSECONDARYCOLOR3USV _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3USV)_getPrivateProcAddress("glSecondaryColor3usv");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3usv;
    }
    _glSecondaryColor3usv = _ptr;
    _glSecondaryColor3usv(v);
}

PFN_GLSECONDARYCOLOR3USV _glSecondaryColor3usv = &_get_glSecondaryColor3usv;

static void APIENTRY _fail_glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glSecondaryColorPointer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLSECONDARYCOLORPOINTER _ptr;
    _ptr = (PFN_GLSECONDARYCOLORPOINTER)_getPrivateProcAddress("glSecondaryColorPointer");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColorPointer;
    }
    _glSecondaryColorPointer = _ptr;
    _glSecondaryColorPointer(size, type, stride, pointer);
}

PFN_GLSECONDARYCOLORPOINTER _glSecondaryColorPointer = &_get_glSecondaryColorPointer;

static void APIENTRY _fail_glWindowPos2d(GLdouble x, GLdouble y) {
    const char *_name = "glWindowPos2d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2d(GLdouble x, GLdouble y) {
    PFN_GLWINDOWPOS2D _ptr;
    _ptr = (PFN_GLWINDOWPOS2D)_getPrivateProcAddress("glWindowPos2d");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2d;
    }
    _glWindowPos2d = _ptr;
    _glWindowPos2d(x, y);
}

PFN_GLWINDOWPOS2D _glWindowPos2d = &_get_glWindowPos2d;

static void APIENTRY _fail_glWindowPos2dv(const GLdouble * v) {
    const char *_name = "glWindowPos2dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2dv(const GLdouble * v) {
    PFN_GLWINDOWPOS2DV _ptr;
    _ptr = (PFN_GLWINDOWPOS2DV)_getPrivateProcAddress("glWindowPos2dv");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2dv;
    }
    _glWindowPos2dv = _ptr;
    _glWindowPos2dv(v);
}

PFN_GLWINDOWPOS2DV _glWindowPos2dv = &_get_glWindowPos2dv;

static void APIENTRY _fail_glWindowPos2f(GLfloat x, GLfloat y) {
    const char *_name = "glWindowPos2f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2f(GLfloat x, GLfloat y) {
    PFN_GLWINDOWPOS2F _ptr;
    _ptr = (PFN_GLWINDOWPOS2F)_getPrivateProcAddress("glWindowPos2f");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2f;
    }
    _glWindowPos2f = _ptr;
    _glWindowPos2f(x, y);
}

PFN_GLWINDOWPOS2F _glWindowPos2f = &_get_glWindowPos2f;

static void APIENTRY _fail_glWindowPos2fv(const GLfloat * v) {
    const char *_name = "glWindowPos2fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2fv(const GLfloat * v) {
    PFN_GLWINDOWPOS2FV _ptr;
    _ptr = (PFN_GLWINDOWPOS2FV)_getPrivateProcAddress("glWindowPos2fv");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2fv;
    }
    _glWindowPos2fv = _ptr;
    _glWindowPos2fv(v);
}

PFN_GLWINDOWPOS2FV _glWindowPos2fv = &_get_glWindowPos2fv;

static void APIENTRY _fail_glWindowPos2i(GLint x, GLint y) {
    const char *_name = "glWindowPos2i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2i(GLint x, GLint y) {
    PFN_GLWINDOWPOS2I _ptr;
    _ptr = (PFN_GLWINDOWPOS2I)_getPrivateProcAddress("glWindowPos2i");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2i;
    }
    _glWindowPos2i = _ptr;
    _glWindowPos2i(x, y);
}

PFN_GLWINDOWPOS2I _glWindowPos2i = &_get_glWindowPos2i;

static void APIENTRY _fail_glWindowPos2iv(const GLint * v) {
    const char *_name = "glWindowPos2iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2iv(const GLint * v) {
    PFN_GLWINDOWPOS2IV _ptr;
    _ptr = (PFN_GLWINDOWPOS2IV)_getPrivateProcAddress("glWindowPos2iv");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2iv;
    }
    _glWindowPos2iv = _ptr;
    _glWindowPos2iv(v);
}

PFN_GLWINDOWPOS2IV _glWindowPos2iv = &_get_glWindowPos2iv;

static void APIENTRY _fail_glWindowPos2s(GLshort x, GLshort y) {
    const char *_name = "glWindowPos2s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2s(GLshort x, GLshort y) {
    PFN_GLWINDOWPOS2S _ptr;
    _ptr = (PFN_GLWINDOWPOS2S)_getPrivateProcAddress("glWindowPos2s");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2s;
    }
    _glWindowPos2s = _ptr;
    _glWindowPos2s(x, y);
}

PFN_GLWINDOWPOS2S _glWindowPos2s = &_get_glWindowPos2s;

static void APIENTRY _fail_glWindowPos2sv(const GLshort * v) {
    const char *_name = "glWindowPos2sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2sv(const GLshort * v) {
    PFN_GLWINDOWPOS2SV _ptr;
    _ptr = (PFN_GLWINDOWPOS2SV)_getPrivateProcAddress("glWindowPos2sv");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2sv;
    }
    _glWindowPos2sv = _ptr;
    _glWindowPos2sv(v);
}

PFN_GLWINDOWPOS2SV _glWindowPos2sv = &_get_glWindowPos2sv;

static void APIENTRY _fail_glWindowPos3d(GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glWindowPos3d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3d(GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLWINDOWPOS3D _ptr;
    _ptr = (PFN_GLWINDOWPOS3D)_getPrivateProcAddress("glWindowPos3d");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3d;
    }
    _glWindowPos3d = _ptr;
    _glWindowPos3d(x, y, z);
}

PFN_GLWINDOWPOS3D _glWindowPos3d = &_get_glWindowPos3d;

static void APIENTRY _fail_glWindowPos3dv(const GLdouble * v) {
    const char *_name = "glWindowPos3dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3dv(const GLdouble * v) {
    PFN_GLWINDOWPOS3DV _ptr;
    _ptr = (PFN_GLWINDOWPOS3DV)_getPrivateProcAddress("glWindowPos3dv");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3dv;
    }
    _glWindowPos3dv = _ptr;
    _glWindowPos3dv(v);
}

PFN_GLWINDOWPOS3DV _glWindowPos3dv = &_get_glWindowPos3dv;

static void APIENTRY _fail_glWindowPos3f(GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glWindowPos3f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3f(GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLWINDOWPOS3F _ptr;
    _ptr = (PFN_GLWINDOWPOS3F)_getPrivateProcAddress("glWindowPos3f");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3f;
    }
    _glWindowPos3f = _ptr;
    _glWindowPos3f(x, y, z);
}

PFN_GLWINDOWPOS3F _glWindowPos3f = &_get_glWindowPos3f;

static void APIENTRY _fail_glWindowPos3fv(const GLfloat * v) {
    const char *_name = "glWindowPos3fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3fv(const GLfloat * v) {
    PFN_GLWINDOWPOS3FV _ptr;
    _ptr = (PFN_GLWINDOWPOS3FV)_getPrivateProcAddress("glWindowPos3fv");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3fv;
    }
    _glWindowPos3fv = _ptr;
    _glWindowPos3fv(v);
}

PFN_GLWINDOWPOS3FV _glWindowPos3fv = &_get_glWindowPos3fv;

static void APIENTRY _fail_glWindowPos3i(GLint x, GLint y, GLint z) {
    const char *_name = "glWindowPos3i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3i(GLint x, GLint y, GLint z) {
    PFN_GLWINDOWPOS3I _ptr;
    _ptr = (PFN_GLWINDOWPOS3I)_getPrivateProcAddress("glWindowPos3i");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3i;
    }
    _glWindowPos3i = _ptr;
    _glWindowPos3i(x, y, z);
}

PFN_GLWINDOWPOS3I _glWindowPos3i = &_get_glWindowPos3i;

static void APIENTRY _fail_glWindowPos3iv(const GLint * v) {
    const char *_name = "glWindowPos3iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3iv(const GLint * v) {
    PFN_GLWINDOWPOS3IV _ptr;
    _ptr = (PFN_GLWINDOWPOS3IV)_getPrivateProcAddress("glWindowPos3iv");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3iv;
    }
    _glWindowPos3iv = _ptr;
    _glWindowPos3iv(v);
}

PFN_GLWINDOWPOS3IV _glWindowPos3iv = &_get_glWindowPos3iv;

static void APIENTRY _fail_glWindowPos3s(GLshort x, GLshort y, GLshort z) {
    const char *_name = "glWindowPos3s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3s(GLshort x, GLshort y, GLshort z) {
    PFN_GLWINDOWPOS3S _ptr;
    _ptr = (PFN_GLWINDOWPOS3S)_getPrivateProcAddress("glWindowPos3s");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3s;
    }
    _glWindowPos3s = _ptr;
    _glWindowPos3s(x, y, z);
}

PFN_GLWINDOWPOS3S _glWindowPos3s = &_get_glWindowPos3s;

static void APIENTRY _fail_glWindowPos3sv(const GLshort * v) {
    const char *_name = "glWindowPos3sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3sv(const GLshort * v) {
    PFN_GLWINDOWPOS3SV _ptr;
    _ptr = (PFN_GLWINDOWPOS3SV)_getPrivateProcAddress("glWindowPos3sv");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3sv;
    }
    _glWindowPos3sv = _ptr;
    _glWindowPos3sv(v);
}

PFN_GLWINDOWPOS3SV _glWindowPos3sv = &_get_glWindowPos3sv;

static void APIENTRY _fail_glGenQueries(GLsizei n, GLuint * ids) {
    const char *_name = "glGenQueries";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenQueries(GLsizei n, GLuint * ids) {
    PFN_GLGENQUERIES _ptr;
    _ptr = (PFN_GLGENQUERIES)_getPrivateProcAddress("glGenQueries");
    if (!_ptr) {
        _ptr = &_fail_glGenQueries;
    }
    _glGenQueries = _ptr;
    _glGenQueries(n, ids);
}

PFN_GLGENQUERIES _glGenQueries = &_get_glGenQueries;

static void APIENTRY _fail_glDeleteQueries(GLsizei n, const GLuint * ids) {
    const char *_name = "glDeleteQueries";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteQueries(GLsizei n, const GLuint * ids) {
    PFN_GLDELETEQUERIES _ptr;
    _ptr = (PFN_GLDELETEQUERIES)_getPrivateProcAddress("glDeleteQueries");
    if (!_ptr) {
        _ptr = &_fail_glDeleteQueries;
    }
    _glDeleteQueries = _ptr;
    _glDeleteQueries(n, ids);
}

PFN_GLDELETEQUERIES _glDeleteQueries = &_get_glDeleteQueries;

static GLboolean APIENTRY _fail_glIsQuery(GLuint id) {
    const char *_name = "glIsQuery";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsQuery(GLuint id) {
    PFN_GLISQUERY _ptr;
    _ptr = (PFN_GLISQUERY)_getPrivateProcAddress("glIsQuery");
    if (!_ptr) {
        _ptr = &_fail_glIsQuery;
    }
    _glIsQuery = _ptr;
    return _glIsQuery(id);
}

PFN_GLISQUERY _glIsQuery = &_get_glIsQuery;

static void APIENTRY _fail_glBeginQuery(GLenum target, GLuint id) {
    const char *_name = "glBeginQuery";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBeginQuery(GLenum target, GLuint id) {
    PFN_GLBEGINQUERY _ptr;
    _ptr = (PFN_GLBEGINQUERY)_getPrivateProcAddress("glBeginQuery");
    if (!_ptr) {
        _ptr = &_fail_glBeginQuery;
    }
    _glBeginQuery = _ptr;
    _glBeginQuery(target, id);
}

PFN_GLBEGINQUERY _glBeginQuery = &_get_glBeginQuery;

static void APIENTRY _fail_glEndQuery(GLenum target) {
    const char *_name = "glEndQuery";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEndQuery(GLenum target) {
    PFN_GLENDQUERY _ptr;
    _ptr = (PFN_GLENDQUERY)_getPrivateProcAddress("glEndQuery");
    if (!_ptr) {
        _ptr = &_fail_glEndQuery;
    }
    _glEndQuery = _ptr;
    _glEndQuery(target);
}

PFN_GLENDQUERY _glEndQuery = &_get_glEndQuery;

static void APIENTRY _fail_glGetQueryiv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetQueryiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryiv(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETQUERYIV _ptr;
    _ptr = (PFN_GLGETQUERYIV)_getPrivateProcAddress("glGetQueryiv");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryiv;
    }
    _glGetQueryiv = _ptr;
    _glGetQueryiv(target, pname, params);
}

PFN_GLGETQUERYIV _glGetQueryiv = &_get_glGetQueryiv;

static void APIENTRY _fail_glGetQueryObjectiv(GLuint id, GLenum pname, GLint * params) {
    const char *_name = "glGetQueryObjectiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryObjectiv(GLuint id, GLenum pname, GLint * params) {
    PFN_GLGETQUERYOBJECTIV _ptr;
    _ptr = (PFN_GLGETQUERYOBJECTIV)_getPrivateProcAddress("glGetQueryObjectiv");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryObjectiv;
    }
    _glGetQueryObjectiv = _ptr;
    _glGetQueryObjectiv(id, pname, params);
}

PFN_GLGETQUERYOBJECTIV _glGetQueryObjectiv = &_get_glGetQueryObjectiv;

static void APIENTRY _fail_glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint * params) {
    const char *_name = "glGetQueryObjectuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint * params) {
    PFN_GLGETQUERYOBJECTUIV _ptr;
    _ptr = (PFN_GLGETQUERYOBJECTUIV)_getPrivateProcAddress("glGetQueryObjectuiv");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryObjectuiv;
    }
    _glGetQueryObjectuiv = _ptr;
    _glGetQueryObjectuiv(id, pname, params);
}

PFN_GLGETQUERYOBJECTUIV _glGetQueryObjectuiv = &_get_glGetQueryObjectuiv;

static void APIENTRY _fail_glBindBuffer(GLenum target, GLuint buffer) {
    const char *_name = "glBindBuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindBuffer(GLenum target, GLuint buffer) {
    PFN_GLBINDBUFFER _ptr;
    _ptr = (PFN_GLBINDBUFFER)_getPrivateProcAddress("glBindBuffer");
    if (!_ptr) {
        _ptr = &_fail_glBindBuffer;
    }
    _glBindBuffer = _ptr;
    _glBindBuffer(target, buffer);
}

PFN_GLBINDBUFFER _glBindBuffer = &_get_glBindBuffer;

static void APIENTRY _fail_glDeleteBuffers(GLsizei n, const GLuint * buffer) {
    const char *_name = "glDeleteBuffers";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteBuffers(GLsizei n, const GLuint * buffer) {
    PFN_GLDELETEBUFFERS _ptr;
    _ptr = (PFN_GLDELETEBUFFERS)_getPrivateProcAddress("glDeleteBuffers");
    if (!_ptr) {
        _ptr = &_fail_glDeleteBuffers;
    }
    _glDeleteBuffers = _ptr;
    _glDeleteBuffers(n, buffer);
}

PFN_GLDELETEBUFFERS _glDeleteBuffers = &_get_glDeleteBuffers;

static void APIENTRY _fail_glGenBuffers(GLsizei n, GLuint * buffer) {
    const char *_name = "glGenBuffers";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenBuffers(GLsizei n, GLuint * buffer) {
    PFN_GLGENBUFFERS _ptr;
    _ptr = (PFN_GLGENBUFFERS)_getPrivateProcAddress("glGenBuffers");
    if (!_ptr) {
        _ptr = &_fail_glGenBuffers;
    }
    _glGenBuffers = _ptr;
    _glGenBuffers(n, buffer);
}

PFN_GLGENBUFFERS _glGenBuffers = &_get_glGenBuffers;

static GLboolean APIENTRY _fail_glIsBuffer(GLuint buffer) {
    const char *_name = "glIsBuffer";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsBuffer(GLuint buffer) {
    PFN_GLISBUFFER _ptr;
    _ptr = (PFN_GLISBUFFER)_getPrivateProcAddress("glIsBuffer");
    if (!_ptr) {
        _ptr = &_fail_glIsBuffer;
    }
    _glIsBuffer = _ptr;
    return _glIsBuffer(buffer);
}

PFN_GLISBUFFER _glIsBuffer = &_get_glIsBuffer;

static void APIENTRY _fail_glBufferData(GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage) {
    const char *_name = "glBufferData";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBufferData(GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage) {
    PFN_GLBUFFERDATA _ptr;
    _ptr = (PFN_GLBUFFERDATA)_getPrivateProcAddress("glBufferData");
    if (!_ptr) {
        _ptr = &_fail_glBufferData;
    }
    _glBufferData = _ptr;
    _glBufferData(target, size, data, usage);
}

PFN_GLBUFFERDATA _glBufferData = &_get_glBufferData;

static void APIENTRY _fail_glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid * data) {
    const char *_name = "glBufferSubData";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid * data) {
    PFN_GLBUFFERSUBDATA _ptr;
    _ptr = (PFN_GLBUFFERSUBDATA)_getPrivateProcAddress("glBufferSubData");
    if (!_ptr) {
        _ptr = &_fail_glBufferSubData;
    }
    _glBufferSubData = _ptr;
    _glBufferSubData(target, offset, size, data);
}

PFN_GLBUFFERSUBDATA _glBufferSubData = &_get_glBufferSubData;

static void APIENTRY _fail_glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid * data) {
    const char *_name = "glGetBufferSubData";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid * data) {
    PFN_GLGETBUFFERSUBDATA _ptr;
    _ptr = (PFN_GLGETBUFFERSUBDATA)_getPrivateProcAddress("glGetBufferSubData");
    if (!_ptr) {
        _ptr = &_fail_glGetBufferSubData;
    }
    _glGetBufferSubData = _ptr;
    _glGetBufferSubData(target, offset, size, data);
}

PFN_GLGETBUFFERSUBDATA _glGetBufferSubData = &_get_glGetBufferSubData;

static GLvoid * APIENTRY _fail_glMapBuffer(GLenum target, GLenum access) {
    const char *_name = "glMapBuffer";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLvoid * APIENTRY _get_glMapBuffer(GLenum target, GLenum access) {
    PFN_GLMAPBUFFER _ptr;
    _ptr = (PFN_GLMAPBUFFER)_getPrivateProcAddress("glMapBuffer");
    if (!_ptr) {
        _ptr = &_fail_glMapBuffer;
    }
    _glMapBuffer = _ptr;
    return _glMapBuffer(target, access);
}

PFN_GLMAPBUFFER _glMapBuffer = &_get_glMapBuffer;

static GLboolean APIENTRY _fail_glUnmapBuffer(GLenum target) {
    const char *_name = "glUnmapBuffer";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glUnmapBuffer(GLenum target) {
    PFN_GLUNMAPBUFFER _ptr;
    _ptr = (PFN_GLUNMAPBUFFER)_getPrivateProcAddress("glUnmapBuffer");
    if (!_ptr) {
        _ptr = &_fail_glUnmapBuffer;
    }
    _glUnmapBuffer = _ptr;
    return _glUnmapBuffer(target);
}

PFN_GLUNMAPBUFFER _glUnmapBuffer = &_get_glUnmapBuffer;

static void APIENTRY _fail_glGetBufferParameteriv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetBufferParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetBufferParameteriv(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETBUFFERPARAMETERIV _ptr;
    _ptr = (PFN_GLGETBUFFERPARAMETERIV)_getPrivateProcAddress("glGetBufferParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glGetBufferParameteriv;
    }
    _glGetBufferParameteriv = _ptr;
    _glGetBufferParameteriv(target, pname, params);
}

PFN_GLGETBUFFERPARAMETERIV _glGetBufferParameteriv = &_get_glGetBufferParameteriv;

static void APIENTRY _fail_glGetBufferPointerv(GLenum target, GLenum pname, GLvoid * * params) {
    const char *_name = "glGetBufferPointerv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetBufferPointerv(GLenum target, GLenum pname, GLvoid * * params) {
    PFN_GLGETBUFFERPOINTERV _ptr;
    _ptr = (PFN_GLGETBUFFERPOINTERV)_getPrivateProcAddress("glGetBufferPointerv");
    if (!_ptr) {
        _ptr = &_fail_glGetBufferPointerv;
    }
    _glGetBufferPointerv = _ptr;
    _glGetBufferPointerv(target, pname, params);
}

PFN_GLGETBUFFERPOINTERV _glGetBufferPointerv = &_get_glGetBufferPointerv;

static void APIENTRY _fail_glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha) {
    const char *_name = "glBlendEquationSeparate";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha) {
    PFN_GLBLENDEQUATIONSEPARATE _ptr;
    _ptr = (PFN_GLBLENDEQUATIONSEPARATE)_getPrivateProcAddress("glBlendEquationSeparate");
    if (!_ptr) {
        _ptr = &_fail_glBlendEquationSeparate;
    }
    _glBlendEquationSeparate = _ptr;
    _glBlendEquationSeparate(modeRGB, modeAlpha);
}

PFN_GLBLENDEQUATIONSEPARATE _glBlendEquationSeparate = &_get_glBlendEquationSeparate;

static void APIENTRY _fail_glDrawBuffers(GLsizei n, const GLenum * bufs) {
    const char *_name = "glDrawBuffers";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawBuffers(GLsizei n, const GLenum * bufs) {
    PFN_GLDRAWBUFFERS _ptr;
    _ptr = (PFN_GLDRAWBUFFERS)_getPrivateProcAddress("glDrawBuffers");
    if (!_ptr) {
        _ptr = &_fail_glDrawBuffers;
    }
    _glDrawBuffers = _ptr;
    _glDrawBuffers(n, bufs);
}

PFN_GLDRAWBUFFERS _glDrawBuffers = &_get_glDrawBuffers;

static void APIENTRY _fail_glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) {
    const char *_name = "glStencilOpSeparate";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) {
    PFN_GLSTENCILOPSEPARATE _ptr;
    _ptr = (PFN_GLSTENCILOPSEPARATE)_getPrivateProcAddress("glStencilOpSeparate");
    if (!_ptr) {
        _ptr = &_fail_glStencilOpSeparate;
    }
    _glStencilOpSeparate = _ptr;
    _glStencilOpSeparate(face, sfail, dpfail, dppass);
}

PFN_GLSTENCILOPSEPARATE _glStencilOpSeparate = &_get_glStencilOpSeparate;

static void APIENTRY _fail_glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask) {
    const char *_name = "glStencilFuncSeparate";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask) {
    PFN_GLSTENCILFUNCSEPARATE _ptr;
    _ptr = (PFN_GLSTENCILFUNCSEPARATE)_getPrivateProcAddress("glStencilFuncSeparate");
    if (!_ptr) {
        _ptr = &_fail_glStencilFuncSeparate;
    }
    _glStencilFuncSeparate = _ptr;
    _glStencilFuncSeparate(face, func, ref, mask);
}

PFN_GLSTENCILFUNCSEPARATE _glStencilFuncSeparate = &_get_glStencilFuncSeparate;

static void APIENTRY _fail_glStencilMaskSeparate(GLenum face, GLuint mask) {
    const char *_name = "glStencilMaskSeparate";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStencilMaskSeparate(GLenum face, GLuint mask) {
    PFN_GLSTENCILMASKSEPARATE _ptr;
    _ptr = (PFN_GLSTENCILMASKSEPARATE)_getPrivateProcAddress("glStencilMaskSeparate");
    if (!_ptr) {
        _ptr = &_fail_glStencilMaskSeparate;
    }
    _glStencilMaskSeparate = _ptr;
    _glStencilMaskSeparate(face, mask);
}

PFN_GLSTENCILMASKSEPARATE _glStencilMaskSeparate = &_get_glStencilMaskSeparate;

static void APIENTRY _fail_glAttachShader(GLuint program, GLuint shader) {
    const char *_name = "glAttachShader";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glAttachShader(GLuint program, GLuint shader) {
    PFN_GLATTACHSHADER _ptr;
    _ptr = (PFN_GLATTACHSHADER)_getPrivateProcAddress("glAttachShader");
    if (!_ptr) {
        _ptr = &_fail_glAttachShader;
    }
    _glAttachShader = _ptr;
    _glAttachShader(program, shader);
}

PFN_GLATTACHSHADER _glAttachShader = &_get_glAttachShader;

static void APIENTRY _fail_glBindAttribLocation(GLuint program, GLuint index, const GLchar * name) {
    const char *_name = "glBindAttribLocation";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindAttribLocation(GLuint program, GLuint index, const GLchar * name) {
    PFN_GLBINDATTRIBLOCATION _ptr;
    _ptr = (PFN_GLBINDATTRIBLOCATION)_getPrivateProcAddress("glBindAttribLocation");
    if (!_ptr) {
        _ptr = &_fail_glBindAttribLocation;
    }
    _glBindAttribLocation = _ptr;
    _glBindAttribLocation(program, index, name);
}

PFN_GLBINDATTRIBLOCATION _glBindAttribLocation = &_get_glBindAttribLocation;

static void APIENTRY _fail_glCompileShader(GLuint shader) {
    const char *_name = "glCompileShader";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompileShader(GLuint shader) {
    PFN_GLCOMPILESHADER _ptr;
    _ptr = (PFN_GLCOMPILESHADER)_getPrivateProcAddress("glCompileShader");
    if (!_ptr) {
        _ptr = &_fail_glCompileShader;
    }
    _glCompileShader = _ptr;
    _glCompileShader(shader);
}

PFN_GLCOMPILESHADER _glCompileShader = &_get_glCompileShader;

static GLuint APIENTRY _fail_glCreateProgram(void) {
    const char *_name = "glCreateProgram";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glCreateProgram(void) {
    PFN_GLCREATEPROGRAM _ptr;
    _ptr = (PFN_GLCREATEPROGRAM)_getPrivateProcAddress("glCreateProgram");
    if (!_ptr) {
        _ptr = &_fail_glCreateProgram;
    }
    _glCreateProgram = _ptr;
    return _glCreateProgram();
}

PFN_GLCREATEPROGRAM _glCreateProgram = &_get_glCreateProgram;

static GLuint APIENTRY _fail_glCreateShader(GLenum type) {
    const char *_name = "glCreateShader";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glCreateShader(GLenum type) {
    PFN_GLCREATESHADER _ptr;
    _ptr = (PFN_GLCREATESHADER)_getPrivateProcAddress("glCreateShader");
    if (!_ptr) {
        _ptr = &_fail_glCreateShader;
    }
    _glCreateShader = _ptr;
    return _glCreateShader(type);
}

PFN_GLCREATESHADER _glCreateShader = &_get_glCreateShader;

static void APIENTRY _fail_glDeleteProgram(GLuint program) {
    const char *_name = "glDeleteProgram";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteProgram(GLuint program) {
    PFN_GLDELETEPROGRAM _ptr;
    _ptr = (PFN_GLDELETEPROGRAM)_getPrivateProcAddress("glDeleteProgram");
    if (!_ptr) {
        _ptr = &_fail_glDeleteProgram;
    }
    _glDeleteProgram = _ptr;
    _glDeleteProgram(program);
}

PFN_GLDELETEPROGRAM _glDeleteProgram = &_get_glDeleteProgram;

static void APIENTRY _fail_glDeleteShader(GLuint shader) {
    const char *_name = "glDeleteShader";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteShader(GLuint shader) {
    PFN_GLDELETESHADER _ptr;
    _ptr = (PFN_GLDELETESHADER)_getPrivateProcAddress("glDeleteShader");
    if (!_ptr) {
        _ptr = &_fail_glDeleteShader;
    }
    _glDeleteShader = _ptr;
    _glDeleteShader(shader);
}

PFN_GLDELETESHADER _glDeleteShader = &_get_glDeleteShader;

static void APIENTRY _fail_glDetachShader(GLuint program, GLuint shader) {
    const char *_name = "glDetachShader";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDetachShader(GLuint program, GLuint shader) {
    PFN_GLDETACHSHADER _ptr;
    _ptr = (PFN_GLDETACHSHADER)_getPrivateProcAddress("glDetachShader");
    if (!_ptr) {
        _ptr = &_fail_glDetachShader;
    }
    _glDetachShader = _ptr;
    _glDetachShader(program, shader);
}

PFN_GLDETACHSHADER _glDetachShader = &_get_glDetachShader;

static void APIENTRY _fail_glDisableVertexAttribArray(GLuint index) {
    const char *_name = "glDisableVertexAttribArray";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDisableVertexAttribArray(GLuint index) {
    PFN_GLDISABLEVERTEXATTRIBARRAY _ptr;
    _ptr = (PFN_GLDISABLEVERTEXATTRIBARRAY)_getPrivateProcAddress("glDisableVertexAttribArray");
    if (!_ptr) {
        _ptr = &_fail_glDisableVertexAttribArray;
    }
    _glDisableVertexAttribArray = _ptr;
    _glDisableVertexAttribArray(index);
}

PFN_GLDISABLEVERTEXATTRIBARRAY _glDisableVertexAttribArray = &_get_glDisableVertexAttribArray;

static void APIENTRY _fail_glEnableVertexAttribArray(GLuint index) {
    const char *_name = "glEnableVertexAttribArray";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEnableVertexAttribArray(GLuint index) {
    PFN_GLENABLEVERTEXATTRIBARRAY _ptr;
    _ptr = (PFN_GLENABLEVERTEXATTRIBARRAY)_getPrivateProcAddress("glEnableVertexAttribArray");
    if (!_ptr) {
        _ptr = &_fail_glEnableVertexAttribArray;
    }
    _glEnableVertexAttribArray = _ptr;
    _glEnableVertexAttribArray(index);
}

PFN_GLENABLEVERTEXATTRIBARRAY _glEnableVertexAttribArray = &_get_glEnableVertexAttribArray;

static void APIENTRY _fail_glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name) {
    const char *_name = "glGetActiveAttrib";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name) {
    PFN_GLGETACTIVEATTRIB _ptr;
    _ptr = (PFN_GLGETACTIVEATTRIB)_getPrivateProcAddress("glGetActiveAttrib");
    if (!_ptr) {
        _ptr = &_fail_glGetActiveAttrib;
    }
    _glGetActiveAttrib = _ptr;
    _glGetActiveAttrib(program, index, bufSize, length, size, type, name);
}

PFN_GLGETACTIVEATTRIB _glGetActiveAttrib = &_get_glGetActiveAttrib;

static void APIENTRY _fail_glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name) {
    const char *_name = "glGetActiveUniform";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name) {
    PFN_GLGETACTIVEUNIFORM _ptr;
    _ptr = (PFN_GLGETACTIVEUNIFORM)_getPrivateProcAddress("glGetActiveUniform");
    if (!_ptr) {
        _ptr = &_fail_glGetActiveUniform;
    }
    _glGetActiveUniform = _ptr;
    _glGetActiveUniform(program, index, bufSize, length, size, type, name);
}

PFN_GLGETACTIVEUNIFORM _glGetActiveUniform = &_get_glGetActiveUniform;

static void APIENTRY _fail_glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei * count, GLuint * obj) {
    const char *_name = "glGetAttachedShaders";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei * count, GLuint * obj) {
    PFN_GLGETATTACHEDSHADERS _ptr;
    _ptr = (PFN_GLGETATTACHEDSHADERS)_getPrivateProcAddress("glGetAttachedShaders");
    if (!_ptr) {
        _ptr = &_fail_glGetAttachedShaders;
    }
    _glGetAttachedShaders = _ptr;
    _glGetAttachedShaders(program, maxCount, count, obj);
}

PFN_GLGETATTACHEDSHADERS _glGetAttachedShaders = &_get_glGetAttachedShaders;

static GLint APIENTRY _fail_glGetAttribLocation(GLuint program, const GLchar * name) {
    const char *_name = "glGetAttribLocation";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLint APIENTRY _get_glGetAttribLocation(GLuint program, const GLchar * name) {
    PFN_GLGETATTRIBLOCATION _ptr;
    _ptr = (PFN_GLGETATTRIBLOCATION)_getPrivateProcAddress("glGetAttribLocation");
    if (!_ptr) {
        _ptr = &_fail_glGetAttribLocation;
    }
    _glGetAttribLocation = _ptr;
    return _glGetAttribLocation(program, name);
}

PFN_GLGETATTRIBLOCATION _glGetAttribLocation = &_get_glGetAttribLocation;

static void APIENTRY _fail_glGetProgramiv(GLuint program, GLenum pname, GLint * params) {
    const char *_name = "glGetProgramiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramiv(GLuint program, GLenum pname, GLint * params) {
    PFN_GLGETPROGRAMIV _ptr;
    _ptr = (PFN_GLGETPROGRAMIV)_getPrivateProcAddress("glGetProgramiv");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramiv;
    }
    _glGetProgramiv = _ptr;
    _glGetProgramiv(program, pname, params);
}

PFN_GLGETPROGRAMIV _glGetProgramiv = &_get_glGetProgramiv;

static void APIENTRY _fail_glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog) {
    const char *_name = "glGetProgramInfoLog";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog) {
    PFN_GLGETPROGRAMINFOLOG _ptr;
    _ptr = (PFN_GLGETPROGRAMINFOLOG)_getPrivateProcAddress("glGetProgramInfoLog");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramInfoLog;
    }
    _glGetProgramInfoLog = _ptr;
    _glGetProgramInfoLog(program, bufSize, length, infoLog);
}

PFN_GLGETPROGRAMINFOLOG _glGetProgramInfoLog = &_get_glGetProgramInfoLog;

static void APIENTRY _fail_glGetShaderiv(GLuint shader, GLenum pname, GLint * params) {
    const char *_name = "glGetShaderiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetShaderiv(GLuint shader, GLenum pname, GLint * params) {
    PFN_GLGETSHADERIV _ptr;
    _ptr = (PFN_GLGETSHADERIV)_getPrivateProcAddress("glGetShaderiv");
    if (!_ptr) {
        _ptr = &_fail_glGetShaderiv;
    }
    _glGetShaderiv = _ptr;
    _glGetShaderiv(shader, pname, params);
}

PFN_GLGETSHADERIV _glGetShaderiv = &_get_glGetShaderiv;

static void APIENTRY _fail_glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog) {
    const char *_name = "glGetShaderInfoLog";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog) {
    PFN_GLGETSHADERINFOLOG _ptr;
    _ptr = (PFN_GLGETSHADERINFOLOG)_getPrivateProcAddress("glGetShaderInfoLog");
    if (!_ptr) {
        _ptr = &_fail_glGetShaderInfoLog;
    }
    _glGetShaderInfoLog = _ptr;
    _glGetShaderInfoLog(shader, bufSize, length, infoLog);
}

PFN_GLGETSHADERINFOLOG _glGetShaderInfoLog = &_get_glGetShaderInfoLog;

static void APIENTRY _fail_glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source) {
    const char *_name = "glGetShaderSource";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source) {
    PFN_GLGETSHADERSOURCE _ptr;
    _ptr = (PFN_GLGETSHADERSOURCE)_getPrivateProcAddress("glGetShaderSource");
    if (!_ptr) {
        _ptr = &_fail_glGetShaderSource;
    }
    _glGetShaderSource = _ptr;
    _glGetShaderSource(shader, bufSize, length, source);
}

PFN_GLGETSHADERSOURCE _glGetShaderSource = &_get_glGetShaderSource;

static GLint APIENTRY _fail_glGetUniformLocation(GLuint program, const GLchar * name) {
    const char *_name = "glGetUniformLocation";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLint APIENTRY _get_glGetUniformLocation(GLuint program, const GLchar * name) {
    PFN_GLGETUNIFORMLOCATION _ptr;
    _ptr = (PFN_GLGETUNIFORMLOCATION)_getPrivateProcAddress("glGetUniformLocation");
    if (!_ptr) {
        _ptr = &_fail_glGetUniformLocation;
    }
    _glGetUniformLocation = _ptr;
    return _glGetUniformLocation(program, name);
}

PFN_GLGETUNIFORMLOCATION _glGetUniformLocation = &_get_glGetUniformLocation;

static void APIENTRY _fail_glGetUniformfv(GLuint program, GLint location, GLfloat * params) {
    const char *_name = "glGetUniformfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetUniformfv(GLuint program, GLint location, GLfloat * params) {
    PFN_GLGETUNIFORMFV _ptr;
    _ptr = (PFN_GLGETUNIFORMFV)_getPrivateProcAddress("glGetUniformfv");
    if (!_ptr) {
        _ptr = &_fail_glGetUniformfv;
    }
    _glGetUniformfv = _ptr;
    _glGetUniformfv(program, location, params);
}

PFN_GLGETUNIFORMFV _glGetUniformfv = &_get_glGetUniformfv;

static void APIENTRY _fail_glGetUniformiv(GLuint program, GLint location, GLint * params) {
    const char *_name = "glGetUniformiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetUniformiv(GLuint program, GLint location, GLint * params) {
    PFN_GLGETUNIFORMIV _ptr;
    _ptr = (PFN_GLGETUNIFORMIV)_getPrivateProcAddress("glGetUniformiv");
    if (!_ptr) {
        _ptr = &_fail_glGetUniformiv;
    }
    _glGetUniformiv = _ptr;
    _glGetUniformiv(program, location, params);
}

PFN_GLGETUNIFORMIV _glGetUniformiv = &_get_glGetUniformiv;

static void APIENTRY _fail_glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble * params) {
    const char *_name = "glGetVertexAttribdv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble * params) {
    PFN_GLGETVERTEXATTRIBDV _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBDV)_getPrivateProcAddress("glGetVertexAttribdv");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribdv;
    }
    _glGetVertexAttribdv = _ptr;
    _glGetVertexAttribdv(index, pname, params);
}

PFN_GLGETVERTEXATTRIBDV _glGetVertexAttribdv = &_get_glGetVertexAttribdv;

static void APIENTRY _fail_glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat * params) {
    const char *_name = "glGetVertexAttribfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat * params) {
    PFN_GLGETVERTEXATTRIBFV _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBFV)_getPrivateProcAddress("glGetVertexAttribfv");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribfv;
    }
    _glGetVertexAttribfv = _ptr;
    _glGetVertexAttribfv(index, pname, params);
}

PFN_GLGETVERTEXATTRIBFV _glGetVertexAttribfv = &_get_glGetVertexAttribfv;

static void APIENTRY _fail_glGetVertexAttribiv(GLuint index, GLenum pname, GLint * params) {
    const char *_name = "glGetVertexAttribiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribiv(GLuint index, GLenum pname, GLint * params) {
    PFN_GLGETVERTEXATTRIBIV _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBIV)_getPrivateProcAddress("glGetVertexAttribiv");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribiv;
    }
    _glGetVertexAttribiv = _ptr;
    _glGetVertexAttribiv(index, pname, params);
}

PFN_GLGETVERTEXATTRIBIV _glGetVertexAttribiv = &_get_glGetVertexAttribiv;

static void APIENTRY _fail_glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid * * pointer) {
    const char *_name = "glGetVertexAttribPointerv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid * * pointer) {
    PFN_GLGETVERTEXATTRIBPOINTERV _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBPOINTERV)_getPrivateProcAddress("glGetVertexAttribPointerv");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribPointerv;
    }
    _glGetVertexAttribPointerv = _ptr;
    _glGetVertexAttribPointerv(index, pname, pointer);
}

PFN_GLGETVERTEXATTRIBPOINTERV _glGetVertexAttribPointerv = &_get_glGetVertexAttribPointerv;

static GLboolean APIENTRY _fail_glIsProgram(GLuint program) {
    const char *_name = "glIsProgram";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsProgram(GLuint program) {
    PFN_GLISPROGRAM _ptr;
    _ptr = (PFN_GLISPROGRAM)_getPrivateProcAddress("glIsProgram");
    if (!_ptr) {
        _ptr = &_fail_glIsProgram;
    }
    _glIsProgram = _ptr;
    return _glIsProgram(program);
}

PFN_GLISPROGRAM _glIsProgram = &_get_glIsProgram;

static GLboolean APIENTRY _fail_glIsShader(GLuint shader) {
    const char *_name = "glIsShader";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsShader(GLuint shader) {
    PFN_GLISSHADER _ptr;
    _ptr = (PFN_GLISSHADER)_getPrivateProcAddress("glIsShader");
    if (!_ptr) {
        _ptr = &_fail_glIsShader;
    }
    _glIsShader = _ptr;
    return _glIsShader(shader);
}

PFN_GLISSHADER _glIsShader = &_get_glIsShader;

static void APIENTRY _fail_glLinkProgram(GLuint program) {
    const char *_name = "glLinkProgram";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLinkProgram(GLuint program) {
    PFN_GLLINKPROGRAM _ptr;
    _ptr = (PFN_GLLINKPROGRAM)_getPrivateProcAddress("glLinkProgram");
    if (!_ptr) {
        _ptr = &_fail_glLinkProgram;
    }
    _glLinkProgram = _ptr;
    _glLinkProgram(program);
}

PFN_GLLINKPROGRAM _glLinkProgram = &_get_glLinkProgram;

static void APIENTRY _fail_glShaderSource(GLuint shader, GLsizei count, const GLchar * const * string, const GLint * length) {
    const char *_name = "glShaderSource";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glShaderSource(GLuint shader, GLsizei count, const GLchar * const * string, const GLint * length) {
    PFN_GLSHADERSOURCE _ptr;
    _ptr = (PFN_GLSHADERSOURCE)_getPrivateProcAddress("glShaderSource");
    if (!_ptr) {
        _ptr = &_fail_glShaderSource;
    }
    _glShaderSource = _ptr;
    _glShaderSource(shader, count, string, length);
}

PFN_GLSHADERSOURCE _glShaderSource = &_get_glShaderSource;

static void APIENTRY _fail_glUseProgram(GLuint program) {
    const char *_name = "glUseProgram";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUseProgram(GLuint program) {
    PFN_GLUSEPROGRAM _ptr;
    _ptr = (PFN_GLUSEPROGRAM)_getPrivateProcAddress("glUseProgram");
    if (!_ptr) {
        _ptr = &_fail_glUseProgram;
    }
    _glUseProgram = _ptr;
    _glUseProgram(program);
}

PFN_GLUSEPROGRAM _glUseProgram = &_get_glUseProgram;

static void APIENTRY _fail_glUniform1f(GLint location, GLfloat v0) {
    const char *_name = "glUniform1f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1f(GLint location, GLfloat v0) {
    PFN_GLUNIFORM1F _ptr;
    _ptr = (PFN_GLUNIFORM1F)_getPrivateProcAddress("glUniform1f");
    if (!_ptr) {
        _ptr = &_fail_glUniform1f;
    }
    _glUniform1f = _ptr;
    _glUniform1f(location, v0);
}

PFN_GLUNIFORM1F _glUniform1f = &_get_glUniform1f;

static void APIENTRY _fail_glUniform2f(GLint location, GLfloat v0, GLfloat v1) {
    const char *_name = "glUniform2f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2f(GLint location, GLfloat v0, GLfloat v1) {
    PFN_GLUNIFORM2F _ptr;
    _ptr = (PFN_GLUNIFORM2F)_getPrivateProcAddress("glUniform2f");
    if (!_ptr) {
        _ptr = &_fail_glUniform2f;
    }
    _glUniform2f = _ptr;
    _glUniform2f(location, v0, v1);
}

PFN_GLUNIFORM2F _glUniform2f = &_get_glUniform2f;

static void APIENTRY _fail_glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
    const char *_name = "glUniform3f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
    PFN_GLUNIFORM3F _ptr;
    _ptr = (PFN_GLUNIFORM3F)_getPrivateProcAddress("glUniform3f");
    if (!_ptr) {
        _ptr = &_fail_glUniform3f;
    }
    _glUniform3f = _ptr;
    _glUniform3f(location, v0, v1, v2);
}

PFN_GLUNIFORM3F _glUniform3f = &_get_glUniform3f;

static void APIENTRY _fail_glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
    const char *_name = "glUniform4f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
    PFN_GLUNIFORM4F _ptr;
    _ptr = (PFN_GLUNIFORM4F)_getPrivateProcAddress("glUniform4f");
    if (!_ptr) {
        _ptr = &_fail_glUniform4f;
    }
    _glUniform4f = _ptr;
    _glUniform4f(location, v0, v1, v2, v3);
}

PFN_GLUNIFORM4F _glUniform4f = &_get_glUniform4f;

static void APIENTRY _fail_glUniform1i(GLint location, GLint v0) {
    const char *_name = "glUniform1i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1i(GLint location, GLint v0) {
    PFN_GLUNIFORM1I _ptr;
    _ptr = (PFN_GLUNIFORM1I)_getPrivateProcAddress("glUniform1i");
    if (!_ptr) {
        _ptr = &_fail_glUniform1i;
    }
    _glUniform1i = _ptr;
    _glUniform1i(location, v0);
}

PFN_GLUNIFORM1I _glUniform1i = &_get_glUniform1i;

static void APIENTRY _fail_glUniform2i(GLint location, GLint v0, GLint v1) {
    const char *_name = "glUniform2i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2i(GLint location, GLint v0, GLint v1) {
    PFN_GLUNIFORM2I _ptr;
    _ptr = (PFN_GLUNIFORM2I)_getPrivateProcAddress("glUniform2i");
    if (!_ptr) {
        _ptr = &_fail_glUniform2i;
    }
    _glUniform2i = _ptr;
    _glUniform2i(location, v0, v1);
}

PFN_GLUNIFORM2I _glUniform2i = &_get_glUniform2i;

static void APIENTRY _fail_glUniform3i(GLint location, GLint v0, GLint v1, GLint v2) {
    const char *_name = "glUniform3i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3i(GLint location, GLint v0, GLint v1, GLint v2) {
    PFN_GLUNIFORM3I _ptr;
    _ptr = (PFN_GLUNIFORM3I)_getPrivateProcAddress("glUniform3i");
    if (!_ptr) {
        _ptr = &_fail_glUniform3i;
    }
    _glUniform3i = _ptr;
    _glUniform3i(location, v0, v1, v2);
}

PFN_GLUNIFORM3I _glUniform3i = &_get_glUniform3i;

static void APIENTRY _fail_glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
    const char *_name = "glUniform4i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
    PFN_GLUNIFORM4I _ptr;
    _ptr = (PFN_GLUNIFORM4I)_getPrivateProcAddress("glUniform4i");
    if (!_ptr) {
        _ptr = &_fail_glUniform4i;
    }
    _glUniform4i = _ptr;
    _glUniform4i(location, v0, v1, v2, v3);
}

PFN_GLUNIFORM4I _glUniform4i = &_get_glUniform4i;

static void APIENTRY _fail_glUniform1fv(GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glUniform1fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1fv(GLint location, GLsizei count, const GLfloat * value) {
    PFN_GLUNIFORM1FV _ptr;
    _ptr = (PFN_GLUNIFORM1FV)_getPrivateProcAddress("glUniform1fv");
    if (!_ptr) {
        _ptr = &_fail_glUniform1fv;
    }
    _glUniform1fv = _ptr;
    _glUniform1fv(location, count, value);
}

PFN_GLUNIFORM1FV _glUniform1fv = &_get_glUniform1fv;

static void APIENTRY _fail_glUniform2fv(GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glUniform2fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2fv(GLint location, GLsizei count, const GLfloat * value) {
    PFN_GLUNIFORM2FV _ptr;
    _ptr = (PFN_GLUNIFORM2FV)_getPrivateProcAddress("glUniform2fv");
    if (!_ptr) {
        _ptr = &_fail_glUniform2fv;
    }
    _glUniform2fv = _ptr;
    _glUniform2fv(location, count, value);
}

PFN_GLUNIFORM2FV _glUniform2fv = &_get_glUniform2fv;

static void APIENTRY _fail_glUniform3fv(GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glUniform3fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3fv(GLint location, GLsizei count, const GLfloat * value) {
    PFN_GLUNIFORM3FV _ptr;
    _ptr = (PFN_GLUNIFORM3FV)_getPrivateProcAddress("glUniform3fv");
    if (!_ptr) {
        _ptr = &_fail_glUniform3fv;
    }
    _glUniform3fv = _ptr;
    _glUniform3fv(location, count, value);
}

PFN_GLUNIFORM3FV _glUniform3fv = &_get_glUniform3fv;

static void APIENTRY _fail_glUniform4fv(GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glUniform4fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4fv(GLint location, GLsizei count, const GLfloat * value) {
    PFN_GLUNIFORM4FV _ptr;
    _ptr = (PFN_GLUNIFORM4FV)_getPrivateProcAddress("glUniform4fv");
    if (!_ptr) {
        _ptr = &_fail_glUniform4fv;
    }
    _glUniform4fv = _ptr;
    _glUniform4fv(location, count, value);
}

PFN_GLUNIFORM4FV _glUniform4fv = &_get_glUniform4fv;

static void APIENTRY _fail_glUniform1iv(GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glUniform1iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1iv(GLint location, GLsizei count, const GLint * value) {
    PFN_GLUNIFORM1IV _ptr;
    _ptr = (PFN_GLUNIFORM1IV)_getPrivateProcAddress("glUniform1iv");
    if (!_ptr) {
        _ptr = &_fail_glUniform1iv;
    }
    _glUniform1iv = _ptr;
    _glUniform1iv(location, count, value);
}

PFN_GLUNIFORM1IV _glUniform1iv = &_get_glUniform1iv;

static void APIENTRY _fail_glUniform2iv(GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glUniform2iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2iv(GLint location, GLsizei count, const GLint * value) {
    PFN_GLUNIFORM2IV _ptr;
    _ptr = (PFN_GLUNIFORM2IV)_getPrivateProcAddress("glUniform2iv");
    if (!_ptr) {
        _ptr = &_fail_glUniform2iv;
    }
    _glUniform2iv = _ptr;
    _glUniform2iv(location, count, value);
}

PFN_GLUNIFORM2IV _glUniform2iv = &_get_glUniform2iv;

static void APIENTRY _fail_glUniform3iv(GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glUniform3iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3iv(GLint location, GLsizei count, const GLint * value) {
    PFN_GLUNIFORM3IV _ptr;
    _ptr = (PFN_GLUNIFORM3IV)_getPrivateProcAddress("glUniform3iv");
    if (!_ptr) {
        _ptr = &_fail_glUniform3iv;
    }
    _glUniform3iv = _ptr;
    _glUniform3iv(location, count, value);
}

PFN_GLUNIFORM3IV _glUniform3iv = &_get_glUniform3iv;

static void APIENTRY _fail_glUniform4iv(GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glUniform4iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4iv(GLint location, GLsizei count, const GLint * value) {
    PFN_GLUNIFORM4IV _ptr;
    _ptr = (PFN_GLUNIFORM4IV)_getPrivateProcAddress("glUniform4iv");
    if (!_ptr) {
        _ptr = &_fail_glUniform4iv;
    }
    _glUniform4iv = _ptr;
    _glUniform4iv(location, count, value);
}

PFN_GLUNIFORM4IV _glUniform4iv = &_get_glUniform4iv;

static void APIENTRY _fail_glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix2fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLUNIFORMMATRIX2FV _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX2FV)_getPrivateProcAddress("glUniformMatrix2fv");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix2fv;
    }
    _glUniformMatrix2fv = _ptr;
    _glUniformMatrix2fv(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX2FV _glUniformMatrix2fv = &_get_glUniformMatrix2fv;

static void APIENTRY _fail_glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix3fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLUNIFORMMATRIX3FV _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX3FV)_getPrivateProcAddress("glUniformMatrix3fv");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix3fv;
    }
    _glUniformMatrix3fv = _ptr;
    _glUniformMatrix3fv(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX3FV _glUniformMatrix3fv = &_get_glUniformMatrix3fv;

static void APIENTRY _fail_glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix4fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLUNIFORMMATRIX4FV _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX4FV)_getPrivateProcAddress("glUniformMatrix4fv");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix4fv;
    }
    _glUniformMatrix4fv = _ptr;
    _glUniformMatrix4fv(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX4FV _glUniformMatrix4fv = &_get_glUniformMatrix4fv;

static void APIENTRY _fail_glValidateProgram(GLuint program) {
    const char *_name = "glValidateProgram";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glValidateProgram(GLuint program) {
    PFN_GLVALIDATEPROGRAM _ptr;
    _ptr = (PFN_GLVALIDATEPROGRAM)_getPrivateProcAddress("glValidateProgram");
    if (!_ptr) {
        _ptr = &_fail_glValidateProgram;
    }
    _glValidateProgram = _ptr;
    _glValidateProgram(program);
}

PFN_GLVALIDATEPROGRAM _glValidateProgram = &_get_glValidateProgram;

static void APIENTRY _fail_glVertexAttrib1d(GLuint index, GLdouble x) {
    const char *_name = "glVertexAttrib1d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1d(GLuint index, GLdouble x) {
    PFN_GLVERTEXATTRIB1D _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1D)_getPrivateProcAddress("glVertexAttrib1d");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1d;
    }
    _glVertexAttrib1d = _ptr;
    _glVertexAttrib1d(index, x);
}

PFN_GLVERTEXATTRIB1D _glVertexAttrib1d = &_get_glVertexAttrib1d;

static void APIENTRY _fail_glVertexAttrib1dv(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib1dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1dv(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIB1DV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1DV)_getPrivateProcAddress("glVertexAttrib1dv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1dv;
    }
    _glVertexAttrib1dv = _ptr;
    _glVertexAttrib1dv(index, v);
}

PFN_GLVERTEXATTRIB1DV _glVertexAttrib1dv = &_get_glVertexAttrib1dv;

static void APIENTRY _fail_glVertexAttrib1f(GLuint index, GLfloat x) {
    const char *_name = "glVertexAttrib1f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1f(GLuint index, GLfloat x) {
    PFN_GLVERTEXATTRIB1F _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1F)_getPrivateProcAddress("glVertexAttrib1f");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1f;
    }
    _glVertexAttrib1f = _ptr;
    _glVertexAttrib1f(index, x);
}

PFN_GLVERTEXATTRIB1F _glVertexAttrib1f = &_get_glVertexAttrib1f;

static void APIENTRY _fail_glVertexAttrib1fv(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib1fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1fv(GLuint index, const GLfloat * v) {
    PFN_GLVERTEXATTRIB1FV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1FV)_getPrivateProcAddress("glVertexAttrib1fv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1fv;
    }
    _glVertexAttrib1fv = _ptr;
    _glVertexAttrib1fv(index, v);
}

PFN_GLVERTEXATTRIB1FV _glVertexAttrib1fv = &_get_glVertexAttrib1fv;

static void APIENTRY _fail_glVertexAttrib1s(GLuint index, GLshort x) {
    const char *_name = "glVertexAttrib1s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1s(GLuint index, GLshort x) {
    PFN_GLVERTEXATTRIB1S _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1S)_getPrivateProcAddress("glVertexAttrib1s");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1s;
    }
    _glVertexAttrib1s = _ptr;
    _glVertexAttrib1s(index, x);
}

PFN_GLVERTEXATTRIB1S _glVertexAttrib1s = &_get_glVertexAttrib1s;

static void APIENTRY _fail_glVertexAttrib1sv(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib1sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1sv(GLuint index, const GLshort * v) {
    PFN_GLVERTEXATTRIB1SV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1SV)_getPrivateProcAddress("glVertexAttrib1sv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1sv;
    }
    _glVertexAttrib1sv = _ptr;
    _glVertexAttrib1sv(index, v);
}

PFN_GLVERTEXATTRIB1SV _glVertexAttrib1sv = &_get_glVertexAttrib1sv;

static void APIENTRY _fail_glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y) {
    const char *_name = "glVertexAttrib2d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y) {
    PFN_GLVERTEXATTRIB2D _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2D)_getPrivateProcAddress("glVertexAttrib2d");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2d;
    }
    _glVertexAttrib2d = _ptr;
    _glVertexAttrib2d(index, x, y);
}

PFN_GLVERTEXATTRIB2D _glVertexAttrib2d = &_get_glVertexAttrib2d;

static void APIENTRY _fail_glVertexAttrib2dv(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib2dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2dv(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIB2DV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2DV)_getPrivateProcAddress("glVertexAttrib2dv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2dv;
    }
    _glVertexAttrib2dv = _ptr;
    _glVertexAttrib2dv(index, v);
}

PFN_GLVERTEXATTRIB2DV _glVertexAttrib2dv = &_get_glVertexAttrib2dv;

static void APIENTRY _fail_glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y) {
    const char *_name = "glVertexAttrib2f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y) {
    PFN_GLVERTEXATTRIB2F _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2F)_getPrivateProcAddress("glVertexAttrib2f");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2f;
    }
    _glVertexAttrib2f = _ptr;
    _glVertexAttrib2f(index, x, y);
}

PFN_GLVERTEXATTRIB2F _glVertexAttrib2f = &_get_glVertexAttrib2f;

static void APIENTRY _fail_glVertexAttrib2fv(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib2fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2fv(GLuint index, const GLfloat * v) {
    PFN_GLVERTEXATTRIB2FV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2FV)_getPrivateProcAddress("glVertexAttrib2fv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2fv;
    }
    _glVertexAttrib2fv = _ptr;
    _glVertexAttrib2fv(index, v);
}

PFN_GLVERTEXATTRIB2FV _glVertexAttrib2fv = &_get_glVertexAttrib2fv;

static void APIENTRY _fail_glVertexAttrib2s(GLuint index, GLshort x, GLshort y) {
    const char *_name = "glVertexAttrib2s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2s(GLuint index, GLshort x, GLshort y) {
    PFN_GLVERTEXATTRIB2S _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2S)_getPrivateProcAddress("glVertexAttrib2s");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2s;
    }
    _glVertexAttrib2s = _ptr;
    _glVertexAttrib2s(index, x, y);
}

PFN_GLVERTEXATTRIB2S _glVertexAttrib2s = &_get_glVertexAttrib2s;

static void APIENTRY _fail_glVertexAttrib2sv(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib2sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2sv(GLuint index, const GLshort * v) {
    PFN_GLVERTEXATTRIB2SV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2SV)_getPrivateProcAddress("glVertexAttrib2sv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2sv;
    }
    _glVertexAttrib2sv = _ptr;
    _glVertexAttrib2sv(index, v);
}

PFN_GLVERTEXATTRIB2SV _glVertexAttrib2sv = &_get_glVertexAttrib2sv;

static void APIENTRY _fail_glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glVertexAttrib3d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLVERTEXATTRIB3D _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3D)_getPrivateProcAddress("glVertexAttrib3d");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3d;
    }
    _glVertexAttrib3d = _ptr;
    _glVertexAttrib3d(index, x, y, z);
}

PFN_GLVERTEXATTRIB3D _glVertexAttrib3d = &_get_glVertexAttrib3d;

static void APIENTRY _fail_glVertexAttrib3dv(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib3dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3dv(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIB3DV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3DV)_getPrivateProcAddress("glVertexAttrib3dv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3dv;
    }
    _glVertexAttrib3dv = _ptr;
    _glVertexAttrib3dv(index, v);
}

PFN_GLVERTEXATTRIB3DV _glVertexAttrib3dv = &_get_glVertexAttrib3dv;

static void APIENTRY _fail_glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glVertexAttrib3f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLVERTEXATTRIB3F _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3F)_getPrivateProcAddress("glVertexAttrib3f");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3f;
    }
    _glVertexAttrib3f = _ptr;
    _glVertexAttrib3f(index, x, y, z);
}

PFN_GLVERTEXATTRIB3F _glVertexAttrib3f = &_get_glVertexAttrib3f;

static void APIENTRY _fail_glVertexAttrib3fv(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib3fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3fv(GLuint index, const GLfloat * v) {
    PFN_GLVERTEXATTRIB3FV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3FV)_getPrivateProcAddress("glVertexAttrib3fv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3fv;
    }
    _glVertexAttrib3fv = _ptr;
    _glVertexAttrib3fv(index, v);
}

PFN_GLVERTEXATTRIB3FV _glVertexAttrib3fv = &_get_glVertexAttrib3fv;

static void APIENTRY _fail_glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z) {
    const char *_name = "glVertexAttrib3s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z) {
    PFN_GLVERTEXATTRIB3S _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3S)_getPrivateProcAddress("glVertexAttrib3s");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3s;
    }
    _glVertexAttrib3s = _ptr;
    _glVertexAttrib3s(index, x, y, z);
}

PFN_GLVERTEXATTRIB3S _glVertexAttrib3s = &_get_glVertexAttrib3s;

static void APIENTRY _fail_glVertexAttrib3sv(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib3sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3sv(GLuint index, const GLshort * v) {
    PFN_GLVERTEXATTRIB3SV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3SV)_getPrivateProcAddress("glVertexAttrib3sv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3sv;
    }
    _glVertexAttrib3sv = _ptr;
    _glVertexAttrib3sv(index, v);
}

PFN_GLVERTEXATTRIB3SV _glVertexAttrib3sv = &_get_glVertexAttrib3sv;

static void APIENTRY _fail_glVertexAttrib4Nbv(GLuint index, const GLbyte * v) {
    const char *_name = "glVertexAttrib4Nbv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4Nbv(GLuint index, const GLbyte * v) {
    PFN_GLVERTEXATTRIB4NBV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4NBV)_getPrivateProcAddress("glVertexAttrib4Nbv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4Nbv;
    }
    _glVertexAttrib4Nbv = _ptr;
    _glVertexAttrib4Nbv(index, v);
}

PFN_GLVERTEXATTRIB4NBV _glVertexAttrib4Nbv = &_get_glVertexAttrib4Nbv;

static void APIENTRY _fail_glVertexAttrib4Niv(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttrib4Niv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4Niv(GLuint index, const GLint * v) {
    PFN_GLVERTEXATTRIB4NIV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4NIV)_getPrivateProcAddress("glVertexAttrib4Niv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4Niv;
    }
    _glVertexAttrib4Niv = _ptr;
    _glVertexAttrib4Niv(index, v);
}

PFN_GLVERTEXATTRIB4NIV _glVertexAttrib4Niv = &_get_glVertexAttrib4Niv;

static void APIENTRY _fail_glVertexAttrib4Nsv(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib4Nsv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4Nsv(GLuint index, const GLshort * v) {
    PFN_GLVERTEXATTRIB4NSV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4NSV)_getPrivateProcAddress("glVertexAttrib4Nsv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4Nsv;
    }
    _glVertexAttrib4Nsv = _ptr;
    _glVertexAttrib4Nsv(index, v);
}

PFN_GLVERTEXATTRIB4NSV _glVertexAttrib4Nsv = &_get_glVertexAttrib4Nsv;

static void APIENTRY _fail_glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) {
    const char *_name = "glVertexAttrib4Nub";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) {
    PFN_GLVERTEXATTRIB4NUB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4NUB)_getPrivateProcAddress("glVertexAttrib4Nub");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4Nub;
    }
    _glVertexAttrib4Nub = _ptr;
    _glVertexAttrib4Nub(index, x, y, z, w);
}

PFN_GLVERTEXATTRIB4NUB _glVertexAttrib4Nub = &_get_glVertexAttrib4Nub;

static void APIENTRY _fail_glVertexAttrib4Nubv(GLuint index, const GLubyte * v) {
    const char *_name = "glVertexAttrib4Nubv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4Nubv(GLuint index, const GLubyte * v) {
    PFN_GLVERTEXATTRIB4NUBV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4NUBV)_getPrivateProcAddress("glVertexAttrib4Nubv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4Nubv;
    }
    _glVertexAttrib4Nubv = _ptr;
    _glVertexAttrib4Nubv(index, v);
}

PFN_GLVERTEXATTRIB4NUBV _glVertexAttrib4Nubv = &_get_glVertexAttrib4Nubv;

static void APIENTRY _fail_glVertexAttrib4Nuiv(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttrib4Nuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4Nuiv(GLuint index, const GLuint * v) {
    PFN_GLVERTEXATTRIB4NUIV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4NUIV)_getPrivateProcAddress("glVertexAttrib4Nuiv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4Nuiv;
    }
    _glVertexAttrib4Nuiv = _ptr;
    _glVertexAttrib4Nuiv(index, v);
}

PFN_GLVERTEXATTRIB4NUIV _glVertexAttrib4Nuiv = &_get_glVertexAttrib4Nuiv;

static void APIENTRY _fail_glVertexAttrib4Nusv(GLuint index, const GLushort * v) {
    const char *_name = "glVertexAttrib4Nusv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4Nusv(GLuint index, const GLushort * v) {
    PFN_GLVERTEXATTRIB4NUSV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4NUSV)_getPrivateProcAddress("glVertexAttrib4Nusv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4Nusv;
    }
    _glVertexAttrib4Nusv = _ptr;
    _glVertexAttrib4Nusv(index, v);
}

PFN_GLVERTEXATTRIB4NUSV _glVertexAttrib4Nusv = &_get_glVertexAttrib4Nusv;

static void APIENTRY _fail_glVertexAttrib4bv(GLuint index, const GLbyte * v) {
    const char *_name = "glVertexAttrib4bv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4bv(GLuint index, const GLbyte * v) {
    PFN_GLVERTEXATTRIB4BV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4BV)_getPrivateProcAddress("glVertexAttrib4bv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4bv;
    }
    _glVertexAttrib4bv = _ptr;
    _glVertexAttrib4bv(index, v);
}

PFN_GLVERTEXATTRIB4BV _glVertexAttrib4bv = &_get_glVertexAttrib4bv;

static void APIENTRY _fail_glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glVertexAttrib4d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    PFN_GLVERTEXATTRIB4D _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4D)_getPrivateProcAddress("glVertexAttrib4d");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4d;
    }
    _glVertexAttrib4d = _ptr;
    _glVertexAttrib4d(index, x, y, z, w);
}

PFN_GLVERTEXATTRIB4D _glVertexAttrib4d = &_get_glVertexAttrib4d;

static void APIENTRY _fail_glVertexAttrib4dv(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib4dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4dv(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIB4DV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4DV)_getPrivateProcAddress("glVertexAttrib4dv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4dv;
    }
    _glVertexAttrib4dv = _ptr;
    _glVertexAttrib4dv(index, v);
}

PFN_GLVERTEXATTRIB4DV _glVertexAttrib4dv = &_get_glVertexAttrib4dv;

static void APIENTRY _fail_glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glVertexAttrib4f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    PFN_GLVERTEXATTRIB4F _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4F)_getPrivateProcAddress("glVertexAttrib4f");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4f;
    }
    _glVertexAttrib4f = _ptr;
    _glVertexAttrib4f(index, x, y, z, w);
}

PFN_GLVERTEXATTRIB4F _glVertexAttrib4f = &_get_glVertexAttrib4f;

static void APIENTRY _fail_glVertexAttrib4fv(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib4fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4fv(GLuint index, const GLfloat * v) {
    PFN_GLVERTEXATTRIB4FV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4FV)_getPrivateProcAddress("glVertexAttrib4fv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4fv;
    }
    _glVertexAttrib4fv = _ptr;
    _glVertexAttrib4fv(index, v);
}

PFN_GLVERTEXATTRIB4FV _glVertexAttrib4fv = &_get_glVertexAttrib4fv;

static void APIENTRY _fail_glVertexAttrib4iv(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttrib4iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4iv(GLuint index, const GLint * v) {
    PFN_GLVERTEXATTRIB4IV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4IV)_getPrivateProcAddress("glVertexAttrib4iv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4iv;
    }
    _glVertexAttrib4iv = _ptr;
    _glVertexAttrib4iv(index, v);
}

PFN_GLVERTEXATTRIB4IV _glVertexAttrib4iv = &_get_glVertexAttrib4iv;

static void APIENTRY _fail_glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) {
    const char *_name = "glVertexAttrib4s";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) {
    PFN_GLVERTEXATTRIB4S _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4S)_getPrivateProcAddress("glVertexAttrib4s");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4s;
    }
    _glVertexAttrib4s = _ptr;
    _glVertexAttrib4s(index, x, y, z, w);
}

PFN_GLVERTEXATTRIB4S _glVertexAttrib4s = &_get_glVertexAttrib4s;

static void APIENTRY _fail_glVertexAttrib4sv(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib4sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4sv(GLuint index, const GLshort * v) {
    PFN_GLVERTEXATTRIB4SV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4SV)_getPrivateProcAddress("glVertexAttrib4sv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4sv;
    }
    _glVertexAttrib4sv = _ptr;
    _glVertexAttrib4sv(index, v);
}

PFN_GLVERTEXATTRIB4SV _glVertexAttrib4sv = &_get_glVertexAttrib4sv;

static void APIENTRY _fail_glVertexAttrib4ubv(GLuint index, const GLubyte * v) {
    const char *_name = "glVertexAttrib4ubv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4ubv(GLuint index, const GLubyte * v) {
    PFN_GLVERTEXATTRIB4UBV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4UBV)_getPrivateProcAddress("glVertexAttrib4ubv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4ubv;
    }
    _glVertexAttrib4ubv = _ptr;
    _glVertexAttrib4ubv(index, v);
}

PFN_GLVERTEXATTRIB4UBV _glVertexAttrib4ubv = &_get_glVertexAttrib4ubv;

static void APIENTRY _fail_glVertexAttrib4uiv(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttrib4uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4uiv(GLuint index, const GLuint * v) {
    PFN_GLVERTEXATTRIB4UIV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4UIV)_getPrivateProcAddress("glVertexAttrib4uiv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4uiv;
    }
    _glVertexAttrib4uiv = _ptr;
    _glVertexAttrib4uiv(index, v);
}

PFN_GLVERTEXATTRIB4UIV _glVertexAttrib4uiv = &_get_glVertexAttrib4uiv;

static void APIENTRY _fail_glVertexAttrib4usv(GLuint index, const GLushort * v) {
    const char *_name = "glVertexAttrib4usv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4usv(GLuint index, const GLushort * v) {
    PFN_GLVERTEXATTRIB4USV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4USV)_getPrivateProcAddress("glVertexAttrib4usv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4usv;
    }
    _glVertexAttrib4usv = _ptr;
    _glVertexAttrib4usv(index, v);
}

PFN_GLVERTEXATTRIB4USV _glVertexAttrib4usv = &_get_glVertexAttrib4usv;

static void APIENTRY _fail_glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glVertexAttribPointer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer) {
    PFN_GLVERTEXATTRIBPOINTER _ptr;
    _ptr = (PFN_GLVERTEXATTRIBPOINTER)_getPrivateProcAddress("glVertexAttribPointer");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribPointer;
    }
    _glVertexAttribPointer = _ptr;
    _glVertexAttribPointer(index, size, type, normalized, stride, pointer);
}

PFN_GLVERTEXATTRIBPOINTER _glVertexAttribPointer = &_get_glVertexAttribPointer;

static void APIENTRY _fail_glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix2x3fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLUNIFORMMATRIX2X3FV _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX2X3FV)_getPrivateProcAddress("glUniformMatrix2x3fv");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix2x3fv;
    }
    _glUniformMatrix2x3fv = _ptr;
    _glUniformMatrix2x3fv(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX2X3FV _glUniformMatrix2x3fv = &_get_glUniformMatrix2x3fv;

static void APIENTRY _fail_glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix3x2fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLUNIFORMMATRIX3X2FV _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX3X2FV)_getPrivateProcAddress("glUniformMatrix3x2fv");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix3x2fv;
    }
    _glUniformMatrix3x2fv = _ptr;
    _glUniformMatrix3x2fv(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX3X2FV _glUniformMatrix3x2fv = &_get_glUniformMatrix3x2fv;

static void APIENTRY _fail_glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix2x4fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLUNIFORMMATRIX2X4FV _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX2X4FV)_getPrivateProcAddress("glUniformMatrix2x4fv");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix2x4fv;
    }
    _glUniformMatrix2x4fv = _ptr;
    _glUniformMatrix2x4fv(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX2X4FV _glUniformMatrix2x4fv = &_get_glUniformMatrix2x4fv;

static void APIENTRY _fail_glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix4x2fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLUNIFORMMATRIX4X2FV _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX4X2FV)_getPrivateProcAddress("glUniformMatrix4x2fv");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix4x2fv;
    }
    _glUniformMatrix4x2fv = _ptr;
    _glUniformMatrix4x2fv(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX4X2FV _glUniformMatrix4x2fv = &_get_glUniformMatrix4x2fv;

static void APIENTRY _fail_glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix3x4fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLUNIFORMMATRIX3X4FV _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX3X4FV)_getPrivateProcAddress("glUniformMatrix3x4fv");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix3x4fv;
    }
    _glUniformMatrix3x4fv = _ptr;
    _glUniformMatrix3x4fv(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX3X4FV _glUniformMatrix3x4fv = &_get_glUniformMatrix3x4fv;

static void APIENTRY _fail_glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix4x3fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLUNIFORMMATRIX4X3FV _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX4X3FV)_getPrivateProcAddress("glUniformMatrix4x3fv");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix4x3fv;
    }
    _glUniformMatrix4x3fv = _ptr;
    _glUniformMatrix4x3fv(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX4X3FV _glUniformMatrix4x3fv = &_get_glUniformMatrix4x3fv;

static void APIENTRY _fail_glColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) {
    const char *_name = "glColorMaski";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) {
    PFN_GLCOLORMASKI _ptr;
    _ptr = (PFN_GLCOLORMASKI)_getPrivateProcAddress("glColorMaski");
    if (!_ptr) {
        _ptr = &_fail_glColorMaski;
    }
    _glColorMaski = _ptr;
    _glColorMaski(index, r, g, b, a);
}

PFN_GLCOLORMASKI _glColorMaski = &_get_glColorMaski;

static void APIENTRY _fail_glGetBooleani_v(GLenum target, GLuint index, GLboolean * data) {
    const char *_name = "glGetBooleani_v";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetBooleani_v(GLenum target, GLuint index, GLboolean * data) {
    PFN_GLGETBOOLEANI_V _ptr;
    _ptr = (PFN_GLGETBOOLEANI_V)_getPrivateProcAddress("glGetBooleani_v");
    if (!_ptr) {
        _ptr = &_fail_glGetBooleani_v;
    }
    _glGetBooleani_v = _ptr;
    _glGetBooleani_v(target, index, data);
}

PFN_GLGETBOOLEANI_V _glGetBooleani_v = &_get_glGetBooleani_v;

static void APIENTRY _fail_glGetIntegeri_v(GLenum target, GLuint index, GLint * data) {
    const char *_name = "glGetIntegeri_v";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetIntegeri_v(GLenum target, GLuint index, GLint * data) {
    PFN_GLGETINTEGERI_V _ptr;
    _ptr = (PFN_GLGETINTEGERI_V)_getPrivateProcAddress("glGetIntegeri_v");
    if (!_ptr) {
        _ptr = &_fail_glGetIntegeri_v;
    }
    _glGetIntegeri_v = _ptr;
    _glGetIntegeri_v(target, index, data);
}

PFN_GLGETINTEGERI_V _glGetIntegeri_v = &_get_glGetIntegeri_v;

static void APIENTRY _fail_glEnablei(GLenum target, GLuint index) {
    const char *_name = "glEnablei";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEnablei(GLenum target, GLuint index) {
    PFN_GLENABLEI _ptr;
    _ptr = (PFN_GLENABLEI)_getPrivateProcAddress("glEnablei");
    if (!_ptr) {
        _ptr = &_fail_glEnablei;
    }
    _glEnablei = _ptr;
    _glEnablei(target, index);
}

PFN_GLENABLEI _glEnablei = &_get_glEnablei;

static void APIENTRY _fail_glDisablei(GLenum target, GLuint index) {
    const char *_name = "glDisablei";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDisablei(GLenum target, GLuint index) {
    PFN_GLDISABLEI _ptr;
    _ptr = (PFN_GLDISABLEI)_getPrivateProcAddress("glDisablei");
    if (!_ptr) {
        _ptr = &_fail_glDisablei;
    }
    _glDisablei = _ptr;
    _glDisablei(target, index);
}

PFN_GLDISABLEI _glDisablei = &_get_glDisablei;

static GLboolean APIENTRY _fail_glIsEnabledi(GLenum target, GLuint index) {
    const char *_name = "glIsEnabledi";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsEnabledi(GLenum target, GLuint index) {
    PFN_GLISENABLEDI _ptr;
    _ptr = (PFN_GLISENABLEDI)_getPrivateProcAddress("glIsEnabledi");
    if (!_ptr) {
        _ptr = &_fail_glIsEnabledi;
    }
    _glIsEnabledi = _ptr;
    return _glIsEnabledi(target, index);
}

PFN_GLISENABLEDI _glIsEnabledi = &_get_glIsEnabledi;

static void APIENTRY _fail_glBeginTransformFeedback(GLenum primitiveMode) {
    const char *_name = "glBeginTransformFeedback";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBeginTransformFeedback(GLenum primitiveMode) {
    PFN_GLBEGINTRANSFORMFEEDBACK _ptr;
    _ptr = (PFN_GLBEGINTRANSFORMFEEDBACK)_getPrivateProcAddress("glBeginTransformFeedback");
    if (!_ptr) {
        _ptr = &_fail_glBeginTransformFeedback;
    }
    _glBeginTransformFeedback = _ptr;
    _glBeginTransformFeedback(primitiveMode);
}

PFN_GLBEGINTRANSFORMFEEDBACK _glBeginTransformFeedback = &_get_glBeginTransformFeedback;

static void APIENTRY _fail_glEndTransformFeedback(void) {
    const char *_name = "glEndTransformFeedback";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEndTransformFeedback(void) {
    PFN_GLENDTRANSFORMFEEDBACK _ptr;
    _ptr = (PFN_GLENDTRANSFORMFEEDBACK)_getPrivateProcAddress("glEndTransformFeedback");
    if (!_ptr) {
        _ptr = &_fail_glEndTransformFeedback;
    }
    _glEndTransformFeedback = _ptr;
    _glEndTransformFeedback();
}

PFN_GLENDTRANSFORMFEEDBACK _glEndTransformFeedback = &_get_glEndTransformFeedback;

static void APIENTRY _fail_glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    const char *_name = "glBindBufferRange";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    PFN_GLBINDBUFFERRANGE _ptr;
    _ptr = (PFN_GLBINDBUFFERRANGE)_getPrivateProcAddress("glBindBufferRange");
    if (!_ptr) {
        _ptr = &_fail_glBindBufferRange;
    }
    _glBindBufferRange = _ptr;
    _glBindBufferRange(target, index, buffer, offset, size);
}

PFN_GLBINDBUFFERRANGE _glBindBufferRange = &_get_glBindBufferRange;

static void APIENTRY _fail_glBindBufferBase(GLenum target, GLuint index, GLuint buffer) {
    const char *_name = "glBindBufferBase";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindBufferBase(GLenum target, GLuint index, GLuint buffer) {
    PFN_GLBINDBUFFERBASE _ptr;
    _ptr = (PFN_GLBINDBUFFERBASE)_getPrivateProcAddress("glBindBufferBase");
    if (!_ptr) {
        _ptr = &_fail_glBindBufferBase;
    }
    _glBindBufferBase = _ptr;
    _glBindBufferBase(target, index, buffer);
}

PFN_GLBINDBUFFERBASE _glBindBufferBase = &_get_glBindBufferBase;

static void APIENTRY _fail_glTransformFeedbackVaryings(GLuint program, GLsizei count, const GLchar * const * varyings, GLenum bufferMode) {
    const char *_name = "glTransformFeedbackVaryings";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTransformFeedbackVaryings(GLuint program, GLsizei count, const GLchar * const * varyings, GLenum bufferMode) {
    PFN_GLTRANSFORMFEEDBACKVARYINGS _ptr;
    _ptr = (PFN_GLTRANSFORMFEEDBACKVARYINGS)_getPrivateProcAddress("glTransformFeedbackVaryings");
    if (!_ptr) {
        _ptr = &_fail_glTransformFeedbackVaryings;
    }
    _glTransformFeedbackVaryings = _ptr;
    _glTransformFeedbackVaryings(program, count, varyings, bufferMode);
}

PFN_GLTRANSFORMFEEDBACKVARYINGS _glTransformFeedbackVaryings = &_get_glTransformFeedbackVaryings;

static void APIENTRY _fail_glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name) {
    const char *_name = "glGetTransformFeedbackVarying";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name) {
    PFN_GLGETTRANSFORMFEEDBACKVARYING _ptr;
    _ptr = (PFN_GLGETTRANSFORMFEEDBACKVARYING)_getPrivateProcAddress("glGetTransformFeedbackVarying");
    if (!_ptr) {
        _ptr = &_fail_glGetTransformFeedbackVarying;
    }
    _glGetTransformFeedbackVarying = _ptr;
    _glGetTransformFeedbackVarying(program, index, bufSize, length, size, type, name);
}

PFN_GLGETTRANSFORMFEEDBACKVARYING _glGetTransformFeedbackVarying = &_get_glGetTransformFeedbackVarying;

static void APIENTRY _fail_glClampColor(GLenum target, GLenum clamp) {
    const char *_name = "glClampColor";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClampColor(GLenum target, GLenum clamp) {
    PFN_GLCLAMPCOLOR _ptr;
    _ptr = (PFN_GLCLAMPCOLOR)_getPrivateProcAddress("glClampColor");
    if (!_ptr) {
        _ptr = &_fail_glClampColor;
    }
    _glClampColor = _ptr;
    _glClampColor(target, clamp);
}

PFN_GLCLAMPCOLOR _glClampColor = &_get_glClampColor;

static void APIENTRY _fail_glBeginConditionalRender(GLuint id, GLenum mode) {
    const char *_name = "glBeginConditionalRender";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBeginConditionalRender(GLuint id, GLenum mode) {
    PFN_GLBEGINCONDITIONALRENDER _ptr;
    _ptr = (PFN_GLBEGINCONDITIONALRENDER)_getPrivateProcAddress("glBeginConditionalRender");
    if (!_ptr) {
        _ptr = &_fail_glBeginConditionalRender;
    }
    _glBeginConditionalRender = _ptr;
    _glBeginConditionalRender(id, mode);
}

PFN_GLBEGINCONDITIONALRENDER _glBeginConditionalRender = &_get_glBeginConditionalRender;

static void APIENTRY _fail_glEndConditionalRender(void) {
    const char *_name = "glEndConditionalRender";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEndConditionalRender(void) {
    PFN_GLENDCONDITIONALRENDER _ptr;
    _ptr = (PFN_GLENDCONDITIONALRENDER)_getPrivateProcAddress("glEndConditionalRender");
    if (!_ptr) {
        _ptr = &_fail_glEndConditionalRender;
    }
    _glEndConditionalRender = _ptr;
    _glEndConditionalRender();
}

PFN_GLENDCONDITIONALRENDER _glEndConditionalRender = &_get_glEndConditionalRender;

static void APIENTRY _fail_glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glVertexAttribIPointer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLVERTEXATTRIBIPOINTER _ptr;
    _ptr = (PFN_GLVERTEXATTRIBIPOINTER)_getPrivateProcAddress("glVertexAttribIPointer");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribIPointer;
    }
    _glVertexAttribIPointer = _ptr;
    _glVertexAttribIPointer(index, size, type, stride, pointer);
}

PFN_GLVERTEXATTRIBIPOINTER _glVertexAttribIPointer = &_get_glVertexAttribIPointer;

static void APIENTRY _fail_glGetVertexAttribIiv(GLuint index, GLenum pname, GLint * params) {
    const char *_name = "glGetVertexAttribIiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribIiv(GLuint index, GLenum pname, GLint * params) {
    PFN_GLGETVERTEXATTRIBIIV _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBIIV)_getPrivateProcAddress("glGetVertexAttribIiv");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribIiv;
    }
    _glGetVertexAttribIiv = _ptr;
    _glGetVertexAttribIiv(index, pname, params);
}

PFN_GLGETVERTEXATTRIBIIV _glGetVertexAttribIiv = &_get_glGetVertexAttribIiv;

static void APIENTRY _fail_glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint * params) {
    const char *_name = "glGetVertexAttribIuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint * params) {
    PFN_GLGETVERTEXATTRIBIUIV _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBIUIV)_getPrivateProcAddress("glGetVertexAttribIuiv");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribIuiv;
    }
    _glGetVertexAttribIuiv = _ptr;
    _glGetVertexAttribIuiv(index, pname, params);
}

PFN_GLGETVERTEXATTRIBIUIV _glGetVertexAttribIuiv = &_get_glGetVertexAttribIuiv;

static void APIENTRY _fail_glVertexAttribI1i(GLuint index, GLint x) {
    const char *_name = "glVertexAttribI1i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI1i(GLuint index, GLint x) {
    PFN_GLVERTEXATTRIBI1I _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI1I)_getPrivateProcAddress("glVertexAttribI1i");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI1i;
    }
    _glVertexAttribI1i = _ptr;
    _glVertexAttribI1i(index, x);
}

PFN_GLVERTEXATTRIBI1I _glVertexAttribI1i = &_get_glVertexAttribI1i;

static void APIENTRY _fail_glVertexAttribI2i(GLuint index, GLint x, GLint y) {
    const char *_name = "glVertexAttribI2i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI2i(GLuint index, GLint x, GLint y) {
    PFN_GLVERTEXATTRIBI2I _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI2I)_getPrivateProcAddress("glVertexAttribI2i");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI2i;
    }
    _glVertexAttribI2i = _ptr;
    _glVertexAttribI2i(index, x, y);
}

PFN_GLVERTEXATTRIBI2I _glVertexAttribI2i = &_get_glVertexAttribI2i;

static void APIENTRY _fail_glVertexAttribI3i(GLuint index, GLint x, GLint y, GLint z) {
    const char *_name = "glVertexAttribI3i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI3i(GLuint index, GLint x, GLint y, GLint z) {
    PFN_GLVERTEXATTRIBI3I _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI3I)_getPrivateProcAddress("glVertexAttribI3i");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI3i;
    }
    _glVertexAttribI3i = _ptr;
    _glVertexAttribI3i(index, x, y, z);
}

PFN_GLVERTEXATTRIBI3I _glVertexAttribI3i = &_get_glVertexAttribI3i;

static void APIENTRY _fail_glVertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w) {
    const char *_name = "glVertexAttribI4i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w) {
    PFN_GLVERTEXATTRIBI4I _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI4I)_getPrivateProcAddress("glVertexAttribI4i");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI4i;
    }
    _glVertexAttribI4i = _ptr;
    _glVertexAttribI4i(index, x, y, z, w);
}

PFN_GLVERTEXATTRIBI4I _glVertexAttribI4i = &_get_glVertexAttribI4i;

static void APIENTRY _fail_glVertexAttribI1ui(GLuint index, GLuint x) {
    const char *_name = "glVertexAttribI1ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI1ui(GLuint index, GLuint x) {
    PFN_GLVERTEXATTRIBI1UI _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI1UI)_getPrivateProcAddress("glVertexAttribI1ui");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI1ui;
    }
    _glVertexAttribI1ui = _ptr;
    _glVertexAttribI1ui(index, x);
}

PFN_GLVERTEXATTRIBI1UI _glVertexAttribI1ui = &_get_glVertexAttribI1ui;

static void APIENTRY _fail_glVertexAttribI2ui(GLuint index, GLuint x, GLuint y) {
    const char *_name = "glVertexAttribI2ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI2ui(GLuint index, GLuint x, GLuint y) {
    PFN_GLVERTEXATTRIBI2UI _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI2UI)_getPrivateProcAddress("glVertexAttribI2ui");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI2ui;
    }
    _glVertexAttribI2ui = _ptr;
    _glVertexAttribI2ui(index, x, y);
}

PFN_GLVERTEXATTRIBI2UI _glVertexAttribI2ui = &_get_glVertexAttribI2ui;

static void APIENTRY _fail_glVertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z) {
    const char *_name = "glVertexAttribI3ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z) {
    PFN_GLVERTEXATTRIBI3UI _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI3UI)_getPrivateProcAddress("glVertexAttribI3ui");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI3ui;
    }
    _glVertexAttribI3ui = _ptr;
    _glVertexAttribI3ui(index, x, y, z);
}

PFN_GLVERTEXATTRIBI3UI _glVertexAttribI3ui = &_get_glVertexAttribI3ui;

static void APIENTRY _fail_glVertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
    const char *_name = "glVertexAttribI4ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
    PFN_GLVERTEXATTRIBI4UI _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI4UI)_getPrivateProcAddress("glVertexAttribI4ui");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI4ui;
    }
    _glVertexAttribI4ui = _ptr;
    _glVertexAttribI4ui(index, x, y, z, w);
}

PFN_GLVERTEXATTRIBI4UI _glVertexAttribI4ui = &_get_glVertexAttribI4ui;

static void APIENTRY _fail_glVertexAttribI1iv(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttribI1iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI1iv(GLuint index, const GLint * v) {
    PFN_GLVERTEXATTRIBI1IV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI1IV)_getPrivateProcAddress("glVertexAttribI1iv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI1iv;
    }
    _glVertexAttribI1iv = _ptr;
    _glVertexAttribI1iv(index, v);
}

PFN_GLVERTEXATTRIBI1IV _glVertexAttribI1iv = &_get_glVertexAttribI1iv;

static void APIENTRY _fail_glVertexAttribI2iv(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttribI2iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI2iv(GLuint index, const GLint * v) {
    PFN_GLVERTEXATTRIBI2IV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI2IV)_getPrivateProcAddress("glVertexAttribI2iv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI2iv;
    }
    _glVertexAttribI2iv = _ptr;
    _glVertexAttribI2iv(index, v);
}

PFN_GLVERTEXATTRIBI2IV _glVertexAttribI2iv = &_get_glVertexAttribI2iv;

static void APIENTRY _fail_glVertexAttribI3iv(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttribI3iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI3iv(GLuint index, const GLint * v) {
    PFN_GLVERTEXATTRIBI3IV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI3IV)_getPrivateProcAddress("glVertexAttribI3iv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI3iv;
    }
    _glVertexAttribI3iv = _ptr;
    _glVertexAttribI3iv(index, v);
}

PFN_GLVERTEXATTRIBI3IV _glVertexAttribI3iv = &_get_glVertexAttribI3iv;

static void APIENTRY _fail_glVertexAttribI4iv(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttribI4iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI4iv(GLuint index, const GLint * v) {
    PFN_GLVERTEXATTRIBI4IV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI4IV)_getPrivateProcAddress("glVertexAttribI4iv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI4iv;
    }
    _glVertexAttribI4iv = _ptr;
    _glVertexAttribI4iv(index, v);
}

PFN_GLVERTEXATTRIBI4IV _glVertexAttribI4iv = &_get_glVertexAttribI4iv;

static void APIENTRY _fail_glVertexAttribI1uiv(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttribI1uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI1uiv(GLuint index, const GLuint * v) {
    PFN_GLVERTEXATTRIBI1UIV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI1UIV)_getPrivateProcAddress("glVertexAttribI1uiv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI1uiv;
    }
    _glVertexAttribI1uiv = _ptr;
    _glVertexAttribI1uiv(index, v);
}

PFN_GLVERTEXATTRIBI1UIV _glVertexAttribI1uiv = &_get_glVertexAttribI1uiv;

static void APIENTRY _fail_glVertexAttribI2uiv(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttribI2uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI2uiv(GLuint index, const GLuint * v) {
    PFN_GLVERTEXATTRIBI2UIV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI2UIV)_getPrivateProcAddress("glVertexAttribI2uiv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI2uiv;
    }
    _glVertexAttribI2uiv = _ptr;
    _glVertexAttribI2uiv(index, v);
}

PFN_GLVERTEXATTRIBI2UIV _glVertexAttribI2uiv = &_get_glVertexAttribI2uiv;

static void APIENTRY _fail_glVertexAttribI3uiv(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttribI3uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI3uiv(GLuint index, const GLuint * v) {
    PFN_GLVERTEXATTRIBI3UIV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI3UIV)_getPrivateProcAddress("glVertexAttribI3uiv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI3uiv;
    }
    _glVertexAttribI3uiv = _ptr;
    _glVertexAttribI3uiv(index, v);
}

PFN_GLVERTEXATTRIBI3UIV _glVertexAttribI3uiv = &_get_glVertexAttribI3uiv;

static void APIENTRY _fail_glVertexAttribI4uiv(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttribI4uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI4uiv(GLuint index, const GLuint * v) {
    PFN_GLVERTEXATTRIBI4UIV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI4UIV)_getPrivateProcAddress("glVertexAttribI4uiv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI4uiv;
    }
    _glVertexAttribI4uiv = _ptr;
    _glVertexAttribI4uiv(index, v);
}

PFN_GLVERTEXATTRIBI4UIV _glVertexAttribI4uiv = &_get_glVertexAttribI4uiv;

static void APIENTRY _fail_glVertexAttribI4bv(GLuint index, const GLbyte * v) {
    const char *_name = "glVertexAttribI4bv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI4bv(GLuint index, const GLbyte * v) {
    PFN_GLVERTEXATTRIBI4BV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI4BV)_getPrivateProcAddress("glVertexAttribI4bv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI4bv;
    }
    _glVertexAttribI4bv = _ptr;
    _glVertexAttribI4bv(index, v);
}

PFN_GLVERTEXATTRIBI4BV _glVertexAttribI4bv = &_get_glVertexAttribI4bv;

static void APIENTRY _fail_glVertexAttribI4sv(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttribI4sv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI4sv(GLuint index, const GLshort * v) {
    PFN_GLVERTEXATTRIBI4SV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI4SV)_getPrivateProcAddress("glVertexAttribI4sv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI4sv;
    }
    _glVertexAttribI4sv = _ptr;
    _glVertexAttribI4sv(index, v);
}

PFN_GLVERTEXATTRIBI4SV _glVertexAttribI4sv = &_get_glVertexAttribI4sv;

static void APIENTRY _fail_glVertexAttribI4ubv(GLuint index, const GLubyte * v) {
    const char *_name = "glVertexAttribI4ubv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI4ubv(GLuint index, const GLubyte * v) {
    PFN_GLVERTEXATTRIBI4UBV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI4UBV)_getPrivateProcAddress("glVertexAttribI4ubv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI4ubv;
    }
    _glVertexAttribI4ubv = _ptr;
    _glVertexAttribI4ubv(index, v);
}

PFN_GLVERTEXATTRIBI4UBV _glVertexAttribI4ubv = &_get_glVertexAttribI4ubv;

static void APIENTRY _fail_glVertexAttribI4usv(GLuint index, const GLushort * v) {
    const char *_name = "glVertexAttribI4usv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI4usv(GLuint index, const GLushort * v) {
    PFN_GLVERTEXATTRIBI4USV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI4USV)_getPrivateProcAddress("glVertexAttribI4usv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI4usv;
    }
    _glVertexAttribI4usv = _ptr;
    _glVertexAttribI4usv(index, v);
}

PFN_GLVERTEXATTRIBI4USV _glVertexAttribI4usv = &_get_glVertexAttribI4usv;

static void APIENTRY _fail_glGetUniformuiv(GLuint program, GLint location, GLuint * params) {
    const char *_name = "glGetUniformuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetUniformuiv(GLuint program, GLint location, GLuint * params) {
    PFN_GLGETUNIFORMUIV _ptr;
    _ptr = (PFN_GLGETUNIFORMUIV)_getPrivateProcAddress("glGetUniformuiv");
    if (!_ptr) {
        _ptr = &_fail_glGetUniformuiv;
    }
    _glGetUniformuiv = _ptr;
    _glGetUniformuiv(program, location, params);
}

PFN_GLGETUNIFORMUIV _glGetUniformuiv = &_get_glGetUniformuiv;

static void APIENTRY _fail_glBindFragDataLocation(GLuint program, GLuint color, const GLchar * name) {
    const char *_name = "glBindFragDataLocation";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindFragDataLocation(GLuint program, GLuint color, const GLchar * name) {
    PFN_GLBINDFRAGDATALOCATION _ptr;
    _ptr = (PFN_GLBINDFRAGDATALOCATION)_getPrivateProcAddress("glBindFragDataLocation");
    if (!_ptr) {
        _ptr = &_fail_glBindFragDataLocation;
    }
    _glBindFragDataLocation = _ptr;
    _glBindFragDataLocation(program, color, name);
}

PFN_GLBINDFRAGDATALOCATION _glBindFragDataLocation = &_get_glBindFragDataLocation;

static GLint APIENTRY _fail_glGetFragDataLocation(GLuint program, const GLchar * name) {
    const char *_name = "glGetFragDataLocation";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLint APIENTRY _get_glGetFragDataLocation(GLuint program, const GLchar * name) {
    PFN_GLGETFRAGDATALOCATION _ptr;
    _ptr = (PFN_GLGETFRAGDATALOCATION)_getPrivateProcAddress("glGetFragDataLocation");
    if (!_ptr) {
        _ptr = &_fail_glGetFragDataLocation;
    }
    _glGetFragDataLocation = _ptr;
    return _glGetFragDataLocation(program, name);
}

PFN_GLGETFRAGDATALOCATION _glGetFragDataLocation = &_get_glGetFragDataLocation;

static void APIENTRY _fail_glUniform1ui(GLint location, GLuint v0) {
    const char *_name = "glUniform1ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1ui(GLint location, GLuint v0) {
    PFN_GLUNIFORM1UI _ptr;
    _ptr = (PFN_GLUNIFORM1UI)_getPrivateProcAddress("glUniform1ui");
    if (!_ptr) {
        _ptr = &_fail_glUniform1ui;
    }
    _glUniform1ui = _ptr;
    _glUniform1ui(location, v0);
}

PFN_GLUNIFORM1UI _glUniform1ui = &_get_glUniform1ui;

static void APIENTRY _fail_glUniform2ui(GLint location, GLuint v0, GLuint v1) {
    const char *_name = "glUniform2ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2ui(GLint location, GLuint v0, GLuint v1) {
    PFN_GLUNIFORM2UI _ptr;
    _ptr = (PFN_GLUNIFORM2UI)_getPrivateProcAddress("glUniform2ui");
    if (!_ptr) {
        _ptr = &_fail_glUniform2ui;
    }
    _glUniform2ui = _ptr;
    _glUniform2ui(location, v0, v1);
}

PFN_GLUNIFORM2UI _glUniform2ui = &_get_glUniform2ui;

static void APIENTRY _fail_glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2) {
    const char *_name = "glUniform3ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2) {
    PFN_GLUNIFORM3UI _ptr;
    _ptr = (PFN_GLUNIFORM3UI)_getPrivateProcAddress("glUniform3ui");
    if (!_ptr) {
        _ptr = &_fail_glUniform3ui;
    }
    _glUniform3ui = _ptr;
    _glUniform3ui(location, v0, v1, v2);
}

PFN_GLUNIFORM3UI _glUniform3ui = &_get_glUniform3ui;

static void APIENTRY _fail_glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
    const char *_name = "glUniform4ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
    PFN_GLUNIFORM4UI _ptr;
    _ptr = (PFN_GLUNIFORM4UI)_getPrivateProcAddress("glUniform4ui");
    if (!_ptr) {
        _ptr = &_fail_glUniform4ui;
    }
    _glUniform4ui = _ptr;
    _glUniform4ui(location, v0, v1, v2, v3);
}

PFN_GLUNIFORM4UI _glUniform4ui = &_get_glUniform4ui;

static void APIENTRY _fail_glUniform1uiv(GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glUniform1uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1uiv(GLint location, GLsizei count, const GLuint * value) {
    PFN_GLUNIFORM1UIV _ptr;
    _ptr = (PFN_GLUNIFORM1UIV)_getPrivateProcAddress("glUniform1uiv");
    if (!_ptr) {
        _ptr = &_fail_glUniform1uiv;
    }
    _glUniform1uiv = _ptr;
    _glUniform1uiv(location, count, value);
}

PFN_GLUNIFORM1UIV _glUniform1uiv = &_get_glUniform1uiv;

static void APIENTRY _fail_glUniform2uiv(GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glUniform2uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2uiv(GLint location, GLsizei count, const GLuint * value) {
    PFN_GLUNIFORM2UIV _ptr;
    _ptr = (PFN_GLUNIFORM2UIV)_getPrivateProcAddress("glUniform2uiv");
    if (!_ptr) {
        _ptr = &_fail_glUniform2uiv;
    }
    _glUniform2uiv = _ptr;
    _glUniform2uiv(location, count, value);
}

PFN_GLUNIFORM2UIV _glUniform2uiv = &_get_glUniform2uiv;

static void APIENTRY _fail_glUniform3uiv(GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glUniform3uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3uiv(GLint location, GLsizei count, const GLuint * value) {
    PFN_GLUNIFORM3UIV _ptr;
    _ptr = (PFN_GLUNIFORM3UIV)_getPrivateProcAddress("glUniform3uiv");
    if (!_ptr) {
        _ptr = &_fail_glUniform3uiv;
    }
    _glUniform3uiv = _ptr;
    _glUniform3uiv(location, count, value);
}

PFN_GLUNIFORM3UIV _glUniform3uiv = &_get_glUniform3uiv;

static void APIENTRY _fail_glUniform4uiv(GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glUniform4uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4uiv(GLint location, GLsizei count, const GLuint * value) {
    PFN_GLUNIFORM4UIV _ptr;
    _ptr = (PFN_GLUNIFORM4UIV)_getPrivateProcAddress("glUniform4uiv");
    if (!_ptr) {
        _ptr = &_fail_glUniform4uiv;
    }
    _glUniform4uiv = _ptr;
    _glUniform4uiv(location, count, value);
}

PFN_GLUNIFORM4UIV _glUniform4uiv = &_get_glUniform4uiv;

static void APIENTRY _fail_glTexParameterIiv(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glTexParameterIiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexParameterIiv(GLenum target, GLenum pname, const GLint * params) {
    PFN_GLTEXPARAMETERIIV _ptr;
    _ptr = (PFN_GLTEXPARAMETERIIV)_getPrivateProcAddress("glTexParameterIiv");
    if (!_ptr) {
        _ptr = &_fail_glTexParameterIiv;
    }
    _glTexParameterIiv = _ptr;
    _glTexParameterIiv(target, pname, params);
}

PFN_GLTEXPARAMETERIIV _glTexParameterIiv = &_get_glTexParameterIiv;

static void APIENTRY _fail_glTexParameterIuiv(GLenum target, GLenum pname, const GLuint * params) {
    const char *_name = "glTexParameterIuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexParameterIuiv(GLenum target, GLenum pname, const GLuint * params) {
    PFN_GLTEXPARAMETERIUIV _ptr;
    _ptr = (PFN_GLTEXPARAMETERIUIV)_getPrivateProcAddress("glTexParameterIuiv");
    if (!_ptr) {
        _ptr = &_fail_glTexParameterIuiv;
    }
    _glTexParameterIuiv = _ptr;
    _glTexParameterIuiv(target, pname, params);
}

PFN_GLTEXPARAMETERIUIV _glTexParameterIuiv = &_get_glTexParameterIuiv;

static void APIENTRY _fail_glGetTexParameterIiv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetTexParameterIiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexParameterIiv(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETTEXPARAMETERIIV _ptr;
    _ptr = (PFN_GLGETTEXPARAMETERIIV)_getPrivateProcAddress("glGetTexParameterIiv");
    if (!_ptr) {
        _ptr = &_fail_glGetTexParameterIiv;
    }
    _glGetTexParameterIiv = _ptr;
    _glGetTexParameterIiv(target, pname, params);
}

PFN_GLGETTEXPARAMETERIIV _glGetTexParameterIiv = &_get_glGetTexParameterIiv;

static void APIENTRY _fail_glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint * params) {
    const char *_name = "glGetTexParameterIuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint * params) {
    PFN_GLGETTEXPARAMETERIUIV _ptr;
    _ptr = (PFN_GLGETTEXPARAMETERIUIV)_getPrivateProcAddress("glGetTexParameterIuiv");
    if (!_ptr) {
        _ptr = &_fail_glGetTexParameterIuiv;
    }
    _glGetTexParameterIuiv = _ptr;
    _glGetTexParameterIuiv(target, pname, params);
}

PFN_GLGETTEXPARAMETERIUIV _glGetTexParameterIuiv = &_get_glGetTexParameterIuiv;

static void APIENTRY _fail_glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint * value) {
    const char *_name = "glClearBufferiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint * value) {
    PFN_GLCLEARBUFFERIV _ptr;
    _ptr = (PFN_GLCLEARBUFFERIV)_getPrivateProcAddress("glClearBufferiv");
    if (!_ptr) {
        _ptr = &_fail_glClearBufferiv;
    }
    _glClearBufferiv = _ptr;
    _glClearBufferiv(buffer, drawbuffer, value);
}

PFN_GLCLEARBUFFERIV _glClearBufferiv = &_get_glClearBufferiv;

static void APIENTRY _fail_glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint * value) {
    const char *_name = "glClearBufferuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint * value) {
    PFN_GLCLEARBUFFERUIV _ptr;
    _ptr = (PFN_GLCLEARBUFFERUIV)_getPrivateProcAddress("glClearBufferuiv");
    if (!_ptr) {
        _ptr = &_fail_glClearBufferuiv;
    }
    _glClearBufferuiv = _ptr;
    _glClearBufferuiv(buffer, drawbuffer, value);
}

PFN_GLCLEARBUFFERUIV _glClearBufferuiv = &_get_glClearBufferuiv;

static void APIENTRY _fail_glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat * value) {
    const char *_name = "glClearBufferfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat * value) {
    PFN_GLCLEARBUFFERFV _ptr;
    _ptr = (PFN_GLCLEARBUFFERFV)_getPrivateProcAddress("glClearBufferfv");
    if (!_ptr) {
        _ptr = &_fail_glClearBufferfv;
    }
    _glClearBufferfv = _ptr;
    _glClearBufferfv(buffer, drawbuffer, value);
}

PFN_GLCLEARBUFFERFV _glClearBufferfv = &_get_glClearBufferfv;

static void APIENTRY _fail_glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil) {
    const char *_name = "glClearBufferfi";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil) {
    PFN_GLCLEARBUFFERFI _ptr;
    _ptr = (PFN_GLCLEARBUFFERFI)_getPrivateProcAddress("glClearBufferfi");
    if (!_ptr) {
        _ptr = &_fail_glClearBufferfi;
    }
    _glClearBufferfi = _ptr;
    _glClearBufferfi(buffer, drawbuffer, depth, stencil);
}

PFN_GLCLEARBUFFERFI _glClearBufferfi = &_get_glClearBufferfi;

static const GLubyte * APIENTRY _fail_glGetStringi(GLenum name, GLuint index) {
    const char *_name = "glGetStringi";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static const GLubyte * APIENTRY _get_glGetStringi(GLenum name, GLuint index) {
    PFN_GLGETSTRINGI _ptr;
    _ptr = (PFN_GLGETSTRINGI)_getPrivateProcAddress("glGetStringi");
    if (!_ptr) {
        _ptr = &_fail_glGetStringi;
    }
    _glGetStringi = _ptr;
    return _glGetStringi(name, index);
}

PFN_GLGETSTRINGI _glGetStringi = &_get_glGetStringi;

static void APIENTRY _fail_glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei primcount) {
    const char *_name = "glDrawArraysInstanced";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei primcount) {
    PFN_GLDRAWARRAYSINSTANCED _ptr;
    _ptr = (PFN_GLDRAWARRAYSINSTANCED)_getPrivateProcAddress("glDrawArraysInstanced");
    if (!_ptr) {
        _ptr = &_fail_glDrawArraysInstanced;
    }
    _glDrawArraysInstanced = _ptr;
    _glDrawArraysInstanced(mode, first, count, primcount);
}

PFN_GLDRAWARRAYSINSTANCED _glDrawArraysInstanced = &_get_glDrawArraysInstanced;

static void APIENTRY _fail_glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount) {
    const char *_name = "glDrawElementsInstanced";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount) {
    PFN_GLDRAWELEMENTSINSTANCED _ptr;
    _ptr = (PFN_GLDRAWELEMENTSINSTANCED)_getPrivateProcAddress("glDrawElementsInstanced");
    if (!_ptr) {
        _ptr = &_fail_glDrawElementsInstanced;
    }
    _glDrawElementsInstanced = _ptr;
    _glDrawElementsInstanced(mode, count, type, indices, primcount);
}

PFN_GLDRAWELEMENTSINSTANCED _glDrawElementsInstanced = &_get_glDrawElementsInstanced;

static void APIENTRY _fail_glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer) {
    const char *_name = "glTexBuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer) {
    PFN_GLTEXBUFFER _ptr;
    _ptr = (PFN_GLTEXBUFFER)_getPrivateProcAddress("glTexBuffer");
    if (!_ptr) {
        _ptr = &_fail_glTexBuffer;
    }
    _glTexBuffer = _ptr;
    _glTexBuffer(target, internalformat, buffer);
}

PFN_GLTEXBUFFER _glTexBuffer = &_get_glTexBuffer;

static void APIENTRY _fail_glPrimitiveRestartIndex(GLuint index) {
    const char *_name = "glPrimitiveRestartIndex";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPrimitiveRestartIndex(GLuint index) {
    PFN_GLPRIMITIVERESTARTINDEX _ptr;
    _ptr = (PFN_GLPRIMITIVERESTARTINDEX)_getPrivateProcAddress("glPrimitiveRestartIndex");
    if (!_ptr) {
        _ptr = &_fail_glPrimitiveRestartIndex;
    }
    _glPrimitiveRestartIndex = _ptr;
    _glPrimitiveRestartIndex(index);
}

PFN_GLPRIMITIVERESTARTINDEX _glPrimitiveRestartIndex = &_get_glPrimitiveRestartIndex;

static void APIENTRY _fail_glGetInteger64i_v(GLenum target, GLuint index, GLint64 * data) {
    const char *_name = "glGetInteger64i_v";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetInteger64i_v(GLenum target, GLuint index, GLint64 * data) {
    PFN_GLGETINTEGER64I_V _ptr;
    _ptr = (PFN_GLGETINTEGER64I_V)_getPrivateProcAddress("glGetInteger64i_v");
    if (!_ptr) {
        _ptr = &_fail_glGetInteger64i_v;
    }
    _glGetInteger64i_v = _ptr;
    _glGetInteger64i_v(target, index, data);
}

PFN_GLGETINTEGER64I_V _glGetInteger64i_v = &_get_glGetInteger64i_v;

static void APIENTRY _fail_glGetBufferParameteri64v(GLenum target, GLenum pname, GLint64 * params) {
    const char *_name = "glGetBufferParameteri64v";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetBufferParameteri64v(GLenum target, GLenum pname, GLint64 * params) {
    PFN_GLGETBUFFERPARAMETERI64V _ptr;
    _ptr = (PFN_GLGETBUFFERPARAMETERI64V)_getPrivateProcAddress("glGetBufferParameteri64v");
    if (!_ptr) {
        _ptr = &_fail_glGetBufferParameteri64v;
    }
    _glGetBufferParameteri64v = _ptr;
    _glGetBufferParameteri64v(target, pname, params);
}

PFN_GLGETBUFFERPARAMETERI64V _glGetBufferParameteri64v = &_get_glGetBufferParameteri64v;

static void APIENTRY _fail_glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level) {
    const char *_name = "glFramebufferTexture";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level) {
    PFN_GLFRAMEBUFFERTEXTURE _ptr;
    _ptr = (PFN_GLFRAMEBUFFERTEXTURE)_getPrivateProcAddress("glFramebufferTexture");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferTexture;
    }
    _glFramebufferTexture = _ptr;
    _glFramebufferTexture(target, attachment, texture, level);
}

PFN_GLFRAMEBUFFERTEXTURE _glFramebufferTexture = &_get_glFramebufferTexture;

static void APIENTRY _fail_glVertexAttribDivisor(GLuint index, GLuint divisor) {
    const char *_name = "glVertexAttribDivisor";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribDivisor(GLuint index, GLuint divisor) {
    PFN_GLVERTEXATTRIBDIVISOR _ptr;
    _ptr = (PFN_GLVERTEXATTRIBDIVISOR)_getPrivateProcAddress("glVertexAttribDivisor");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribDivisor;
    }
    _glVertexAttribDivisor = _ptr;
    _glVertexAttribDivisor(index, divisor);
}

PFN_GLVERTEXATTRIBDIVISOR _glVertexAttribDivisor = &_get_glVertexAttribDivisor;

static void APIENTRY _fail_glMinSampleShading(GLfloat value) {
    const char *_name = "glMinSampleShading";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMinSampleShading(GLfloat value) {
    PFN_GLMINSAMPLESHADING _ptr;
    _ptr = (PFN_GLMINSAMPLESHADING)_getPrivateProcAddress("glMinSampleShading");
    if (!_ptr) {
        _ptr = &_fail_glMinSampleShading;
    }
    _glMinSampleShading = _ptr;
    _glMinSampleShading(value);
}

PFN_GLMINSAMPLESHADING _glMinSampleShading = &_get_glMinSampleShading;

static void APIENTRY _fail_glBlendEquationi(GLuint buf, GLenum mode) {
    const char *_name = "glBlendEquationi";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendEquationi(GLuint buf, GLenum mode) {
    PFN_GLBLENDEQUATIONI _ptr;
    _ptr = (PFN_GLBLENDEQUATIONI)_getPrivateProcAddress("glBlendEquationi");
    if (!_ptr) {
        _ptr = &_fail_glBlendEquationi;
    }
    _glBlendEquationi = _ptr;
    _glBlendEquationi(buf, mode);
}

PFN_GLBLENDEQUATIONI _glBlendEquationi = &_get_glBlendEquationi;

static void APIENTRY _fail_glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha) {
    const char *_name = "glBlendEquationSeparatei";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha) {
    PFN_GLBLENDEQUATIONSEPARATEI _ptr;
    _ptr = (PFN_GLBLENDEQUATIONSEPARATEI)_getPrivateProcAddress("glBlendEquationSeparatei");
    if (!_ptr) {
        _ptr = &_fail_glBlendEquationSeparatei;
    }
    _glBlendEquationSeparatei = _ptr;
    _glBlendEquationSeparatei(buf, modeRGB, modeAlpha);
}

PFN_GLBLENDEQUATIONSEPARATEI _glBlendEquationSeparatei = &_get_glBlendEquationSeparatei;

static void APIENTRY _fail_glBlendFunci(GLuint buf, GLenum src, GLenum dst) {
    const char *_name = "glBlendFunci";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendFunci(GLuint buf, GLenum src, GLenum dst) {
    PFN_GLBLENDFUNCI _ptr;
    _ptr = (PFN_GLBLENDFUNCI)_getPrivateProcAddress("glBlendFunci");
    if (!_ptr) {
        _ptr = &_fail_glBlendFunci;
    }
    _glBlendFunci = _ptr;
    _glBlendFunci(buf, src, dst);
}

PFN_GLBLENDFUNCI _glBlendFunci = &_get_glBlendFunci;

static void APIENTRY _fail_glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) {
    const char *_name = "glBlendFuncSeparatei";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) {
    PFN_GLBLENDFUNCSEPARATEI _ptr;
    _ptr = (PFN_GLBLENDFUNCSEPARATEI)_getPrivateProcAddress("glBlendFuncSeparatei");
    if (!_ptr) {
        _ptr = &_fail_glBlendFuncSeparatei;
    }
    _glBlendFuncSeparatei = _ptr;
    _glBlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

PFN_GLBLENDFUNCSEPARATEI _glBlendFuncSeparatei = &_get_glBlendFuncSeparatei;

static void APIENTRY _fail_glGetnCompressedTexImage(GLenum target, GLint lod, GLsizei bufSize, void * pixels) {
    const char *_name = "glGetnCompressedTexImage";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnCompressedTexImage(GLenum target, GLint lod, GLsizei bufSize, void * pixels) {
    PFN_GLGETNCOMPRESSEDTEXIMAGE _ptr;
    _ptr = (PFN_GLGETNCOMPRESSEDTEXIMAGE)_getPrivateProcAddress("glGetnCompressedTexImage");
    if (!_ptr) {
        _ptr = &_fail_glGetnCompressedTexImage;
    }
    _glGetnCompressedTexImage = _ptr;
    _glGetnCompressedTexImage(target, lod, bufSize, pixels);
}

PFN_GLGETNCOMPRESSEDTEXIMAGE _glGetnCompressedTexImage = &_get_glGetnCompressedTexImage;

static void APIENTRY _fail_glGetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * pixels) {
    const char *_name = "glGetnTexImage";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void * pixels) {
    PFN_GLGETNTEXIMAGE _ptr;
    _ptr = (PFN_GLGETNTEXIMAGE)_getPrivateProcAddress("glGetnTexImage");
    if (!_ptr) {
        _ptr = &_fail_glGetnTexImage;
    }
    _glGetnTexImage = _ptr;
    _glGetnTexImage(target, level, format, type, bufSize, pixels);
}

PFN_GLGETNTEXIMAGE _glGetnTexImage = &_get_glGetnTexImage;

static void APIENTRY _fail_glGetnUniformdv(GLuint program, GLint location, GLsizei bufSize, GLdouble * params) {
    const char *_name = "glGetnUniformdv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnUniformdv(GLuint program, GLint location, GLsizei bufSize, GLdouble * params) {
    PFN_GLGETNUNIFORMDV _ptr;
    _ptr = (PFN_GLGETNUNIFORMDV)_getPrivateProcAddress("glGetnUniformdv");
    if (!_ptr) {
        _ptr = &_fail_glGetnUniformdv;
    }
    _glGetnUniformdv = _ptr;
    _glGetnUniformdv(program, location, bufSize, params);
}

PFN_GLGETNUNIFORMDV _glGetnUniformdv = &_get_glGetnUniformdv;

static void APIENTRY _fail_glGetnMapdv(GLenum target, GLenum query, GLsizei bufSize, GLdouble * v) {
    const char *_name = "glGetnMapdv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnMapdv(GLenum target, GLenum query, GLsizei bufSize, GLdouble * v) {
    PFN_GLGETNMAPDV _ptr;
    _ptr = (PFN_GLGETNMAPDV)_getPrivateProcAddress("glGetnMapdv");
    if (!_ptr) {
        _ptr = &_fail_glGetnMapdv;
    }
    _glGetnMapdv = _ptr;
    _glGetnMapdv(target, query, bufSize, v);
}

PFN_GLGETNMAPDV _glGetnMapdv = &_get_glGetnMapdv;

static void APIENTRY _fail_glGetnMapfv(GLenum target, GLenum query, GLsizei bufSize, GLfloat * v) {
    const char *_name = "glGetnMapfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnMapfv(GLenum target, GLenum query, GLsizei bufSize, GLfloat * v) {
    PFN_GLGETNMAPFV _ptr;
    _ptr = (PFN_GLGETNMAPFV)_getPrivateProcAddress("glGetnMapfv");
    if (!_ptr) {
        _ptr = &_fail_glGetnMapfv;
    }
    _glGetnMapfv = _ptr;
    _glGetnMapfv(target, query, bufSize, v);
}

PFN_GLGETNMAPFV _glGetnMapfv = &_get_glGetnMapfv;

static void APIENTRY _fail_glGetnMapiv(GLenum target, GLenum query, GLsizei bufSize, GLint * v) {
    const char *_name = "glGetnMapiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnMapiv(GLenum target, GLenum query, GLsizei bufSize, GLint * v) {
    PFN_GLGETNMAPIV _ptr;
    _ptr = (PFN_GLGETNMAPIV)_getPrivateProcAddress("glGetnMapiv");
    if (!_ptr) {
        _ptr = &_fail_glGetnMapiv;
    }
    _glGetnMapiv = _ptr;
    _glGetnMapiv(target, query, bufSize, v);
}

PFN_GLGETNMAPIV _glGetnMapiv = &_get_glGetnMapiv;

static void APIENTRY _fail_glGetnPixelMapfv(GLenum map, GLsizei bufSize, GLfloat * values) {
    const char *_name = "glGetnPixelMapfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnPixelMapfv(GLenum map, GLsizei bufSize, GLfloat * values) {
    PFN_GLGETNPIXELMAPFV _ptr;
    _ptr = (PFN_GLGETNPIXELMAPFV)_getPrivateProcAddress("glGetnPixelMapfv");
    if (!_ptr) {
        _ptr = &_fail_glGetnPixelMapfv;
    }
    _glGetnPixelMapfv = _ptr;
    _glGetnPixelMapfv(map, bufSize, values);
}

PFN_GLGETNPIXELMAPFV _glGetnPixelMapfv = &_get_glGetnPixelMapfv;

static void APIENTRY _fail_glGetnPixelMapuiv(GLenum map, GLsizei bufSize, GLuint * values) {
    const char *_name = "glGetnPixelMapuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnPixelMapuiv(GLenum map, GLsizei bufSize, GLuint * values) {
    PFN_GLGETNPIXELMAPUIV _ptr;
    _ptr = (PFN_GLGETNPIXELMAPUIV)_getPrivateProcAddress("glGetnPixelMapuiv");
    if (!_ptr) {
        _ptr = &_fail_glGetnPixelMapuiv;
    }
    _glGetnPixelMapuiv = _ptr;
    _glGetnPixelMapuiv(map, bufSize, values);
}

PFN_GLGETNPIXELMAPUIV _glGetnPixelMapuiv = &_get_glGetnPixelMapuiv;

static void APIENTRY _fail_glGetnPixelMapusv(GLenum map, GLsizei bufSize, GLushort * values) {
    const char *_name = "glGetnPixelMapusv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnPixelMapusv(GLenum map, GLsizei bufSize, GLushort * values) {
    PFN_GLGETNPIXELMAPUSV _ptr;
    _ptr = (PFN_GLGETNPIXELMAPUSV)_getPrivateProcAddress("glGetnPixelMapusv");
    if (!_ptr) {
        _ptr = &_fail_glGetnPixelMapusv;
    }
    _glGetnPixelMapusv = _ptr;
    _glGetnPixelMapusv(map, bufSize, values);
}

PFN_GLGETNPIXELMAPUSV _glGetnPixelMapusv = &_get_glGetnPixelMapusv;

static void APIENTRY _fail_glGetnPolygonStipple(GLsizei bufSize, GLubyte * pattern) {
    const char *_name = "glGetnPolygonStipple";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnPolygonStipple(GLsizei bufSize, GLubyte * pattern) {
    PFN_GLGETNPOLYGONSTIPPLE _ptr;
    _ptr = (PFN_GLGETNPOLYGONSTIPPLE)_getPrivateProcAddress("glGetnPolygonStipple");
    if (!_ptr) {
        _ptr = &_fail_glGetnPolygonStipple;
    }
    _glGetnPolygonStipple = _ptr;
    _glGetnPolygonStipple(bufSize, pattern);
}

PFN_GLGETNPOLYGONSTIPPLE _glGetnPolygonStipple = &_get_glGetnPolygonStipple;

static void APIENTRY _fail_glGetnColorTable(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void * table) {
    const char *_name = "glGetnColorTable";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnColorTable(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void * table) {
    PFN_GLGETNCOLORTABLE _ptr;
    _ptr = (PFN_GLGETNCOLORTABLE)_getPrivateProcAddress("glGetnColorTable");
    if (!_ptr) {
        _ptr = &_fail_glGetnColorTable;
    }
    _glGetnColorTable = _ptr;
    _glGetnColorTable(target, format, type, bufSize, table);
}

PFN_GLGETNCOLORTABLE _glGetnColorTable = &_get_glGetnColorTable;

static void APIENTRY _fail_glGetnConvolutionFilter(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void * image) {
    const char *_name = "glGetnConvolutionFilter";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnConvolutionFilter(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void * image) {
    PFN_GLGETNCONVOLUTIONFILTER _ptr;
    _ptr = (PFN_GLGETNCONVOLUTIONFILTER)_getPrivateProcAddress("glGetnConvolutionFilter");
    if (!_ptr) {
        _ptr = &_fail_glGetnConvolutionFilter;
    }
    _glGetnConvolutionFilter = _ptr;
    _glGetnConvolutionFilter(target, format, type, bufSize, image);
}

PFN_GLGETNCONVOLUTIONFILTER _glGetnConvolutionFilter = &_get_glGetnConvolutionFilter;

static void APIENTRY _fail_glGetnSeparableFilter(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void * row, GLsizei columnBufSize, void * column, GLvoid * span) {
    const char *_name = "glGetnSeparableFilter";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnSeparableFilter(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void * row, GLsizei columnBufSize, void * column, GLvoid * span) {
    PFN_GLGETNSEPARABLEFILTER _ptr;
    _ptr = (PFN_GLGETNSEPARABLEFILTER)_getPrivateProcAddress("glGetnSeparableFilter");
    if (!_ptr) {
        _ptr = &_fail_glGetnSeparableFilter;
    }
    _glGetnSeparableFilter = _ptr;
    _glGetnSeparableFilter(target, format, type, rowBufSize, row, columnBufSize, column, span);
}

PFN_GLGETNSEPARABLEFILTER _glGetnSeparableFilter = &_get_glGetnSeparableFilter;

static void APIENTRY _fail_glGetnHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void * values) {
    const char *_name = "glGetnHistogram";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void * values) {
    PFN_GLGETNHISTOGRAM _ptr;
    _ptr = (PFN_GLGETNHISTOGRAM)_getPrivateProcAddress("glGetnHistogram");
    if (!_ptr) {
        _ptr = &_fail_glGetnHistogram;
    }
    _glGetnHistogram = _ptr;
    _glGetnHistogram(target, reset, format, type, bufSize, values);
}

PFN_GLGETNHISTOGRAM _glGetnHistogram = &_get_glGetnHistogram;

static void APIENTRY _fail_glGetnMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void * values) {
    const char *_name = "glGetnMinmax";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void * values) {
    PFN_GLGETNMINMAX _ptr;
    _ptr = (PFN_GLGETNMINMAX)_getPrivateProcAddress("glGetnMinmax");
    if (!_ptr) {
        _ptr = &_fail_glGetnMinmax;
    }
    _glGetnMinmax = _ptr;
    _glGetnMinmax(target, reset, format, type, bufSize, values);
}

PFN_GLGETNMINMAX _glGetnMinmax = &_get_glGetnMinmax;

static void APIENTRY _fail_glClipPlanef(GLenum plane, const GLfloat * equation) {
    const char *_name = "glClipPlanef";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClipPlanef(GLenum plane, const GLfloat * equation) {
    PFN_GLCLIPPLANEF _ptr;
    _ptr = (PFN_GLCLIPPLANEF)_getPrivateProcAddress("glClipPlanef");
    if (!_ptr) {
        _ptr = &_fail_glClipPlanef;
    }
    _glClipPlanef = _ptr;
    _glClipPlanef(plane, equation);
}

PFN_GLCLIPPLANEF _glClipPlanef = &_get_glClipPlanef;

static void APIENTRY _fail_glFrustumf(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar) {
    const char *_name = "glFrustumf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFrustumf(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar) {
    PFN_GLFRUSTUMF _ptr;
    _ptr = (PFN_GLFRUSTUMF)_getPrivateProcAddress("glFrustumf");
    if (!_ptr) {
        _ptr = &_fail_glFrustumf;
    }
    _glFrustumf = _ptr;
    _glFrustumf(left, right, bottom, top, zNear, zFar);
}

PFN_GLFRUSTUMF _glFrustumf = &_get_glFrustumf;

static void APIENTRY _fail_glGetClipPlanef(GLenum plane, GLfloat * equation) {
    const char *_name = "glGetClipPlanef";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetClipPlanef(GLenum plane, GLfloat * equation) {
    PFN_GLGETCLIPPLANEF _ptr;
    _ptr = (PFN_GLGETCLIPPLANEF)_getPrivateProcAddress("glGetClipPlanef");
    if (!_ptr) {
        _ptr = &_fail_glGetClipPlanef;
    }
    _glGetClipPlanef = _ptr;
    _glGetClipPlanef(plane, equation);
}

PFN_GLGETCLIPPLANEF _glGetClipPlanef = &_get_glGetClipPlanef;

static void APIENTRY _fail_glOrthof(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar) {
    const char *_name = "glOrthof";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glOrthof(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar) {
    PFN_GLORTHOF _ptr;
    _ptr = (PFN_GLORTHOF)_getPrivateProcAddress("glOrthof");
    if (!_ptr) {
        _ptr = &_fail_glOrthof;
    }
    _glOrthof = _ptr;
    _glOrthof(left, right, bottom, top, zNear, zFar);
}

PFN_GLORTHOF _glOrthof = &_get_glOrthof;

static void APIENTRY _fail_glAlphaFuncx(GLenum func, GLclampx ref) {
    const char *_name = "glAlphaFuncx";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glAlphaFuncx(GLenum func, GLclampx ref) {
    PFN_GLALPHAFUNCX _ptr;
    _ptr = (PFN_GLALPHAFUNCX)_getPrivateProcAddress("glAlphaFuncx");
    if (!_ptr) {
        _ptr = &_fail_glAlphaFuncx;
    }
    _glAlphaFuncx = _ptr;
    _glAlphaFuncx(func, ref);
}

PFN_GLALPHAFUNCX _glAlphaFuncx = &_get_glAlphaFuncx;

static void APIENTRY _fail_glClearColorx(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha) {
    const char *_name = "glClearColorx";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearColorx(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha) {
    PFN_GLCLEARCOLORX _ptr;
    _ptr = (PFN_GLCLEARCOLORX)_getPrivateProcAddress("glClearColorx");
    if (!_ptr) {
        _ptr = &_fail_glClearColorx;
    }
    _glClearColorx = _ptr;
    _glClearColorx(red, green, blue, alpha);
}

PFN_GLCLEARCOLORX _glClearColorx = &_get_glClearColorx;

static void APIENTRY _fail_glClearDepthx(GLclampx depth) {
    const char *_name = "glClearDepthx";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearDepthx(GLclampx depth) {
    PFN_GLCLEARDEPTHX _ptr;
    _ptr = (PFN_GLCLEARDEPTHX)_getPrivateProcAddress("glClearDepthx");
    if (!_ptr) {
        _ptr = &_fail_glClearDepthx;
    }
    _glClearDepthx = _ptr;
    _glClearDepthx(depth);
}

PFN_GLCLEARDEPTHX _glClearDepthx = &_get_glClearDepthx;

static void APIENTRY _fail_glClipPlanex(GLenum plane, const GLfixed * equation) {
    const char *_name = "glClipPlanex";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClipPlanex(GLenum plane, const GLfixed * equation) {
    PFN_GLCLIPPLANEX _ptr;
    _ptr = (PFN_GLCLIPPLANEX)_getPrivateProcAddress("glClipPlanex");
    if (!_ptr) {
        _ptr = &_fail_glClipPlanex;
    }
    _glClipPlanex = _ptr;
    _glClipPlanex(plane, equation);
}

PFN_GLCLIPPLANEX _glClipPlanex = &_get_glClipPlanex;

static void APIENTRY _fail_glColor4x(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) {
    const char *_name = "glColor4x";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4x(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) {
    PFN_GLCOLOR4X _ptr;
    _ptr = (PFN_GLCOLOR4X)_getPrivateProcAddress("glColor4x");
    if (!_ptr) {
        _ptr = &_fail_glColor4x;
    }
    _glColor4x = _ptr;
    _glColor4x(red, green, blue, alpha);
}

PFN_GLCOLOR4X _glColor4x = &_get_glColor4x;

static void APIENTRY _fail_glDepthRangex(GLclampx zNear, GLclampx zFar) {
    const char *_name = "glDepthRangex";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDepthRangex(GLclampx zNear, GLclampx zFar) {
    PFN_GLDEPTHRANGEX _ptr;
    _ptr = (PFN_GLDEPTHRANGEX)_getPrivateProcAddress("glDepthRangex");
    if (!_ptr) {
        _ptr = &_fail_glDepthRangex;
    }
    _glDepthRangex = _ptr;
    _glDepthRangex(zNear, zFar);
}

PFN_GLDEPTHRANGEX _glDepthRangex = &_get_glDepthRangex;

static void APIENTRY _fail_glFogx(GLenum pname, GLfixed param) {
    const char *_name = "glFogx";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogx(GLenum pname, GLfixed param) {
    PFN_GLFOGX _ptr;
    _ptr = (PFN_GLFOGX)_getPrivateProcAddress("glFogx");
    if (!_ptr) {
        _ptr = &_fail_glFogx;
    }
    _glFogx = _ptr;
    _glFogx(pname, param);
}

PFN_GLFOGX _glFogx = &_get_glFogx;

static void APIENTRY _fail_glFogxv(GLenum pname, const GLfixed * params) {
    const char *_name = "glFogxv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogxv(GLenum pname, const GLfixed * params) {
    PFN_GLFOGXV _ptr;
    _ptr = (PFN_GLFOGXV)_getPrivateProcAddress("glFogxv");
    if (!_ptr) {
        _ptr = &_fail_glFogxv;
    }
    _glFogxv = _ptr;
    _glFogxv(pname, params);
}

PFN_GLFOGXV _glFogxv = &_get_glFogxv;

static void APIENTRY _fail_glFrustumx(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar) {
    const char *_name = "glFrustumx";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFrustumx(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar) {
    PFN_GLFRUSTUMX _ptr;
    _ptr = (PFN_GLFRUSTUMX)_getPrivateProcAddress("glFrustumx");
    if (!_ptr) {
        _ptr = &_fail_glFrustumx;
    }
    _glFrustumx = _ptr;
    _glFrustumx(left, right, bottom, top, zNear, zFar);
}

PFN_GLFRUSTUMX _glFrustumx = &_get_glFrustumx;

static void APIENTRY _fail_glGetClipPlanex(GLenum plane, GLfixed * equation) {
    const char *_name = "glGetClipPlanex";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetClipPlanex(GLenum plane, GLfixed * equation) {
    PFN_GLGETCLIPPLANEX _ptr;
    _ptr = (PFN_GLGETCLIPPLANEX)_getPrivateProcAddress("glGetClipPlanex");
    if (!_ptr) {
        _ptr = &_fail_glGetClipPlanex;
    }
    _glGetClipPlanex = _ptr;
    _glGetClipPlanex(plane, equation);
}

PFN_GLGETCLIPPLANEX _glGetClipPlanex = &_get_glGetClipPlanex;

static void APIENTRY _fail_glGetFixedv(GLenum pname, GLfixed * params) {
    const char *_name = "glGetFixedv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFixedv(GLenum pname, GLfixed * params) {
    PFN_GLGETFIXEDV _ptr;
    _ptr = (PFN_GLGETFIXEDV)_getPrivateProcAddress("glGetFixedv");
    if (!_ptr) {
        _ptr = &_fail_glGetFixedv;
    }
    _glGetFixedv = _ptr;
    _glGetFixedv(pname, params);
}

PFN_GLGETFIXEDV _glGetFixedv = &_get_glGetFixedv;

static void APIENTRY _fail_glGetLightxv(GLenum light, GLenum pname, GLfixed * params) {
    const char *_name = "glGetLightxv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetLightxv(GLenum light, GLenum pname, GLfixed * params) {
    PFN_GLGETLIGHTXV _ptr;
    _ptr = (PFN_GLGETLIGHTXV)_getPrivateProcAddress("glGetLightxv");
    if (!_ptr) {
        _ptr = &_fail_glGetLightxv;
    }
    _glGetLightxv = _ptr;
    _glGetLightxv(light, pname, params);
}

PFN_GLGETLIGHTXV _glGetLightxv = &_get_glGetLightxv;

static void APIENTRY _fail_glGetMaterialxv(GLenum face, GLenum pname, GLfixed * params) {
    const char *_name = "glGetMaterialxv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMaterialxv(GLenum face, GLenum pname, GLfixed * params) {
    PFN_GLGETMATERIALXV _ptr;
    _ptr = (PFN_GLGETMATERIALXV)_getPrivateProcAddress("glGetMaterialxv");
    if (!_ptr) {
        _ptr = &_fail_glGetMaterialxv;
    }
    _glGetMaterialxv = _ptr;
    _glGetMaterialxv(face, pname, params);
}

PFN_GLGETMATERIALXV _glGetMaterialxv = &_get_glGetMaterialxv;

static void APIENTRY _fail_glGetTexEnvxv(GLenum target, GLenum pname, GLfixed * params) {
    const char *_name = "glGetTexEnvxv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexEnvxv(GLenum target, GLenum pname, GLfixed * params) {
    PFN_GLGETTEXENVXV _ptr;
    _ptr = (PFN_GLGETTEXENVXV)_getPrivateProcAddress("glGetTexEnvxv");
    if (!_ptr) {
        _ptr = &_fail_glGetTexEnvxv;
    }
    _glGetTexEnvxv = _ptr;
    _glGetTexEnvxv(target, pname, params);
}

PFN_GLGETTEXENVXV _glGetTexEnvxv = &_get_glGetTexEnvxv;

static void APIENTRY _fail_glGetTexParameterxv(GLenum target, GLenum pname, GLfixed * params) {
    const char *_name = "glGetTexParameterxv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexParameterxv(GLenum target, GLenum pname, GLfixed * params) {
    PFN_GLGETTEXPARAMETERXV _ptr;
    _ptr = (PFN_GLGETTEXPARAMETERXV)_getPrivateProcAddress("glGetTexParameterxv");
    if (!_ptr) {
        _ptr = &_fail_glGetTexParameterxv;
    }
    _glGetTexParameterxv = _ptr;
    _glGetTexParameterxv(target, pname, params);
}

PFN_GLGETTEXPARAMETERXV _glGetTexParameterxv = &_get_glGetTexParameterxv;

static void APIENTRY _fail_glLightModelx(GLenum pname, GLfixed param) {
    const char *_name = "glLightModelx";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLightModelx(GLenum pname, GLfixed param) {
    PFN_GLLIGHTMODELX _ptr;
    _ptr = (PFN_GLLIGHTMODELX)_getPrivateProcAddress("glLightModelx");
    if (!_ptr) {
        _ptr = &_fail_glLightModelx;
    }
    _glLightModelx = _ptr;
    _glLightModelx(pname, param);
}

PFN_GLLIGHTMODELX _glLightModelx = &_get_glLightModelx;

static void APIENTRY _fail_glLightModelxv(GLenum pname, const GLfixed * params) {
    const char *_name = "glLightModelxv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLightModelxv(GLenum pname, const GLfixed * params) {
    PFN_GLLIGHTMODELXV _ptr;
    _ptr = (PFN_GLLIGHTMODELXV)_getPrivateProcAddress("glLightModelxv");
    if (!_ptr) {
        _ptr = &_fail_glLightModelxv;
    }
    _glLightModelxv = _ptr;
    _glLightModelxv(pname, params);
}

PFN_GLLIGHTMODELXV _glLightModelxv = &_get_glLightModelxv;

static void APIENTRY _fail_glLightx(GLenum light, GLenum pname, GLfixed param) {
    const char *_name = "glLightx";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLightx(GLenum light, GLenum pname, GLfixed param) {
    PFN_GLLIGHTX _ptr;
    _ptr = (PFN_GLLIGHTX)_getPrivateProcAddress("glLightx");
    if (!_ptr) {
        _ptr = &_fail_glLightx;
    }
    _glLightx = _ptr;
    _glLightx(light, pname, param);
}

PFN_GLLIGHTX _glLightx = &_get_glLightx;

static void APIENTRY _fail_glLightxv(GLenum light, GLenum pname, const GLfixed * params) {
    const char *_name = "glLightxv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLightxv(GLenum light, GLenum pname, const GLfixed * params) {
    PFN_GLLIGHTXV _ptr;
    _ptr = (PFN_GLLIGHTXV)_getPrivateProcAddress("glLightxv");
    if (!_ptr) {
        _ptr = &_fail_glLightxv;
    }
    _glLightxv = _ptr;
    _glLightxv(light, pname, params);
}

PFN_GLLIGHTXV _glLightxv = &_get_glLightxv;

static void APIENTRY _fail_glLineWidthx(GLfixed width) {
    const char *_name = "glLineWidthx";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLineWidthx(GLfixed width) {
    PFN_GLLINEWIDTHX _ptr;
    _ptr = (PFN_GLLINEWIDTHX)_getPrivateProcAddress("glLineWidthx");
    if (!_ptr) {
        _ptr = &_fail_glLineWidthx;
    }
    _glLineWidthx = _ptr;
    _glLineWidthx(width);
}

PFN_GLLINEWIDTHX _glLineWidthx = &_get_glLineWidthx;

static void APIENTRY _fail_glLoadMatrixx(const GLfixed * m) {
    const char *_name = "glLoadMatrixx";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLoadMatrixx(const GLfixed * m) {
    PFN_GLLOADMATRIXX _ptr;
    _ptr = (PFN_GLLOADMATRIXX)_getPrivateProcAddress("glLoadMatrixx");
    if (!_ptr) {
        _ptr = &_fail_glLoadMatrixx;
    }
    _glLoadMatrixx = _ptr;
    _glLoadMatrixx(m);
}

PFN_GLLOADMATRIXX _glLoadMatrixx = &_get_glLoadMatrixx;

static void APIENTRY _fail_glMaterialx(GLenum face, GLenum pname, GLfixed param) {
    const char *_name = "glMaterialx";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMaterialx(GLenum face, GLenum pname, GLfixed param) {
    PFN_GLMATERIALX _ptr;
    _ptr = (PFN_GLMATERIALX)_getPrivateProcAddress("glMaterialx");
    if (!_ptr) {
        _ptr = &_fail_glMaterialx;
    }
    _glMaterialx = _ptr;
    _glMaterialx(face, pname, param);
}

PFN_GLMATERIALX _glMaterialx = &_get_glMaterialx;

static void APIENTRY _fail_glMaterialxv(GLenum face, GLenum pname, const GLfixed * params) {
    const char *_name = "glMaterialxv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMaterialxv(GLenum face, GLenum pname, const GLfixed * params) {
    PFN_GLMATERIALXV _ptr;
    _ptr = (PFN_GLMATERIALXV)_getPrivateProcAddress("glMaterialxv");
    if (!_ptr) {
        _ptr = &_fail_glMaterialxv;
    }
    _glMaterialxv = _ptr;
    _glMaterialxv(face, pname, params);
}

PFN_GLMATERIALXV _glMaterialxv = &_get_glMaterialxv;

static void APIENTRY _fail_glMultMatrixx(const GLfixed * m) {
    const char *_name = "glMultMatrixx";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultMatrixx(const GLfixed * m) {
    PFN_GLMULTMATRIXX _ptr;
    _ptr = (PFN_GLMULTMATRIXX)_getPrivateProcAddress("glMultMatrixx");
    if (!_ptr) {
        _ptr = &_fail_glMultMatrixx;
    }
    _glMultMatrixx = _ptr;
    _glMultMatrixx(m);
}

PFN_GLMULTMATRIXX _glMultMatrixx = &_get_glMultMatrixx;

static void APIENTRY _fail_glMultiTexCoord4x(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q) {
    const char *_name = "glMultiTexCoord4x";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4x(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q) {
    PFN_GLMULTITEXCOORD4X _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4X)_getPrivateProcAddress("glMultiTexCoord4x");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4x;
    }
    _glMultiTexCoord4x = _ptr;
    _glMultiTexCoord4x(target, s, t, r, q);
}

PFN_GLMULTITEXCOORD4X _glMultiTexCoord4x = &_get_glMultiTexCoord4x;

static void APIENTRY _fail_glNormal3x(GLfixed nx, GLfixed ny, GLfixed nz) {
    const char *_name = "glNormal3x";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormal3x(GLfixed nx, GLfixed ny, GLfixed nz) {
    PFN_GLNORMAL3X _ptr;
    _ptr = (PFN_GLNORMAL3X)_getPrivateProcAddress("glNormal3x");
    if (!_ptr) {
        _ptr = &_fail_glNormal3x;
    }
    _glNormal3x = _ptr;
    _glNormal3x(nx, ny, nz);
}

PFN_GLNORMAL3X _glNormal3x = &_get_glNormal3x;

static void APIENTRY _fail_glOrthox(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar) {
    const char *_name = "glOrthox";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glOrthox(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar) {
    PFN_GLORTHOX _ptr;
    _ptr = (PFN_GLORTHOX)_getPrivateProcAddress("glOrthox");
    if (!_ptr) {
        _ptr = &_fail_glOrthox;
    }
    _glOrthox = _ptr;
    _glOrthox(left, right, bottom, top, zNear, zFar);
}

PFN_GLORTHOX _glOrthox = &_get_glOrthox;

static void APIENTRY _fail_glPointParameterx(GLenum pname, GLfixed param) {
    const char *_name = "glPointParameterx";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPointParameterx(GLenum pname, GLfixed param) {
    PFN_GLPOINTPARAMETERX _ptr;
    _ptr = (PFN_GLPOINTPARAMETERX)_getPrivateProcAddress("glPointParameterx");
    if (!_ptr) {
        _ptr = &_fail_glPointParameterx;
    }
    _glPointParameterx = _ptr;
    _glPointParameterx(pname, param);
}

PFN_GLPOINTPARAMETERX _glPointParameterx = &_get_glPointParameterx;

static void APIENTRY _fail_glPointParameterxv(GLenum pname, const GLfixed * params) {
    const char *_name = "glPointParameterxv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPointParameterxv(GLenum pname, const GLfixed * params) {
    PFN_GLPOINTPARAMETERXV _ptr;
    _ptr = (PFN_GLPOINTPARAMETERXV)_getPrivateProcAddress("glPointParameterxv");
    if (!_ptr) {
        _ptr = &_fail_glPointParameterxv;
    }
    _glPointParameterxv = _ptr;
    _glPointParameterxv(pname, params);
}

PFN_GLPOINTPARAMETERXV _glPointParameterxv = &_get_glPointParameterxv;

static void APIENTRY _fail_glPointSizex(GLfixed size) {
    const char *_name = "glPointSizex";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPointSizex(GLfixed size) {
    PFN_GLPOINTSIZEX _ptr;
    _ptr = (PFN_GLPOINTSIZEX)_getPrivateProcAddress("glPointSizex");
    if (!_ptr) {
        _ptr = &_fail_glPointSizex;
    }
    _glPointSizex = _ptr;
    _glPointSizex(size);
}

PFN_GLPOINTSIZEX _glPointSizex = &_get_glPointSizex;

static void APIENTRY _fail_glPolygonOffsetx(GLfixed factor, GLfixed units) {
    const char *_name = "glPolygonOffsetx";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPolygonOffsetx(GLfixed factor, GLfixed units) {
    PFN_GLPOLYGONOFFSETX _ptr;
    _ptr = (PFN_GLPOLYGONOFFSETX)_getPrivateProcAddress("glPolygonOffsetx");
    if (!_ptr) {
        _ptr = &_fail_glPolygonOffsetx;
    }
    _glPolygonOffsetx = _ptr;
    _glPolygonOffsetx(factor, units);
}

PFN_GLPOLYGONOFFSETX _glPolygonOffsetx = &_get_glPolygonOffsetx;

static void APIENTRY _fail_glRotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z) {
    const char *_name = "glRotatex";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z) {
    PFN_GLROTATEX _ptr;
    _ptr = (PFN_GLROTATEX)_getPrivateProcAddress("glRotatex");
    if (!_ptr) {
        _ptr = &_fail_glRotatex;
    }
    _glRotatex = _ptr;
    _glRotatex(angle, x, y, z);
}

PFN_GLROTATEX _glRotatex = &_get_glRotatex;

static void APIENTRY _fail_glSampleCoveragex(GLclampx value, GLboolean invert) {
    const char *_name = "glSampleCoveragex";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSampleCoveragex(GLclampx value, GLboolean invert) {
    PFN_GLSAMPLECOVERAGEX _ptr;
    _ptr = (PFN_GLSAMPLECOVERAGEX)_getPrivateProcAddress("glSampleCoveragex");
    if (!_ptr) {
        _ptr = &_fail_glSampleCoveragex;
    }
    _glSampleCoveragex = _ptr;
    _glSampleCoveragex(value, invert);
}

PFN_GLSAMPLECOVERAGEX _glSampleCoveragex = &_get_glSampleCoveragex;

static void APIENTRY _fail_glScalex(GLfixed x, GLfixed y, GLfixed z) {
    const char *_name = "glScalex";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glScalex(GLfixed x, GLfixed y, GLfixed z) {
    PFN_GLSCALEX _ptr;
    _ptr = (PFN_GLSCALEX)_getPrivateProcAddress("glScalex");
    if (!_ptr) {
        _ptr = &_fail_glScalex;
    }
    _glScalex = _ptr;
    _glScalex(x, y, z);
}

PFN_GLSCALEX _glScalex = &_get_glScalex;

static void APIENTRY _fail_glTexEnvx(GLenum target, GLenum pname, GLfixed param) {
    const char *_name = "glTexEnvx";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexEnvx(GLenum target, GLenum pname, GLfixed param) {
    PFN_GLTEXENVX _ptr;
    _ptr = (PFN_GLTEXENVX)_getPrivateProcAddress("glTexEnvx");
    if (!_ptr) {
        _ptr = &_fail_glTexEnvx;
    }
    _glTexEnvx = _ptr;
    _glTexEnvx(target, pname, param);
}

PFN_GLTEXENVX _glTexEnvx = &_get_glTexEnvx;

static void APIENTRY _fail_glTexEnvxv(GLenum target, GLenum pname, const GLfixed * params) {
    const char *_name = "glTexEnvxv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexEnvxv(GLenum target, GLenum pname, const GLfixed * params) {
    PFN_GLTEXENVXV _ptr;
    _ptr = (PFN_GLTEXENVXV)_getPrivateProcAddress("glTexEnvxv");
    if (!_ptr) {
        _ptr = &_fail_glTexEnvxv;
    }
    _glTexEnvxv = _ptr;
    _glTexEnvxv(target, pname, params);
}

PFN_GLTEXENVXV _glTexEnvxv = &_get_glTexEnvxv;

static void APIENTRY _fail_glTexParameterx(GLenum target, GLenum pname, GLfixed param) {
    const char *_name = "glTexParameterx";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexParameterx(GLenum target, GLenum pname, GLfixed param) {
    PFN_GLTEXPARAMETERX _ptr;
    _ptr = (PFN_GLTEXPARAMETERX)_getPrivateProcAddress("glTexParameterx");
    if (!_ptr) {
        _ptr = &_fail_glTexParameterx;
    }
    _glTexParameterx = _ptr;
    _glTexParameterx(target, pname, param);
}

PFN_GLTEXPARAMETERX _glTexParameterx = &_get_glTexParameterx;

static void APIENTRY _fail_glTexParameterxv(GLenum target, GLenum pname, const GLfixed * params) {
    const char *_name = "glTexParameterxv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexParameterxv(GLenum target, GLenum pname, const GLfixed * params) {
    PFN_GLTEXPARAMETERXV _ptr;
    _ptr = (PFN_GLTEXPARAMETERXV)_getPrivateProcAddress("glTexParameterxv");
    if (!_ptr) {
        _ptr = &_fail_glTexParameterxv;
    }
    _glTexParameterxv = _ptr;
    _glTexParameterxv(target, pname, params);
}

PFN_GLTEXPARAMETERXV _glTexParameterxv = &_get_glTexParameterxv;

static void APIENTRY _fail_glTranslatex(GLfixed x, GLfixed y, GLfixed z) {
    const char *_name = "glTranslatex";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTranslatex(GLfixed x, GLfixed y, GLfixed z) {
    PFN_GLTRANSLATEX _ptr;
    _ptr = (PFN_GLTRANSLATEX)_getPrivateProcAddress("glTranslatex");
    if (!_ptr) {
        _ptr = &_fail_glTranslatex;
    }
    _glTranslatex = _ptr;
    _glTranslatex(x, y, z);
}

PFN_GLTRANSLATEX _glTranslatex = &_get_glTranslatex;

static void APIENTRY _fail_glTbufferMask3DFX(GLuint mask) {
    const char *_name = "glTbufferMask3DFX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTbufferMask3DFX(GLuint mask) {
    PFN_GLTBUFFERMASK3DFX _ptr;
    _ptr = (PFN_GLTBUFFERMASK3DFX)_getPrivateProcAddress("glTbufferMask3DFX");
    if (!_ptr) {
        _ptr = &_fail_glTbufferMask3DFX;
    }
    _glTbufferMask3DFX = _ptr;
    _glTbufferMask3DFX(mask);
}

PFN_GLTBUFFERMASK3DFX _glTbufferMask3DFX = &_get_glTbufferMask3DFX;

static void APIENTRY _fail_glDebugMessageEnableAMD(GLenum category, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled) {
}

static void APIENTRY _get_glDebugMessageEnableAMD(GLenum category, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled) {
    PFN_GLDEBUGMESSAGEENABLEAMD _ptr;
    _ptr = (PFN_GLDEBUGMESSAGEENABLEAMD)_getPrivateProcAddress("glDebugMessageEnableAMD");
    if (!_ptr) {
        _ptr = &_fail_glDebugMessageEnableAMD;
    }
    _glDebugMessageEnableAMD = _ptr;
    _glDebugMessageEnableAMD(category, severity, count, ids, enabled);
}

PFN_GLDEBUGMESSAGEENABLEAMD _glDebugMessageEnableAMD = &_get_glDebugMessageEnableAMD;

static void APIENTRY _fail_glDebugMessageInsertAMD(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar * buf) {
}

static void APIENTRY _get_glDebugMessageInsertAMD(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar * buf) {
    PFN_GLDEBUGMESSAGEINSERTAMD _ptr;
    _ptr = (PFN_GLDEBUGMESSAGEINSERTAMD)_getPrivateProcAddress("glDebugMessageInsertAMD");
    if (!_ptr) {
        _ptr = &_fail_glDebugMessageInsertAMD;
    }
    _glDebugMessageInsertAMD = _ptr;
    _glDebugMessageInsertAMD(category, severity, id, length, buf);
}

PFN_GLDEBUGMESSAGEINSERTAMD _glDebugMessageInsertAMD = &_get_glDebugMessageInsertAMD;

static void APIENTRY _fail_glDebugMessageCallbackAMD(GLDEBUGPROCAMD callback, GLvoid * userParam) {
}

static void APIENTRY _get_glDebugMessageCallbackAMD(GLDEBUGPROCAMD callback, GLvoid * userParam) {
    PFN_GLDEBUGMESSAGECALLBACKAMD _ptr;
    _ptr = (PFN_GLDEBUGMESSAGECALLBACKAMD)_getPrivateProcAddress("glDebugMessageCallbackAMD");
    if (!_ptr) {
        _ptr = &_fail_glDebugMessageCallbackAMD;
    }
    _glDebugMessageCallbackAMD = _ptr;
    _glDebugMessageCallbackAMD(callback, userParam);
}

PFN_GLDEBUGMESSAGECALLBACKAMD _glDebugMessageCallbackAMD = &_get_glDebugMessageCallbackAMD;

static GLuint APIENTRY _fail_glGetDebugMessageLogAMD(GLuint count, GLsizei bufsize, GLenum * categories, GLuint * severities, GLuint * ids, GLsizei * lengths, GLchar * message) {
    if (categories != 0) *categories = 0;
    if (ids != 0) *ids = 0;
    if (severities != 0) *severities = 0;
    if (lengths != 0) *lengths = 0;
    if (message != 0 && bufsize > 0) *message = 0;
    return 0;
}

static GLuint APIENTRY _get_glGetDebugMessageLogAMD(GLuint count, GLsizei bufsize, GLenum * categories, GLuint * severities, GLuint * ids, GLsizei * lengths, GLchar * message) {
    PFN_GLGETDEBUGMESSAGELOGAMD _ptr;
    _ptr = (PFN_GLGETDEBUGMESSAGELOGAMD)_getPrivateProcAddress("glGetDebugMessageLogAMD");
    if (!_ptr) {
        _ptr = &_fail_glGetDebugMessageLogAMD;
    }
    _glGetDebugMessageLogAMD = _ptr;
    return _glGetDebugMessageLogAMD(count, bufsize, categories, severities, ids, lengths, message);
}

PFN_GLGETDEBUGMESSAGELOGAMD _glGetDebugMessageLogAMD = &_get_glGetDebugMessageLogAMD;

static void APIENTRY _fail_glBlendFuncIndexedAMD(GLuint buf, GLenum src, GLenum dst) {
    const char *_name = "glBlendFuncIndexedAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendFuncIndexedAMD(GLuint buf, GLenum src, GLenum dst) {
    PFN_GLBLENDFUNCINDEXEDAMD _ptr;
    _ptr = (PFN_GLBLENDFUNCINDEXEDAMD)_getPrivateProcAddress("glBlendFuncIndexedAMD");
    if (!_ptr) {
        _ptr = &_fail_glBlendFuncIndexedAMD;
    }
    _glBlendFuncIndexedAMD = _ptr;
    _glBlendFuncIndexedAMD(buf, src, dst);
}

PFN_GLBLENDFUNCINDEXEDAMD _glBlendFuncIndexedAMD = &_get_glBlendFuncIndexedAMD;

static void APIENTRY _fail_glBlendFuncSeparateIndexedAMD(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) {
    const char *_name = "glBlendFuncSeparateIndexedAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendFuncSeparateIndexedAMD(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) {
    PFN_GLBLENDFUNCSEPARATEINDEXEDAMD _ptr;
    _ptr = (PFN_GLBLENDFUNCSEPARATEINDEXEDAMD)_getPrivateProcAddress("glBlendFuncSeparateIndexedAMD");
    if (!_ptr) {
        _ptr = &_fail_glBlendFuncSeparateIndexedAMD;
    }
    _glBlendFuncSeparateIndexedAMD = _ptr;
    _glBlendFuncSeparateIndexedAMD(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

PFN_GLBLENDFUNCSEPARATEINDEXEDAMD _glBlendFuncSeparateIndexedAMD = &_get_glBlendFuncSeparateIndexedAMD;

static void APIENTRY _fail_glBlendEquationIndexedAMD(GLuint buf, GLenum mode) {
    const char *_name = "glBlendEquationIndexedAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendEquationIndexedAMD(GLuint buf, GLenum mode) {
    PFN_GLBLENDEQUATIONINDEXEDAMD _ptr;
    _ptr = (PFN_GLBLENDEQUATIONINDEXEDAMD)_getPrivateProcAddress("glBlendEquationIndexedAMD");
    if (!_ptr) {
        _ptr = &_fail_glBlendEquationIndexedAMD;
    }
    _glBlendEquationIndexedAMD = _ptr;
    _glBlendEquationIndexedAMD(buf, mode);
}

PFN_GLBLENDEQUATIONINDEXEDAMD _glBlendEquationIndexedAMD = &_get_glBlendEquationIndexedAMD;

static void APIENTRY _fail_glBlendEquationSeparateIndexedAMD(GLuint buf, GLenum modeRGB, GLenum modeAlpha) {
    const char *_name = "glBlendEquationSeparateIndexedAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendEquationSeparateIndexedAMD(GLuint buf, GLenum modeRGB, GLenum modeAlpha) {
    PFN_GLBLENDEQUATIONSEPARATEINDEXEDAMD _ptr;
    _ptr = (PFN_GLBLENDEQUATIONSEPARATEINDEXEDAMD)_getPrivateProcAddress("glBlendEquationSeparateIndexedAMD");
    if (!_ptr) {
        _ptr = &_fail_glBlendEquationSeparateIndexedAMD;
    }
    _glBlendEquationSeparateIndexedAMD = _ptr;
    _glBlendEquationSeparateIndexedAMD(buf, modeRGB, modeAlpha);
}

PFN_GLBLENDEQUATIONSEPARATEINDEXEDAMD _glBlendEquationSeparateIndexedAMD = &_get_glBlendEquationSeparateIndexedAMD;

static void APIENTRY _fail_glVertexAttribParameteriAMD(GLuint index, GLenum pname, GLint param) {
    const char *_name = "glVertexAttribParameteriAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribParameteriAMD(GLuint index, GLenum pname, GLint param) {
    PFN_GLVERTEXATTRIBPARAMETERIAMD _ptr;
    _ptr = (PFN_GLVERTEXATTRIBPARAMETERIAMD)_getPrivateProcAddress("glVertexAttribParameteriAMD");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribParameteriAMD;
    }
    _glVertexAttribParameteriAMD = _ptr;
    _glVertexAttribParameteriAMD(index, pname, param);
}

PFN_GLVERTEXATTRIBPARAMETERIAMD _glVertexAttribParameteriAMD = &_get_glVertexAttribParameteriAMD;

static void APIENTRY _fail_glMultiDrawArraysIndirectAMD(GLenum mode, const GLvoid * indirect, GLsizei primcount, GLsizei stride) {
    const char *_name = "glMultiDrawArraysIndirectAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiDrawArraysIndirectAMD(GLenum mode, const GLvoid * indirect, GLsizei primcount, GLsizei stride) {
    PFN_GLMULTIDRAWARRAYSINDIRECTAMD _ptr;
    _ptr = (PFN_GLMULTIDRAWARRAYSINDIRECTAMD)_getPrivateProcAddress("glMultiDrawArraysIndirectAMD");
    if (!_ptr) {
        _ptr = &_fail_glMultiDrawArraysIndirectAMD;
    }
    _glMultiDrawArraysIndirectAMD = _ptr;
    _glMultiDrawArraysIndirectAMD(mode, indirect, primcount, stride);
}

PFN_GLMULTIDRAWARRAYSINDIRECTAMD _glMultiDrawArraysIndirectAMD = &_get_glMultiDrawArraysIndirectAMD;

static void APIENTRY _fail_glMultiDrawElementsIndirectAMD(GLenum mode, GLenum type, const GLvoid * indirect, GLsizei primcount, GLsizei stride) {
    const char *_name = "glMultiDrawElementsIndirectAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiDrawElementsIndirectAMD(GLenum mode, GLenum type, const GLvoid * indirect, GLsizei primcount, GLsizei stride) {
    PFN_GLMULTIDRAWELEMENTSINDIRECTAMD _ptr;
    _ptr = (PFN_GLMULTIDRAWELEMENTSINDIRECTAMD)_getPrivateProcAddress("glMultiDrawElementsIndirectAMD");
    if (!_ptr) {
        _ptr = &_fail_glMultiDrawElementsIndirectAMD;
    }
    _glMultiDrawElementsIndirectAMD = _ptr;
    _glMultiDrawElementsIndirectAMD(mode, type, indirect, primcount, stride);
}

PFN_GLMULTIDRAWELEMENTSINDIRECTAMD _glMultiDrawElementsIndirectAMD = &_get_glMultiDrawElementsIndirectAMD;

static void APIENTRY _fail_glGenNamesAMD(GLenum identifier, GLuint num, GLuint * names) {
    const char *_name = "glGenNamesAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenNamesAMD(GLenum identifier, GLuint num, GLuint * names) {
    PFN_GLGENNAMESAMD _ptr;
    _ptr = (PFN_GLGENNAMESAMD)_getPrivateProcAddress("glGenNamesAMD");
    if (!_ptr) {
        _ptr = &_fail_glGenNamesAMD;
    }
    _glGenNamesAMD = _ptr;
    _glGenNamesAMD(identifier, num, names);
}

PFN_GLGENNAMESAMD _glGenNamesAMD = &_get_glGenNamesAMD;

static void APIENTRY _fail_glDeleteNamesAMD(GLenum identifier, GLuint num, const GLuint * names) {
    const char *_name = "glDeleteNamesAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteNamesAMD(GLenum identifier, GLuint num, const GLuint * names) {
    PFN_GLDELETENAMESAMD _ptr;
    _ptr = (PFN_GLDELETENAMESAMD)_getPrivateProcAddress("glDeleteNamesAMD");
    if (!_ptr) {
        _ptr = &_fail_glDeleteNamesAMD;
    }
    _glDeleteNamesAMD = _ptr;
    _glDeleteNamesAMD(identifier, num, names);
}

PFN_GLDELETENAMESAMD _glDeleteNamesAMD = &_get_glDeleteNamesAMD;

static GLboolean APIENTRY _fail_glIsNameAMD(GLenum identifier, GLuint name) {
    const char *_name = "glIsNameAMD";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsNameAMD(GLenum identifier, GLuint name) {
    PFN_GLISNAMEAMD _ptr;
    _ptr = (PFN_GLISNAMEAMD)_getPrivateProcAddress("glIsNameAMD");
    if (!_ptr) {
        _ptr = &_fail_glIsNameAMD;
    }
    _glIsNameAMD = _ptr;
    return _glIsNameAMD(identifier, name);
}

PFN_GLISNAMEAMD _glIsNameAMD = &_get_glIsNameAMD;

static void APIENTRY _fail_glQueryObjectParameteruiAMD(GLenum target, GLuint id, GLenum pname, GLuint param) {
    const char *_name = "glQueryObjectParameteruiAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glQueryObjectParameteruiAMD(GLenum target, GLuint id, GLenum pname, GLuint param) {
    PFN_GLQUERYOBJECTPARAMETERUIAMD _ptr;
    _ptr = (PFN_GLQUERYOBJECTPARAMETERUIAMD)_getPrivateProcAddress("glQueryObjectParameteruiAMD");
    if (!_ptr) {
        _ptr = &_fail_glQueryObjectParameteruiAMD;
    }
    _glQueryObjectParameteruiAMD = _ptr;
    _glQueryObjectParameteruiAMD(target, id, pname, param);
}

PFN_GLQUERYOBJECTPARAMETERUIAMD _glQueryObjectParameteruiAMD = &_get_glQueryObjectParameteruiAMD;

static void APIENTRY _fail_glGetPerfMonitorGroupsAMD(GLint * numGroups, GLsizei groupsSize, GLuint * groups) {
    const char *_name = "glGetPerfMonitorGroupsAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPerfMonitorGroupsAMD(GLint * numGroups, GLsizei groupsSize, GLuint * groups) {
    PFN_GLGETPERFMONITORGROUPSAMD _ptr;
    _ptr = (PFN_GLGETPERFMONITORGROUPSAMD)_getPrivateProcAddress("glGetPerfMonitorGroupsAMD");
    if (!_ptr) {
        _ptr = &_fail_glGetPerfMonitorGroupsAMD;
    }
    _glGetPerfMonitorGroupsAMD = _ptr;
    _glGetPerfMonitorGroupsAMD(numGroups, groupsSize, groups);
}

PFN_GLGETPERFMONITORGROUPSAMD _glGetPerfMonitorGroupsAMD = &_get_glGetPerfMonitorGroupsAMD;

static void APIENTRY _fail_glGetPerfMonitorCountersAMD(GLuint group, GLint * numCounters, GLint * maxActiveCounters, GLsizei counterSize, GLuint * counters) {
    const char *_name = "glGetPerfMonitorCountersAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPerfMonitorCountersAMD(GLuint group, GLint * numCounters, GLint * maxActiveCounters, GLsizei counterSize, GLuint * counters) {
    PFN_GLGETPERFMONITORCOUNTERSAMD _ptr;
    _ptr = (PFN_GLGETPERFMONITORCOUNTERSAMD)_getPrivateProcAddress("glGetPerfMonitorCountersAMD");
    if (!_ptr) {
        _ptr = &_fail_glGetPerfMonitorCountersAMD;
    }
    _glGetPerfMonitorCountersAMD = _ptr;
    _glGetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, counterSize, counters);
}

PFN_GLGETPERFMONITORCOUNTERSAMD _glGetPerfMonitorCountersAMD = &_get_glGetPerfMonitorCountersAMD;

static void APIENTRY _fail_glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei * length, GLchar * groupString) {
    const char *_name = "glGetPerfMonitorGroupStringAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei * length, GLchar * groupString) {
    PFN_GLGETPERFMONITORGROUPSTRINGAMD _ptr;
    _ptr = (PFN_GLGETPERFMONITORGROUPSTRINGAMD)_getPrivateProcAddress("glGetPerfMonitorGroupStringAMD");
    if (!_ptr) {
        _ptr = &_fail_glGetPerfMonitorGroupStringAMD;
    }
    _glGetPerfMonitorGroupStringAMD = _ptr;
    _glGetPerfMonitorGroupStringAMD(group, bufSize, length, groupString);
}

PFN_GLGETPERFMONITORGROUPSTRINGAMD _glGetPerfMonitorGroupStringAMD = &_get_glGetPerfMonitorGroupStringAMD;

static void APIENTRY _fail_glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei * length, GLchar * counterString) {
    const char *_name = "glGetPerfMonitorCounterStringAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei * length, GLchar * counterString) {
    PFN_GLGETPERFMONITORCOUNTERSTRINGAMD _ptr;
    _ptr = (PFN_GLGETPERFMONITORCOUNTERSTRINGAMD)_getPrivateProcAddress("glGetPerfMonitorCounterStringAMD");
    if (!_ptr) {
        _ptr = &_fail_glGetPerfMonitorCounterStringAMD;
    }
    _glGetPerfMonitorCounterStringAMD = _ptr;
    _glGetPerfMonitorCounterStringAMD(group, counter, bufSize, length, counterString);
}

PFN_GLGETPERFMONITORCOUNTERSTRINGAMD _glGetPerfMonitorCounterStringAMD = &_get_glGetPerfMonitorCounterStringAMD;

static void APIENTRY _fail_glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, GLvoid * data) {
    const char *_name = "glGetPerfMonitorCounterInfoAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, GLvoid * data) {
    PFN_GLGETPERFMONITORCOUNTERINFOAMD _ptr;
    _ptr = (PFN_GLGETPERFMONITORCOUNTERINFOAMD)_getPrivateProcAddress("glGetPerfMonitorCounterInfoAMD");
    if (!_ptr) {
        _ptr = &_fail_glGetPerfMonitorCounterInfoAMD;
    }
    _glGetPerfMonitorCounterInfoAMD = _ptr;
    _glGetPerfMonitorCounterInfoAMD(group, counter, pname, data);
}

PFN_GLGETPERFMONITORCOUNTERINFOAMD _glGetPerfMonitorCounterInfoAMD = &_get_glGetPerfMonitorCounterInfoAMD;

static void APIENTRY _fail_glGenPerfMonitorsAMD(GLsizei n, GLuint * monitors) {
    const char *_name = "glGenPerfMonitorsAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenPerfMonitorsAMD(GLsizei n, GLuint * monitors) {
    PFN_GLGENPERFMONITORSAMD _ptr;
    _ptr = (PFN_GLGENPERFMONITORSAMD)_getPrivateProcAddress("glGenPerfMonitorsAMD");
    if (!_ptr) {
        _ptr = &_fail_glGenPerfMonitorsAMD;
    }
    _glGenPerfMonitorsAMD = _ptr;
    _glGenPerfMonitorsAMD(n, monitors);
}

PFN_GLGENPERFMONITORSAMD _glGenPerfMonitorsAMD = &_get_glGenPerfMonitorsAMD;

static void APIENTRY _fail_glDeletePerfMonitorsAMD(GLsizei n, GLuint * monitors) {
    const char *_name = "glDeletePerfMonitorsAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeletePerfMonitorsAMD(GLsizei n, GLuint * monitors) {
    PFN_GLDELETEPERFMONITORSAMD _ptr;
    _ptr = (PFN_GLDELETEPERFMONITORSAMD)_getPrivateProcAddress("glDeletePerfMonitorsAMD");
    if (!_ptr) {
        _ptr = &_fail_glDeletePerfMonitorsAMD;
    }
    _glDeletePerfMonitorsAMD = _ptr;
    _glDeletePerfMonitorsAMD(n, monitors);
}

PFN_GLDELETEPERFMONITORSAMD _glDeletePerfMonitorsAMD = &_get_glDeletePerfMonitorsAMD;

static void APIENTRY _fail_glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint * counterList) {
    const char *_name = "glSelectPerfMonitorCountersAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint * counterList) {
    PFN_GLSELECTPERFMONITORCOUNTERSAMD _ptr;
    _ptr = (PFN_GLSELECTPERFMONITORCOUNTERSAMD)_getPrivateProcAddress("glSelectPerfMonitorCountersAMD");
    if (!_ptr) {
        _ptr = &_fail_glSelectPerfMonitorCountersAMD;
    }
    _glSelectPerfMonitorCountersAMD = _ptr;
    _glSelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList);
}

PFN_GLSELECTPERFMONITORCOUNTERSAMD _glSelectPerfMonitorCountersAMD = &_get_glSelectPerfMonitorCountersAMD;

static void APIENTRY _fail_glBeginPerfMonitorAMD(GLuint monitor) {
    const char *_name = "glBeginPerfMonitorAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBeginPerfMonitorAMD(GLuint monitor) {
    PFN_GLBEGINPERFMONITORAMD _ptr;
    _ptr = (PFN_GLBEGINPERFMONITORAMD)_getPrivateProcAddress("glBeginPerfMonitorAMD");
    if (!_ptr) {
        _ptr = &_fail_glBeginPerfMonitorAMD;
    }
    _glBeginPerfMonitorAMD = _ptr;
    _glBeginPerfMonitorAMD(monitor);
}

PFN_GLBEGINPERFMONITORAMD _glBeginPerfMonitorAMD = &_get_glBeginPerfMonitorAMD;

static void APIENTRY _fail_glEndPerfMonitorAMD(GLuint monitor) {
    const char *_name = "glEndPerfMonitorAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEndPerfMonitorAMD(GLuint monitor) {
    PFN_GLENDPERFMONITORAMD _ptr;
    _ptr = (PFN_GLENDPERFMONITORAMD)_getPrivateProcAddress("glEndPerfMonitorAMD");
    if (!_ptr) {
        _ptr = &_fail_glEndPerfMonitorAMD;
    }
    _glEndPerfMonitorAMD = _ptr;
    _glEndPerfMonitorAMD(monitor);
}

PFN_GLENDPERFMONITORAMD _glEndPerfMonitorAMD = &_get_glEndPerfMonitorAMD;

static void APIENTRY _fail_glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint * data, GLint * bytesWritten) {
    const char *_name = "glGetPerfMonitorCounterDataAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint * data, GLint * bytesWritten) {
    PFN_GLGETPERFMONITORCOUNTERDATAAMD _ptr;
    _ptr = (PFN_GLGETPERFMONITORCOUNTERDATAAMD)_getPrivateProcAddress("glGetPerfMonitorCounterDataAMD");
    if (!_ptr) {
        _ptr = &_fail_glGetPerfMonitorCounterDataAMD;
    }
    _glGetPerfMonitorCounterDataAMD = _ptr;
    _glGetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, bytesWritten);
}

PFN_GLGETPERFMONITORCOUNTERDATAAMD _glGetPerfMonitorCounterDataAMD = &_get_glGetPerfMonitorCounterDataAMD;

static void APIENTRY _fail_glSetMultisamplefvAMD(GLenum pname, GLuint index, const GLfloat * val) {
    const char *_name = "glSetMultisamplefvAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSetMultisamplefvAMD(GLenum pname, GLuint index, const GLfloat * val) {
    PFN_GLSETMULTISAMPLEFVAMD _ptr;
    _ptr = (PFN_GLSETMULTISAMPLEFVAMD)_getPrivateProcAddress("glSetMultisamplefvAMD");
    if (!_ptr) {
        _ptr = &_fail_glSetMultisamplefvAMD;
    }
    _glSetMultisamplefvAMD = _ptr;
    _glSetMultisamplefvAMD(pname, index, val);
}

PFN_GLSETMULTISAMPLEFVAMD _glSetMultisamplefvAMD = &_get_glSetMultisamplefvAMD;

static void APIENTRY _fail_glTexStorageSparseAMD(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags) {
    const char *_name = "glTexStorageSparseAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexStorageSparseAMD(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags) {
    PFN_GLTEXSTORAGESPARSEAMD _ptr;
    _ptr = (PFN_GLTEXSTORAGESPARSEAMD)_getPrivateProcAddress("glTexStorageSparseAMD");
    if (!_ptr) {
        _ptr = &_fail_glTexStorageSparseAMD;
    }
    _glTexStorageSparseAMD = _ptr;
    _glTexStorageSparseAMD(target, internalFormat, width, height, depth, layers, flags);
}

PFN_GLTEXSTORAGESPARSEAMD _glTexStorageSparseAMD = &_get_glTexStorageSparseAMD;

static void APIENTRY _fail_glTextureStorageSparseAMD(GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags) {
    const char *_name = "glTextureStorageSparseAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureStorageSparseAMD(GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags) {
    PFN_GLTEXTURESTORAGESPARSEAMD _ptr;
    _ptr = (PFN_GLTEXTURESTORAGESPARSEAMD)_getPrivateProcAddress("glTextureStorageSparseAMD");
    if (!_ptr) {
        _ptr = &_fail_glTextureStorageSparseAMD;
    }
    _glTextureStorageSparseAMD = _ptr;
    _glTextureStorageSparseAMD(texture, target, internalFormat, width, height, depth, layers, flags);
}

PFN_GLTEXTURESTORAGESPARSEAMD _glTextureStorageSparseAMD = &_get_glTextureStorageSparseAMD;

static void APIENTRY _fail_glStencilOpValueAMD(GLenum face, GLuint value) {
    const char *_name = "glStencilOpValueAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStencilOpValueAMD(GLenum face, GLuint value) {
    PFN_GLSTENCILOPVALUEAMD _ptr;
    _ptr = (PFN_GLSTENCILOPVALUEAMD)_getPrivateProcAddress("glStencilOpValueAMD");
    if (!_ptr) {
        _ptr = &_fail_glStencilOpValueAMD;
    }
    _glStencilOpValueAMD = _ptr;
    _glStencilOpValueAMD(face, value);
}

PFN_GLSTENCILOPVALUEAMD _glStencilOpValueAMD = &_get_glStencilOpValueAMD;

static void APIENTRY _fail_glTessellationFactorAMD(GLfloat factor) {
    const char *_name = "glTessellationFactorAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTessellationFactorAMD(GLfloat factor) {
    PFN_GLTESSELLATIONFACTORAMD _ptr;
    _ptr = (PFN_GLTESSELLATIONFACTORAMD)_getPrivateProcAddress("glTessellationFactorAMD");
    if (!_ptr) {
        _ptr = &_fail_glTessellationFactorAMD;
    }
    _glTessellationFactorAMD = _ptr;
    _glTessellationFactorAMD(factor);
}

PFN_GLTESSELLATIONFACTORAMD _glTessellationFactorAMD = &_get_glTessellationFactorAMD;

static void APIENTRY _fail_glTessellationModeAMD(GLenum mode) {
    const char *_name = "glTessellationModeAMD";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTessellationModeAMD(GLenum mode) {
    PFN_GLTESSELLATIONMODEAMD _ptr;
    _ptr = (PFN_GLTESSELLATIONMODEAMD)_getPrivateProcAddress("glTessellationModeAMD");
    if (!_ptr) {
        _ptr = &_fail_glTessellationModeAMD;
    }
    _glTessellationModeAMD = _ptr;
    _glTessellationModeAMD(mode);
}

PFN_GLTESSELLATIONMODEAMD _glTessellationModeAMD = &_get_glTessellationModeAMD;

static void APIENTRY _fail_glBlitFramebufferANGLE(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
    const char *_name = "glBlitFramebufferANGLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlitFramebufferANGLE(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
    PFN_GLBLITFRAMEBUFFERANGLE _ptr;
    _ptr = (PFN_GLBLITFRAMEBUFFERANGLE)_getPrivateProcAddress("glBlitFramebufferANGLE");
    if (!_ptr) {
        _ptr = &_fail_glBlitFramebufferANGLE;
    }
    _glBlitFramebufferANGLE = _ptr;
    _glBlitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

PFN_GLBLITFRAMEBUFFERANGLE _glBlitFramebufferANGLE = &_get_glBlitFramebufferANGLE;

static void APIENTRY _fail_glRenderbufferStorageMultisampleANGLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glRenderbufferStorageMultisampleANGLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRenderbufferStorageMultisampleANGLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEANGLE _ptr;
    _ptr = (PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEANGLE)_getPrivateProcAddress("glRenderbufferStorageMultisampleANGLE");
    if (!_ptr) {
        _ptr = &_fail_glRenderbufferStorageMultisampleANGLE;
    }
    _glRenderbufferStorageMultisampleANGLE = _ptr;
    _glRenderbufferStorageMultisampleANGLE(target, samples, internalformat, width, height);
}

PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEANGLE _glRenderbufferStorageMultisampleANGLE = &_get_glRenderbufferStorageMultisampleANGLE;

static void APIENTRY _fail_glDrawArraysInstancedANGLE(GLenum mode, GLint first, GLsizei count, GLsizei primcount) {
    const char *_name = "glDrawArraysInstancedANGLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawArraysInstancedANGLE(GLenum mode, GLint first, GLsizei count, GLsizei primcount) {
    PFN_GLDRAWARRAYSINSTANCEDANGLE _ptr;
    _ptr = (PFN_GLDRAWARRAYSINSTANCEDANGLE)_getPrivateProcAddress("glDrawArraysInstancedANGLE");
    if (!_ptr) {
        _ptr = &_fail_glDrawArraysInstancedANGLE;
    }
    _glDrawArraysInstancedANGLE = _ptr;
    _glDrawArraysInstancedANGLE(mode, first, count, primcount);
}

PFN_GLDRAWARRAYSINSTANCEDANGLE _glDrawArraysInstancedANGLE = &_get_glDrawArraysInstancedANGLE;

static void APIENTRY _fail_glDrawElementsInstancedANGLE(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount) {
    const char *_name = "glDrawElementsInstancedANGLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawElementsInstancedANGLE(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount) {
    PFN_GLDRAWELEMENTSINSTANCEDANGLE _ptr;
    _ptr = (PFN_GLDRAWELEMENTSINSTANCEDANGLE)_getPrivateProcAddress("glDrawElementsInstancedANGLE");
    if (!_ptr) {
        _ptr = &_fail_glDrawElementsInstancedANGLE;
    }
    _glDrawElementsInstancedANGLE = _ptr;
    _glDrawElementsInstancedANGLE(mode, count, type, indices, primcount);
}

PFN_GLDRAWELEMENTSINSTANCEDANGLE _glDrawElementsInstancedANGLE = &_get_glDrawElementsInstancedANGLE;

static void APIENTRY _fail_glVertexAttribDivisorANGLE(GLuint index, GLuint divisor) {
    const char *_name = "glVertexAttribDivisorANGLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribDivisorANGLE(GLuint index, GLuint divisor) {
    PFN_GLVERTEXATTRIBDIVISORANGLE _ptr;
    _ptr = (PFN_GLVERTEXATTRIBDIVISORANGLE)_getPrivateProcAddress("glVertexAttribDivisorANGLE");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribDivisorANGLE;
    }
    _glVertexAttribDivisorANGLE = _ptr;
    _glVertexAttribDivisorANGLE(index, divisor);
}

PFN_GLVERTEXATTRIBDIVISORANGLE _glVertexAttribDivisorANGLE = &_get_glVertexAttribDivisorANGLE;

static void APIENTRY _fail_glGenQueriesANGLE(GLsizei n, GLuint * ids) {
    const char *_name = "glGenQueriesANGLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenQueriesANGLE(GLsizei n, GLuint * ids) {
    PFN_GLGENQUERIESANGLE _ptr;
    _ptr = (PFN_GLGENQUERIESANGLE)_getPrivateProcAddress("glGenQueriesANGLE");
    if (!_ptr) {
        _ptr = &_fail_glGenQueriesANGLE;
    }
    _glGenQueriesANGLE = _ptr;
    _glGenQueriesANGLE(n, ids);
}

PFN_GLGENQUERIESANGLE _glGenQueriesANGLE = &_get_glGenQueriesANGLE;

static void APIENTRY _fail_glDeleteQueriesANGLE(GLsizei n, const GLuint * ids) {
    const char *_name = "glDeleteQueriesANGLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteQueriesANGLE(GLsizei n, const GLuint * ids) {
    PFN_GLDELETEQUERIESANGLE _ptr;
    _ptr = (PFN_GLDELETEQUERIESANGLE)_getPrivateProcAddress("glDeleteQueriesANGLE");
    if (!_ptr) {
        _ptr = &_fail_glDeleteQueriesANGLE;
    }
    _glDeleteQueriesANGLE = _ptr;
    _glDeleteQueriesANGLE(n, ids);
}

PFN_GLDELETEQUERIESANGLE _glDeleteQueriesANGLE = &_get_glDeleteQueriesANGLE;

static GLboolean APIENTRY _fail_glIsQueryANGLE(GLuint id) {
    const char *_name = "glIsQueryANGLE";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsQueryANGLE(GLuint id) {
    PFN_GLISQUERYANGLE _ptr;
    _ptr = (PFN_GLISQUERYANGLE)_getPrivateProcAddress("glIsQueryANGLE");
    if (!_ptr) {
        _ptr = &_fail_glIsQueryANGLE;
    }
    _glIsQueryANGLE = _ptr;
    return _glIsQueryANGLE(id);
}

PFN_GLISQUERYANGLE _glIsQueryANGLE = &_get_glIsQueryANGLE;

static void APIENTRY _fail_glBeginQueryANGLE(GLenum target, GLuint id) {
    const char *_name = "glBeginQueryANGLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBeginQueryANGLE(GLenum target, GLuint id) {
    PFN_GLBEGINQUERYANGLE _ptr;
    _ptr = (PFN_GLBEGINQUERYANGLE)_getPrivateProcAddress("glBeginQueryANGLE");
    if (!_ptr) {
        _ptr = &_fail_glBeginQueryANGLE;
    }
    _glBeginQueryANGLE = _ptr;
    _glBeginQueryANGLE(target, id);
}

PFN_GLBEGINQUERYANGLE _glBeginQueryANGLE = &_get_glBeginQueryANGLE;

static void APIENTRY _fail_glEndQueryANGLE(GLenum target) {
    const char *_name = "glEndQueryANGLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEndQueryANGLE(GLenum target) {
    PFN_GLENDQUERYANGLE _ptr;
    _ptr = (PFN_GLENDQUERYANGLE)_getPrivateProcAddress("glEndQueryANGLE");
    if (!_ptr) {
        _ptr = &_fail_glEndQueryANGLE;
    }
    _glEndQueryANGLE = _ptr;
    _glEndQueryANGLE(target);
}

PFN_GLENDQUERYANGLE _glEndQueryANGLE = &_get_glEndQueryANGLE;

static void APIENTRY _fail_glQueryCounterANGLE(GLuint id, GLenum target) {
    const char *_name = "glQueryCounterANGLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glQueryCounterANGLE(GLuint id, GLenum target) {
    PFN_GLQUERYCOUNTERANGLE _ptr;
    _ptr = (PFN_GLQUERYCOUNTERANGLE)_getPrivateProcAddress("glQueryCounterANGLE");
    if (!_ptr) {
        _ptr = &_fail_glQueryCounterANGLE;
    }
    _glQueryCounterANGLE = _ptr;
    _glQueryCounterANGLE(id, target);
}

PFN_GLQUERYCOUNTERANGLE _glQueryCounterANGLE = &_get_glQueryCounterANGLE;

static void APIENTRY _fail_glGetQueryivANGLE(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetQueryivANGLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryivANGLE(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETQUERYIVANGLE _ptr;
    _ptr = (PFN_GLGETQUERYIVANGLE)_getPrivateProcAddress("glGetQueryivANGLE");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryivANGLE;
    }
    _glGetQueryivANGLE = _ptr;
    _glGetQueryivANGLE(target, pname, params);
}

PFN_GLGETQUERYIVANGLE _glGetQueryivANGLE = &_get_glGetQueryivANGLE;

static void APIENTRY _fail_glGetQueryObjectivANGLE(GLuint id, GLenum pname, GLint * params) {
    const char *_name = "glGetQueryObjectivANGLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryObjectivANGLE(GLuint id, GLenum pname, GLint * params) {
    PFN_GLGETQUERYOBJECTIVANGLE _ptr;
    _ptr = (PFN_GLGETQUERYOBJECTIVANGLE)_getPrivateProcAddress("glGetQueryObjectivANGLE");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryObjectivANGLE;
    }
    _glGetQueryObjectivANGLE = _ptr;
    _glGetQueryObjectivANGLE(id, pname, params);
}

PFN_GLGETQUERYOBJECTIVANGLE _glGetQueryObjectivANGLE = &_get_glGetQueryObjectivANGLE;

static void APIENTRY _fail_glGetQueryObjectuivANGLE(GLuint id, GLenum pname, GLuint * params) {
    const char *_name = "glGetQueryObjectuivANGLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryObjectuivANGLE(GLuint id, GLenum pname, GLuint * params) {
    PFN_GLGETQUERYOBJECTUIVANGLE _ptr;
    _ptr = (PFN_GLGETQUERYOBJECTUIVANGLE)_getPrivateProcAddress("glGetQueryObjectuivANGLE");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryObjectuivANGLE;
    }
    _glGetQueryObjectuivANGLE = _ptr;
    _glGetQueryObjectuivANGLE(id, pname, params);
}

PFN_GLGETQUERYOBJECTUIVANGLE _glGetQueryObjectuivANGLE = &_get_glGetQueryObjectuivANGLE;

static void APIENTRY _fail_glGetQueryObjecti64vANGLE(GLuint id, GLenum pname, GLint64 * params) {
    const char *_name = "glGetQueryObjecti64vANGLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryObjecti64vANGLE(GLuint id, GLenum pname, GLint64 * params) {
    PFN_GLGETQUERYOBJECTI64VANGLE _ptr;
    _ptr = (PFN_GLGETQUERYOBJECTI64VANGLE)_getPrivateProcAddress("glGetQueryObjecti64vANGLE");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryObjecti64vANGLE;
    }
    _glGetQueryObjecti64vANGLE = _ptr;
    _glGetQueryObjecti64vANGLE(id, pname, params);
}

PFN_GLGETQUERYOBJECTI64VANGLE _glGetQueryObjecti64vANGLE = &_get_glGetQueryObjecti64vANGLE;

static void APIENTRY _fail_glGetQueryObjectui64vANGLE(GLuint id, GLenum pname, GLuint64 * params) {
    const char *_name = "glGetQueryObjectui64vANGLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryObjectui64vANGLE(GLuint id, GLenum pname, GLuint64 * params) {
    PFN_GLGETQUERYOBJECTUI64VANGLE _ptr;
    _ptr = (PFN_GLGETQUERYOBJECTUI64VANGLE)_getPrivateProcAddress("glGetQueryObjectui64vANGLE");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryObjectui64vANGLE;
    }
    _glGetQueryObjectui64vANGLE = _ptr;
    _glGetQueryObjectui64vANGLE(id, pname, params);
}

PFN_GLGETQUERYOBJECTUI64VANGLE _glGetQueryObjectui64vANGLE = &_get_glGetQueryObjectui64vANGLE;

static void APIENTRY _fail_glGetTranslatedShaderSourceANGLE(GLuint shader, GLsizei bufsize, GLsizei * length, GLchar * source) {
    const char *_name = "glGetTranslatedShaderSourceANGLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTranslatedShaderSourceANGLE(GLuint shader, GLsizei bufsize, GLsizei * length, GLchar * source) {
    PFN_GLGETTRANSLATEDSHADERSOURCEANGLE _ptr;
    _ptr = (PFN_GLGETTRANSLATEDSHADERSOURCEANGLE)_getPrivateProcAddress("glGetTranslatedShaderSourceANGLE");
    if (!_ptr) {
        _ptr = &_fail_glGetTranslatedShaderSourceANGLE;
    }
    _glGetTranslatedShaderSourceANGLE = _ptr;
    _glGetTranslatedShaderSourceANGLE(shader, bufsize, length, source);
}

PFN_GLGETTRANSLATEDSHADERSOURCEANGLE _glGetTranslatedShaderSourceANGLE = &_get_glGetTranslatedShaderSourceANGLE;

static void APIENTRY _fail_glCopyTextureLevelsAPPLE(GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount) {
    const char *_name = "glCopyTextureLevelsAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTextureLevelsAPPLE(GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount) {
    PFN_GLCOPYTEXTURELEVELSAPPLE _ptr;
    _ptr = (PFN_GLCOPYTEXTURELEVELSAPPLE)_getPrivateProcAddress("glCopyTextureLevelsAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glCopyTextureLevelsAPPLE;
    }
    _glCopyTextureLevelsAPPLE = _ptr;
    _glCopyTextureLevelsAPPLE(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount);
}

PFN_GLCOPYTEXTURELEVELSAPPLE _glCopyTextureLevelsAPPLE = &_get_glCopyTextureLevelsAPPLE;

static void APIENTRY _fail_glElementPointerAPPLE(GLenum type, const GLvoid * pointer) {
    const char *_name = "glElementPointerAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glElementPointerAPPLE(GLenum type, const GLvoid * pointer) {
    PFN_GLELEMENTPOINTERAPPLE _ptr;
    _ptr = (PFN_GLELEMENTPOINTERAPPLE)_getPrivateProcAddress("glElementPointerAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glElementPointerAPPLE;
    }
    _glElementPointerAPPLE = _ptr;
    _glElementPointerAPPLE(type, pointer);
}

PFN_GLELEMENTPOINTERAPPLE _glElementPointerAPPLE = &_get_glElementPointerAPPLE;

static void APIENTRY _fail_glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count) {
    const char *_name = "glDrawElementArrayAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count) {
    PFN_GLDRAWELEMENTARRAYAPPLE _ptr;
    _ptr = (PFN_GLDRAWELEMENTARRAYAPPLE)_getPrivateProcAddress("glDrawElementArrayAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glDrawElementArrayAPPLE;
    }
    _glDrawElementArrayAPPLE = _ptr;
    _glDrawElementArrayAPPLE(mode, first, count);
}

PFN_GLDRAWELEMENTARRAYAPPLE _glDrawElementArrayAPPLE = &_get_glDrawElementArrayAPPLE;

static void APIENTRY _fail_glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count) {
    const char *_name = "glDrawRangeElementArrayAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count) {
    PFN_GLDRAWRANGEELEMENTARRAYAPPLE _ptr;
    _ptr = (PFN_GLDRAWRANGEELEMENTARRAYAPPLE)_getPrivateProcAddress("glDrawRangeElementArrayAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glDrawRangeElementArrayAPPLE;
    }
    _glDrawRangeElementArrayAPPLE = _ptr;
    _glDrawRangeElementArrayAPPLE(mode, start, end, first, count);
}

PFN_GLDRAWRANGEELEMENTARRAYAPPLE _glDrawRangeElementArrayAPPLE = &_get_glDrawRangeElementArrayAPPLE;

static void APIENTRY _fail_glMultiDrawElementArrayAPPLE(GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount) {
    const char *_name = "glMultiDrawElementArrayAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiDrawElementArrayAPPLE(GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount) {
    PFN_GLMULTIDRAWELEMENTARRAYAPPLE _ptr;
    _ptr = (PFN_GLMULTIDRAWELEMENTARRAYAPPLE)_getPrivateProcAddress("glMultiDrawElementArrayAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glMultiDrawElementArrayAPPLE;
    }
    _glMultiDrawElementArrayAPPLE = _ptr;
    _glMultiDrawElementArrayAPPLE(mode, first, count, primcount);
}

PFN_GLMULTIDRAWELEMENTARRAYAPPLE _glMultiDrawElementArrayAPPLE = &_get_glMultiDrawElementArrayAPPLE;

static void APIENTRY _fail_glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint * first, const GLsizei * count, GLsizei primcount) {
    const char *_name = "glMultiDrawRangeElementArrayAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint * first, const GLsizei * count, GLsizei primcount) {
    PFN_GLMULTIDRAWRANGEELEMENTARRAYAPPLE _ptr;
    _ptr = (PFN_GLMULTIDRAWRANGEELEMENTARRAYAPPLE)_getPrivateProcAddress("glMultiDrawRangeElementArrayAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glMultiDrawRangeElementArrayAPPLE;
    }
    _glMultiDrawRangeElementArrayAPPLE = _ptr;
    _glMultiDrawRangeElementArrayAPPLE(mode, start, end, first, count, primcount);
}

PFN_GLMULTIDRAWRANGEELEMENTARRAYAPPLE _glMultiDrawRangeElementArrayAPPLE = &_get_glMultiDrawRangeElementArrayAPPLE;

static void APIENTRY _fail_glGenFencesAPPLE(GLsizei n, GLuint * fences) {
    const char *_name = "glGenFencesAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenFencesAPPLE(GLsizei n, GLuint * fences) {
    PFN_GLGENFENCESAPPLE _ptr;
    _ptr = (PFN_GLGENFENCESAPPLE)_getPrivateProcAddress("glGenFencesAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glGenFencesAPPLE;
    }
    _glGenFencesAPPLE = _ptr;
    _glGenFencesAPPLE(n, fences);
}

PFN_GLGENFENCESAPPLE _glGenFencesAPPLE = &_get_glGenFencesAPPLE;

static void APIENTRY _fail_glDeleteFencesAPPLE(GLsizei n, const GLuint * fences) {
    const char *_name = "glDeleteFencesAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteFencesAPPLE(GLsizei n, const GLuint * fences) {
    PFN_GLDELETEFENCESAPPLE _ptr;
    _ptr = (PFN_GLDELETEFENCESAPPLE)_getPrivateProcAddress("glDeleteFencesAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glDeleteFencesAPPLE;
    }
    _glDeleteFencesAPPLE = _ptr;
    _glDeleteFencesAPPLE(n, fences);
}

PFN_GLDELETEFENCESAPPLE _glDeleteFencesAPPLE = &_get_glDeleteFencesAPPLE;

static void APIENTRY _fail_glSetFenceAPPLE(GLuint fence) {
    const char *_name = "glSetFenceAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSetFenceAPPLE(GLuint fence) {
    PFN_GLSETFENCEAPPLE _ptr;
    _ptr = (PFN_GLSETFENCEAPPLE)_getPrivateProcAddress("glSetFenceAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glSetFenceAPPLE;
    }
    _glSetFenceAPPLE = _ptr;
    _glSetFenceAPPLE(fence);
}

PFN_GLSETFENCEAPPLE _glSetFenceAPPLE = &_get_glSetFenceAPPLE;

static GLboolean APIENTRY _fail_glIsFenceAPPLE(GLuint fence) {
    const char *_name = "glIsFenceAPPLE";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsFenceAPPLE(GLuint fence) {
    PFN_GLISFENCEAPPLE _ptr;
    _ptr = (PFN_GLISFENCEAPPLE)_getPrivateProcAddress("glIsFenceAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glIsFenceAPPLE;
    }
    _glIsFenceAPPLE = _ptr;
    return _glIsFenceAPPLE(fence);
}

PFN_GLISFENCEAPPLE _glIsFenceAPPLE = &_get_glIsFenceAPPLE;

static GLboolean APIENTRY _fail_glTestFenceAPPLE(GLuint fence) {
    const char *_name = "glTestFenceAPPLE";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glTestFenceAPPLE(GLuint fence) {
    PFN_GLTESTFENCEAPPLE _ptr;
    _ptr = (PFN_GLTESTFENCEAPPLE)_getPrivateProcAddress("glTestFenceAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glTestFenceAPPLE;
    }
    _glTestFenceAPPLE = _ptr;
    return _glTestFenceAPPLE(fence);
}

PFN_GLTESTFENCEAPPLE _glTestFenceAPPLE = &_get_glTestFenceAPPLE;

static void APIENTRY _fail_glFinishFenceAPPLE(GLuint fence) {
    const char *_name = "glFinishFenceAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFinishFenceAPPLE(GLuint fence) {
    PFN_GLFINISHFENCEAPPLE _ptr;
    _ptr = (PFN_GLFINISHFENCEAPPLE)_getPrivateProcAddress("glFinishFenceAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glFinishFenceAPPLE;
    }
    _glFinishFenceAPPLE = _ptr;
    _glFinishFenceAPPLE(fence);
}

PFN_GLFINISHFENCEAPPLE _glFinishFenceAPPLE = &_get_glFinishFenceAPPLE;

static GLboolean APIENTRY _fail_glTestObjectAPPLE(GLenum object, GLuint name) {
    const char *_name = "glTestObjectAPPLE";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glTestObjectAPPLE(GLenum object, GLuint name) {
    PFN_GLTESTOBJECTAPPLE _ptr;
    _ptr = (PFN_GLTESTOBJECTAPPLE)_getPrivateProcAddress("glTestObjectAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glTestObjectAPPLE;
    }
    _glTestObjectAPPLE = _ptr;
    return _glTestObjectAPPLE(object, name);
}

PFN_GLTESTOBJECTAPPLE _glTestObjectAPPLE = &_get_glTestObjectAPPLE;

static void APIENTRY _fail_glFinishObjectAPPLE(GLenum object, GLint name) {
    const char *_name = "glFinishObjectAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFinishObjectAPPLE(GLenum object, GLint name) {
    PFN_GLFINISHOBJECTAPPLE _ptr;
    _ptr = (PFN_GLFINISHOBJECTAPPLE)_getPrivateProcAddress("glFinishObjectAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glFinishObjectAPPLE;
    }
    _glFinishObjectAPPLE = _ptr;
    _glFinishObjectAPPLE(object, name);
}

PFN_GLFINISHOBJECTAPPLE _glFinishObjectAPPLE = &_get_glFinishObjectAPPLE;

static void APIENTRY _fail_glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param) {
    const char *_name = "glBufferParameteriAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param) {
    PFN_GLBUFFERPARAMETERIAPPLE _ptr;
    _ptr = (PFN_GLBUFFERPARAMETERIAPPLE)_getPrivateProcAddress("glBufferParameteriAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glBufferParameteriAPPLE;
    }
    _glBufferParameteriAPPLE = _ptr;
    _glBufferParameteriAPPLE(target, pname, param);
}

PFN_GLBUFFERPARAMETERIAPPLE _glBufferParameteriAPPLE = &_get_glBufferParameteriAPPLE;

static void APIENTRY _fail_glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size) {
    const char *_name = "glFlushMappedBufferRangeAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size) {
    PFN_GLFLUSHMAPPEDBUFFERRANGEAPPLE _ptr;
    _ptr = (PFN_GLFLUSHMAPPEDBUFFERRANGEAPPLE)_getPrivateProcAddress("glFlushMappedBufferRangeAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glFlushMappedBufferRangeAPPLE;
    }
    _glFlushMappedBufferRangeAPPLE = _ptr;
    _glFlushMappedBufferRangeAPPLE(target, offset, size);
}

PFN_GLFLUSHMAPPEDBUFFERRANGEAPPLE _glFlushMappedBufferRangeAPPLE = &_get_glFlushMappedBufferRangeAPPLE;

static void APIENTRY _fail_glFlushRenderAPPLE(void) {
    const char *_name = "glFlushRenderAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFlushRenderAPPLE(void) {
    PFN_GLFLUSHRENDERAPPLE _ptr;
    _ptr = (PFN_GLFLUSHRENDERAPPLE)_getPrivateProcAddress("glFlushRenderAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glFlushRenderAPPLE;
    }
    _glFlushRenderAPPLE = _ptr;
    _glFlushRenderAPPLE();
}

PFN_GLFLUSHRENDERAPPLE _glFlushRenderAPPLE = &_get_glFlushRenderAPPLE;

static void APIENTRY _fail_glFinishRenderAPPLE(void) {
    const char *_name = "glFinishRenderAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFinishRenderAPPLE(void) {
    PFN_GLFINISHRENDERAPPLE _ptr;
    _ptr = (PFN_GLFINISHRENDERAPPLE)_getPrivateProcAddress("glFinishRenderAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glFinishRenderAPPLE;
    }
    _glFinishRenderAPPLE = _ptr;
    _glFinishRenderAPPLE();
}

PFN_GLFINISHRENDERAPPLE _glFinishRenderAPPLE = &_get_glFinishRenderAPPLE;

static void APIENTRY _fail_glSwapAPPLE(void) {
    const char *_name = "glSwapAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSwapAPPLE(void) {
    PFN_GLSWAPAPPLE _ptr;
    _ptr = (PFN_GLSWAPAPPLE)_getPrivateProcAddress("glSwapAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glSwapAPPLE;
    }
    _glSwapAPPLE = _ptr;
    _glSwapAPPLE();
}

PFN_GLSWAPAPPLE _glSwapAPPLE = &_get_glSwapAPPLE;

static void APIENTRY _fail_glRenderbufferStorageMultisampleAPPLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glRenderbufferStorageMultisampleAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRenderbufferStorageMultisampleAPPLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEAPPLE _ptr;
    _ptr = (PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEAPPLE)_getPrivateProcAddress("glRenderbufferStorageMultisampleAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glRenderbufferStorageMultisampleAPPLE;
    }
    _glRenderbufferStorageMultisampleAPPLE = _ptr;
    _glRenderbufferStorageMultisampleAPPLE(target, samples, internalformat, width, height);
}

PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEAPPLE _glRenderbufferStorageMultisampleAPPLE = &_get_glRenderbufferStorageMultisampleAPPLE;

static void APIENTRY _fail_glResolveMultisampleFramebufferAPPLE(void) {
    const char *_name = "glResolveMultisampleFramebufferAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glResolveMultisampleFramebufferAPPLE(void) {
    PFN_GLRESOLVEMULTISAMPLEFRAMEBUFFERAPPLE _ptr;
    _ptr = (PFN_GLRESOLVEMULTISAMPLEFRAMEBUFFERAPPLE)_getPrivateProcAddress("glResolveMultisampleFramebufferAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glResolveMultisampleFramebufferAPPLE;
    }
    _glResolveMultisampleFramebufferAPPLE = _ptr;
    _glResolveMultisampleFramebufferAPPLE();
}

PFN_GLRESOLVEMULTISAMPLEFRAMEBUFFERAPPLE _glResolveMultisampleFramebufferAPPLE = &_get_glResolveMultisampleFramebufferAPPLE;

static GLenum APIENTRY _fail_glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option) {
    const char *_name = "glObjectPurgeableAPPLE";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLenum APIENTRY _get_glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option) {
    PFN_GLOBJECTPURGEABLEAPPLE _ptr;
    _ptr = (PFN_GLOBJECTPURGEABLEAPPLE)_getPrivateProcAddress("glObjectPurgeableAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glObjectPurgeableAPPLE;
    }
    _glObjectPurgeableAPPLE = _ptr;
    return _glObjectPurgeableAPPLE(objectType, name, option);
}

PFN_GLOBJECTPURGEABLEAPPLE _glObjectPurgeableAPPLE = &_get_glObjectPurgeableAPPLE;

static GLenum APIENTRY _fail_glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option) {
    const char *_name = "glObjectUnpurgeableAPPLE";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLenum APIENTRY _get_glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option) {
    PFN_GLOBJECTUNPURGEABLEAPPLE _ptr;
    _ptr = (PFN_GLOBJECTUNPURGEABLEAPPLE)_getPrivateProcAddress("glObjectUnpurgeableAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glObjectUnpurgeableAPPLE;
    }
    _glObjectUnpurgeableAPPLE = _ptr;
    return _glObjectUnpurgeableAPPLE(objectType, name, option);
}

PFN_GLOBJECTUNPURGEABLEAPPLE _glObjectUnpurgeableAPPLE = &_get_glObjectUnpurgeableAPPLE;

static void APIENTRY _fail_glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint * params) {
    const char *_name = "glGetObjectParameterivAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint * params) {
    PFN_GLGETOBJECTPARAMETERIVAPPLE _ptr;
    _ptr = (PFN_GLGETOBJECTPARAMETERIVAPPLE)_getPrivateProcAddress("glGetObjectParameterivAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glGetObjectParameterivAPPLE;
    }
    _glGetObjectParameterivAPPLE = _ptr;
    _glGetObjectParameterivAPPLE(objectType, name, pname, params);
}

PFN_GLGETOBJECTPARAMETERIVAPPLE _glGetObjectParameterivAPPLE = &_get_glGetObjectParameterivAPPLE;

static GLsync APIENTRY _fail_glFenceSyncAPPLE(GLenum condition, GLbitfield flags) {
    const char *_name = "glFenceSyncAPPLE";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLsync APIENTRY _get_glFenceSyncAPPLE(GLenum condition, GLbitfield flags) {
    PFN_GLFENCESYNCAPPLE _ptr;
    _ptr = (PFN_GLFENCESYNCAPPLE)_getPrivateProcAddress("glFenceSyncAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glFenceSyncAPPLE;
    }
    _glFenceSyncAPPLE = _ptr;
    return _glFenceSyncAPPLE(condition, flags);
}

PFN_GLFENCESYNCAPPLE _glFenceSyncAPPLE = &_get_glFenceSyncAPPLE;

static GLboolean APIENTRY _fail_glIsSyncAPPLE(GLsync sync) {
    const char *_name = "glIsSyncAPPLE";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsSyncAPPLE(GLsync sync) {
    PFN_GLISSYNCAPPLE _ptr;
    _ptr = (PFN_GLISSYNCAPPLE)_getPrivateProcAddress("glIsSyncAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glIsSyncAPPLE;
    }
    _glIsSyncAPPLE = _ptr;
    return _glIsSyncAPPLE(sync);
}

PFN_GLISSYNCAPPLE _glIsSyncAPPLE = &_get_glIsSyncAPPLE;

static void APIENTRY _fail_glDeleteSyncAPPLE(GLsync sync) {
    const char *_name = "glDeleteSyncAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteSyncAPPLE(GLsync sync) {
    PFN_GLDELETESYNCAPPLE _ptr;
    _ptr = (PFN_GLDELETESYNCAPPLE)_getPrivateProcAddress("glDeleteSyncAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glDeleteSyncAPPLE;
    }
    _glDeleteSyncAPPLE = _ptr;
    _glDeleteSyncAPPLE(sync);
}

PFN_GLDELETESYNCAPPLE _glDeleteSyncAPPLE = &_get_glDeleteSyncAPPLE;

static GLenum APIENTRY _fail_glClientWaitSyncAPPLE(GLsync sync, GLbitfield flags, GLuint64 timeout) {
    const char *_name = "glClientWaitSyncAPPLE";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLenum APIENTRY _get_glClientWaitSyncAPPLE(GLsync sync, GLbitfield flags, GLuint64 timeout) {
    PFN_GLCLIENTWAITSYNCAPPLE _ptr;
    _ptr = (PFN_GLCLIENTWAITSYNCAPPLE)_getPrivateProcAddress("glClientWaitSyncAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glClientWaitSyncAPPLE;
    }
    _glClientWaitSyncAPPLE = _ptr;
    return _glClientWaitSyncAPPLE(sync, flags, timeout);
}

PFN_GLCLIENTWAITSYNCAPPLE _glClientWaitSyncAPPLE = &_get_glClientWaitSyncAPPLE;

static void APIENTRY _fail_glWaitSyncAPPLE(GLsync sync, GLbitfield flags, GLuint64 timeout) {
    const char *_name = "glWaitSyncAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWaitSyncAPPLE(GLsync sync, GLbitfield flags, GLuint64 timeout) {
    PFN_GLWAITSYNCAPPLE _ptr;
    _ptr = (PFN_GLWAITSYNCAPPLE)_getPrivateProcAddress("glWaitSyncAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glWaitSyncAPPLE;
    }
    _glWaitSyncAPPLE = _ptr;
    _glWaitSyncAPPLE(sync, flags, timeout);
}

PFN_GLWAITSYNCAPPLE _glWaitSyncAPPLE = &_get_glWaitSyncAPPLE;

static void APIENTRY _fail_glGetInteger64vAPPLE(GLenum pname, GLint64 * params) {
    const char *_name = "glGetInteger64vAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetInteger64vAPPLE(GLenum pname, GLint64 * params) {
    PFN_GLGETINTEGER64VAPPLE _ptr;
    _ptr = (PFN_GLGETINTEGER64VAPPLE)_getPrivateProcAddress("glGetInteger64vAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glGetInteger64vAPPLE;
    }
    _glGetInteger64vAPPLE = _ptr;
    _glGetInteger64vAPPLE(pname, params);
}

PFN_GLGETINTEGER64VAPPLE _glGetInteger64vAPPLE = &_get_glGetInteger64vAPPLE;

static void APIENTRY _fail_glGetSyncivAPPLE(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values) {
    const char *_name = "glGetSyncivAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetSyncivAPPLE(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values) {
    PFN_GLGETSYNCIVAPPLE _ptr;
    _ptr = (PFN_GLGETSYNCIVAPPLE)_getPrivateProcAddress("glGetSyncivAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glGetSyncivAPPLE;
    }
    _glGetSyncivAPPLE = _ptr;
    _glGetSyncivAPPLE(sync, pname, bufSize, length, values);
}

PFN_GLGETSYNCIVAPPLE _glGetSyncivAPPLE = &_get_glGetSyncivAPPLE;

static void APIENTRY _fail_glTextureRangeAPPLE(GLenum target, GLsizei length, const GLvoid * pointer) {
    const char *_name = "glTextureRangeAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureRangeAPPLE(GLenum target, GLsizei length, const GLvoid * pointer) {
    PFN_GLTEXTURERANGEAPPLE _ptr;
    _ptr = (PFN_GLTEXTURERANGEAPPLE)_getPrivateProcAddress("glTextureRangeAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glTextureRangeAPPLE;
    }
    _glTextureRangeAPPLE = _ptr;
    _glTextureRangeAPPLE(target, length, pointer);
}

PFN_GLTEXTURERANGEAPPLE _glTextureRangeAPPLE = &_get_glTextureRangeAPPLE;

static void APIENTRY _fail_glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid * * params) {
    const char *_name = "glGetTexParameterPointervAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid * * params) {
    PFN_GLGETTEXPARAMETERPOINTERVAPPLE _ptr;
    _ptr = (PFN_GLGETTEXPARAMETERPOINTERVAPPLE)_getPrivateProcAddress("glGetTexParameterPointervAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glGetTexParameterPointervAPPLE;
    }
    _glGetTexParameterPointervAPPLE = _ptr;
    _glGetTexParameterPointervAPPLE(target, pname, params);
}

PFN_GLGETTEXPARAMETERPOINTERVAPPLE _glGetTexParameterPointervAPPLE = &_get_glGetTexParameterPointervAPPLE;

static void APIENTRY _fail_glBindVertexArrayAPPLE(GLuint array) {
    const char *_name = "glBindVertexArrayAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindVertexArrayAPPLE(GLuint array) {
    PFN_GLBINDVERTEXARRAYAPPLE _ptr;
    _ptr = (PFN_GLBINDVERTEXARRAYAPPLE)_getPrivateProcAddress("glBindVertexArrayAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glBindVertexArrayAPPLE;
    }
    _glBindVertexArrayAPPLE = _ptr;
    _glBindVertexArrayAPPLE(array);
}

PFN_GLBINDVERTEXARRAYAPPLE _glBindVertexArrayAPPLE = &_get_glBindVertexArrayAPPLE;

static void APIENTRY _fail_glDeleteVertexArraysAPPLE(GLsizei n, const GLuint * arrays) {
    const char *_name = "glDeleteVertexArraysAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteVertexArraysAPPLE(GLsizei n, const GLuint * arrays) {
    PFN_GLDELETEVERTEXARRAYSAPPLE _ptr;
    _ptr = (PFN_GLDELETEVERTEXARRAYSAPPLE)_getPrivateProcAddress("glDeleteVertexArraysAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glDeleteVertexArraysAPPLE;
    }
    _glDeleteVertexArraysAPPLE = _ptr;
    _glDeleteVertexArraysAPPLE(n, arrays);
}

PFN_GLDELETEVERTEXARRAYSAPPLE _glDeleteVertexArraysAPPLE = &_get_glDeleteVertexArraysAPPLE;

static void APIENTRY _fail_glGenVertexArraysAPPLE(GLsizei n, GLuint * arrays) {
    const char *_name = "glGenVertexArraysAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenVertexArraysAPPLE(GLsizei n, GLuint * arrays) {
    PFN_GLGENVERTEXARRAYSAPPLE _ptr;
    _ptr = (PFN_GLGENVERTEXARRAYSAPPLE)_getPrivateProcAddress("glGenVertexArraysAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glGenVertexArraysAPPLE;
    }
    _glGenVertexArraysAPPLE = _ptr;
    _glGenVertexArraysAPPLE(n, arrays);
}

PFN_GLGENVERTEXARRAYSAPPLE _glGenVertexArraysAPPLE = &_get_glGenVertexArraysAPPLE;

static GLboolean APIENTRY _fail_glIsVertexArrayAPPLE(GLuint array) {
    const char *_name = "glIsVertexArrayAPPLE";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsVertexArrayAPPLE(GLuint array) {
    PFN_GLISVERTEXARRAYAPPLE _ptr;
    _ptr = (PFN_GLISVERTEXARRAYAPPLE)_getPrivateProcAddress("glIsVertexArrayAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glIsVertexArrayAPPLE;
    }
    _glIsVertexArrayAPPLE = _ptr;
    return _glIsVertexArrayAPPLE(array);
}

PFN_GLISVERTEXARRAYAPPLE _glIsVertexArrayAPPLE = &_get_glIsVertexArrayAPPLE;

static void APIENTRY _fail_glVertexArrayRangeAPPLE(GLsizei length, GLvoid * pointer) {
    const char *_name = "glVertexArrayRangeAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayRangeAPPLE(GLsizei length, GLvoid * pointer) {
    PFN_GLVERTEXARRAYRANGEAPPLE _ptr;
    _ptr = (PFN_GLVERTEXARRAYRANGEAPPLE)_getPrivateProcAddress("glVertexArrayRangeAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayRangeAPPLE;
    }
    _glVertexArrayRangeAPPLE = _ptr;
    _glVertexArrayRangeAPPLE(length, pointer);
}

PFN_GLVERTEXARRAYRANGEAPPLE _glVertexArrayRangeAPPLE = &_get_glVertexArrayRangeAPPLE;

static void APIENTRY _fail_glFlushVertexArrayRangeAPPLE(GLsizei length, GLvoid * pointer) {
    const char *_name = "glFlushVertexArrayRangeAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFlushVertexArrayRangeAPPLE(GLsizei length, GLvoid * pointer) {
    PFN_GLFLUSHVERTEXARRAYRANGEAPPLE _ptr;
    _ptr = (PFN_GLFLUSHVERTEXARRAYRANGEAPPLE)_getPrivateProcAddress("glFlushVertexArrayRangeAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glFlushVertexArrayRangeAPPLE;
    }
    _glFlushVertexArrayRangeAPPLE = _ptr;
    _glFlushVertexArrayRangeAPPLE(length, pointer);
}

PFN_GLFLUSHVERTEXARRAYRANGEAPPLE _glFlushVertexArrayRangeAPPLE = &_get_glFlushVertexArrayRangeAPPLE;

static void APIENTRY _fail_glVertexArrayParameteriAPPLE(GLenum pname, GLint param) {
    const char *_name = "glVertexArrayParameteriAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayParameteriAPPLE(GLenum pname, GLint param) {
    PFN_GLVERTEXARRAYPARAMETERIAPPLE _ptr;
    _ptr = (PFN_GLVERTEXARRAYPARAMETERIAPPLE)_getPrivateProcAddress("glVertexArrayParameteriAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayParameteriAPPLE;
    }
    _glVertexArrayParameteriAPPLE = _ptr;
    _glVertexArrayParameteriAPPLE(pname, param);
}

PFN_GLVERTEXARRAYPARAMETERIAPPLE _glVertexArrayParameteriAPPLE = &_get_glVertexArrayParameteriAPPLE;

static void APIENTRY _fail_glEnableVertexAttribAPPLE(GLuint index, GLenum pname) {
    const char *_name = "glEnableVertexAttribAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEnableVertexAttribAPPLE(GLuint index, GLenum pname) {
    PFN_GLENABLEVERTEXATTRIBAPPLE _ptr;
    _ptr = (PFN_GLENABLEVERTEXATTRIBAPPLE)_getPrivateProcAddress("glEnableVertexAttribAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glEnableVertexAttribAPPLE;
    }
    _glEnableVertexAttribAPPLE = _ptr;
    _glEnableVertexAttribAPPLE(index, pname);
}

PFN_GLENABLEVERTEXATTRIBAPPLE _glEnableVertexAttribAPPLE = &_get_glEnableVertexAttribAPPLE;

static void APIENTRY _fail_glDisableVertexAttribAPPLE(GLuint index, GLenum pname) {
    const char *_name = "glDisableVertexAttribAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDisableVertexAttribAPPLE(GLuint index, GLenum pname) {
    PFN_GLDISABLEVERTEXATTRIBAPPLE _ptr;
    _ptr = (PFN_GLDISABLEVERTEXATTRIBAPPLE)_getPrivateProcAddress("glDisableVertexAttribAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glDisableVertexAttribAPPLE;
    }
    _glDisableVertexAttribAPPLE = _ptr;
    _glDisableVertexAttribAPPLE(index, pname);
}

PFN_GLDISABLEVERTEXATTRIBAPPLE _glDisableVertexAttribAPPLE = &_get_glDisableVertexAttribAPPLE;

static GLboolean APIENTRY _fail_glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname) {
    const char *_name = "glIsVertexAttribEnabledAPPLE";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname) {
    PFN_GLISVERTEXATTRIBENABLEDAPPLE _ptr;
    _ptr = (PFN_GLISVERTEXATTRIBENABLEDAPPLE)_getPrivateProcAddress("glIsVertexAttribEnabledAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glIsVertexAttribEnabledAPPLE;
    }
    _glIsVertexAttribEnabledAPPLE = _ptr;
    return _glIsVertexAttribEnabledAPPLE(index, pname);
}

PFN_GLISVERTEXATTRIBENABLEDAPPLE _glIsVertexAttribEnabledAPPLE = &_get_glIsVertexAttribEnabledAPPLE;

static void APIENTRY _fail_glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points) {
    const char *_name = "glMapVertexAttrib1dAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points) {
    PFN_GLMAPVERTEXATTRIB1DAPPLE _ptr;
    _ptr = (PFN_GLMAPVERTEXATTRIB1DAPPLE)_getPrivateProcAddress("glMapVertexAttrib1dAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glMapVertexAttrib1dAPPLE;
    }
    _glMapVertexAttrib1dAPPLE = _ptr;
    _glMapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points);
}

PFN_GLMAPVERTEXATTRIB1DAPPLE _glMapVertexAttrib1dAPPLE = &_get_glMapVertexAttrib1dAPPLE;

static void APIENTRY _fail_glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points) {
    const char *_name = "glMapVertexAttrib1fAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points) {
    PFN_GLMAPVERTEXATTRIB1FAPPLE _ptr;
    _ptr = (PFN_GLMAPVERTEXATTRIB1FAPPLE)_getPrivateProcAddress("glMapVertexAttrib1fAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glMapVertexAttrib1fAPPLE;
    }
    _glMapVertexAttrib1fAPPLE = _ptr;
    _glMapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points);
}

PFN_GLMAPVERTEXATTRIB1FAPPLE _glMapVertexAttrib1fAPPLE = &_get_glMapVertexAttrib1fAPPLE;

static void APIENTRY _fail_glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points) {
    const char *_name = "glMapVertexAttrib2dAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points) {
    PFN_GLMAPVERTEXATTRIB2DAPPLE _ptr;
    _ptr = (PFN_GLMAPVERTEXATTRIB2DAPPLE)_getPrivateProcAddress("glMapVertexAttrib2dAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glMapVertexAttrib2dAPPLE;
    }
    _glMapVertexAttrib2dAPPLE = _ptr;
    _glMapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

PFN_GLMAPVERTEXATTRIB2DAPPLE _glMapVertexAttrib2dAPPLE = &_get_glMapVertexAttrib2dAPPLE;

static void APIENTRY _fail_glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points) {
    const char *_name = "glMapVertexAttrib2fAPPLE";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points) {
    PFN_GLMAPVERTEXATTRIB2FAPPLE _ptr;
    _ptr = (PFN_GLMAPVERTEXATTRIB2FAPPLE)_getPrivateProcAddress("glMapVertexAttrib2fAPPLE");
    if (!_ptr) {
        _ptr = &_fail_glMapVertexAttrib2fAPPLE;
    }
    _glMapVertexAttrib2fAPPLE = _ptr;
    _glMapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

PFN_GLMAPVERTEXATTRIB2FAPPLE _glMapVertexAttrib2fAPPLE = &_get_glMapVertexAttrib2fAPPLE;

static void APIENTRY _fail_glReleaseShaderCompiler(void) {
    const char *_name = "glReleaseShaderCompiler";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReleaseShaderCompiler(void) {
    PFN_GLRELEASESHADERCOMPILER _ptr;
    _ptr = (PFN_GLRELEASESHADERCOMPILER)_getPrivateProcAddress("glReleaseShaderCompiler");
    if (!_ptr) {
        _ptr = &_fail_glReleaseShaderCompiler;
    }
    _glReleaseShaderCompiler = _ptr;
    _glReleaseShaderCompiler();
}

PFN_GLRELEASESHADERCOMPILER _glReleaseShaderCompiler = &_get_glReleaseShaderCompiler;

static void APIENTRY _fail_glShaderBinary(GLsizei count, const GLuint * shaders, GLenum binaryformat, const GLvoid * binary, GLsizei length) {
    const char *_name = "glShaderBinary";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glShaderBinary(GLsizei count, const GLuint * shaders, GLenum binaryformat, const GLvoid * binary, GLsizei length) {
    PFN_GLSHADERBINARY _ptr;
    _ptr = (PFN_GLSHADERBINARY)_getPrivateProcAddress("glShaderBinary");
    if (!_ptr) {
        _ptr = &_fail_glShaderBinary;
    }
    _glShaderBinary = _ptr;
    _glShaderBinary(count, shaders, binaryformat, binary, length);
}

PFN_GLSHADERBINARY _glShaderBinary = &_get_glShaderBinary;

static void APIENTRY _fail_glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint * range, GLint * precision) {
    const char *_name = "glGetShaderPrecisionFormat";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint * range, GLint * precision) {
    PFN_GLGETSHADERPRECISIONFORMAT _ptr;
    _ptr = (PFN_GLGETSHADERPRECISIONFORMAT)_getPrivateProcAddress("glGetShaderPrecisionFormat");
    if (!_ptr) {
        _ptr = &_fail_glGetShaderPrecisionFormat;
    }
    _glGetShaderPrecisionFormat = _ptr;
    _glGetShaderPrecisionFormat(shadertype, precisiontype, range, precision);
}

PFN_GLGETSHADERPRECISIONFORMAT _glGetShaderPrecisionFormat = &_get_glGetShaderPrecisionFormat;

static void APIENTRY _fail_glDepthRangef(GLfloat n, GLfloat f) {
    const char *_name = "glDepthRangef";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDepthRangef(GLfloat n, GLfloat f) {
    PFN_GLDEPTHRANGEF _ptr;
    _ptr = (PFN_GLDEPTHRANGEF)_getPrivateProcAddress("glDepthRangef");
    if (!_ptr) {
        _ptr = &_fail_glDepthRangef;
    }
    _glDepthRangef = _ptr;
    _glDepthRangef(n, f);
}

PFN_GLDEPTHRANGEF _glDepthRangef = &_get_glDepthRangef;

static void APIENTRY _fail_glClearDepthf(GLfloat d) {
    const char *_name = "glClearDepthf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearDepthf(GLfloat d) {
    PFN_GLCLEARDEPTHF _ptr;
    _ptr = (PFN_GLCLEARDEPTHF)_getPrivateProcAddress("glClearDepthf");
    if (!_ptr) {
        _ptr = &_fail_glClearDepthf;
    }
    _glClearDepthf = _ptr;
    _glClearDepthf(d);
}

PFN_GLCLEARDEPTHF _glClearDepthf = &_get_glClearDepthf;

static void APIENTRY _fail_glMemoryBarrierByRegion(GLbitfield barriers) {
    const char *_name = "glMemoryBarrierByRegion";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMemoryBarrierByRegion(GLbitfield barriers) {
    PFN_GLMEMORYBARRIERBYREGION _ptr;
    _ptr = (PFN_GLMEMORYBARRIERBYREGION)_getPrivateProcAddress("glMemoryBarrierByRegion");
    if (!_ptr) {
        _ptr = &_fail_glMemoryBarrierByRegion;
    }
    _glMemoryBarrierByRegion = _ptr;
    _glMemoryBarrierByRegion(barriers);
}

PFN_GLMEMORYBARRIERBYREGION _glMemoryBarrierByRegion = &_get_glMemoryBarrierByRegion;

static void APIENTRY _fail_glPrimitiveBoundingBoxARB(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) {
    const char *_name = "glPrimitiveBoundingBoxARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPrimitiveBoundingBoxARB(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) {
    PFN_GLPRIMITIVEBOUNDINGBOXARB _ptr;
    _ptr = (PFN_GLPRIMITIVEBOUNDINGBOXARB)_getPrivateProcAddress("glPrimitiveBoundingBoxARB");
    if (!_ptr) {
        _ptr = &_fail_glPrimitiveBoundingBoxARB;
    }
    _glPrimitiveBoundingBoxARB = _ptr;
    _glPrimitiveBoundingBoxARB(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
}

PFN_GLPRIMITIVEBOUNDINGBOXARB _glPrimitiveBoundingBoxARB = &_get_glPrimitiveBoundingBoxARB;

static void APIENTRY _fail_glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance) {
    const char *_name = "glDrawArraysInstancedBaseInstance";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance) {
    PFN_GLDRAWARRAYSINSTANCEDBASEINSTANCE _ptr;
    _ptr = (PFN_GLDRAWARRAYSINSTANCEDBASEINSTANCE)_getPrivateProcAddress("glDrawArraysInstancedBaseInstance");
    if (!_ptr) {
        _ptr = &_fail_glDrawArraysInstancedBaseInstance;
    }
    _glDrawArraysInstancedBaseInstance = _ptr;
    _glDrawArraysInstancedBaseInstance(mode, first, count, primcount, baseinstance);
}

PFN_GLDRAWARRAYSINSTANCEDBASEINSTANCE _glDrawArraysInstancedBaseInstance = &_get_glDrawArraysInstancedBaseInstance;

static void APIENTRY _fail_glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount, GLuint baseinstance) {
    const char *_name = "glDrawElementsInstancedBaseInstance";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount, GLuint baseinstance) {
    PFN_GLDRAWELEMENTSINSTANCEDBASEINSTANCE _ptr;
    _ptr = (PFN_GLDRAWELEMENTSINSTANCEDBASEINSTANCE)_getPrivateProcAddress("glDrawElementsInstancedBaseInstance");
    if (!_ptr) {
        _ptr = &_fail_glDrawElementsInstancedBaseInstance;
    }
    _glDrawElementsInstancedBaseInstance = _ptr;
    _glDrawElementsInstancedBaseInstance(mode, count, type, indices, primcount, baseinstance);
}

PFN_GLDRAWELEMENTSINSTANCEDBASEINSTANCE _glDrawElementsInstancedBaseInstance = &_get_glDrawElementsInstancedBaseInstance;

static void APIENTRY _fail_glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount, GLint basevertex, GLuint baseinstance) {
    const char *_name = "glDrawElementsInstancedBaseVertexBaseInstance";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount, GLint basevertex, GLuint baseinstance) {
    PFN_GLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCE _ptr;
    _ptr = (PFN_GLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCE)_getPrivateProcAddress("glDrawElementsInstancedBaseVertexBaseInstance");
    if (!_ptr) {
        _ptr = &_fail_glDrawElementsInstancedBaseVertexBaseInstance;
    }
    _glDrawElementsInstancedBaseVertexBaseInstance = _ptr;
    _glDrawElementsInstancedBaseVertexBaseInstance(mode, count, type, indices, primcount, basevertex, baseinstance);
}

PFN_GLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCE _glDrawElementsInstancedBaseVertexBaseInstance = &_get_glDrawElementsInstancedBaseVertexBaseInstance;

static GLuint64 APIENTRY _fail_glGetTextureHandleARB(GLuint texture) {
    const char *_name = "glGetTextureHandleARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint64 APIENTRY _get_glGetTextureHandleARB(GLuint texture) {
    PFN_GLGETTEXTUREHANDLEARB _ptr;
    _ptr = (PFN_GLGETTEXTUREHANDLEARB)_getPrivateProcAddress("glGetTextureHandleARB");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureHandleARB;
    }
    _glGetTextureHandleARB = _ptr;
    return _glGetTextureHandleARB(texture);
}

PFN_GLGETTEXTUREHANDLEARB _glGetTextureHandleARB = &_get_glGetTextureHandleARB;

static GLuint64 APIENTRY _fail_glGetTextureSamplerHandleARB(GLuint texture, GLuint sampler) {
    const char *_name = "glGetTextureSamplerHandleARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint64 APIENTRY _get_glGetTextureSamplerHandleARB(GLuint texture, GLuint sampler) {
    PFN_GLGETTEXTURESAMPLERHANDLEARB _ptr;
    _ptr = (PFN_GLGETTEXTURESAMPLERHANDLEARB)_getPrivateProcAddress("glGetTextureSamplerHandleARB");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureSamplerHandleARB;
    }
    _glGetTextureSamplerHandleARB = _ptr;
    return _glGetTextureSamplerHandleARB(texture, sampler);
}

PFN_GLGETTEXTURESAMPLERHANDLEARB _glGetTextureSamplerHandleARB = &_get_glGetTextureSamplerHandleARB;

static void APIENTRY _fail_glMakeTextureHandleResidentARB(GLuint64 handle) {
    const char *_name = "glMakeTextureHandleResidentARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMakeTextureHandleResidentARB(GLuint64 handle) {
    PFN_GLMAKETEXTUREHANDLERESIDENTARB _ptr;
    _ptr = (PFN_GLMAKETEXTUREHANDLERESIDENTARB)_getPrivateProcAddress("glMakeTextureHandleResidentARB");
    if (!_ptr) {
        _ptr = &_fail_glMakeTextureHandleResidentARB;
    }
    _glMakeTextureHandleResidentARB = _ptr;
    _glMakeTextureHandleResidentARB(handle);
}

PFN_GLMAKETEXTUREHANDLERESIDENTARB _glMakeTextureHandleResidentARB = &_get_glMakeTextureHandleResidentARB;

static void APIENTRY _fail_glMakeTextureHandleNonResidentARB(GLuint64 handle) {
    const char *_name = "glMakeTextureHandleNonResidentARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMakeTextureHandleNonResidentARB(GLuint64 handle) {
    PFN_GLMAKETEXTUREHANDLENONRESIDENTARB _ptr;
    _ptr = (PFN_GLMAKETEXTUREHANDLENONRESIDENTARB)_getPrivateProcAddress("glMakeTextureHandleNonResidentARB");
    if (!_ptr) {
        _ptr = &_fail_glMakeTextureHandleNonResidentARB;
    }
    _glMakeTextureHandleNonResidentARB = _ptr;
    _glMakeTextureHandleNonResidentARB(handle);
}

PFN_GLMAKETEXTUREHANDLENONRESIDENTARB _glMakeTextureHandleNonResidentARB = &_get_glMakeTextureHandleNonResidentARB;

static GLuint64 APIENTRY _fail_glGetImageHandleARB(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format) {
    const char *_name = "glGetImageHandleARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint64 APIENTRY _get_glGetImageHandleARB(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format) {
    PFN_GLGETIMAGEHANDLEARB _ptr;
    _ptr = (PFN_GLGETIMAGEHANDLEARB)_getPrivateProcAddress("glGetImageHandleARB");
    if (!_ptr) {
        _ptr = &_fail_glGetImageHandleARB;
    }
    _glGetImageHandleARB = _ptr;
    return _glGetImageHandleARB(texture, level, layered, layer, format);
}

PFN_GLGETIMAGEHANDLEARB _glGetImageHandleARB = &_get_glGetImageHandleARB;

static void APIENTRY _fail_glMakeImageHandleResidentARB(GLuint64 handle, GLenum access) {
    const char *_name = "glMakeImageHandleResidentARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMakeImageHandleResidentARB(GLuint64 handle, GLenum access) {
    PFN_GLMAKEIMAGEHANDLERESIDENTARB _ptr;
    _ptr = (PFN_GLMAKEIMAGEHANDLERESIDENTARB)_getPrivateProcAddress("glMakeImageHandleResidentARB");
    if (!_ptr) {
        _ptr = &_fail_glMakeImageHandleResidentARB;
    }
    _glMakeImageHandleResidentARB = _ptr;
    _glMakeImageHandleResidentARB(handle, access);
}

PFN_GLMAKEIMAGEHANDLERESIDENTARB _glMakeImageHandleResidentARB = &_get_glMakeImageHandleResidentARB;

static void APIENTRY _fail_glMakeImageHandleNonResidentARB(GLuint64 handle) {
    const char *_name = "glMakeImageHandleNonResidentARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMakeImageHandleNonResidentARB(GLuint64 handle) {
    PFN_GLMAKEIMAGEHANDLENONRESIDENTARB _ptr;
    _ptr = (PFN_GLMAKEIMAGEHANDLENONRESIDENTARB)_getPrivateProcAddress("glMakeImageHandleNonResidentARB");
    if (!_ptr) {
        _ptr = &_fail_glMakeImageHandleNonResidentARB;
    }
    _glMakeImageHandleNonResidentARB = _ptr;
    _glMakeImageHandleNonResidentARB(handle);
}

PFN_GLMAKEIMAGEHANDLENONRESIDENTARB _glMakeImageHandleNonResidentARB = &_get_glMakeImageHandleNonResidentARB;

static void APIENTRY _fail_glUniformHandleui64ARB(GLint location, GLuint64 value) {
    const char *_name = "glUniformHandleui64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformHandleui64ARB(GLint location, GLuint64 value) {
    PFN_GLUNIFORMHANDLEUI64ARB _ptr;
    _ptr = (PFN_GLUNIFORMHANDLEUI64ARB)_getPrivateProcAddress("glUniformHandleui64ARB");
    if (!_ptr) {
        _ptr = &_fail_glUniformHandleui64ARB;
    }
    _glUniformHandleui64ARB = _ptr;
    _glUniformHandleui64ARB(location, value);
}

PFN_GLUNIFORMHANDLEUI64ARB _glUniformHandleui64ARB = &_get_glUniformHandleui64ARB;

static void APIENTRY _fail_glUniformHandleui64vARB(GLint location, GLsizei count, const GLuint64 * value) {
    const char *_name = "glUniformHandleui64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformHandleui64vARB(GLint location, GLsizei count, const GLuint64 * value) {
    PFN_GLUNIFORMHANDLEUI64VARB _ptr;
    _ptr = (PFN_GLUNIFORMHANDLEUI64VARB)_getPrivateProcAddress("glUniformHandleui64vARB");
    if (!_ptr) {
        _ptr = &_fail_glUniformHandleui64vARB;
    }
    _glUniformHandleui64vARB = _ptr;
    _glUniformHandleui64vARB(location, count, value);
}

PFN_GLUNIFORMHANDLEUI64VARB _glUniformHandleui64vARB = &_get_glUniformHandleui64vARB;

static void APIENTRY _fail_glProgramUniformHandleui64ARB(GLuint program, GLint location, GLuint64 value) {
    const char *_name = "glProgramUniformHandleui64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformHandleui64ARB(GLuint program, GLint location, GLuint64 value) {
    PFN_GLPROGRAMUNIFORMHANDLEUI64ARB _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMHANDLEUI64ARB)_getPrivateProcAddress("glProgramUniformHandleui64ARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformHandleui64ARB;
    }
    _glProgramUniformHandleui64ARB = _ptr;
    _glProgramUniformHandleui64ARB(program, location, value);
}

PFN_GLPROGRAMUNIFORMHANDLEUI64ARB _glProgramUniformHandleui64ARB = &_get_glProgramUniformHandleui64ARB;

static void APIENTRY _fail_glProgramUniformHandleui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * values) {
    const char *_name = "glProgramUniformHandleui64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformHandleui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * values) {
    PFN_GLPROGRAMUNIFORMHANDLEUI64VARB _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMHANDLEUI64VARB)_getPrivateProcAddress("glProgramUniformHandleui64vARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformHandleui64vARB;
    }
    _glProgramUniformHandleui64vARB = _ptr;
    _glProgramUniformHandleui64vARB(program, location, count, values);
}

PFN_GLPROGRAMUNIFORMHANDLEUI64VARB _glProgramUniformHandleui64vARB = &_get_glProgramUniformHandleui64vARB;

static GLboolean APIENTRY _fail_glIsTextureHandleResidentARB(GLuint64 handle) {
    const char *_name = "glIsTextureHandleResidentARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsTextureHandleResidentARB(GLuint64 handle) {
    PFN_GLISTEXTUREHANDLERESIDENTARB _ptr;
    _ptr = (PFN_GLISTEXTUREHANDLERESIDENTARB)_getPrivateProcAddress("glIsTextureHandleResidentARB");
    if (!_ptr) {
        _ptr = &_fail_glIsTextureHandleResidentARB;
    }
    _glIsTextureHandleResidentARB = _ptr;
    return _glIsTextureHandleResidentARB(handle);
}

PFN_GLISTEXTUREHANDLERESIDENTARB _glIsTextureHandleResidentARB = &_get_glIsTextureHandleResidentARB;

static GLboolean APIENTRY _fail_glIsImageHandleResidentARB(GLuint64 handle) {
    const char *_name = "glIsImageHandleResidentARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsImageHandleResidentARB(GLuint64 handle) {
    PFN_GLISIMAGEHANDLERESIDENTARB _ptr;
    _ptr = (PFN_GLISIMAGEHANDLERESIDENTARB)_getPrivateProcAddress("glIsImageHandleResidentARB");
    if (!_ptr) {
        _ptr = &_fail_glIsImageHandleResidentARB;
    }
    _glIsImageHandleResidentARB = _ptr;
    return _glIsImageHandleResidentARB(handle);
}

PFN_GLISIMAGEHANDLERESIDENTARB _glIsImageHandleResidentARB = &_get_glIsImageHandleResidentARB;

static void APIENTRY _fail_glVertexAttribL1ui64ARB(GLuint index, GLuint64EXT x) {
    const char *_name = "glVertexAttribL1ui64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL1ui64ARB(GLuint index, GLuint64EXT x) {
    PFN_GLVERTEXATTRIBL1UI64ARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL1UI64ARB)_getPrivateProcAddress("glVertexAttribL1ui64ARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL1ui64ARB;
    }
    _glVertexAttribL1ui64ARB = _ptr;
    _glVertexAttribL1ui64ARB(index, x);
}

PFN_GLVERTEXATTRIBL1UI64ARB _glVertexAttribL1ui64ARB = &_get_glVertexAttribL1ui64ARB;

static void APIENTRY _fail_glVertexAttribL1ui64vARB(GLuint index, const GLuint64EXT * v) {
    const char *_name = "glVertexAttribL1ui64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL1ui64vARB(GLuint index, const GLuint64EXT * v) {
    PFN_GLVERTEXATTRIBL1UI64VARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL1UI64VARB)_getPrivateProcAddress("glVertexAttribL1ui64vARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL1ui64vARB;
    }
    _glVertexAttribL1ui64vARB = _ptr;
    _glVertexAttribL1ui64vARB(index, v);
}

PFN_GLVERTEXATTRIBL1UI64VARB _glVertexAttribL1ui64vARB = &_get_glVertexAttribL1ui64vARB;

static void APIENTRY _fail_glGetVertexAttribLui64vARB(GLuint index, GLenum pname, GLuint64EXT * params) {
    const char *_name = "glGetVertexAttribLui64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribLui64vARB(GLuint index, GLenum pname, GLuint64EXT * params) {
    PFN_GLGETVERTEXATTRIBLUI64VARB _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBLUI64VARB)_getPrivateProcAddress("glGetVertexAttribLui64vARB");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribLui64vARB;
    }
    _glGetVertexAttribLui64vARB = _ptr;
    _glGetVertexAttribLui64vARB(index, pname, params);
}

PFN_GLGETVERTEXATTRIBLUI64VARB _glGetVertexAttribLui64vARB = &_get_glGetVertexAttribLui64vARB;

static void APIENTRY _fail_glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar * name) {
    const char *_name = "glBindFragDataLocationIndexed";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar * name) {
    PFN_GLBINDFRAGDATALOCATIONINDEXED _ptr;
    _ptr = (PFN_GLBINDFRAGDATALOCATIONINDEXED)_getPrivateProcAddress("glBindFragDataLocationIndexed");
    if (!_ptr) {
        _ptr = &_fail_glBindFragDataLocationIndexed;
    }
    _glBindFragDataLocationIndexed = _ptr;
    _glBindFragDataLocationIndexed(program, colorNumber, index, name);
}

PFN_GLBINDFRAGDATALOCATIONINDEXED _glBindFragDataLocationIndexed = &_get_glBindFragDataLocationIndexed;

static GLint APIENTRY _fail_glGetFragDataIndex(GLuint program, const GLchar * name) {
    const char *_name = "glGetFragDataIndex";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLint APIENTRY _get_glGetFragDataIndex(GLuint program, const GLchar * name) {
    PFN_GLGETFRAGDATAINDEX _ptr;
    _ptr = (PFN_GLGETFRAGDATAINDEX)_getPrivateProcAddress("glGetFragDataIndex");
    if (!_ptr) {
        _ptr = &_fail_glGetFragDataIndex;
    }
    _glGetFragDataIndex = _ptr;
    return _glGetFragDataIndex(program, name);
}

PFN_GLGETFRAGDATAINDEX _glGetFragDataIndex = &_get_glGetFragDataIndex;

static void APIENTRY _fail_glBufferStorage(GLenum target, GLsizeiptr size, const GLvoid * data, GLbitfield flags) {
    const char *_name = "glBufferStorage";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBufferStorage(GLenum target, GLsizeiptr size, const GLvoid * data, GLbitfield flags) {
    PFN_GLBUFFERSTORAGE _ptr;
    _ptr = (PFN_GLBUFFERSTORAGE)_getPrivateProcAddress("glBufferStorage");
    if (!_ptr) {
        _ptr = &_fail_glBufferStorage;
    }
    _glBufferStorage = _ptr;
    _glBufferStorage(target, size, data, flags);
}

PFN_GLBUFFERSTORAGE _glBufferStorage = &_get_glBufferStorage;

static GLsync APIENTRY _fail_glCreateSyncFromCLeventARB(struct _cl_context * context, struct _cl_event * event, GLbitfield flags) {
    const char *_name = "glCreateSyncFromCLeventARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLsync APIENTRY _get_glCreateSyncFromCLeventARB(struct _cl_context * context, struct _cl_event * event, GLbitfield flags) {
    PFN_GLCREATESYNCFROMCLEVENTARB _ptr;
    _ptr = (PFN_GLCREATESYNCFROMCLEVENTARB)_getPrivateProcAddress("glCreateSyncFromCLeventARB");
    if (!_ptr) {
        _ptr = &_fail_glCreateSyncFromCLeventARB;
    }
    _glCreateSyncFromCLeventARB = _ptr;
    return _glCreateSyncFromCLeventARB(context, event, flags);
}

PFN_GLCREATESYNCFROMCLEVENTARB _glCreateSyncFromCLeventARB = &_get_glCreateSyncFromCLeventARB;

static void APIENTRY _fail_glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data) {
    const char *_name = "glClearBufferData";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data) {
    PFN_GLCLEARBUFFERDATA _ptr;
    _ptr = (PFN_GLCLEARBUFFERDATA)_getPrivateProcAddress("glClearBufferData");
    if (!_ptr) {
        _ptr = &_fail_glClearBufferData;
    }
    _glClearBufferData = _ptr;
    _glClearBufferData(target, internalformat, format, type, data);
}

PFN_GLCLEARBUFFERDATA _glClearBufferData = &_get_glClearBufferData;

static void APIENTRY _fail_glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data) {
    const char *_name = "glClearBufferSubData";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data) {
    PFN_GLCLEARBUFFERSUBDATA _ptr;
    _ptr = (PFN_GLCLEARBUFFERSUBDATA)_getPrivateProcAddress("glClearBufferSubData");
    if (!_ptr) {
        _ptr = &_fail_glClearBufferSubData;
    }
    _glClearBufferSubData = _ptr;
    _glClearBufferSubData(target, internalformat, offset, size, format, type, data);
}

PFN_GLCLEARBUFFERSUBDATA _glClearBufferSubData = &_get_glClearBufferSubData;

static void APIENTRY _fail_glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const GLvoid * data) {
    const char *_name = "glClearTexImage";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const GLvoid * data) {
    PFN_GLCLEARTEXIMAGE _ptr;
    _ptr = (PFN_GLCLEARTEXIMAGE)_getPrivateProcAddress("glClearTexImage");
    if (!_ptr) {
        _ptr = &_fail_glClearTexImage;
    }
    _glClearTexImage = _ptr;
    _glClearTexImage(texture, level, format, type, data);
}

PFN_GLCLEARTEXIMAGE _glClearTexImage = &_get_glClearTexImage;

static void APIENTRY _fail_glClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * data) {
    const char *_name = "glClearTexSubImage";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * data) {
    PFN_GLCLEARTEXSUBIMAGE _ptr;
    _ptr = (PFN_GLCLEARTEXSUBIMAGE)_getPrivateProcAddress("glClearTexSubImage");
    if (!_ptr) {
        _ptr = &_fail_glClearTexSubImage;
    }
    _glClearTexSubImage = _ptr;
    _glClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
}

PFN_GLCLEARTEXSUBIMAGE _glClearTexSubImage = &_get_glClearTexSubImage;

static void APIENTRY _fail_glClipControl(GLenum origin, GLenum depth) {
    const char *_name = "glClipControl";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClipControl(GLenum origin, GLenum depth) {
    PFN_GLCLIPCONTROL _ptr;
    _ptr = (PFN_GLCLIPCONTROL)_getPrivateProcAddress("glClipControl");
    if (!_ptr) {
        _ptr = &_fail_glClipControl;
    }
    _glClipControl = _ptr;
    _glClipControl(origin, depth);
}

PFN_GLCLIPCONTROL _glClipControl = &_get_glClipControl;

static void APIENTRY _fail_glClampColorARB(GLenum target, GLenum clamp) {
    const char *_name = "glClampColorARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClampColorARB(GLenum target, GLenum clamp) {
    PFN_GLCLAMPCOLORARB _ptr;
    _ptr = (PFN_GLCLAMPCOLORARB)_getPrivateProcAddress("glClampColorARB");
    if (!_ptr) {
        _ptr = &_fail_glClampColorARB;
    }
    _glClampColorARB = _ptr;
    _glClampColorARB(target, clamp);
}

PFN_GLCLAMPCOLORARB _glClampColorARB = &_get_glClampColorARB;

static void APIENTRY _fail_glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z) {
    const char *_name = "glDispatchCompute";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z) {
    PFN_GLDISPATCHCOMPUTE _ptr;
    _ptr = (PFN_GLDISPATCHCOMPUTE)_getPrivateProcAddress("glDispatchCompute");
    if (!_ptr) {
        _ptr = &_fail_glDispatchCompute;
    }
    _glDispatchCompute = _ptr;
    _glDispatchCompute(num_groups_x, num_groups_y, num_groups_z);
}

PFN_GLDISPATCHCOMPUTE _glDispatchCompute = &_get_glDispatchCompute;

static void APIENTRY _fail_glDispatchComputeIndirect(GLintptr indirect) {
    const char *_name = "glDispatchComputeIndirect";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDispatchComputeIndirect(GLintptr indirect) {
    PFN_GLDISPATCHCOMPUTEINDIRECT _ptr;
    _ptr = (PFN_GLDISPATCHCOMPUTEINDIRECT)_getPrivateProcAddress("glDispatchComputeIndirect");
    if (!_ptr) {
        _ptr = &_fail_glDispatchComputeIndirect;
    }
    _glDispatchComputeIndirect = _ptr;
    _glDispatchComputeIndirect(indirect);
}

PFN_GLDISPATCHCOMPUTEINDIRECT _glDispatchComputeIndirect = &_get_glDispatchComputeIndirect;

static void APIENTRY _fail_glDispatchComputeGroupSizeARB(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z) {
    const char *_name = "glDispatchComputeGroupSizeARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDispatchComputeGroupSizeARB(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z) {
    PFN_GLDISPATCHCOMPUTEGROUPSIZEARB _ptr;
    _ptr = (PFN_GLDISPATCHCOMPUTEGROUPSIZEARB)_getPrivateProcAddress("glDispatchComputeGroupSizeARB");
    if (!_ptr) {
        _ptr = &_fail_glDispatchComputeGroupSizeARB;
    }
    _glDispatchComputeGroupSizeARB = _ptr;
    _glDispatchComputeGroupSizeARB(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
}

PFN_GLDISPATCHCOMPUTEGROUPSIZEARB _glDispatchComputeGroupSizeARB = &_get_glDispatchComputeGroupSizeARB;

static void APIENTRY _fail_glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) {
    const char *_name = "glCopyBufferSubData";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) {
    PFN_GLCOPYBUFFERSUBDATA _ptr;
    _ptr = (PFN_GLCOPYBUFFERSUBDATA)_getPrivateProcAddress("glCopyBufferSubData");
    if (!_ptr) {
        _ptr = &_fail_glCopyBufferSubData;
    }
    _glCopyBufferSubData = _ptr;
    _glCopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
}

PFN_GLCOPYBUFFERSUBDATA _glCopyBufferSubData = &_get_glCopyBufferSubData;

static void APIENTRY _fail_glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) {
    const char *_name = "glCopyImageSubData";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) {
    PFN_GLCOPYIMAGESUBDATA _ptr;
    _ptr = (PFN_GLCOPYIMAGESUBDATA)_getPrivateProcAddress("glCopyImageSubData");
    if (!_ptr) {
        _ptr = &_fail_glCopyImageSubData;
    }
    _glCopyImageSubData = _ptr;
    _glCopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
}

PFN_GLCOPYIMAGESUBDATA _glCopyImageSubData = &_get_glCopyImageSubData;

static void APIENTRY _fail_glDebugMessageControlARB(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled) {
}

static void APIENTRY _get_glDebugMessageControlARB(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled) {
    PFN_GLDEBUGMESSAGECONTROLARB _ptr;
    _ptr = (PFN_GLDEBUGMESSAGECONTROLARB)_getPrivateProcAddress("glDebugMessageControlARB");
    if (!_ptr) {
        _ptr = &_fail_glDebugMessageControlARB;
    }
    _glDebugMessageControlARB = _ptr;
    _glDebugMessageControlARB(source, type, severity, count, ids, enabled);
}

PFN_GLDEBUGMESSAGECONTROLARB _glDebugMessageControlARB = &_get_glDebugMessageControlARB;

static void APIENTRY _fail_glDebugMessageInsertARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf) {
}

static void APIENTRY _get_glDebugMessageInsertARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf) {
    PFN_GLDEBUGMESSAGEINSERTARB _ptr;
    _ptr = (PFN_GLDEBUGMESSAGEINSERTARB)_getPrivateProcAddress("glDebugMessageInsertARB");
    if (!_ptr) {
        _ptr = &_fail_glDebugMessageInsertARB;
    }
    _glDebugMessageInsertARB = _ptr;
    _glDebugMessageInsertARB(source, type, id, severity, length, buf);
}

PFN_GLDEBUGMESSAGEINSERTARB _glDebugMessageInsertARB = &_get_glDebugMessageInsertARB;

static void APIENTRY _fail_glDebugMessageCallbackARB(GLDEBUGPROCARB callback, const GLvoid * userParam) {
}

static void APIENTRY _get_glDebugMessageCallbackARB(GLDEBUGPROCARB callback, const GLvoid * userParam) {
    PFN_GLDEBUGMESSAGECALLBACKARB _ptr;
    _ptr = (PFN_GLDEBUGMESSAGECALLBACKARB)_getPrivateProcAddress("glDebugMessageCallbackARB");
    if (!_ptr) {
        _ptr = &_fail_glDebugMessageCallbackARB;
    }
    _glDebugMessageCallbackARB = _ptr;
    _glDebugMessageCallbackARB(callback, userParam);
}

PFN_GLDEBUGMESSAGECALLBACKARB _glDebugMessageCallbackARB = &_get_glDebugMessageCallbackARB;

static GLuint APIENTRY _fail_glGetDebugMessageLogARB(GLuint count, GLsizei bufsize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog) {
    if (sources != 0) *sources = 0;
    if (types != 0) *types = 0;
    if (ids != 0) *ids = 0;
    if (severities != 0) *severities = 0;
    if (lengths != 0) *lengths = 0;
    if (messageLog != 0 && bufsize > 0) *messageLog = 0;
    return 0;
}

static GLuint APIENTRY _get_glGetDebugMessageLogARB(GLuint count, GLsizei bufsize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog) {
    PFN_GLGETDEBUGMESSAGELOGARB _ptr;
    _ptr = (PFN_GLGETDEBUGMESSAGELOGARB)_getPrivateProcAddress("glGetDebugMessageLogARB");
    if (!_ptr) {
        _ptr = &_fail_glGetDebugMessageLogARB;
    }
    _glGetDebugMessageLogARB = _ptr;
    return _glGetDebugMessageLogARB(count, bufsize, sources, types, ids, severities, lengths, messageLog);
}

PFN_GLGETDEBUGMESSAGELOGARB _glGetDebugMessageLogARB = &_get_glGetDebugMessageLogARB;

static void APIENTRY _fail_glCreateTransformFeedbacks(GLsizei n, GLuint * ids) {
    const char *_name = "glCreateTransformFeedbacks";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCreateTransformFeedbacks(GLsizei n, GLuint * ids) {
    PFN_GLCREATETRANSFORMFEEDBACKS _ptr;
    _ptr = (PFN_GLCREATETRANSFORMFEEDBACKS)_getPrivateProcAddress("glCreateTransformFeedbacks");
    if (!_ptr) {
        _ptr = &_fail_glCreateTransformFeedbacks;
    }
    _glCreateTransformFeedbacks = _ptr;
    _glCreateTransformFeedbacks(n, ids);
}

PFN_GLCREATETRANSFORMFEEDBACKS _glCreateTransformFeedbacks = &_get_glCreateTransformFeedbacks;

static void APIENTRY _fail_glTransformFeedbackBufferBase(GLuint xfb, GLuint index, GLuint buffer) {
    const char *_name = "glTransformFeedbackBufferBase";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTransformFeedbackBufferBase(GLuint xfb, GLuint index, GLuint buffer) {
    PFN_GLTRANSFORMFEEDBACKBUFFERBASE _ptr;
    _ptr = (PFN_GLTRANSFORMFEEDBACKBUFFERBASE)_getPrivateProcAddress("glTransformFeedbackBufferBase");
    if (!_ptr) {
        _ptr = &_fail_glTransformFeedbackBufferBase;
    }
    _glTransformFeedbackBufferBase = _ptr;
    _glTransformFeedbackBufferBase(xfb, index, buffer);
}

PFN_GLTRANSFORMFEEDBACKBUFFERBASE _glTransformFeedbackBufferBase = &_get_glTransformFeedbackBufferBase;

static void APIENTRY _fail_glTransformFeedbackBufferRange(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    const char *_name = "glTransformFeedbackBufferRange";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTransformFeedbackBufferRange(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    PFN_GLTRANSFORMFEEDBACKBUFFERRANGE _ptr;
    _ptr = (PFN_GLTRANSFORMFEEDBACKBUFFERRANGE)_getPrivateProcAddress("glTransformFeedbackBufferRange");
    if (!_ptr) {
        _ptr = &_fail_glTransformFeedbackBufferRange;
    }
    _glTransformFeedbackBufferRange = _ptr;
    _glTransformFeedbackBufferRange(xfb, index, buffer, offset, size);
}

PFN_GLTRANSFORMFEEDBACKBUFFERRANGE _glTransformFeedbackBufferRange = &_get_glTransformFeedbackBufferRange;

static void APIENTRY _fail_glGetTransformFeedbackiv(GLuint xfb, GLenum pname, GLint * param) {
    const char *_name = "glGetTransformFeedbackiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTransformFeedbackiv(GLuint xfb, GLenum pname, GLint * param) {
    PFN_GLGETTRANSFORMFEEDBACKIV _ptr;
    _ptr = (PFN_GLGETTRANSFORMFEEDBACKIV)_getPrivateProcAddress("glGetTransformFeedbackiv");
    if (!_ptr) {
        _ptr = &_fail_glGetTransformFeedbackiv;
    }
    _glGetTransformFeedbackiv = _ptr;
    _glGetTransformFeedbackiv(xfb, pname, param);
}

PFN_GLGETTRANSFORMFEEDBACKIV _glGetTransformFeedbackiv = &_get_glGetTransformFeedbackiv;

static void APIENTRY _fail_glGetTransformFeedbacki_v(GLuint xfb, GLenum pname, GLuint index, GLint * param) {
    const char *_name = "glGetTransformFeedbacki_v";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTransformFeedbacki_v(GLuint xfb, GLenum pname, GLuint index, GLint * param) {
    PFN_GLGETTRANSFORMFEEDBACKI_V _ptr;
    _ptr = (PFN_GLGETTRANSFORMFEEDBACKI_V)_getPrivateProcAddress("glGetTransformFeedbacki_v");
    if (!_ptr) {
        _ptr = &_fail_glGetTransformFeedbacki_v;
    }
    _glGetTransformFeedbacki_v = _ptr;
    _glGetTransformFeedbacki_v(xfb, pname, index, param);
}

PFN_GLGETTRANSFORMFEEDBACKI_V _glGetTransformFeedbacki_v = &_get_glGetTransformFeedbacki_v;

static void APIENTRY _fail_glGetTransformFeedbacki64_v(GLuint xfb, GLenum pname, GLuint index, GLint64 * param) {
    const char *_name = "glGetTransformFeedbacki64_v";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTransformFeedbacki64_v(GLuint xfb, GLenum pname, GLuint index, GLint64 * param) {
    PFN_GLGETTRANSFORMFEEDBACKI64_V _ptr;
    _ptr = (PFN_GLGETTRANSFORMFEEDBACKI64_V)_getPrivateProcAddress("glGetTransformFeedbacki64_v");
    if (!_ptr) {
        _ptr = &_fail_glGetTransformFeedbacki64_v;
    }
    _glGetTransformFeedbacki64_v = _ptr;
    _glGetTransformFeedbacki64_v(xfb, pname, index, param);
}

PFN_GLGETTRANSFORMFEEDBACKI64_V _glGetTransformFeedbacki64_v = &_get_glGetTransformFeedbacki64_v;

static void APIENTRY _fail_glCreateBuffers(GLsizei n, GLuint * buffers) {
    const char *_name = "glCreateBuffers";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCreateBuffers(GLsizei n, GLuint * buffers) {
    PFN_GLCREATEBUFFERS _ptr;
    _ptr = (PFN_GLCREATEBUFFERS)_getPrivateProcAddress("glCreateBuffers");
    if (!_ptr) {
        _ptr = &_fail_glCreateBuffers;
    }
    _glCreateBuffers = _ptr;
    _glCreateBuffers(n, buffers);
}

PFN_GLCREATEBUFFERS _glCreateBuffers = &_get_glCreateBuffers;

static void APIENTRY _fail_glNamedBufferStorage(GLuint buffer, GLsizeiptr size, const void * data, GLbitfield flags) {
    const char *_name = "glNamedBufferStorage";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedBufferStorage(GLuint buffer, GLsizeiptr size, const void * data, GLbitfield flags) {
    PFN_GLNAMEDBUFFERSTORAGE _ptr;
    _ptr = (PFN_GLNAMEDBUFFERSTORAGE)_getPrivateProcAddress("glNamedBufferStorage");
    if (!_ptr) {
        _ptr = &_fail_glNamedBufferStorage;
    }
    _glNamedBufferStorage = _ptr;
    _glNamedBufferStorage(buffer, size, data, flags);
}

PFN_GLNAMEDBUFFERSTORAGE _glNamedBufferStorage = &_get_glNamedBufferStorage;

static void APIENTRY _fail_glNamedBufferData(GLuint buffer, GLsizeiptr size, const void * data, GLenum usage) {
    const char *_name = "glNamedBufferData";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedBufferData(GLuint buffer, GLsizeiptr size, const void * data, GLenum usage) {
    PFN_GLNAMEDBUFFERDATA _ptr;
    _ptr = (PFN_GLNAMEDBUFFERDATA)_getPrivateProcAddress("glNamedBufferData");
    if (!_ptr) {
        _ptr = &_fail_glNamedBufferData;
    }
    _glNamedBufferData = _ptr;
    _glNamedBufferData(buffer, size, data, usage);
}

PFN_GLNAMEDBUFFERDATA _glNamedBufferData = &_get_glNamedBufferData;

static void APIENTRY _fail_glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data) {
    const char *_name = "glNamedBufferSubData";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data) {
    PFN_GLNAMEDBUFFERSUBDATA _ptr;
    _ptr = (PFN_GLNAMEDBUFFERSUBDATA)_getPrivateProcAddress("glNamedBufferSubData");
    if (!_ptr) {
        _ptr = &_fail_glNamedBufferSubData;
    }
    _glNamedBufferSubData = _ptr;
    _glNamedBufferSubData(buffer, offset, size, data);
}

PFN_GLNAMEDBUFFERSUBDATA _glNamedBufferSubData = &_get_glNamedBufferSubData;

static void APIENTRY _fail_glCopyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) {
    const char *_name = "glCopyNamedBufferSubData";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) {
    PFN_GLCOPYNAMEDBUFFERSUBDATA _ptr;
    _ptr = (PFN_GLCOPYNAMEDBUFFERSUBDATA)_getPrivateProcAddress("glCopyNamedBufferSubData");
    if (!_ptr) {
        _ptr = &_fail_glCopyNamedBufferSubData;
    }
    _glCopyNamedBufferSubData = _ptr;
    _glCopyNamedBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size);
}

PFN_GLCOPYNAMEDBUFFERSUBDATA _glCopyNamedBufferSubData = &_get_glCopyNamedBufferSubData;

static void APIENTRY _fail_glClearNamedBufferData(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data) {
    const char *_name = "glClearNamedBufferData";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearNamedBufferData(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data) {
    PFN_GLCLEARNAMEDBUFFERDATA _ptr;
    _ptr = (PFN_GLCLEARNAMEDBUFFERDATA)_getPrivateProcAddress("glClearNamedBufferData");
    if (!_ptr) {
        _ptr = &_fail_glClearNamedBufferData;
    }
    _glClearNamedBufferData = _ptr;
    _glClearNamedBufferData(buffer, internalformat, format, type, data);
}

PFN_GLCLEARNAMEDBUFFERDATA _glClearNamedBufferData = &_get_glClearNamedBufferData;

static void APIENTRY _fail_glClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data) {
    const char *_name = "glClearNamedBufferSubData";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data) {
    PFN_GLCLEARNAMEDBUFFERSUBDATA _ptr;
    _ptr = (PFN_GLCLEARNAMEDBUFFERSUBDATA)_getPrivateProcAddress("glClearNamedBufferSubData");
    if (!_ptr) {
        _ptr = &_fail_glClearNamedBufferSubData;
    }
    _glClearNamedBufferSubData = _ptr;
    _glClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, data);
}

PFN_GLCLEARNAMEDBUFFERSUBDATA _glClearNamedBufferSubData = &_get_glClearNamedBufferSubData;

static GLvoid * APIENTRY _fail_glMapNamedBuffer(GLuint buffer, GLenum access) {
    const char *_name = "glMapNamedBuffer";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLvoid * APIENTRY _get_glMapNamedBuffer(GLuint buffer, GLenum access) {
    PFN_GLMAPNAMEDBUFFER _ptr;
    _ptr = (PFN_GLMAPNAMEDBUFFER)_getPrivateProcAddress("glMapNamedBuffer");
    if (!_ptr) {
        _ptr = &_fail_glMapNamedBuffer;
    }
    _glMapNamedBuffer = _ptr;
    return _glMapNamedBuffer(buffer, access);
}

PFN_GLMAPNAMEDBUFFER _glMapNamedBuffer = &_get_glMapNamedBuffer;

static GLvoid * APIENTRY _fail_glMapNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access) {
    const char *_name = "glMapNamedBufferRange";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLvoid * APIENTRY _get_glMapNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access) {
    PFN_GLMAPNAMEDBUFFERRANGE _ptr;
    _ptr = (PFN_GLMAPNAMEDBUFFERRANGE)_getPrivateProcAddress("glMapNamedBufferRange");
    if (!_ptr) {
        _ptr = &_fail_glMapNamedBufferRange;
    }
    _glMapNamedBufferRange = _ptr;
    return _glMapNamedBufferRange(buffer, offset, length, access);
}

PFN_GLMAPNAMEDBUFFERRANGE _glMapNamedBufferRange = &_get_glMapNamedBufferRange;

static GLboolean APIENTRY _fail_glUnmapNamedBuffer(GLuint buffer) {
    const char *_name = "glUnmapNamedBuffer";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glUnmapNamedBuffer(GLuint buffer) {
    PFN_GLUNMAPNAMEDBUFFER _ptr;
    _ptr = (PFN_GLUNMAPNAMEDBUFFER)_getPrivateProcAddress("glUnmapNamedBuffer");
    if (!_ptr) {
        _ptr = &_fail_glUnmapNamedBuffer;
    }
    _glUnmapNamedBuffer = _ptr;
    return _glUnmapNamedBuffer(buffer);
}

PFN_GLUNMAPNAMEDBUFFER _glUnmapNamedBuffer = &_get_glUnmapNamedBuffer;

static void APIENTRY _fail_glFlushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length) {
    const char *_name = "glFlushMappedNamedBufferRange";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFlushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length) {
    PFN_GLFLUSHMAPPEDNAMEDBUFFERRANGE _ptr;
    _ptr = (PFN_GLFLUSHMAPPEDNAMEDBUFFERRANGE)_getPrivateProcAddress("glFlushMappedNamedBufferRange");
    if (!_ptr) {
        _ptr = &_fail_glFlushMappedNamedBufferRange;
    }
    _glFlushMappedNamedBufferRange = _ptr;
    _glFlushMappedNamedBufferRange(buffer, offset, length);
}

PFN_GLFLUSHMAPPEDNAMEDBUFFERRANGE _glFlushMappedNamedBufferRange = &_get_glFlushMappedNamedBufferRange;

static void APIENTRY _fail_glGetNamedBufferParameteriv(GLuint buffer, GLenum pname, GLint * params) {
    const char *_name = "glGetNamedBufferParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedBufferParameteriv(GLuint buffer, GLenum pname, GLint * params) {
    PFN_GLGETNAMEDBUFFERPARAMETERIV _ptr;
    _ptr = (PFN_GLGETNAMEDBUFFERPARAMETERIV)_getPrivateProcAddress("glGetNamedBufferParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedBufferParameteriv;
    }
    _glGetNamedBufferParameteriv = _ptr;
    _glGetNamedBufferParameteriv(buffer, pname, params);
}

PFN_GLGETNAMEDBUFFERPARAMETERIV _glGetNamedBufferParameteriv = &_get_glGetNamedBufferParameteriv;

static void APIENTRY _fail_glGetNamedBufferParameteri64v(GLuint buffer, GLenum pname, GLint64 * params) {
    const char *_name = "glGetNamedBufferParameteri64v";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedBufferParameteri64v(GLuint buffer, GLenum pname, GLint64 * params) {
    PFN_GLGETNAMEDBUFFERPARAMETERI64V _ptr;
    _ptr = (PFN_GLGETNAMEDBUFFERPARAMETERI64V)_getPrivateProcAddress("glGetNamedBufferParameteri64v");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedBufferParameteri64v;
    }
    _glGetNamedBufferParameteri64v = _ptr;
    _glGetNamedBufferParameteri64v(buffer, pname, params);
}

PFN_GLGETNAMEDBUFFERPARAMETERI64V _glGetNamedBufferParameteri64v = &_get_glGetNamedBufferParameteri64v;

static void APIENTRY _fail_glGetNamedBufferPointerv(GLuint buffer, GLenum pname, GLvoid * * params) {
    const char *_name = "glGetNamedBufferPointerv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedBufferPointerv(GLuint buffer, GLenum pname, GLvoid * * params) {
    PFN_GLGETNAMEDBUFFERPOINTERV _ptr;
    _ptr = (PFN_GLGETNAMEDBUFFERPOINTERV)_getPrivateProcAddress("glGetNamedBufferPointerv");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedBufferPointerv;
    }
    _glGetNamedBufferPointerv = _ptr;
    _glGetNamedBufferPointerv(buffer, pname, params);
}

PFN_GLGETNAMEDBUFFERPOINTERV _glGetNamedBufferPointerv = &_get_glGetNamedBufferPointerv;

static void APIENTRY _fail_glGetNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, void * data) {
    const char *_name = "glGetNamedBufferSubData";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, void * data) {
    PFN_GLGETNAMEDBUFFERSUBDATA _ptr;
    _ptr = (PFN_GLGETNAMEDBUFFERSUBDATA)_getPrivateProcAddress("glGetNamedBufferSubData");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedBufferSubData;
    }
    _glGetNamedBufferSubData = _ptr;
    _glGetNamedBufferSubData(buffer, offset, size, data);
}

PFN_GLGETNAMEDBUFFERSUBDATA _glGetNamedBufferSubData = &_get_glGetNamedBufferSubData;

static void APIENTRY _fail_glCreateFramebuffers(GLsizei n, GLuint * framebuffers) {
    const char *_name = "glCreateFramebuffers";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCreateFramebuffers(GLsizei n, GLuint * framebuffers) {
    PFN_GLCREATEFRAMEBUFFERS _ptr;
    _ptr = (PFN_GLCREATEFRAMEBUFFERS)_getPrivateProcAddress("glCreateFramebuffers");
    if (!_ptr) {
        _ptr = &_fail_glCreateFramebuffers;
    }
    _glCreateFramebuffers = _ptr;
    _glCreateFramebuffers(n, framebuffers);
}

PFN_GLCREATEFRAMEBUFFERS _glCreateFramebuffers = &_get_glCreateFramebuffers;

static void APIENTRY _fail_glNamedFramebufferRenderbuffer(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) {
    const char *_name = "glNamedFramebufferRenderbuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedFramebufferRenderbuffer(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) {
    PFN_GLNAMEDFRAMEBUFFERRENDERBUFFER _ptr;
    _ptr = (PFN_GLNAMEDFRAMEBUFFERRENDERBUFFER)_getPrivateProcAddress("glNamedFramebufferRenderbuffer");
    if (!_ptr) {
        _ptr = &_fail_glNamedFramebufferRenderbuffer;
    }
    _glNamedFramebufferRenderbuffer = _ptr;
    _glNamedFramebufferRenderbuffer(framebuffer, attachment, renderbuffertarget, renderbuffer);
}

PFN_GLNAMEDFRAMEBUFFERRENDERBUFFER _glNamedFramebufferRenderbuffer = &_get_glNamedFramebufferRenderbuffer;

static void APIENTRY _fail_glNamedFramebufferParameteri(GLuint framebuffer, GLenum pname, GLint param) {
    const char *_name = "glNamedFramebufferParameteri";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedFramebufferParameteri(GLuint framebuffer, GLenum pname, GLint param) {
    PFN_GLNAMEDFRAMEBUFFERPARAMETERI _ptr;
    _ptr = (PFN_GLNAMEDFRAMEBUFFERPARAMETERI)_getPrivateProcAddress("glNamedFramebufferParameteri");
    if (!_ptr) {
        _ptr = &_fail_glNamedFramebufferParameteri;
    }
    _glNamedFramebufferParameteri = _ptr;
    _glNamedFramebufferParameteri(framebuffer, pname, param);
}

PFN_GLNAMEDFRAMEBUFFERPARAMETERI _glNamedFramebufferParameteri = &_get_glNamedFramebufferParameteri;

static void APIENTRY _fail_glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level) {
    const char *_name = "glNamedFramebufferTexture";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level) {
    PFN_GLNAMEDFRAMEBUFFERTEXTURE _ptr;
    _ptr = (PFN_GLNAMEDFRAMEBUFFERTEXTURE)_getPrivateProcAddress("glNamedFramebufferTexture");
    if (!_ptr) {
        _ptr = &_fail_glNamedFramebufferTexture;
    }
    _glNamedFramebufferTexture = _ptr;
    _glNamedFramebufferTexture(framebuffer, attachment, texture, level);
}

PFN_GLNAMEDFRAMEBUFFERTEXTURE _glNamedFramebufferTexture = &_get_glNamedFramebufferTexture;

static void APIENTRY _fail_glNamedFramebufferTextureLayer(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer) {
    const char *_name = "glNamedFramebufferTextureLayer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedFramebufferTextureLayer(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer) {
    PFN_GLNAMEDFRAMEBUFFERTEXTURELAYER _ptr;
    _ptr = (PFN_GLNAMEDFRAMEBUFFERTEXTURELAYER)_getPrivateProcAddress("glNamedFramebufferTextureLayer");
    if (!_ptr) {
        _ptr = &_fail_glNamedFramebufferTextureLayer;
    }
    _glNamedFramebufferTextureLayer = _ptr;
    _glNamedFramebufferTextureLayer(framebuffer, attachment, texture, level, layer);
}

PFN_GLNAMEDFRAMEBUFFERTEXTURELAYER _glNamedFramebufferTextureLayer = &_get_glNamedFramebufferTextureLayer;

static void APIENTRY _fail_glNamedFramebufferDrawBuffer(GLuint framebuffer, GLenum buf) {
    const char *_name = "glNamedFramebufferDrawBuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedFramebufferDrawBuffer(GLuint framebuffer, GLenum buf) {
    PFN_GLNAMEDFRAMEBUFFERDRAWBUFFER _ptr;
    _ptr = (PFN_GLNAMEDFRAMEBUFFERDRAWBUFFER)_getPrivateProcAddress("glNamedFramebufferDrawBuffer");
    if (!_ptr) {
        _ptr = &_fail_glNamedFramebufferDrawBuffer;
    }
    _glNamedFramebufferDrawBuffer = _ptr;
    _glNamedFramebufferDrawBuffer(framebuffer, buf);
}

PFN_GLNAMEDFRAMEBUFFERDRAWBUFFER _glNamedFramebufferDrawBuffer = &_get_glNamedFramebufferDrawBuffer;

static void APIENTRY _fail_glNamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, const GLenum * bufs) {
    const char *_name = "glNamedFramebufferDrawBuffers";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, const GLenum * bufs) {
    PFN_GLNAMEDFRAMEBUFFERDRAWBUFFERS _ptr;
    _ptr = (PFN_GLNAMEDFRAMEBUFFERDRAWBUFFERS)_getPrivateProcAddress("glNamedFramebufferDrawBuffers");
    if (!_ptr) {
        _ptr = &_fail_glNamedFramebufferDrawBuffers;
    }
    _glNamedFramebufferDrawBuffers = _ptr;
    _glNamedFramebufferDrawBuffers(framebuffer, n, bufs);
}

PFN_GLNAMEDFRAMEBUFFERDRAWBUFFERS _glNamedFramebufferDrawBuffers = &_get_glNamedFramebufferDrawBuffers;

static void APIENTRY _fail_glNamedFramebufferReadBuffer(GLuint framebuffer, GLenum src) {
    const char *_name = "glNamedFramebufferReadBuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedFramebufferReadBuffer(GLuint framebuffer, GLenum src) {
    PFN_GLNAMEDFRAMEBUFFERREADBUFFER _ptr;
    _ptr = (PFN_GLNAMEDFRAMEBUFFERREADBUFFER)_getPrivateProcAddress("glNamedFramebufferReadBuffer");
    if (!_ptr) {
        _ptr = &_fail_glNamedFramebufferReadBuffer;
    }
    _glNamedFramebufferReadBuffer = _ptr;
    _glNamedFramebufferReadBuffer(framebuffer, src);
}

PFN_GLNAMEDFRAMEBUFFERREADBUFFER _glNamedFramebufferReadBuffer = &_get_glNamedFramebufferReadBuffer;

static void APIENTRY _fail_glInvalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, const GLenum * attachments) {
    const char *_name = "glInvalidateNamedFramebufferData";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glInvalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, const GLenum * attachments) {
    PFN_GLINVALIDATENAMEDFRAMEBUFFERDATA _ptr;
    _ptr = (PFN_GLINVALIDATENAMEDFRAMEBUFFERDATA)_getPrivateProcAddress("glInvalidateNamedFramebufferData");
    if (!_ptr) {
        _ptr = &_fail_glInvalidateNamedFramebufferData;
    }
    _glInvalidateNamedFramebufferData = _ptr;
    _glInvalidateNamedFramebufferData(framebuffer, numAttachments, attachments);
}

PFN_GLINVALIDATENAMEDFRAMEBUFFERDATA _glInvalidateNamedFramebufferData = &_get_glInvalidateNamedFramebufferData;

static void APIENTRY _fail_glInvalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glInvalidateNamedFramebufferSubData";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glInvalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLINVALIDATENAMEDFRAMEBUFFERSUBDATA _ptr;
    _ptr = (PFN_GLINVALIDATENAMEDFRAMEBUFFERSUBDATA)_getPrivateProcAddress("glInvalidateNamedFramebufferSubData");
    if (!_ptr) {
        _ptr = &_fail_glInvalidateNamedFramebufferSubData;
    }
    _glInvalidateNamedFramebufferSubData = _ptr;
    _glInvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments, x, y, width, height);
}

PFN_GLINVALIDATENAMEDFRAMEBUFFERSUBDATA _glInvalidateNamedFramebufferSubData = &_get_glInvalidateNamedFramebufferSubData;

static void APIENTRY _fail_glClearNamedFramebufferiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint * value) {
    const char *_name = "glClearNamedFramebufferiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearNamedFramebufferiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint * value) {
    PFN_GLCLEARNAMEDFRAMEBUFFERIV _ptr;
    _ptr = (PFN_GLCLEARNAMEDFRAMEBUFFERIV)_getPrivateProcAddress("glClearNamedFramebufferiv");
    if (!_ptr) {
        _ptr = &_fail_glClearNamedFramebufferiv;
    }
    _glClearNamedFramebufferiv = _ptr;
    _glClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value);
}

PFN_GLCLEARNAMEDFRAMEBUFFERIV _glClearNamedFramebufferiv = &_get_glClearNamedFramebufferiv;

static void APIENTRY _fail_glClearNamedFramebufferuiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint * value) {
    const char *_name = "glClearNamedFramebufferuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearNamedFramebufferuiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint * value) {
    PFN_GLCLEARNAMEDFRAMEBUFFERUIV _ptr;
    _ptr = (PFN_GLCLEARNAMEDFRAMEBUFFERUIV)_getPrivateProcAddress("glClearNamedFramebufferuiv");
    if (!_ptr) {
        _ptr = &_fail_glClearNamedFramebufferuiv;
    }
    _glClearNamedFramebufferuiv = _ptr;
    _glClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value);
}

PFN_GLCLEARNAMEDFRAMEBUFFERUIV _glClearNamedFramebufferuiv = &_get_glClearNamedFramebufferuiv;

static void APIENTRY _fail_glClearNamedFramebufferfv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat * value) {
    const char *_name = "glClearNamedFramebufferfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearNamedFramebufferfv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat * value) {
    PFN_GLCLEARNAMEDFRAMEBUFFERFV _ptr;
    _ptr = (PFN_GLCLEARNAMEDFRAMEBUFFERFV)_getPrivateProcAddress("glClearNamedFramebufferfv");
    if (!_ptr) {
        _ptr = &_fail_glClearNamedFramebufferfv;
    }
    _glClearNamedFramebufferfv = _ptr;
    _glClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value);
}

PFN_GLCLEARNAMEDFRAMEBUFFERFV _glClearNamedFramebufferfv = &_get_glClearNamedFramebufferfv;

static void APIENTRY _fail_glClearNamedFramebufferfi(GLuint framebuffer, GLenum buffer, const GLfloat depth, GLint stencil) {
    const char *_name = "glClearNamedFramebufferfi";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearNamedFramebufferfi(GLuint framebuffer, GLenum buffer, const GLfloat depth, GLint stencil) {
    PFN_GLCLEARNAMEDFRAMEBUFFERFI _ptr;
    _ptr = (PFN_GLCLEARNAMEDFRAMEBUFFERFI)_getPrivateProcAddress("glClearNamedFramebufferfi");
    if (!_ptr) {
        _ptr = &_fail_glClearNamedFramebufferfi;
    }
    _glClearNamedFramebufferfi = _ptr;
    _glClearNamedFramebufferfi(framebuffer, buffer, depth, stencil);
}

PFN_GLCLEARNAMEDFRAMEBUFFERFI _glClearNamedFramebufferfi = &_get_glClearNamedFramebufferfi;

static void APIENTRY _fail_glBlitNamedFramebuffer(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
    const char *_name = "glBlitNamedFramebuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlitNamedFramebuffer(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
    PFN_GLBLITNAMEDFRAMEBUFFER _ptr;
    _ptr = (PFN_GLBLITNAMEDFRAMEBUFFER)_getPrivateProcAddress("glBlitNamedFramebuffer");
    if (!_ptr) {
        _ptr = &_fail_glBlitNamedFramebuffer;
    }
    _glBlitNamedFramebuffer = _ptr;
    _glBlitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

PFN_GLBLITNAMEDFRAMEBUFFER _glBlitNamedFramebuffer = &_get_glBlitNamedFramebuffer;

static GLenum APIENTRY _fail_glCheckNamedFramebufferStatus(GLuint framebuffer, GLenum target) {
    const char *_name = "glCheckNamedFramebufferStatus";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLenum APIENTRY _get_glCheckNamedFramebufferStatus(GLuint framebuffer, GLenum target) {
    PFN_GLCHECKNAMEDFRAMEBUFFERSTATUS _ptr;
    _ptr = (PFN_GLCHECKNAMEDFRAMEBUFFERSTATUS)_getPrivateProcAddress("glCheckNamedFramebufferStatus");
    if (!_ptr) {
        _ptr = &_fail_glCheckNamedFramebufferStatus;
    }
    _glCheckNamedFramebufferStatus = _ptr;
    return _glCheckNamedFramebufferStatus(framebuffer, target);
}

PFN_GLCHECKNAMEDFRAMEBUFFERSTATUS _glCheckNamedFramebufferStatus = &_get_glCheckNamedFramebufferStatus;

static void APIENTRY _fail_glGetNamedFramebufferParameteriv(GLuint framebuffer, GLenum pname, GLint * param) {
    const char *_name = "glGetNamedFramebufferParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedFramebufferParameteriv(GLuint framebuffer, GLenum pname, GLint * param) {
    PFN_GLGETNAMEDFRAMEBUFFERPARAMETERIV _ptr;
    _ptr = (PFN_GLGETNAMEDFRAMEBUFFERPARAMETERIV)_getPrivateProcAddress("glGetNamedFramebufferParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedFramebufferParameteriv;
    }
    _glGetNamedFramebufferParameteriv = _ptr;
    _glGetNamedFramebufferParameteriv(framebuffer, pname, param);
}

PFN_GLGETNAMEDFRAMEBUFFERPARAMETERIV _glGetNamedFramebufferParameteriv = &_get_glGetNamedFramebufferParameteriv;

static void APIENTRY _fail_glGetNamedFramebufferAttachmentParameteriv(GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params) {
    const char *_name = "glGetNamedFramebufferAttachmentParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedFramebufferAttachmentParameteriv(GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params) {
    PFN_GLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIV _ptr;
    _ptr = (PFN_GLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIV)_getPrivateProcAddress("glGetNamedFramebufferAttachmentParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedFramebufferAttachmentParameteriv;
    }
    _glGetNamedFramebufferAttachmentParameteriv = _ptr;
    _glGetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, params);
}

PFN_GLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIV _glGetNamedFramebufferAttachmentParameteriv = &_get_glGetNamedFramebufferAttachmentParameteriv;

static void APIENTRY _fail_glCreateRenderbuffers(GLsizei n, GLuint * renderbuffers) {
    const char *_name = "glCreateRenderbuffers";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCreateRenderbuffers(GLsizei n, GLuint * renderbuffers) {
    PFN_GLCREATERENDERBUFFERS _ptr;
    _ptr = (PFN_GLCREATERENDERBUFFERS)_getPrivateProcAddress("glCreateRenderbuffers");
    if (!_ptr) {
        _ptr = &_fail_glCreateRenderbuffers;
    }
    _glCreateRenderbuffers = _ptr;
    _glCreateRenderbuffers(n, renderbuffers);
}

PFN_GLCREATERENDERBUFFERS _glCreateRenderbuffers = &_get_glCreateRenderbuffers;

static void APIENTRY _fail_glNamedRenderbufferStorage(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glNamedRenderbufferStorage";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedRenderbufferStorage(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height) {
    PFN_GLNAMEDRENDERBUFFERSTORAGE _ptr;
    _ptr = (PFN_GLNAMEDRENDERBUFFERSTORAGE)_getPrivateProcAddress("glNamedRenderbufferStorage");
    if (!_ptr) {
        _ptr = &_fail_glNamedRenderbufferStorage;
    }
    _glNamedRenderbufferStorage = _ptr;
    _glNamedRenderbufferStorage(renderbuffer, internalformat, width, height);
}

PFN_GLNAMEDRENDERBUFFERSTORAGE _glNamedRenderbufferStorage = &_get_glNamedRenderbufferStorage;

static void APIENTRY _fail_glNamedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glNamedRenderbufferStorageMultisample";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    PFN_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLE _ptr;
    _ptr = (PFN_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLE)_getPrivateProcAddress("glNamedRenderbufferStorageMultisample");
    if (!_ptr) {
        _ptr = &_fail_glNamedRenderbufferStorageMultisample;
    }
    _glNamedRenderbufferStorageMultisample = _ptr;
    _glNamedRenderbufferStorageMultisample(renderbuffer, samples, internalformat, width, height);
}

PFN_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLE _glNamedRenderbufferStorageMultisample = &_get_glNamedRenderbufferStorageMultisample;

static void APIENTRY _fail_glGetNamedRenderbufferParameteriv(GLuint renderbuffer, GLenum pname, GLint * params) {
    const char *_name = "glGetNamedRenderbufferParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedRenderbufferParameteriv(GLuint renderbuffer, GLenum pname, GLint * params) {
    PFN_GLGETNAMEDRENDERBUFFERPARAMETERIV _ptr;
    _ptr = (PFN_GLGETNAMEDRENDERBUFFERPARAMETERIV)_getPrivateProcAddress("glGetNamedRenderbufferParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedRenderbufferParameteriv;
    }
    _glGetNamedRenderbufferParameteriv = _ptr;
    _glGetNamedRenderbufferParameteriv(renderbuffer, pname, params);
}

PFN_GLGETNAMEDRENDERBUFFERPARAMETERIV _glGetNamedRenderbufferParameteriv = &_get_glGetNamedRenderbufferParameteriv;

static void APIENTRY _fail_glCreateTextures(GLenum target, GLsizei n, GLuint * textures) {
    const char *_name = "glCreateTextures";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCreateTextures(GLenum target, GLsizei n, GLuint * textures) {
    PFN_GLCREATETEXTURES _ptr;
    _ptr = (PFN_GLCREATETEXTURES)_getPrivateProcAddress("glCreateTextures");
    if (!_ptr) {
        _ptr = &_fail_glCreateTextures;
    }
    _glCreateTextures = _ptr;
    _glCreateTextures(target, n, textures);
}

PFN_GLCREATETEXTURES _glCreateTextures = &_get_glCreateTextures;

static void APIENTRY _fail_glTextureBuffer(GLuint texture, GLenum internalformat, GLuint buffer) {
    const char *_name = "glTextureBuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureBuffer(GLuint texture, GLenum internalformat, GLuint buffer) {
    PFN_GLTEXTUREBUFFER _ptr;
    _ptr = (PFN_GLTEXTUREBUFFER)_getPrivateProcAddress("glTextureBuffer");
    if (!_ptr) {
        _ptr = &_fail_glTextureBuffer;
    }
    _glTextureBuffer = _ptr;
    _glTextureBuffer(texture, internalformat, buffer);
}

PFN_GLTEXTUREBUFFER _glTextureBuffer = &_get_glTextureBuffer;

static void APIENTRY _fail_glTextureBufferRange(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    const char *_name = "glTextureBufferRange";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureBufferRange(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    PFN_GLTEXTUREBUFFERRANGE _ptr;
    _ptr = (PFN_GLTEXTUREBUFFERRANGE)_getPrivateProcAddress("glTextureBufferRange");
    if (!_ptr) {
        _ptr = &_fail_glTextureBufferRange;
    }
    _glTextureBufferRange = _ptr;
    _glTextureBufferRange(texture, internalformat, buffer, offset, size);
}

PFN_GLTEXTUREBUFFERRANGE _glTextureBufferRange = &_get_glTextureBufferRange;

static void APIENTRY _fail_glTextureStorage1D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width) {
    const char *_name = "glTextureStorage1D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureStorage1D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width) {
    PFN_GLTEXTURESTORAGE1D _ptr;
    _ptr = (PFN_GLTEXTURESTORAGE1D)_getPrivateProcAddress("glTextureStorage1D");
    if (!_ptr) {
        _ptr = &_fail_glTextureStorage1D;
    }
    _glTextureStorage1D = _ptr;
    _glTextureStorage1D(texture, levels, internalformat, width);
}

PFN_GLTEXTURESTORAGE1D _glTextureStorage1D = &_get_glTextureStorage1D;

static void APIENTRY _fail_glTextureStorage2D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glTextureStorage2D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureStorage2D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) {
    PFN_GLTEXTURESTORAGE2D _ptr;
    _ptr = (PFN_GLTEXTURESTORAGE2D)_getPrivateProcAddress("glTextureStorage2D");
    if (!_ptr) {
        _ptr = &_fail_glTextureStorage2D;
    }
    _glTextureStorage2D = _ptr;
    _glTextureStorage2D(texture, levels, internalformat, width, height);
}

PFN_GLTEXTURESTORAGE2D _glTextureStorage2D = &_get_glTextureStorage2D;

static void APIENTRY _fail_glTextureStorage3D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) {
    const char *_name = "glTextureStorage3D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureStorage3D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) {
    PFN_GLTEXTURESTORAGE3D _ptr;
    _ptr = (PFN_GLTEXTURESTORAGE3D)_getPrivateProcAddress("glTextureStorage3D");
    if (!_ptr) {
        _ptr = &_fail_glTextureStorage3D;
    }
    _glTextureStorage3D = _ptr;
    _glTextureStorage3D(texture, levels, internalformat, width, height, depth);
}

PFN_GLTEXTURESTORAGE3D _glTextureStorage3D = &_get_glTextureStorage3D;

static void APIENTRY _fail_glTextureStorage2DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
    const char *_name = "glTextureStorage2DMultisample";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureStorage2DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
    PFN_GLTEXTURESTORAGE2DMULTISAMPLE _ptr;
    _ptr = (PFN_GLTEXTURESTORAGE2DMULTISAMPLE)_getPrivateProcAddress("glTextureStorage2DMultisample");
    if (!_ptr) {
        _ptr = &_fail_glTextureStorage2DMultisample;
    }
    _glTextureStorage2DMultisample = _ptr;
    _glTextureStorage2DMultisample(texture, samples, internalformat, width, height, fixedsamplelocations);
}

PFN_GLTEXTURESTORAGE2DMULTISAMPLE _glTextureStorage2DMultisample = &_get_glTextureStorage2DMultisample;

static void APIENTRY _fail_glTextureStorage3DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
    const char *_name = "glTextureStorage3DMultisample";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureStorage3DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
    PFN_GLTEXTURESTORAGE3DMULTISAMPLE _ptr;
    _ptr = (PFN_GLTEXTURESTORAGE3DMULTISAMPLE)_getPrivateProcAddress("glTextureStorage3DMultisample");
    if (!_ptr) {
        _ptr = &_fail_glTextureStorage3DMultisample;
    }
    _glTextureStorage3DMultisample = _ptr;
    _glTextureStorage3DMultisample(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
}

PFN_GLTEXTURESTORAGE3DMULTISAMPLE _glTextureStorage3DMultisample = &_get_glTextureStorage3DMultisample;

static void APIENTRY _fail_glTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels) {
    const char *_name = "glTextureSubImage1D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void * pixels) {
    PFN_GLTEXTURESUBIMAGE1D _ptr;
    _ptr = (PFN_GLTEXTURESUBIMAGE1D)_getPrivateProcAddress("glTextureSubImage1D");
    if (!_ptr) {
        _ptr = &_fail_glTextureSubImage1D;
    }
    _glTextureSubImage1D = _ptr;
    _glTextureSubImage1D(texture, level, xoffset, width, format, type, pixels);
}

PFN_GLTEXTURESUBIMAGE1D _glTextureSubImage1D = &_get_glTextureSubImage1D;

static void APIENTRY _fail_glTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels) {
    const char *_name = "glTextureSubImage2D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * pixels) {
    PFN_GLTEXTURESUBIMAGE2D _ptr;
    _ptr = (PFN_GLTEXTURESUBIMAGE2D)_getPrivateProcAddress("glTextureSubImage2D");
    if (!_ptr) {
        _ptr = &_fail_glTextureSubImage2D;
    }
    _glTextureSubImage2D = _ptr;
    _glTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, pixels);
}

PFN_GLTEXTURESUBIMAGE2D _glTextureSubImage2D = &_get_glTextureSubImage2D;

static void APIENTRY _fail_glTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels) {
    const char *_name = "glTextureSubImage3D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * pixels) {
    PFN_GLTEXTURESUBIMAGE3D _ptr;
    _ptr = (PFN_GLTEXTURESUBIMAGE3D)_getPrivateProcAddress("glTextureSubImage3D");
    if (!_ptr) {
        _ptr = &_fail_glTextureSubImage3D;
    }
    _glTextureSubImage3D = _ptr;
    _glTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

PFN_GLTEXTURESUBIMAGE3D _glTextureSubImage3D = &_get_glTextureSubImage3D;

static void APIENTRY _fail_glCompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data) {
    const char *_name = "glCompressedTextureSubImage1D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void * data) {
    PFN_GLCOMPRESSEDTEXTURESUBIMAGE1D _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXTURESUBIMAGE1D)_getPrivateProcAddress("glCompressedTextureSubImage1D");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTextureSubImage1D;
    }
    _glCompressedTextureSubImage1D = _ptr;
    _glCompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data);
}

PFN_GLCOMPRESSEDTEXTURESUBIMAGE1D _glCompressedTextureSubImage1D = &_get_glCompressedTextureSubImage1D;

static void APIENTRY _fail_glCompressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data) {
    const char *_name = "glCompressedTextureSubImage2D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void * data) {
    PFN_GLCOMPRESSEDTEXTURESUBIMAGE2D _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXTURESUBIMAGE2D)_getPrivateProcAddress("glCompressedTextureSubImage2D");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTextureSubImage2D;
    }
    _glCompressedTextureSubImage2D = _ptr;
    _glCompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
}

PFN_GLCOMPRESSEDTEXTURESUBIMAGE2D _glCompressedTextureSubImage2D = &_get_glCompressedTextureSubImage2D;

static void APIENTRY _fail_glCompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data) {
    const char *_name = "glCompressedTextureSubImage3D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void * data) {
    PFN_GLCOMPRESSEDTEXTURESUBIMAGE3D _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXTURESUBIMAGE3D)_getPrivateProcAddress("glCompressedTextureSubImage3D");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTextureSubImage3D;
    }
    _glCompressedTextureSubImage3D = _ptr;
    _glCompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

PFN_GLCOMPRESSEDTEXTURESUBIMAGE3D _glCompressedTextureSubImage3D = &_get_glCompressedTextureSubImage3D;

static void APIENTRY _fail_glCopyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyTextureSubImage1D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    PFN_GLCOPYTEXTURESUBIMAGE1D _ptr;
    _ptr = (PFN_GLCOPYTEXTURESUBIMAGE1D)_getPrivateProcAddress("glCopyTextureSubImage1D");
    if (!_ptr) {
        _ptr = &_fail_glCopyTextureSubImage1D;
    }
    _glCopyTextureSubImage1D = _ptr;
    _glCopyTextureSubImage1D(texture, level, xoffset, x, y, width);
}

PFN_GLCOPYTEXTURESUBIMAGE1D _glCopyTextureSubImage1D = &_get_glCopyTextureSubImage1D;

static void APIENTRY _fail_glCopyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyTextureSubImage2D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLCOPYTEXTURESUBIMAGE2D _ptr;
    _ptr = (PFN_GLCOPYTEXTURESUBIMAGE2D)_getPrivateProcAddress("glCopyTextureSubImage2D");
    if (!_ptr) {
        _ptr = &_fail_glCopyTextureSubImage2D;
    }
    _glCopyTextureSubImage2D = _ptr;
    _glCopyTextureSubImage2D(texture, level, xoffset, yoffset, x, y, width, height);
}

PFN_GLCOPYTEXTURESUBIMAGE2D _glCopyTextureSubImage2D = &_get_glCopyTextureSubImage2D;

static void APIENTRY _fail_glCopyTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyTextureSubImage3D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLCOPYTEXTURESUBIMAGE3D _ptr;
    _ptr = (PFN_GLCOPYTEXTURESUBIMAGE3D)_getPrivateProcAddress("glCopyTextureSubImage3D");
    if (!_ptr) {
        _ptr = &_fail_glCopyTextureSubImage3D;
    }
    _glCopyTextureSubImage3D = _ptr;
    _glCopyTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
}

PFN_GLCOPYTEXTURESUBIMAGE3D _glCopyTextureSubImage3D = &_get_glCopyTextureSubImage3D;

static void APIENTRY _fail_glTextureParameterf(GLuint texture, GLenum pname, GLfloat param) {
    const char *_name = "glTextureParameterf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureParameterf(GLuint texture, GLenum pname, GLfloat param) {
    PFN_GLTEXTUREPARAMETERF _ptr;
    _ptr = (PFN_GLTEXTUREPARAMETERF)_getPrivateProcAddress("glTextureParameterf");
    if (!_ptr) {
        _ptr = &_fail_glTextureParameterf;
    }
    _glTextureParameterf = _ptr;
    _glTextureParameterf(texture, pname, param);
}

PFN_GLTEXTUREPARAMETERF _glTextureParameterf = &_get_glTextureParameterf;

static void APIENTRY _fail_glTextureParameterfv(GLuint texture, GLenum pname, const GLfloat * params) {
    const char *_name = "glTextureParameterfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureParameterfv(GLuint texture, GLenum pname, const GLfloat * params) {
    PFN_GLTEXTUREPARAMETERFV _ptr;
    _ptr = (PFN_GLTEXTUREPARAMETERFV)_getPrivateProcAddress("glTextureParameterfv");
    if (!_ptr) {
        _ptr = &_fail_glTextureParameterfv;
    }
    _glTextureParameterfv = _ptr;
    _glTextureParameterfv(texture, pname, params);
}

PFN_GLTEXTUREPARAMETERFV _glTextureParameterfv = &_get_glTextureParameterfv;

static void APIENTRY _fail_glTextureParameteri(GLuint texture, GLenum pname, GLint param) {
    const char *_name = "glTextureParameteri";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureParameteri(GLuint texture, GLenum pname, GLint param) {
    PFN_GLTEXTUREPARAMETERI _ptr;
    _ptr = (PFN_GLTEXTUREPARAMETERI)_getPrivateProcAddress("glTextureParameteri");
    if (!_ptr) {
        _ptr = &_fail_glTextureParameteri;
    }
    _glTextureParameteri = _ptr;
    _glTextureParameteri(texture, pname, param);
}

PFN_GLTEXTUREPARAMETERI _glTextureParameteri = &_get_glTextureParameteri;

static void APIENTRY _fail_glTextureParameterIiv(GLuint texture, GLenum pname, const GLint * params) {
    const char *_name = "glTextureParameterIiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureParameterIiv(GLuint texture, GLenum pname, const GLint * params) {
    PFN_GLTEXTUREPARAMETERIIV _ptr;
    _ptr = (PFN_GLTEXTUREPARAMETERIIV)_getPrivateProcAddress("glTextureParameterIiv");
    if (!_ptr) {
        _ptr = &_fail_glTextureParameterIiv;
    }
    _glTextureParameterIiv = _ptr;
    _glTextureParameterIiv(texture, pname, params);
}

PFN_GLTEXTUREPARAMETERIIV _glTextureParameterIiv = &_get_glTextureParameterIiv;

static void APIENTRY _fail_glTextureParameterIuiv(GLuint texture, GLenum pname, const GLuint * params) {
    const char *_name = "glTextureParameterIuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureParameterIuiv(GLuint texture, GLenum pname, const GLuint * params) {
    PFN_GLTEXTUREPARAMETERIUIV _ptr;
    _ptr = (PFN_GLTEXTUREPARAMETERIUIV)_getPrivateProcAddress("glTextureParameterIuiv");
    if (!_ptr) {
        _ptr = &_fail_glTextureParameterIuiv;
    }
    _glTextureParameterIuiv = _ptr;
    _glTextureParameterIuiv(texture, pname, params);
}

PFN_GLTEXTUREPARAMETERIUIV _glTextureParameterIuiv = &_get_glTextureParameterIuiv;

static void APIENTRY _fail_glTextureParameteriv(GLuint texture, GLenum pname, const GLint * params) {
    const char *_name = "glTextureParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureParameteriv(GLuint texture, GLenum pname, const GLint * params) {
    PFN_GLTEXTUREPARAMETERIV _ptr;
    _ptr = (PFN_GLTEXTUREPARAMETERIV)_getPrivateProcAddress("glTextureParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glTextureParameteriv;
    }
    _glTextureParameteriv = _ptr;
    _glTextureParameteriv(texture, pname, params);
}

PFN_GLTEXTUREPARAMETERIV _glTextureParameteriv = &_get_glTextureParameteriv;

static void APIENTRY _fail_glGenerateTextureMipmap(GLuint texture) {
    const char *_name = "glGenerateTextureMipmap";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenerateTextureMipmap(GLuint texture) {
    PFN_GLGENERATETEXTUREMIPMAP _ptr;
    _ptr = (PFN_GLGENERATETEXTUREMIPMAP)_getPrivateProcAddress("glGenerateTextureMipmap");
    if (!_ptr) {
        _ptr = &_fail_glGenerateTextureMipmap;
    }
    _glGenerateTextureMipmap = _ptr;
    _glGenerateTextureMipmap(texture);
}

PFN_GLGENERATETEXTUREMIPMAP _glGenerateTextureMipmap = &_get_glGenerateTextureMipmap;

static void APIENTRY _fail_glBindTextureUnit(GLuint unit, GLuint texture) {
    const char *_name = "glBindTextureUnit";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindTextureUnit(GLuint unit, GLuint texture) {
    PFN_GLBINDTEXTUREUNIT _ptr;
    _ptr = (PFN_GLBINDTEXTUREUNIT)_getPrivateProcAddress("glBindTextureUnit");
    if (!_ptr) {
        _ptr = &_fail_glBindTextureUnit;
    }
    _glBindTextureUnit = _ptr;
    _glBindTextureUnit(unit, texture);
}

PFN_GLBINDTEXTUREUNIT _glBindTextureUnit = &_get_glBindTextureUnit;

static void APIENTRY _fail_glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid * pixels) {
    const char *_name = "glGetTextureImage";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid * pixels) {
    PFN_GLGETTEXTUREIMAGE _ptr;
    _ptr = (PFN_GLGETTEXTUREIMAGE)_getPrivateProcAddress("glGetTextureImage");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureImage;
    }
    _glGetTextureImage = _ptr;
    _glGetTextureImage(texture, level, format, type, bufSize, pixels);
}

PFN_GLGETTEXTUREIMAGE _glGetTextureImage = &_get_glGetTextureImage;

static void APIENTRY _fail_glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, GLvoid * pixels) {
    const char *_name = "glGetCompressedTextureImage";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, GLvoid * pixels) {
    PFN_GLGETCOMPRESSEDTEXTUREIMAGE _ptr;
    _ptr = (PFN_GLGETCOMPRESSEDTEXTUREIMAGE)_getPrivateProcAddress("glGetCompressedTextureImage");
    if (!_ptr) {
        _ptr = &_fail_glGetCompressedTextureImage;
    }
    _glGetCompressedTextureImage = _ptr;
    _glGetCompressedTextureImage(texture, level, bufSize, pixels);
}

PFN_GLGETCOMPRESSEDTEXTUREIMAGE _glGetCompressedTextureImage = &_get_glGetCompressedTextureImage;

static void APIENTRY _fail_glGetTextureLevelParameterfv(GLuint texture, GLint level, GLenum pname, GLfloat * params) {
    const char *_name = "glGetTextureLevelParameterfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTextureLevelParameterfv(GLuint texture, GLint level, GLenum pname, GLfloat * params) {
    PFN_GLGETTEXTURELEVELPARAMETERFV _ptr;
    _ptr = (PFN_GLGETTEXTURELEVELPARAMETERFV)_getPrivateProcAddress("glGetTextureLevelParameterfv");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureLevelParameterfv;
    }
    _glGetTextureLevelParameterfv = _ptr;
    _glGetTextureLevelParameterfv(texture, level, pname, params);
}

PFN_GLGETTEXTURELEVELPARAMETERFV _glGetTextureLevelParameterfv = &_get_glGetTextureLevelParameterfv;

static void APIENTRY _fail_glGetTextureLevelParameteriv(GLuint texture, GLint level, GLenum pname, GLint * params) {
    const char *_name = "glGetTextureLevelParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTextureLevelParameteriv(GLuint texture, GLint level, GLenum pname, GLint * params) {
    PFN_GLGETTEXTURELEVELPARAMETERIV _ptr;
    _ptr = (PFN_GLGETTEXTURELEVELPARAMETERIV)_getPrivateProcAddress("glGetTextureLevelParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureLevelParameteriv;
    }
    _glGetTextureLevelParameteriv = _ptr;
    _glGetTextureLevelParameteriv(texture, level, pname, params);
}

PFN_GLGETTEXTURELEVELPARAMETERIV _glGetTextureLevelParameteriv = &_get_glGetTextureLevelParameteriv;

static void APIENTRY _fail_glGetTextureParameterfv(GLuint texture, GLenum pname, GLfloat * params) {
    const char *_name = "glGetTextureParameterfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTextureParameterfv(GLuint texture, GLenum pname, GLfloat * params) {
    PFN_GLGETTEXTUREPARAMETERFV _ptr;
    _ptr = (PFN_GLGETTEXTUREPARAMETERFV)_getPrivateProcAddress("glGetTextureParameterfv");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureParameterfv;
    }
    _glGetTextureParameterfv = _ptr;
    _glGetTextureParameterfv(texture, pname, params);
}

PFN_GLGETTEXTUREPARAMETERFV _glGetTextureParameterfv = &_get_glGetTextureParameterfv;

static void APIENTRY _fail_glGetTextureParameterIiv(GLuint texture, GLenum pname, GLint * params) {
    const char *_name = "glGetTextureParameterIiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTextureParameterIiv(GLuint texture, GLenum pname, GLint * params) {
    PFN_GLGETTEXTUREPARAMETERIIV _ptr;
    _ptr = (PFN_GLGETTEXTUREPARAMETERIIV)_getPrivateProcAddress("glGetTextureParameterIiv");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureParameterIiv;
    }
    _glGetTextureParameterIiv = _ptr;
    _glGetTextureParameterIiv(texture, pname, params);
}

PFN_GLGETTEXTUREPARAMETERIIV _glGetTextureParameterIiv = &_get_glGetTextureParameterIiv;

static void APIENTRY _fail_glGetTextureParameterIuiv(GLuint texture, GLenum pname, GLuint * params) {
    const char *_name = "glGetTextureParameterIuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTextureParameterIuiv(GLuint texture, GLenum pname, GLuint * params) {
    PFN_GLGETTEXTUREPARAMETERIUIV _ptr;
    _ptr = (PFN_GLGETTEXTUREPARAMETERIUIV)_getPrivateProcAddress("glGetTextureParameterIuiv");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureParameterIuiv;
    }
    _glGetTextureParameterIuiv = _ptr;
    _glGetTextureParameterIuiv(texture, pname, params);
}

PFN_GLGETTEXTUREPARAMETERIUIV _glGetTextureParameterIuiv = &_get_glGetTextureParameterIuiv;

static void APIENTRY _fail_glGetTextureParameteriv(GLuint texture, GLenum pname, GLint * params) {
    const char *_name = "glGetTextureParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTextureParameteriv(GLuint texture, GLenum pname, GLint * params) {
    PFN_GLGETTEXTUREPARAMETERIV _ptr;
    _ptr = (PFN_GLGETTEXTUREPARAMETERIV)_getPrivateProcAddress("glGetTextureParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureParameteriv;
    }
    _glGetTextureParameteriv = _ptr;
    _glGetTextureParameteriv(texture, pname, params);
}

PFN_GLGETTEXTUREPARAMETERIV _glGetTextureParameteriv = &_get_glGetTextureParameteriv;

static void APIENTRY _fail_glCreateVertexArrays(GLsizei n, GLuint * arrays) {
    const char *_name = "glCreateVertexArrays";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCreateVertexArrays(GLsizei n, GLuint * arrays) {
    PFN_GLCREATEVERTEXARRAYS _ptr;
    _ptr = (PFN_GLCREATEVERTEXARRAYS)_getPrivateProcAddress("glCreateVertexArrays");
    if (!_ptr) {
        _ptr = &_fail_glCreateVertexArrays;
    }
    _glCreateVertexArrays = _ptr;
    _glCreateVertexArrays(n, arrays);
}

PFN_GLCREATEVERTEXARRAYS _glCreateVertexArrays = &_get_glCreateVertexArrays;

static void APIENTRY _fail_glDisableVertexArrayAttrib(GLuint vaobj, GLuint index) {
    const char *_name = "glDisableVertexArrayAttrib";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDisableVertexArrayAttrib(GLuint vaobj, GLuint index) {
    PFN_GLDISABLEVERTEXARRAYATTRIB _ptr;
    _ptr = (PFN_GLDISABLEVERTEXARRAYATTRIB)_getPrivateProcAddress("glDisableVertexArrayAttrib");
    if (!_ptr) {
        _ptr = &_fail_glDisableVertexArrayAttrib;
    }
    _glDisableVertexArrayAttrib = _ptr;
    _glDisableVertexArrayAttrib(vaobj, index);
}

PFN_GLDISABLEVERTEXARRAYATTRIB _glDisableVertexArrayAttrib = &_get_glDisableVertexArrayAttrib;

static void APIENTRY _fail_glEnableVertexArrayAttrib(GLuint vaobj, GLuint index) {
    const char *_name = "glEnableVertexArrayAttrib";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEnableVertexArrayAttrib(GLuint vaobj, GLuint index) {
    PFN_GLENABLEVERTEXARRAYATTRIB _ptr;
    _ptr = (PFN_GLENABLEVERTEXARRAYATTRIB)_getPrivateProcAddress("glEnableVertexArrayAttrib");
    if (!_ptr) {
        _ptr = &_fail_glEnableVertexArrayAttrib;
    }
    _glEnableVertexArrayAttrib = _ptr;
    _glEnableVertexArrayAttrib(vaobj, index);
}

PFN_GLENABLEVERTEXARRAYATTRIB _glEnableVertexArrayAttrib = &_get_glEnableVertexArrayAttrib;

static void APIENTRY _fail_glVertexArrayElementBuffer(GLuint vaobj, GLuint buffer) {
    const char *_name = "glVertexArrayElementBuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayElementBuffer(GLuint vaobj, GLuint buffer) {
    PFN_GLVERTEXARRAYELEMENTBUFFER _ptr;
    _ptr = (PFN_GLVERTEXARRAYELEMENTBUFFER)_getPrivateProcAddress("glVertexArrayElementBuffer");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayElementBuffer;
    }
    _glVertexArrayElementBuffer = _ptr;
    _glVertexArrayElementBuffer(vaobj, buffer);
}

PFN_GLVERTEXARRAYELEMENTBUFFER _glVertexArrayElementBuffer = &_get_glVertexArrayElementBuffer;

static void APIENTRY _fail_glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) {
    const char *_name = "glVertexArrayVertexBuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) {
    PFN_GLVERTEXARRAYVERTEXBUFFER _ptr;
    _ptr = (PFN_GLVERTEXARRAYVERTEXBUFFER)_getPrivateProcAddress("glVertexArrayVertexBuffer");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayVertexBuffer;
    }
    _glVertexArrayVertexBuffer = _ptr;
    _glVertexArrayVertexBuffer(vaobj, bindingindex, buffer, offset, stride);
}

PFN_GLVERTEXARRAYVERTEXBUFFER _glVertexArrayVertexBuffer = &_get_glVertexArrayVertexBuffer;

static void APIENTRY _fail_glVertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides) {
    const char *_name = "glVertexArrayVertexBuffers";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides) {
    PFN_GLVERTEXARRAYVERTEXBUFFERS _ptr;
    _ptr = (PFN_GLVERTEXARRAYVERTEXBUFFERS)_getPrivateProcAddress("glVertexArrayVertexBuffers");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayVertexBuffers;
    }
    _glVertexArrayVertexBuffers = _ptr;
    _glVertexArrayVertexBuffers(vaobj, first, count, buffers, offsets, strides);
}

PFN_GLVERTEXARRAYVERTEXBUFFERS _glVertexArrayVertexBuffers = &_get_glVertexArrayVertexBuffers;

static void APIENTRY _fail_glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex) {
    const char *_name = "glVertexArrayAttribBinding";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex) {
    PFN_GLVERTEXARRAYATTRIBBINDING _ptr;
    _ptr = (PFN_GLVERTEXARRAYATTRIBBINDING)_getPrivateProcAddress("glVertexArrayAttribBinding");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayAttribBinding;
    }
    _glVertexArrayAttribBinding = _ptr;
    _glVertexArrayAttribBinding(vaobj, attribindex, bindingindex);
}

PFN_GLVERTEXARRAYATTRIBBINDING _glVertexArrayAttribBinding = &_get_glVertexArrayAttribBinding;

static void APIENTRY _fail_glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) {
    const char *_name = "glVertexArrayAttribFormat";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) {
    PFN_GLVERTEXARRAYATTRIBFORMAT _ptr;
    _ptr = (PFN_GLVERTEXARRAYATTRIBFORMAT)_getPrivateProcAddress("glVertexArrayAttribFormat");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayAttribFormat;
    }
    _glVertexArrayAttribFormat = _ptr;
    _glVertexArrayAttribFormat(vaobj, attribindex, size, type, normalized, relativeoffset);
}

PFN_GLVERTEXARRAYATTRIBFORMAT _glVertexArrayAttribFormat = &_get_glVertexArrayAttribFormat;

static void APIENTRY _fail_glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
    const char *_name = "glVertexArrayAttribIFormat";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
    PFN_GLVERTEXARRAYATTRIBIFORMAT _ptr;
    _ptr = (PFN_GLVERTEXARRAYATTRIBIFORMAT)_getPrivateProcAddress("glVertexArrayAttribIFormat");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayAttribIFormat;
    }
    _glVertexArrayAttribIFormat = _ptr;
    _glVertexArrayAttribIFormat(vaobj, attribindex, size, type, relativeoffset);
}

PFN_GLVERTEXARRAYATTRIBIFORMAT _glVertexArrayAttribIFormat = &_get_glVertexArrayAttribIFormat;

static void APIENTRY _fail_glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
    const char *_name = "glVertexArrayAttribLFormat";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
    PFN_GLVERTEXARRAYATTRIBLFORMAT _ptr;
    _ptr = (PFN_GLVERTEXARRAYATTRIBLFORMAT)_getPrivateProcAddress("glVertexArrayAttribLFormat");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayAttribLFormat;
    }
    _glVertexArrayAttribLFormat = _ptr;
    _glVertexArrayAttribLFormat(vaobj, attribindex, size, type, relativeoffset);
}

PFN_GLVERTEXARRAYATTRIBLFORMAT _glVertexArrayAttribLFormat = &_get_glVertexArrayAttribLFormat;

static void APIENTRY _fail_glVertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor) {
    const char *_name = "glVertexArrayBindingDivisor";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor) {
    PFN_GLVERTEXARRAYBINDINGDIVISOR _ptr;
    _ptr = (PFN_GLVERTEXARRAYBINDINGDIVISOR)_getPrivateProcAddress("glVertexArrayBindingDivisor");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayBindingDivisor;
    }
    _glVertexArrayBindingDivisor = _ptr;
    _glVertexArrayBindingDivisor(vaobj, bindingindex, divisor);
}

PFN_GLVERTEXARRAYBINDINGDIVISOR _glVertexArrayBindingDivisor = &_get_glVertexArrayBindingDivisor;

static void APIENTRY _fail_glGetVertexArrayiv(GLuint vaobj, GLenum pname, GLint * param) {
    const char *_name = "glGetVertexArrayiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexArrayiv(GLuint vaobj, GLenum pname, GLint * param) {
    PFN_GLGETVERTEXARRAYIV _ptr;
    _ptr = (PFN_GLGETVERTEXARRAYIV)_getPrivateProcAddress("glGetVertexArrayiv");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexArrayiv;
    }
    _glGetVertexArrayiv = _ptr;
    _glGetVertexArrayiv(vaobj, pname, param);
}

PFN_GLGETVERTEXARRAYIV _glGetVertexArrayiv = &_get_glGetVertexArrayiv;

static void APIENTRY _fail_glGetVertexArrayIndexediv(GLuint vaobj, GLuint index, GLenum pname, GLint * param) {
    const char *_name = "glGetVertexArrayIndexediv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexArrayIndexediv(GLuint vaobj, GLuint index, GLenum pname, GLint * param) {
    PFN_GLGETVERTEXARRAYINDEXEDIV _ptr;
    _ptr = (PFN_GLGETVERTEXARRAYINDEXEDIV)_getPrivateProcAddress("glGetVertexArrayIndexediv");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexArrayIndexediv;
    }
    _glGetVertexArrayIndexediv = _ptr;
    _glGetVertexArrayIndexediv(vaobj, index, pname, param);
}

PFN_GLGETVERTEXARRAYINDEXEDIV _glGetVertexArrayIndexediv = &_get_glGetVertexArrayIndexediv;

static void APIENTRY _fail_glGetVertexArrayIndexed64iv(GLuint vaobj, GLuint index, GLenum pname, GLint64 * param) {
    const char *_name = "glGetVertexArrayIndexed64iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexArrayIndexed64iv(GLuint vaobj, GLuint index, GLenum pname, GLint64 * param) {
    PFN_GLGETVERTEXARRAYINDEXED64IV _ptr;
    _ptr = (PFN_GLGETVERTEXARRAYINDEXED64IV)_getPrivateProcAddress("glGetVertexArrayIndexed64iv");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexArrayIndexed64iv;
    }
    _glGetVertexArrayIndexed64iv = _ptr;
    _glGetVertexArrayIndexed64iv(vaobj, index, pname, param);
}

PFN_GLGETVERTEXARRAYINDEXED64IV _glGetVertexArrayIndexed64iv = &_get_glGetVertexArrayIndexed64iv;

static void APIENTRY _fail_glCreateSamplers(GLsizei n, GLuint * samplers) {
    const char *_name = "glCreateSamplers";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCreateSamplers(GLsizei n, GLuint * samplers) {
    PFN_GLCREATESAMPLERS _ptr;
    _ptr = (PFN_GLCREATESAMPLERS)_getPrivateProcAddress("glCreateSamplers");
    if (!_ptr) {
        _ptr = &_fail_glCreateSamplers;
    }
    _glCreateSamplers = _ptr;
    _glCreateSamplers(n, samplers);
}

PFN_GLCREATESAMPLERS _glCreateSamplers = &_get_glCreateSamplers;

static void APIENTRY _fail_glCreateProgramPipelines(GLsizei n, GLuint * pipelines) {
    const char *_name = "glCreateProgramPipelines";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCreateProgramPipelines(GLsizei n, GLuint * pipelines) {
    PFN_GLCREATEPROGRAMPIPELINES _ptr;
    _ptr = (PFN_GLCREATEPROGRAMPIPELINES)_getPrivateProcAddress("glCreateProgramPipelines");
    if (!_ptr) {
        _ptr = &_fail_glCreateProgramPipelines;
    }
    _glCreateProgramPipelines = _ptr;
    _glCreateProgramPipelines(n, pipelines);
}

PFN_GLCREATEPROGRAMPIPELINES _glCreateProgramPipelines = &_get_glCreateProgramPipelines;

static void APIENTRY _fail_glCreateQueries(GLenum target, GLsizei n, GLuint * ids) {
    const char *_name = "glCreateQueries";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCreateQueries(GLenum target, GLsizei n, GLuint * ids) {
    PFN_GLCREATEQUERIES _ptr;
    _ptr = (PFN_GLCREATEQUERIES)_getPrivateProcAddress("glCreateQueries");
    if (!_ptr) {
        _ptr = &_fail_glCreateQueries;
    }
    _glCreateQueries = _ptr;
    _glCreateQueries(target, n, ids);
}

PFN_GLCREATEQUERIES _glCreateQueries = &_get_glCreateQueries;

static void APIENTRY _fail_glGetQueryBufferObjecti64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) {
    const char *_name = "glGetQueryBufferObjecti64v";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryBufferObjecti64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) {
    PFN_GLGETQUERYBUFFEROBJECTI64V _ptr;
    _ptr = (PFN_GLGETQUERYBUFFEROBJECTI64V)_getPrivateProcAddress("glGetQueryBufferObjecti64v");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryBufferObjecti64v;
    }
    _glGetQueryBufferObjecti64v = _ptr;
    _glGetQueryBufferObjecti64v(id, buffer, pname, offset);
}

PFN_GLGETQUERYBUFFEROBJECTI64V _glGetQueryBufferObjecti64v = &_get_glGetQueryBufferObjecti64v;

static void APIENTRY _fail_glGetQueryBufferObjectiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) {
    const char *_name = "glGetQueryBufferObjectiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryBufferObjectiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) {
    PFN_GLGETQUERYBUFFEROBJECTIV _ptr;
    _ptr = (PFN_GLGETQUERYBUFFEROBJECTIV)_getPrivateProcAddress("glGetQueryBufferObjectiv");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryBufferObjectiv;
    }
    _glGetQueryBufferObjectiv = _ptr;
    _glGetQueryBufferObjectiv(id, buffer, pname, offset);
}

PFN_GLGETQUERYBUFFEROBJECTIV _glGetQueryBufferObjectiv = &_get_glGetQueryBufferObjectiv;

static void APIENTRY _fail_glGetQueryBufferObjectui64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) {
    const char *_name = "glGetQueryBufferObjectui64v";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryBufferObjectui64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) {
    PFN_GLGETQUERYBUFFEROBJECTUI64V _ptr;
    _ptr = (PFN_GLGETQUERYBUFFEROBJECTUI64V)_getPrivateProcAddress("glGetQueryBufferObjectui64v");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryBufferObjectui64v;
    }
    _glGetQueryBufferObjectui64v = _ptr;
    _glGetQueryBufferObjectui64v(id, buffer, pname, offset);
}

PFN_GLGETQUERYBUFFEROBJECTUI64V _glGetQueryBufferObjectui64v = &_get_glGetQueryBufferObjectui64v;

static void APIENTRY _fail_glGetQueryBufferObjectuiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) {
    const char *_name = "glGetQueryBufferObjectuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryBufferObjectuiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) {
    PFN_GLGETQUERYBUFFEROBJECTUIV _ptr;
    _ptr = (PFN_GLGETQUERYBUFFEROBJECTUIV)_getPrivateProcAddress("glGetQueryBufferObjectuiv");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryBufferObjectuiv;
    }
    _glGetQueryBufferObjectuiv = _ptr;
    _glGetQueryBufferObjectuiv(id, buffer, pname, offset);
}

PFN_GLGETQUERYBUFFEROBJECTUIV _glGetQueryBufferObjectuiv = &_get_glGetQueryBufferObjectuiv;

static void APIENTRY _fail_glDrawBuffersARB(GLsizei n, const GLenum * bufs) {
    const char *_name = "glDrawBuffersARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawBuffersARB(GLsizei n, const GLenum * bufs) {
    PFN_GLDRAWBUFFERSARB _ptr;
    _ptr = (PFN_GLDRAWBUFFERSARB)_getPrivateProcAddress("glDrawBuffersARB");
    if (!_ptr) {
        _ptr = &_fail_glDrawBuffersARB;
    }
    _glDrawBuffersARB = _ptr;
    _glDrawBuffersARB(n, bufs);
}

PFN_GLDRAWBUFFERSARB _glDrawBuffersARB = &_get_glDrawBuffersARB;

static void APIENTRY _fail_glBlendEquationiARB(GLuint buf, GLenum mode) {
    const char *_name = "glBlendEquationiARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendEquationiARB(GLuint buf, GLenum mode) {
    PFN_GLBLENDEQUATIONIARB _ptr;
    _ptr = (PFN_GLBLENDEQUATIONIARB)_getPrivateProcAddress("glBlendEquationiARB");
    if (!_ptr) {
        _ptr = &_fail_glBlendEquationiARB;
    }
    _glBlendEquationiARB = _ptr;
    _glBlendEquationiARB(buf, mode);
}

PFN_GLBLENDEQUATIONIARB _glBlendEquationiARB = &_get_glBlendEquationiARB;

static void APIENTRY _fail_glBlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeAlpha) {
    const char *_name = "glBlendEquationSeparateiARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeAlpha) {
    PFN_GLBLENDEQUATIONSEPARATEIARB _ptr;
    _ptr = (PFN_GLBLENDEQUATIONSEPARATEIARB)_getPrivateProcAddress("glBlendEquationSeparateiARB");
    if (!_ptr) {
        _ptr = &_fail_glBlendEquationSeparateiARB;
    }
    _glBlendEquationSeparateiARB = _ptr;
    _glBlendEquationSeparateiARB(buf, modeRGB, modeAlpha);
}

PFN_GLBLENDEQUATIONSEPARATEIARB _glBlendEquationSeparateiARB = &_get_glBlendEquationSeparateiARB;

static void APIENTRY _fail_glBlendFunciARB(GLuint buf, GLenum src, GLenum dst) {
    const char *_name = "glBlendFunciARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendFunciARB(GLuint buf, GLenum src, GLenum dst) {
    PFN_GLBLENDFUNCIARB _ptr;
    _ptr = (PFN_GLBLENDFUNCIARB)_getPrivateProcAddress("glBlendFunciARB");
    if (!_ptr) {
        _ptr = &_fail_glBlendFunciARB;
    }
    _glBlendFunciARB = _ptr;
    _glBlendFunciARB(buf, src, dst);
}

PFN_GLBLENDFUNCIARB _glBlendFunciARB = &_get_glBlendFunciARB;

static void APIENTRY _fail_glBlendFuncSeparateiARB(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) {
    const char *_name = "glBlendFuncSeparateiARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendFuncSeparateiARB(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) {
    PFN_GLBLENDFUNCSEPARATEIARB _ptr;
    _ptr = (PFN_GLBLENDFUNCSEPARATEIARB)_getPrivateProcAddress("glBlendFuncSeparateiARB");
    if (!_ptr) {
        _ptr = &_fail_glBlendFuncSeparateiARB;
    }
    _glBlendFuncSeparateiARB = _ptr;
    _glBlendFuncSeparateiARB(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

PFN_GLBLENDFUNCSEPARATEIARB _glBlendFuncSeparateiARB = &_get_glBlendFuncSeparateiARB;

static void APIENTRY _fail_glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLint basevertex) {
    const char *_name = "glDrawElementsBaseVertex";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLint basevertex) {
    PFN_GLDRAWELEMENTSBASEVERTEX _ptr;
    _ptr = (PFN_GLDRAWELEMENTSBASEVERTEX)_getPrivateProcAddress("glDrawElementsBaseVertex");
    if (!_ptr) {
        _ptr = &_fail_glDrawElementsBaseVertex;
    }
    _glDrawElementsBaseVertex = _ptr;
    _glDrawElementsBaseVertex(mode, count, type, indices, basevertex);
}

PFN_GLDRAWELEMENTSBASEVERTEX _glDrawElementsBaseVertex = &_get_glDrawElementsBaseVertex;

static void APIENTRY _fail_glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices, GLint basevertex) {
    const char *_name = "glDrawRangeElementsBaseVertex";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices, GLint basevertex) {
    PFN_GLDRAWRANGEELEMENTSBASEVERTEX _ptr;
    _ptr = (PFN_GLDRAWRANGEELEMENTSBASEVERTEX)_getPrivateProcAddress("glDrawRangeElementsBaseVertex");
    if (!_ptr) {
        _ptr = &_fail_glDrawRangeElementsBaseVertex;
    }
    _glDrawRangeElementsBaseVertex = _ptr;
    _glDrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex);
}

PFN_GLDRAWRANGEELEMENTSBASEVERTEX _glDrawRangeElementsBaseVertex = &_get_glDrawRangeElementsBaseVertex;

static void APIENTRY _fail_glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount, GLint basevertex) {
    const char *_name = "glDrawElementsInstancedBaseVertex";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount, GLint basevertex) {
    PFN_GLDRAWELEMENTSINSTANCEDBASEVERTEX _ptr;
    _ptr = (PFN_GLDRAWELEMENTSINSTANCEDBASEVERTEX)_getPrivateProcAddress("glDrawElementsInstancedBaseVertex");
    if (!_ptr) {
        _ptr = &_fail_glDrawElementsInstancedBaseVertex;
    }
    _glDrawElementsInstancedBaseVertex = _ptr;
    _glDrawElementsInstancedBaseVertex(mode, count, type, indices, primcount, basevertex);
}

PFN_GLDRAWELEMENTSINSTANCEDBASEVERTEX _glDrawElementsInstancedBaseVertex = &_get_glDrawElementsInstancedBaseVertex;

static void APIENTRY _fail_glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei drawcount, const GLint * basevertex) {
    const char *_name = "glMultiDrawElementsBaseVertex";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei drawcount, const GLint * basevertex) {
    PFN_GLMULTIDRAWELEMENTSBASEVERTEX _ptr;
    _ptr = (PFN_GLMULTIDRAWELEMENTSBASEVERTEX)_getPrivateProcAddress("glMultiDrawElementsBaseVertex");
    if (!_ptr) {
        _ptr = &_fail_glMultiDrawElementsBaseVertex;
    }
    _glMultiDrawElementsBaseVertex = _ptr;
    _glMultiDrawElementsBaseVertex(mode, count, type, indices, drawcount, basevertex);
}

PFN_GLMULTIDRAWELEMENTSBASEVERTEX _glMultiDrawElementsBaseVertex = &_get_glMultiDrawElementsBaseVertex;

static void APIENTRY _fail_glDrawArraysIndirect(GLenum mode, const GLvoid * indirect) {
    const char *_name = "glDrawArraysIndirect";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawArraysIndirect(GLenum mode, const GLvoid * indirect) {
    PFN_GLDRAWARRAYSINDIRECT _ptr;
    _ptr = (PFN_GLDRAWARRAYSINDIRECT)_getPrivateProcAddress("glDrawArraysIndirect");
    if (!_ptr) {
        _ptr = &_fail_glDrawArraysIndirect;
    }
    _glDrawArraysIndirect = _ptr;
    _glDrawArraysIndirect(mode, indirect);
}

PFN_GLDRAWARRAYSINDIRECT _glDrawArraysIndirect = &_get_glDrawArraysIndirect;

static void APIENTRY _fail_glDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid * indirect) {
    const char *_name = "glDrawElementsIndirect";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid * indirect) {
    PFN_GLDRAWELEMENTSINDIRECT _ptr;
    _ptr = (PFN_GLDRAWELEMENTSINDIRECT)_getPrivateProcAddress("glDrawElementsIndirect");
    if (!_ptr) {
        _ptr = &_fail_glDrawElementsIndirect;
    }
    _glDrawElementsIndirect = _ptr;
    _glDrawElementsIndirect(mode, type, indirect);
}

PFN_GLDRAWELEMENTSINDIRECT _glDrawElementsIndirect = &_get_glDrawElementsIndirect;

static void APIENTRY _fail_glDrawArraysInstancedARB(GLenum mode, GLint first, GLsizei count, GLsizei primcount) {
    const char *_name = "glDrawArraysInstancedARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawArraysInstancedARB(GLenum mode, GLint first, GLsizei count, GLsizei primcount) {
    PFN_GLDRAWARRAYSINSTANCEDARB _ptr;
    _ptr = (PFN_GLDRAWARRAYSINSTANCEDARB)_getPrivateProcAddress("glDrawArraysInstancedARB");
    if (!_ptr) {
        _ptr = &_fail_glDrawArraysInstancedARB;
    }
    _glDrawArraysInstancedARB = _ptr;
    _glDrawArraysInstancedARB(mode, first, count, primcount);
}

PFN_GLDRAWARRAYSINSTANCEDARB _glDrawArraysInstancedARB = &_get_glDrawArraysInstancedARB;

static void APIENTRY _fail_glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount) {
    const char *_name = "glDrawElementsInstancedARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount) {
    PFN_GLDRAWELEMENTSINSTANCEDARB _ptr;
    _ptr = (PFN_GLDRAWELEMENTSINSTANCEDARB)_getPrivateProcAddress("glDrawElementsInstancedARB");
    if (!_ptr) {
        _ptr = &_fail_glDrawElementsInstancedARB;
    }
    _glDrawElementsInstancedARB = _ptr;
    _glDrawElementsInstancedARB(mode, count, type, indices, primcount);
}

PFN_GLDRAWELEMENTSINSTANCEDARB _glDrawElementsInstancedARB = &_get_glDrawElementsInstancedARB;

static void APIENTRY _fail_glFramebufferParameteri(GLenum target, GLenum pname, GLint param) {
    const char *_name = "glFramebufferParameteri";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferParameteri(GLenum target, GLenum pname, GLint param) {
    PFN_GLFRAMEBUFFERPARAMETERI _ptr;
    _ptr = (PFN_GLFRAMEBUFFERPARAMETERI)_getPrivateProcAddress("glFramebufferParameteri");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferParameteri;
    }
    _glFramebufferParameteri = _ptr;
    _glFramebufferParameteri(target, pname, param);
}

PFN_GLFRAMEBUFFERPARAMETERI _glFramebufferParameteri = &_get_glFramebufferParameteri;

static void APIENTRY _fail_glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetFramebufferParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETFRAMEBUFFERPARAMETERIV _ptr;
    _ptr = (PFN_GLGETFRAMEBUFFERPARAMETERIV)_getPrivateProcAddress("glGetFramebufferParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glGetFramebufferParameteriv;
    }
    _glGetFramebufferParameteriv = _ptr;
    _glGetFramebufferParameteriv(target, pname, params);
}

PFN_GLGETFRAMEBUFFERPARAMETERIV _glGetFramebufferParameteriv = &_get_glGetFramebufferParameteriv;

static GLboolean APIENTRY _fail_glIsRenderbuffer(GLuint renderbuffer) {
    const char *_name = "glIsRenderbuffer";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsRenderbuffer(GLuint renderbuffer) {
    PFN_GLISRENDERBUFFER _ptr;
    _ptr = (PFN_GLISRENDERBUFFER)_getPrivateProcAddress("glIsRenderbuffer");
    if (!_ptr) {
        _ptr = &_fail_glIsRenderbuffer;
    }
    _glIsRenderbuffer = _ptr;
    return _glIsRenderbuffer(renderbuffer);
}

PFN_GLISRENDERBUFFER _glIsRenderbuffer = &_get_glIsRenderbuffer;

static void APIENTRY _fail_glBindRenderbuffer(GLenum target, GLuint renderbuffer) {
    const char *_name = "glBindRenderbuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindRenderbuffer(GLenum target, GLuint renderbuffer) {
    PFN_GLBINDRENDERBUFFER _ptr;
    _ptr = (PFN_GLBINDRENDERBUFFER)_getPrivateProcAddress("glBindRenderbuffer");
    if (!_ptr) {
        _ptr = &_fail_glBindRenderbuffer;
    }
    _glBindRenderbuffer = _ptr;
    _glBindRenderbuffer(target, renderbuffer);
}

PFN_GLBINDRENDERBUFFER _glBindRenderbuffer = &_get_glBindRenderbuffer;

static void APIENTRY _fail_glDeleteRenderbuffers(GLsizei n, const GLuint * renderbuffers) {
    const char *_name = "glDeleteRenderbuffers";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteRenderbuffers(GLsizei n, const GLuint * renderbuffers) {
    PFN_GLDELETERENDERBUFFERS _ptr;
    _ptr = (PFN_GLDELETERENDERBUFFERS)_getPrivateProcAddress("glDeleteRenderbuffers");
    if (!_ptr) {
        _ptr = &_fail_glDeleteRenderbuffers;
    }
    _glDeleteRenderbuffers = _ptr;
    _glDeleteRenderbuffers(n, renderbuffers);
}

PFN_GLDELETERENDERBUFFERS _glDeleteRenderbuffers = &_get_glDeleteRenderbuffers;

static void APIENTRY _fail_glGenRenderbuffers(GLsizei n, GLuint * renderbuffers) {
    const char *_name = "glGenRenderbuffers";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenRenderbuffers(GLsizei n, GLuint * renderbuffers) {
    PFN_GLGENRENDERBUFFERS _ptr;
    _ptr = (PFN_GLGENRENDERBUFFERS)_getPrivateProcAddress("glGenRenderbuffers");
    if (!_ptr) {
        _ptr = &_fail_glGenRenderbuffers;
    }
    _glGenRenderbuffers = _ptr;
    _glGenRenderbuffers(n, renderbuffers);
}

PFN_GLGENRENDERBUFFERS _glGenRenderbuffers = &_get_glGenRenderbuffers;

static void APIENTRY _fail_glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glRenderbufferStorage";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) {
    PFN_GLRENDERBUFFERSTORAGE _ptr;
    _ptr = (PFN_GLRENDERBUFFERSTORAGE)_getPrivateProcAddress("glRenderbufferStorage");
    if (!_ptr) {
        _ptr = &_fail_glRenderbufferStorage;
    }
    _glRenderbufferStorage = _ptr;
    _glRenderbufferStorage(target, internalformat, width, height);
}

PFN_GLRENDERBUFFERSTORAGE _glRenderbufferStorage = &_get_glRenderbufferStorage;

static void APIENTRY _fail_glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetRenderbufferParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETRENDERBUFFERPARAMETERIV _ptr;
    _ptr = (PFN_GLGETRENDERBUFFERPARAMETERIV)_getPrivateProcAddress("glGetRenderbufferParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glGetRenderbufferParameteriv;
    }
    _glGetRenderbufferParameteriv = _ptr;
    _glGetRenderbufferParameteriv(target, pname, params);
}

PFN_GLGETRENDERBUFFERPARAMETERIV _glGetRenderbufferParameteriv = &_get_glGetRenderbufferParameteriv;

static GLboolean APIENTRY _fail_glIsFramebuffer(GLuint framebuffer) {
    const char *_name = "glIsFramebuffer";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsFramebuffer(GLuint framebuffer) {
    PFN_GLISFRAMEBUFFER _ptr;
    _ptr = (PFN_GLISFRAMEBUFFER)_getPrivateProcAddress("glIsFramebuffer");
    if (!_ptr) {
        _ptr = &_fail_glIsFramebuffer;
    }
    _glIsFramebuffer = _ptr;
    return _glIsFramebuffer(framebuffer);
}

PFN_GLISFRAMEBUFFER _glIsFramebuffer = &_get_glIsFramebuffer;

static void APIENTRY _fail_glBindFramebuffer(GLenum target, GLuint framebuffer) {
    const char *_name = "glBindFramebuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindFramebuffer(GLenum target, GLuint framebuffer) {
    PFN_GLBINDFRAMEBUFFER _ptr;
    _ptr = (PFN_GLBINDFRAMEBUFFER)_getPrivateProcAddress("glBindFramebuffer");
    if (!_ptr) {
        _ptr = &_fail_glBindFramebuffer;
    }
    _glBindFramebuffer = _ptr;
    _glBindFramebuffer(target, framebuffer);
}

PFN_GLBINDFRAMEBUFFER _glBindFramebuffer = &_get_glBindFramebuffer;

static void APIENTRY _fail_glDeleteFramebuffers(GLsizei n, const GLuint * framebuffers) {
    const char *_name = "glDeleteFramebuffers";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteFramebuffers(GLsizei n, const GLuint * framebuffers) {
    PFN_GLDELETEFRAMEBUFFERS _ptr;
    _ptr = (PFN_GLDELETEFRAMEBUFFERS)_getPrivateProcAddress("glDeleteFramebuffers");
    if (!_ptr) {
        _ptr = &_fail_glDeleteFramebuffers;
    }
    _glDeleteFramebuffers = _ptr;
    _glDeleteFramebuffers(n, framebuffers);
}

PFN_GLDELETEFRAMEBUFFERS _glDeleteFramebuffers = &_get_glDeleteFramebuffers;

static void APIENTRY _fail_glGenFramebuffers(GLsizei n, GLuint * framebuffers) {
    const char *_name = "glGenFramebuffers";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenFramebuffers(GLsizei n, GLuint * framebuffers) {
    PFN_GLGENFRAMEBUFFERS _ptr;
    _ptr = (PFN_GLGENFRAMEBUFFERS)_getPrivateProcAddress("glGenFramebuffers");
    if (!_ptr) {
        _ptr = &_fail_glGenFramebuffers;
    }
    _glGenFramebuffers = _ptr;
    _glGenFramebuffers(n, framebuffers);
}

PFN_GLGENFRAMEBUFFERS _glGenFramebuffers = &_get_glGenFramebuffers;

static GLenum APIENTRY _fail_glCheckFramebufferStatus(GLenum target) {
    const char *_name = "glCheckFramebufferStatus";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLenum APIENTRY _get_glCheckFramebufferStatus(GLenum target) {
    PFN_GLCHECKFRAMEBUFFERSTATUS _ptr;
    _ptr = (PFN_GLCHECKFRAMEBUFFERSTATUS)_getPrivateProcAddress("glCheckFramebufferStatus");
    if (!_ptr) {
        _ptr = &_fail_glCheckFramebufferStatus;
    }
    _glCheckFramebufferStatus = _ptr;
    return _glCheckFramebufferStatus(target);
}

PFN_GLCHECKFRAMEBUFFERSTATUS _glCheckFramebufferStatus = &_get_glCheckFramebufferStatus;

static void APIENTRY _fail_glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    const char *_name = "glFramebufferTexture1D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    PFN_GLFRAMEBUFFERTEXTURE1D _ptr;
    _ptr = (PFN_GLFRAMEBUFFERTEXTURE1D)_getPrivateProcAddress("glFramebufferTexture1D");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferTexture1D;
    }
    _glFramebufferTexture1D = _ptr;
    _glFramebufferTexture1D(target, attachment, textarget, texture, level);
}

PFN_GLFRAMEBUFFERTEXTURE1D _glFramebufferTexture1D = &_get_glFramebufferTexture1D;

static void APIENTRY _fail_glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    const char *_name = "glFramebufferTexture2D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    PFN_GLFRAMEBUFFERTEXTURE2D _ptr;
    _ptr = (PFN_GLFRAMEBUFFERTEXTURE2D)_getPrivateProcAddress("glFramebufferTexture2D");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferTexture2D;
    }
    _glFramebufferTexture2D = _ptr;
    _glFramebufferTexture2D(target, attachment, textarget, texture, level);
}

PFN_GLFRAMEBUFFERTEXTURE2D _glFramebufferTexture2D = &_get_glFramebufferTexture2D;

static void APIENTRY _fail_glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) {
    const char *_name = "glFramebufferTexture3D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) {
    PFN_GLFRAMEBUFFERTEXTURE3D _ptr;
    _ptr = (PFN_GLFRAMEBUFFERTEXTURE3D)_getPrivateProcAddress("glFramebufferTexture3D");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferTexture3D;
    }
    _glFramebufferTexture3D = _ptr;
    _glFramebufferTexture3D(target, attachment, textarget, texture, level, zoffset);
}

PFN_GLFRAMEBUFFERTEXTURE3D _glFramebufferTexture3D = &_get_glFramebufferTexture3D;

static void APIENTRY _fail_glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) {
    const char *_name = "glFramebufferRenderbuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) {
    PFN_GLFRAMEBUFFERRENDERBUFFER _ptr;
    _ptr = (PFN_GLFRAMEBUFFERRENDERBUFFER)_getPrivateProcAddress("glFramebufferRenderbuffer");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferRenderbuffer;
    }
    _glFramebufferRenderbuffer = _ptr;
    _glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
}

PFN_GLFRAMEBUFFERRENDERBUFFER _glFramebufferRenderbuffer = &_get_glFramebufferRenderbuffer;

static void APIENTRY _fail_glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint * params) {
    const char *_name = "glGetFramebufferAttachmentParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint * params) {
    PFN_GLGETFRAMEBUFFERATTACHMENTPARAMETERIV _ptr;
    _ptr = (PFN_GLGETFRAMEBUFFERATTACHMENTPARAMETERIV)_getPrivateProcAddress("glGetFramebufferAttachmentParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glGetFramebufferAttachmentParameteriv;
    }
    _glGetFramebufferAttachmentParameteriv = _ptr;
    _glGetFramebufferAttachmentParameteriv(target, attachment, pname, params);
}

PFN_GLGETFRAMEBUFFERATTACHMENTPARAMETERIV _glGetFramebufferAttachmentParameteriv = &_get_glGetFramebufferAttachmentParameteriv;

static void APIENTRY _fail_glGenerateMipmap(GLenum target) {
    const char *_name = "glGenerateMipmap";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenerateMipmap(GLenum target) {
    PFN_GLGENERATEMIPMAP _ptr;
    _ptr = (PFN_GLGENERATEMIPMAP)_getPrivateProcAddress("glGenerateMipmap");
    if (!_ptr) {
        _ptr = &_fail_glGenerateMipmap;
    }
    _glGenerateMipmap = _ptr;
    _glGenerateMipmap(target);
}

PFN_GLGENERATEMIPMAP _glGenerateMipmap = &_get_glGenerateMipmap;

static void APIENTRY _fail_glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
    const char *_name = "glBlitFramebuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
    PFN_GLBLITFRAMEBUFFER _ptr;
    _ptr = (PFN_GLBLITFRAMEBUFFER)_getPrivateProcAddress("glBlitFramebuffer");
    if (!_ptr) {
        _ptr = &_fail_glBlitFramebuffer;
    }
    _glBlitFramebuffer = _ptr;
    _glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

PFN_GLBLITFRAMEBUFFER _glBlitFramebuffer = &_get_glBlitFramebuffer;

static void APIENTRY _fail_glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glRenderbufferStorageMultisample";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    PFN_GLRENDERBUFFERSTORAGEMULTISAMPLE _ptr;
    _ptr = (PFN_GLRENDERBUFFERSTORAGEMULTISAMPLE)_getPrivateProcAddress("glRenderbufferStorageMultisample");
    if (!_ptr) {
        _ptr = &_fail_glRenderbufferStorageMultisample;
    }
    _glRenderbufferStorageMultisample = _ptr;
    _glRenderbufferStorageMultisample(target, samples, internalformat, width, height);
}

PFN_GLRENDERBUFFERSTORAGEMULTISAMPLE _glRenderbufferStorageMultisample = &_get_glRenderbufferStorageMultisample;

static void APIENTRY _fail_glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) {
    const char *_name = "glFramebufferTextureLayer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) {
    PFN_GLFRAMEBUFFERTEXTURELAYER _ptr;
    _ptr = (PFN_GLFRAMEBUFFERTEXTURELAYER)_getPrivateProcAddress("glFramebufferTextureLayer");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferTextureLayer;
    }
    _glFramebufferTextureLayer = _ptr;
    _glFramebufferTextureLayer(target, attachment, texture, level, layer);
}

PFN_GLFRAMEBUFFERTEXTURELAYER _glFramebufferTextureLayer = &_get_glFramebufferTextureLayer;

static void APIENTRY _fail_glProgramParameteriARB(GLuint program, GLenum pname, GLint value) {
    const char *_name = "glProgramParameteriARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramParameteriARB(GLuint program, GLenum pname, GLint value) {
    PFN_GLPROGRAMPARAMETERIARB _ptr;
    _ptr = (PFN_GLPROGRAMPARAMETERIARB)_getPrivateProcAddress("glProgramParameteriARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramParameteriARB;
    }
    _glProgramParameteriARB = _ptr;
    _glProgramParameteriARB(program, pname, value);
}

PFN_GLPROGRAMPARAMETERIARB _glProgramParameteriARB = &_get_glProgramParameteriARB;

static void APIENTRY _fail_glFramebufferTextureARB(GLenum target, GLenum attachment, GLuint texture, GLint level) {
    const char *_name = "glFramebufferTextureARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferTextureARB(GLenum target, GLenum attachment, GLuint texture, GLint level) {
    PFN_GLFRAMEBUFFERTEXTUREARB _ptr;
    _ptr = (PFN_GLFRAMEBUFFERTEXTUREARB)_getPrivateProcAddress("glFramebufferTextureARB");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferTextureARB;
    }
    _glFramebufferTextureARB = _ptr;
    _glFramebufferTextureARB(target, attachment, texture, level);
}

PFN_GLFRAMEBUFFERTEXTUREARB _glFramebufferTextureARB = &_get_glFramebufferTextureARB;

static void APIENTRY _fail_glFramebufferTextureLayerARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) {
    const char *_name = "glFramebufferTextureLayerARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferTextureLayerARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) {
    PFN_GLFRAMEBUFFERTEXTURELAYERARB _ptr;
    _ptr = (PFN_GLFRAMEBUFFERTEXTURELAYERARB)_getPrivateProcAddress("glFramebufferTextureLayerARB");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferTextureLayerARB;
    }
    _glFramebufferTextureLayerARB = _ptr;
    _glFramebufferTextureLayerARB(target, attachment, texture, level, layer);
}

PFN_GLFRAMEBUFFERTEXTURELAYERARB _glFramebufferTextureLayerARB = &_get_glFramebufferTextureLayerARB;

static void APIENTRY _fail_glFramebufferTextureFaceARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face) {
    const char *_name = "glFramebufferTextureFaceARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferTextureFaceARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face) {
    PFN_GLFRAMEBUFFERTEXTUREFACEARB _ptr;
    _ptr = (PFN_GLFRAMEBUFFERTEXTUREFACEARB)_getPrivateProcAddress("glFramebufferTextureFaceARB");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferTextureFaceARB;
    }
    _glFramebufferTextureFaceARB = _ptr;
    _glFramebufferTextureFaceARB(target, attachment, texture, level, face);
}

PFN_GLFRAMEBUFFERTEXTUREFACEARB _glFramebufferTextureFaceARB = &_get_glFramebufferTextureFaceARB;

static void APIENTRY _fail_glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, GLvoid * binary) {
    const char *_name = "glGetProgramBinary";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, GLvoid * binary) {
    PFN_GLGETPROGRAMBINARY _ptr;
    _ptr = (PFN_GLGETPROGRAMBINARY)_getPrivateProcAddress("glGetProgramBinary");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramBinary;
    }
    _glGetProgramBinary = _ptr;
    _glGetProgramBinary(program, bufSize, length, binaryFormat, binary);
}

PFN_GLGETPROGRAMBINARY _glGetProgramBinary = &_get_glGetProgramBinary;

static void APIENTRY _fail_glProgramBinary(GLuint program, GLenum binaryFormat, const GLvoid * binary, GLsizei length) {
    const char *_name = "glProgramBinary";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramBinary(GLuint program, GLenum binaryFormat, const GLvoid * binary, GLsizei length) {
    PFN_GLPROGRAMBINARY _ptr;
    _ptr = (PFN_GLPROGRAMBINARY)_getPrivateProcAddress("glProgramBinary");
    if (!_ptr) {
        _ptr = &_fail_glProgramBinary;
    }
    _glProgramBinary = _ptr;
    _glProgramBinary(program, binaryFormat, binary, length);
}

PFN_GLPROGRAMBINARY _glProgramBinary = &_get_glProgramBinary;

static void APIENTRY _fail_glProgramParameteri(GLuint program, GLenum pname, GLint value) {
    const char *_name = "glProgramParameteri";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramParameteri(GLuint program, GLenum pname, GLint value) {
    PFN_GLPROGRAMPARAMETERI _ptr;
    _ptr = (PFN_GLPROGRAMPARAMETERI)_getPrivateProcAddress("glProgramParameteri");
    if (!_ptr) {
        _ptr = &_fail_glProgramParameteri;
    }
    _glProgramParameteri = _ptr;
    _glProgramParameteri(program, pname, value);
}

PFN_GLPROGRAMPARAMETERI _glProgramParameteri = &_get_glProgramParameteri;

static void APIENTRY _fail_glGetTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, GLvoid * pixels) {
    const char *_name = "glGetTextureSubImage";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, GLvoid * pixels) {
    PFN_GLGETTEXTURESUBIMAGE _ptr;
    _ptr = (PFN_GLGETTEXTURESUBIMAGE)_getPrivateProcAddress("glGetTextureSubImage");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureSubImage;
    }
    _glGetTextureSubImage = _ptr;
    _glGetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
}

PFN_GLGETTEXTURESUBIMAGE _glGetTextureSubImage = &_get_glGetTextureSubImage;

static void APIENTRY _fail_glGetCompressedTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, GLvoid * pixels) {
    const char *_name = "glGetCompressedTextureSubImage";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetCompressedTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, GLvoid * pixels) {
    PFN_GLGETCOMPRESSEDTEXTURESUBIMAGE _ptr;
    _ptr = (PFN_GLGETCOMPRESSEDTEXTURESUBIMAGE)_getPrivateProcAddress("glGetCompressedTextureSubImage");
    if (!_ptr) {
        _ptr = &_fail_glGetCompressedTextureSubImage;
    }
    _glGetCompressedTextureSubImage = _ptr;
    _glGetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
}

PFN_GLGETCOMPRESSEDTEXTURESUBIMAGE _glGetCompressedTextureSubImage = &_get_glGetCompressedTextureSubImage;

static void APIENTRY _fail_glUniform1d(GLint location, GLdouble x) {
    const char *_name = "glUniform1d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1d(GLint location, GLdouble x) {
    PFN_GLUNIFORM1D _ptr;
    _ptr = (PFN_GLUNIFORM1D)_getPrivateProcAddress("glUniform1d");
    if (!_ptr) {
        _ptr = &_fail_glUniform1d;
    }
    _glUniform1d = _ptr;
    _glUniform1d(location, x);
}

PFN_GLUNIFORM1D _glUniform1d = &_get_glUniform1d;

static void APIENTRY _fail_glUniform2d(GLint location, GLdouble x, GLdouble y) {
    const char *_name = "glUniform2d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2d(GLint location, GLdouble x, GLdouble y) {
    PFN_GLUNIFORM2D _ptr;
    _ptr = (PFN_GLUNIFORM2D)_getPrivateProcAddress("glUniform2d");
    if (!_ptr) {
        _ptr = &_fail_glUniform2d;
    }
    _glUniform2d = _ptr;
    _glUniform2d(location, x, y);
}

PFN_GLUNIFORM2D _glUniform2d = &_get_glUniform2d;

static void APIENTRY _fail_glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glUniform3d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLUNIFORM3D _ptr;
    _ptr = (PFN_GLUNIFORM3D)_getPrivateProcAddress("glUniform3d");
    if (!_ptr) {
        _ptr = &_fail_glUniform3d;
    }
    _glUniform3d = _ptr;
    _glUniform3d(location, x, y, z);
}

PFN_GLUNIFORM3D _glUniform3d = &_get_glUniform3d;

static void APIENTRY _fail_glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glUniform4d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    PFN_GLUNIFORM4D _ptr;
    _ptr = (PFN_GLUNIFORM4D)_getPrivateProcAddress("glUniform4d");
    if (!_ptr) {
        _ptr = &_fail_glUniform4d;
    }
    _glUniform4d = _ptr;
    _glUniform4d(location, x, y, z, w);
}

PFN_GLUNIFORM4D _glUniform4d = &_get_glUniform4d;

static void APIENTRY _fail_glUniform1dv(GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glUniform1dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1dv(GLint location, GLsizei count, const GLdouble * value) {
    PFN_GLUNIFORM1DV _ptr;
    _ptr = (PFN_GLUNIFORM1DV)_getPrivateProcAddress("glUniform1dv");
    if (!_ptr) {
        _ptr = &_fail_glUniform1dv;
    }
    _glUniform1dv = _ptr;
    _glUniform1dv(location, count, value);
}

PFN_GLUNIFORM1DV _glUniform1dv = &_get_glUniform1dv;

static void APIENTRY _fail_glUniform2dv(GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glUniform2dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2dv(GLint location, GLsizei count, const GLdouble * value) {
    PFN_GLUNIFORM2DV _ptr;
    _ptr = (PFN_GLUNIFORM2DV)_getPrivateProcAddress("glUniform2dv");
    if (!_ptr) {
        _ptr = &_fail_glUniform2dv;
    }
    _glUniform2dv = _ptr;
    _glUniform2dv(location, count, value);
}

PFN_GLUNIFORM2DV _glUniform2dv = &_get_glUniform2dv;

static void APIENTRY _fail_glUniform3dv(GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glUniform3dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3dv(GLint location, GLsizei count, const GLdouble * value) {
    PFN_GLUNIFORM3DV _ptr;
    _ptr = (PFN_GLUNIFORM3DV)_getPrivateProcAddress("glUniform3dv");
    if (!_ptr) {
        _ptr = &_fail_glUniform3dv;
    }
    _glUniform3dv = _ptr;
    _glUniform3dv(location, count, value);
}

PFN_GLUNIFORM3DV _glUniform3dv = &_get_glUniform3dv;

static void APIENTRY _fail_glUniform4dv(GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glUniform4dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4dv(GLint location, GLsizei count, const GLdouble * value) {
    PFN_GLUNIFORM4DV _ptr;
    _ptr = (PFN_GLUNIFORM4DV)_getPrivateProcAddress("glUniform4dv");
    if (!_ptr) {
        _ptr = &_fail_glUniform4dv;
    }
    _glUniform4dv = _ptr;
    _glUniform4dv(location, count, value);
}

PFN_GLUNIFORM4DV _glUniform4dv = &_get_glUniform4dv;

static void APIENTRY _fail_glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glUniformMatrix2dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLUNIFORMMATRIX2DV _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX2DV)_getPrivateProcAddress("glUniformMatrix2dv");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix2dv;
    }
    _glUniformMatrix2dv = _ptr;
    _glUniformMatrix2dv(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX2DV _glUniformMatrix2dv = &_get_glUniformMatrix2dv;

static void APIENTRY _fail_glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glUniformMatrix3dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLUNIFORMMATRIX3DV _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX3DV)_getPrivateProcAddress("glUniformMatrix3dv");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix3dv;
    }
    _glUniformMatrix3dv = _ptr;
    _glUniformMatrix3dv(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX3DV _glUniformMatrix3dv = &_get_glUniformMatrix3dv;

static void APIENTRY _fail_glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glUniformMatrix4dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLUNIFORMMATRIX4DV _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX4DV)_getPrivateProcAddress("glUniformMatrix4dv");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix4dv;
    }
    _glUniformMatrix4dv = _ptr;
    _glUniformMatrix4dv(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX4DV _glUniformMatrix4dv = &_get_glUniformMatrix4dv;

static void APIENTRY _fail_glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glUniformMatrix2x3dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLUNIFORMMATRIX2X3DV _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX2X3DV)_getPrivateProcAddress("glUniformMatrix2x3dv");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix2x3dv;
    }
    _glUniformMatrix2x3dv = _ptr;
    _glUniformMatrix2x3dv(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX2X3DV _glUniformMatrix2x3dv = &_get_glUniformMatrix2x3dv;

static void APIENTRY _fail_glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glUniformMatrix2x4dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLUNIFORMMATRIX2X4DV _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX2X4DV)_getPrivateProcAddress("glUniformMatrix2x4dv");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix2x4dv;
    }
    _glUniformMatrix2x4dv = _ptr;
    _glUniformMatrix2x4dv(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX2X4DV _glUniformMatrix2x4dv = &_get_glUniformMatrix2x4dv;

static void APIENTRY _fail_glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glUniformMatrix3x2dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLUNIFORMMATRIX3X2DV _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX3X2DV)_getPrivateProcAddress("glUniformMatrix3x2dv");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix3x2dv;
    }
    _glUniformMatrix3x2dv = _ptr;
    _glUniformMatrix3x2dv(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX3X2DV _glUniformMatrix3x2dv = &_get_glUniformMatrix3x2dv;

static void APIENTRY _fail_glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glUniformMatrix3x4dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLUNIFORMMATRIX3X4DV _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX3X4DV)_getPrivateProcAddress("glUniformMatrix3x4dv");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix3x4dv;
    }
    _glUniformMatrix3x4dv = _ptr;
    _glUniformMatrix3x4dv(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX3X4DV _glUniformMatrix3x4dv = &_get_glUniformMatrix3x4dv;

static void APIENTRY _fail_glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glUniformMatrix4x2dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLUNIFORMMATRIX4X2DV _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX4X2DV)_getPrivateProcAddress("glUniformMatrix4x2dv");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix4x2dv;
    }
    _glUniformMatrix4x2dv = _ptr;
    _glUniformMatrix4x2dv(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX4X2DV _glUniformMatrix4x2dv = &_get_glUniformMatrix4x2dv;

static void APIENTRY _fail_glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glUniformMatrix4x3dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLUNIFORMMATRIX4X3DV _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX4X3DV)_getPrivateProcAddress("glUniformMatrix4x3dv");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix4x3dv;
    }
    _glUniformMatrix4x3dv = _ptr;
    _glUniformMatrix4x3dv(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX4X3DV _glUniformMatrix4x3dv = &_get_glUniformMatrix4x3dv;

static void APIENTRY _fail_glGetUniformdv(GLuint program, GLint location, GLdouble * params) {
    const char *_name = "glGetUniformdv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetUniformdv(GLuint program, GLint location, GLdouble * params) {
    PFN_GLGETUNIFORMDV _ptr;
    _ptr = (PFN_GLGETUNIFORMDV)_getPrivateProcAddress("glGetUniformdv");
    if (!_ptr) {
        _ptr = &_fail_glGetUniformdv;
    }
    _glGetUniformdv = _ptr;
    _glGetUniformdv(program, location, params);
}

PFN_GLGETUNIFORMDV _glGetUniformdv = &_get_glGetUniformdv;

static void APIENTRY _fail_glUniform1i64ARB(GLint location, GLint64 x) {
    const char *_name = "glUniform1i64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1i64ARB(GLint location, GLint64 x) {
    PFN_GLUNIFORM1I64ARB _ptr;
    _ptr = (PFN_GLUNIFORM1I64ARB)_getPrivateProcAddress("glUniform1i64ARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform1i64ARB;
    }
    _glUniform1i64ARB = _ptr;
    _glUniform1i64ARB(location, x);
}

PFN_GLUNIFORM1I64ARB _glUniform1i64ARB = &_get_glUniform1i64ARB;

static void APIENTRY _fail_glUniform2i64ARB(GLint location, GLint64 x, GLint64 y) {
    const char *_name = "glUniform2i64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2i64ARB(GLint location, GLint64 x, GLint64 y) {
    PFN_GLUNIFORM2I64ARB _ptr;
    _ptr = (PFN_GLUNIFORM2I64ARB)_getPrivateProcAddress("glUniform2i64ARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform2i64ARB;
    }
    _glUniform2i64ARB = _ptr;
    _glUniform2i64ARB(location, x, y);
}

PFN_GLUNIFORM2I64ARB _glUniform2i64ARB = &_get_glUniform2i64ARB;

static void APIENTRY _fail_glUniform3i64ARB(GLint location, GLint64 x, GLint64 y, GLint64 z) {
    const char *_name = "glUniform3i64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3i64ARB(GLint location, GLint64 x, GLint64 y, GLint64 z) {
    PFN_GLUNIFORM3I64ARB _ptr;
    _ptr = (PFN_GLUNIFORM3I64ARB)_getPrivateProcAddress("glUniform3i64ARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform3i64ARB;
    }
    _glUniform3i64ARB = _ptr;
    _glUniform3i64ARB(location, x, y, z);
}

PFN_GLUNIFORM3I64ARB _glUniform3i64ARB = &_get_glUniform3i64ARB;

static void APIENTRY _fail_glUniform4i64ARB(GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w) {
    const char *_name = "glUniform4i64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4i64ARB(GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w) {
    PFN_GLUNIFORM4I64ARB _ptr;
    _ptr = (PFN_GLUNIFORM4I64ARB)_getPrivateProcAddress("glUniform4i64ARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform4i64ARB;
    }
    _glUniform4i64ARB = _ptr;
    _glUniform4i64ARB(location, x, y, z, w);
}

PFN_GLUNIFORM4I64ARB _glUniform4i64ARB = &_get_glUniform4i64ARB;

static void APIENTRY _fail_glUniform1i64vARB(GLint location, GLsizei count, const GLint64 * value) {
    const char *_name = "glUniform1i64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1i64vARB(GLint location, GLsizei count, const GLint64 * value) {
    PFN_GLUNIFORM1I64VARB _ptr;
    _ptr = (PFN_GLUNIFORM1I64VARB)_getPrivateProcAddress("glUniform1i64vARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform1i64vARB;
    }
    _glUniform1i64vARB = _ptr;
    _glUniform1i64vARB(location, count, value);
}

PFN_GLUNIFORM1I64VARB _glUniform1i64vARB = &_get_glUniform1i64vARB;

static void APIENTRY _fail_glUniform2i64vARB(GLint location, GLsizei count, const GLint64 * value) {
    const char *_name = "glUniform2i64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2i64vARB(GLint location, GLsizei count, const GLint64 * value) {
    PFN_GLUNIFORM2I64VARB _ptr;
    _ptr = (PFN_GLUNIFORM2I64VARB)_getPrivateProcAddress("glUniform2i64vARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform2i64vARB;
    }
    _glUniform2i64vARB = _ptr;
    _glUniform2i64vARB(location, count, value);
}

PFN_GLUNIFORM2I64VARB _glUniform2i64vARB = &_get_glUniform2i64vARB;

static void APIENTRY _fail_glUniform3i64vARB(GLint location, GLsizei count, const GLint64 * value) {
    const char *_name = "glUniform3i64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3i64vARB(GLint location, GLsizei count, const GLint64 * value) {
    PFN_GLUNIFORM3I64VARB _ptr;
    _ptr = (PFN_GLUNIFORM3I64VARB)_getPrivateProcAddress("glUniform3i64vARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform3i64vARB;
    }
    _glUniform3i64vARB = _ptr;
    _glUniform3i64vARB(location, count, value);
}

PFN_GLUNIFORM3I64VARB _glUniform3i64vARB = &_get_glUniform3i64vARB;

static void APIENTRY _fail_glUniform4i64vARB(GLint location, GLsizei count, const GLint64 * value) {
    const char *_name = "glUniform4i64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4i64vARB(GLint location, GLsizei count, const GLint64 * value) {
    PFN_GLUNIFORM4I64VARB _ptr;
    _ptr = (PFN_GLUNIFORM4I64VARB)_getPrivateProcAddress("glUniform4i64vARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform4i64vARB;
    }
    _glUniform4i64vARB = _ptr;
    _glUniform4i64vARB(location, count, value);
}

PFN_GLUNIFORM4I64VARB _glUniform4i64vARB = &_get_glUniform4i64vARB;

static void APIENTRY _fail_glUniform1ui64ARB(GLint location, GLuint64 x) {
    const char *_name = "glUniform1ui64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1ui64ARB(GLint location, GLuint64 x) {
    PFN_GLUNIFORM1UI64ARB _ptr;
    _ptr = (PFN_GLUNIFORM1UI64ARB)_getPrivateProcAddress("glUniform1ui64ARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform1ui64ARB;
    }
    _glUniform1ui64ARB = _ptr;
    _glUniform1ui64ARB(location, x);
}

PFN_GLUNIFORM1UI64ARB _glUniform1ui64ARB = &_get_glUniform1ui64ARB;

static void APIENTRY _fail_glUniform2ui64ARB(GLint location, GLuint64 x, GLuint64 y) {
    const char *_name = "glUniform2ui64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2ui64ARB(GLint location, GLuint64 x, GLuint64 y) {
    PFN_GLUNIFORM2UI64ARB _ptr;
    _ptr = (PFN_GLUNIFORM2UI64ARB)_getPrivateProcAddress("glUniform2ui64ARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform2ui64ARB;
    }
    _glUniform2ui64ARB = _ptr;
    _glUniform2ui64ARB(location, x, y);
}

PFN_GLUNIFORM2UI64ARB _glUniform2ui64ARB = &_get_glUniform2ui64ARB;

static void APIENTRY _fail_glUniform3ui64ARB(GLint location, GLuint64 x, GLuint64 y, GLuint64 z) {
    const char *_name = "glUniform3ui64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3ui64ARB(GLint location, GLuint64 x, GLuint64 y, GLuint64 z) {
    PFN_GLUNIFORM3UI64ARB _ptr;
    _ptr = (PFN_GLUNIFORM3UI64ARB)_getPrivateProcAddress("glUniform3ui64ARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform3ui64ARB;
    }
    _glUniform3ui64ARB = _ptr;
    _glUniform3ui64ARB(location, x, y, z);
}

PFN_GLUNIFORM3UI64ARB _glUniform3ui64ARB = &_get_glUniform3ui64ARB;

static void APIENTRY _fail_glUniform4ui64ARB(GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w) {
    const char *_name = "glUniform4ui64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4ui64ARB(GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w) {
    PFN_GLUNIFORM4UI64ARB _ptr;
    _ptr = (PFN_GLUNIFORM4UI64ARB)_getPrivateProcAddress("glUniform4ui64ARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform4ui64ARB;
    }
    _glUniform4ui64ARB = _ptr;
    _glUniform4ui64ARB(location, x, y, z, w);
}

PFN_GLUNIFORM4UI64ARB _glUniform4ui64ARB = &_get_glUniform4ui64ARB;

static void APIENTRY _fail_glUniform1ui64vARB(GLint location, GLsizei count, const GLuint64 * value) {
    const char *_name = "glUniform1ui64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1ui64vARB(GLint location, GLsizei count, const GLuint64 * value) {
    PFN_GLUNIFORM1UI64VARB _ptr;
    _ptr = (PFN_GLUNIFORM1UI64VARB)_getPrivateProcAddress("glUniform1ui64vARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform1ui64vARB;
    }
    _glUniform1ui64vARB = _ptr;
    _glUniform1ui64vARB(location, count, value);
}

PFN_GLUNIFORM1UI64VARB _glUniform1ui64vARB = &_get_glUniform1ui64vARB;

static void APIENTRY _fail_glUniform2ui64vARB(GLint location, GLsizei count, const GLuint64 * value) {
    const char *_name = "glUniform2ui64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2ui64vARB(GLint location, GLsizei count, const GLuint64 * value) {
    PFN_GLUNIFORM2UI64VARB _ptr;
    _ptr = (PFN_GLUNIFORM2UI64VARB)_getPrivateProcAddress("glUniform2ui64vARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform2ui64vARB;
    }
    _glUniform2ui64vARB = _ptr;
    _glUniform2ui64vARB(location, count, value);
}

PFN_GLUNIFORM2UI64VARB _glUniform2ui64vARB = &_get_glUniform2ui64vARB;

static void APIENTRY _fail_glUniform3ui64vARB(GLint location, GLsizei count, const GLuint64 * value) {
    const char *_name = "glUniform3ui64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3ui64vARB(GLint location, GLsizei count, const GLuint64 * value) {
    PFN_GLUNIFORM3UI64VARB _ptr;
    _ptr = (PFN_GLUNIFORM3UI64VARB)_getPrivateProcAddress("glUniform3ui64vARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform3ui64vARB;
    }
    _glUniform3ui64vARB = _ptr;
    _glUniform3ui64vARB(location, count, value);
}

PFN_GLUNIFORM3UI64VARB _glUniform3ui64vARB = &_get_glUniform3ui64vARB;

static void APIENTRY _fail_glUniform4ui64vARB(GLint location, GLsizei count, const GLuint64 * value) {
    const char *_name = "glUniform4ui64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4ui64vARB(GLint location, GLsizei count, const GLuint64 * value) {
    PFN_GLUNIFORM4UI64VARB _ptr;
    _ptr = (PFN_GLUNIFORM4UI64VARB)_getPrivateProcAddress("glUniform4ui64vARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform4ui64vARB;
    }
    _glUniform4ui64vARB = _ptr;
    _glUniform4ui64vARB(location, count, value);
}

PFN_GLUNIFORM4UI64VARB _glUniform4ui64vARB = &_get_glUniform4ui64vARB;

static void APIENTRY _fail_glGetUniformi64vARB(GLuint program, GLint location, GLint64 * params) {
    const char *_name = "glGetUniformi64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetUniformi64vARB(GLuint program, GLint location, GLint64 * params) {
    PFN_GLGETUNIFORMI64VARB _ptr;
    _ptr = (PFN_GLGETUNIFORMI64VARB)_getPrivateProcAddress("glGetUniformi64vARB");
    if (!_ptr) {
        _ptr = &_fail_glGetUniformi64vARB;
    }
    _glGetUniformi64vARB = _ptr;
    _glGetUniformi64vARB(program, location, params);
}

PFN_GLGETUNIFORMI64VARB _glGetUniformi64vARB = &_get_glGetUniformi64vARB;

static void APIENTRY _fail_glGetUniformui64vARB(GLuint program, GLint location, GLuint64 * params) {
    const char *_name = "glGetUniformui64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetUniformui64vARB(GLuint program, GLint location, GLuint64 * params) {
    PFN_GLGETUNIFORMUI64VARB _ptr;
    _ptr = (PFN_GLGETUNIFORMUI64VARB)_getPrivateProcAddress("glGetUniformui64vARB");
    if (!_ptr) {
        _ptr = &_fail_glGetUniformui64vARB;
    }
    _glGetUniformui64vARB = _ptr;
    _glGetUniformui64vARB(program, location, params);
}

PFN_GLGETUNIFORMUI64VARB _glGetUniformui64vARB = &_get_glGetUniformui64vARB;

static void APIENTRY _fail_glGetnUniformi64vARB(GLuint program, GLint location, GLsizei bufSize, GLint64 * params) {
    const char *_name = "glGetnUniformi64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnUniformi64vARB(GLuint program, GLint location, GLsizei bufSize, GLint64 * params) {
    PFN_GLGETNUNIFORMI64VARB _ptr;
    _ptr = (PFN_GLGETNUNIFORMI64VARB)_getPrivateProcAddress("glGetnUniformi64vARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnUniformi64vARB;
    }
    _glGetnUniformi64vARB = _ptr;
    _glGetnUniformi64vARB(program, location, bufSize, params);
}

PFN_GLGETNUNIFORMI64VARB _glGetnUniformi64vARB = &_get_glGetnUniformi64vARB;

static void APIENTRY _fail_glGetnUniformui64vARB(GLuint program, GLint location, GLsizei bufSize, GLuint64 * params) {
    const char *_name = "glGetnUniformui64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnUniformui64vARB(GLuint program, GLint location, GLsizei bufSize, GLuint64 * params) {
    PFN_GLGETNUNIFORMUI64VARB _ptr;
    _ptr = (PFN_GLGETNUNIFORMUI64VARB)_getPrivateProcAddress("glGetnUniformui64vARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnUniformui64vARB;
    }
    _glGetnUniformui64vARB = _ptr;
    _glGetnUniformui64vARB(program, location, bufSize, params);
}

PFN_GLGETNUNIFORMUI64VARB _glGetnUniformui64vARB = &_get_glGetnUniformui64vARB;

static void APIENTRY _fail_glProgramUniform1i64ARB(GLuint program, GLint location, GLint64 x) {
    const char *_name = "glProgramUniform1i64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1i64ARB(GLuint program, GLint location, GLint64 x) {
    PFN_GLPROGRAMUNIFORM1I64ARB _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1I64ARB)_getPrivateProcAddress("glProgramUniform1i64ARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1i64ARB;
    }
    _glProgramUniform1i64ARB = _ptr;
    _glProgramUniform1i64ARB(program, location, x);
}

PFN_GLPROGRAMUNIFORM1I64ARB _glProgramUniform1i64ARB = &_get_glProgramUniform1i64ARB;

static void APIENTRY _fail_glProgramUniform2i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y) {
    const char *_name = "glProgramUniform2i64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y) {
    PFN_GLPROGRAMUNIFORM2I64ARB _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2I64ARB)_getPrivateProcAddress("glProgramUniform2i64ARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2i64ARB;
    }
    _glProgramUniform2i64ARB = _ptr;
    _glProgramUniform2i64ARB(program, location, x, y);
}

PFN_GLPROGRAMUNIFORM2I64ARB _glProgramUniform2i64ARB = &_get_glProgramUniform2i64ARB;

static void APIENTRY _fail_glProgramUniform3i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z) {
    const char *_name = "glProgramUniform3i64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z) {
    PFN_GLPROGRAMUNIFORM3I64ARB _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3I64ARB)_getPrivateProcAddress("glProgramUniform3i64ARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3i64ARB;
    }
    _glProgramUniform3i64ARB = _ptr;
    _glProgramUniform3i64ARB(program, location, x, y, z);
}

PFN_GLPROGRAMUNIFORM3I64ARB _glProgramUniform3i64ARB = &_get_glProgramUniform3i64ARB;

static void APIENTRY _fail_glProgramUniform4i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w) {
    const char *_name = "glProgramUniform4i64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w) {
    PFN_GLPROGRAMUNIFORM4I64ARB _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4I64ARB)_getPrivateProcAddress("glProgramUniform4i64ARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4i64ARB;
    }
    _glProgramUniform4i64ARB = _ptr;
    _glProgramUniform4i64ARB(program, location, x, y, z, w);
}

PFN_GLPROGRAMUNIFORM4I64ARB _glProgramUniform4i64ARB = &_get_glProgramUniform4i64ARB;

static void APIENTRY _fail_glProgramUniform1i64vARB(GLuint program, GLint location, GLsizei count, const GLint64 * value) {
    const char *_name = "glProgramUniform1i64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1i64vARB(GLuint program, GLint location, GLsizei count, const GLint64 * value) {
    PFN_GLPROGRAMUNIFORM1I64VARB _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1I64VARB)_getPrivateProcAddress("glProgramUniform1i64vARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1i64vARB;
    }
    _glProgramUniform1i64vARB = _ptr;
    _glProgramUniform1i64vARB(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM1I64VARB _glProgramUniform1i64vARB = &_get_glProgramUniform1i64vARB;

static void APIENTRY _fail_glProgramUniform2i64vARB(GLuint program, GLint location, GLsizei count, const GLint64 * value) {
    const char *_name = "glProgramUniform2i64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2i64vARB(GLuint program, GLint location, GLsizei count, const GLint64 * value) {
    PFN_GLPROGRAMUNIFORM2I64VARB _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2I64VARB)_getPrivateProcAddress("glProgramUniform2i64vARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2i64vARB;
    }
    _glProgramUniform2i64vARB = _ptr;
    _glProgramUniform2i64vARB(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM2I64VARB _glProgramUniform2i64vARB = &_get_glProgramUniform2i64vARB;

static void APIENTRY _fail_glProgramUniform3i64vARB(GLuint program, GLint location, GLsizei count, const GLint64 * value) {
    const char *_name = "glProgramUniform3i64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3i64vARB(GLuint program, GLint location, GLsizei count, const GLint64 * value) {
    PFN_GLPROGRAMUNIFORM3I64VARB _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3I64VARB)_getPrivateProcAddress("glProgramUniform3i64vARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3i64vARB;
    }
    _glProgramUniform3i64vARB = _ptr;
    _glProgramUniform3i64vARB(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM3I64VARB _glProgramUniform3i64vARB = &_get_glProgramUniform3i64vARB;

static void APIENTRY _fail_glProgramUniform4i64vARB(GLuint program, GLint location, GLsizei count, const GLint64 * value) {
    const char *_name = "glProgramUniform4i64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4i64vARB(GLuint program, GLint location, GLsizei count, const GLint64 * value) {
    PFN_GLPROGRAMUNIFORM4I64VARB _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4I64VARB)_getPrivateProcAddress("glProgramUniform4i64vARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4i64vARB;
    }
    _glProgramUniform4i64vARB = _ptr;
    _glProgramUniform4i64vARB(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM4I64VARB _glProgramUniform4i64vARB = &_get_glProgramUniform4i64vARB;

static void APIENTRY _fail_glProgramUniform1ui64ARB(GLuint program, GLint location, GLuint64 x) {
    const char *_name = "glProgramUniform1ui64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1ui64ARB(GLuint program, GLint location, GLuint64 x) {
    PFN_GLPROGRAMUNIFORM1UI64ARB _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1UI64ARB)_getPrivateProcAddress("glProgramUniform1ui64ARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1ui64ARB;
    }
    _glProgramUniform1ui64ARB = _ptr;
    _glProgramUniform1ui64ARB(program, location, x);
}

PFN_GLPROGRAMUNIFORM1UI64ARB _glProgramUniform1ui64ARB = &_get_glProgramUniform1ui64ARB;

static void APIENTRY _fail_glProgramUniform2ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y) {
    const char *_name = "glProgramUniform2ui64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y) {
    PFN_GLPROGRAMUNIFORM2UI64ARB _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2UI64ARB)_getPrivateProcAddress("glProgramUniform2ui64ARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2ui64ARB;
    }
    _glProgramUniform2ui64ARB = _ptr;
    _glProgramUniform2ui64ARB(program, location, x, y);
}

PFN_GLPROGRAMUNIFORM2UI64ARB _glProgramUniform2ui64ARB = &_get_glProgramUniform2ui64ARB;

static void APIENTRY _fail_glProgramUniform3ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z) {
    const char *_name = "glProgramUniform3ui64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z) {
    PFN_GLPROGRAMUNIFORM3UI64ARB _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3UI64ARB)_getPrivateProcAddress("glProgramUniform3ui64ARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3ui64ARB;
    }
    _glProgramUniform3ui64ARB = _ptr;
    _glProgramUniform3ui64ARB(program, location, x, y, z);
}

PFN_GLPROGRAMUNIFORM3UI64ARB _glProgramUniform3ui64ARB = &_get_glProgramUniform3ui64ARB;

static void APIENTRY _fail_glProgramUniform4ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w) {
    const char *_name = "glProgramUniform4ui64ARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w) {
    PFN_GLPROGRAMUNIFORM4UI64ARB _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4UI64ARB)_getPrivateProcAddress("glProgramUniform4ui64ARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4ui64ARB;
    }
    _glProgramUniform4ui64ARB = _ptr;
    _glProgramUniform4ui64ARB(program, location, x, y, z, w);
}

PFN_GLPROGRAMUNIFORM4UI64ARB _glProgramUniform4ui64ARB = &_get_glProgramUniform4ui64ARB;

static void APIENTRY _fail_glProgramUniform1ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * value) {
    const char *_name = "glProgramUniform1ui64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * value) {
    PFN_GLPROGRAMUNIFORM1UI64VARB _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1UI64VARB)_getPrivateProcAddress("glProgramUniform1ui64vARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1ui64vARB;
    }
    _glProgramUniform1ui64vARB = _ptr;
    _glProgramUniform1ui64vARB(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM1UI64VARB _glProgramUniform1ui64vARB = &_get_glProgramUniform1ui64vARB;

static void APIENTRY _fail_glProgramUniform2ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * value) {
    const char *_name = "glProgramUniform2ui64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * value) {
    PFN_GLPROGRAMUNIFORM2UI64VARB _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2UI64VARB)_getPrivateProcAddress("glProgramUniform2ui64vARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2ui64vARB;
    }
    _glProgramUniform2ui64vARB = _ptr;
    _glProgramUniform2ui64vARB(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM2UI64VARB _glProgramUniform2ui64vARB = &_get_glProgramUniform2ui64vARB;

static void APIENTRY _fail_glProgramUniform3ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * value) {
    const char *_name = "glProgramUniform3ui64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * value) {
    PFN_GLPROGRAMUNIFORM3UI64VARB _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3UI64VARB)_getPrivateProcAddress("glProgramUniform3ui64vARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3ui64vARB;
    }
    _glProgramUniform3ui64vARB = _ptr;
    _glProgramUniform3ui64vARB(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM3UI64VARB _glProgramUniform3ui64vARB = &_get_glProgramUniform3ui64vARB;

static void APIENTRY _fail_glProgramUniform4ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * value) {
    const char *_name = "glProgramUniform4ui64vARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 * value) {
    PFN_GLPROGRAMUNIFORM4UI64VARB _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4UI64VARB)_getPrivateProcAddress("glProgramUniform4ui64vARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4ui64vARB;
    }
    _glProgramUniform4ui64vARB = _ptr;
    _glProgramUniform4ui64vARB(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM4UI64VARB _glProgramUniform4ui64vARB = &_get_glProgramUniform4ui64vARB;

static void APIENTRY _fail_glMultiDrawArraysIndirectCountARB(GLenum mode, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) {
    const char *_name = "glMultiDrawArraysIndirectCountARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiDrawArraysIndirectCountARB(GLenum mode, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) {
    PFN_GLMULTIDRAWARRAYSINDIRECTCOUNTARB _ptr;
    _ptr = (PFN_GLMULTIDRAWARRAYSINDIRECTCOUNTARB)_getPrivateProcAddress("glMultiDrawArraysIndirectCountARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiDrawArraysIndirectCountARB;
    }
    _glMultiDrawArraysIndirectCountARB = _ptr;
    _glMultiDrawArraysIndirectCountARB(mode, indirect, drawcount, maxdrawcount, stride);
}

PFN_GLMULTIDRAWARRAYSINDIRECTCOUNTARB _glMultiDrawArraysIndirectCountARB = &_get_glMultiDrawArraysIndirectCountARB;

static void APIENTRY _fail_glMultiDrawElementsIndirectCountARB(GLenum mode, GLenum type, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) {
    const char *_name = "glMultiDrawElementsIndirectCountARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiDrawElementsIndirectCountARB(GLenum mode, GLenum type, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) {
    PFN_GLMULTIDRAWELEMENTSINDIRECTCOUNTARB _ptr;
    _ptr = (PFN_GLMULTIDRAWELEMENTSINDIRECTCOUNTARB)_getPrivateProcAddress("glMultiDrawElementsIndirectCountARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiDrawElementsIndirectCountARB;
    }
    _glMultiDrawElementsIndirectCountARB = _ptr;
    _glMultiDrawElementsIndirectCountARB(mode, type, indirect, drawcount, maxdrawcount, stride);
}

PFN_GLMULTIDRAWELEMENTSINDIRECTCOUNTARB _glMultiDrawElementsIndirectCountARB = &_get_glMultiDrawElementsIndirectCountARB;

static void APIENTRY _fail_glVertexAttribDivisorARB(GLuint index, GLuint divisor) {
    const char *_name = "glVertexAttribDivisorARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribDivisorARB(GLuint index, GLuint divisor) {
    PFN_GLVERTEXATTRIBDIVISORARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIBDIVISORARB)_getPrivateProcAddress("glVertexAttribDivisorARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribDivisorARB;
    }
    _glVertexAttribDivisorARB = _ptr;
    _glVertexAttribDivisorARB(index, divisor);
}

PFN_GLVERTEXATTRIBDIVISORARB _glVertexAttribDivisorARB = &_get_glVertexAttribDivisorARB;

static void APIENTRY _fail_glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint * params) {
    const char *_name = "glGetInternalformativ";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint * params) {
    PFN_GLGETINTERNALFORMATIV _ptr;
    _ptr = (PFN_GLGETINTERNALFORMATIV)_getPrivateProcAddress("glGetInternalformativ");
    if (!_ptr) {
        _ptr = &_fail_glGetInternalformativ;
    }
    _glGetInternalformativ = _ptr;
    _glGetInternalformativ(target, internalformat, pname, bufSize, params);
}

PFN_GLGETINTERNALFORMATIV _glGetInternalformativ = &_get_glGetInternalformativ;

static void APIENTRY _fail_glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 * params) {
    const char *_name = "glGetInternalformati64v";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 * params) {
    PFN_GLGETINTERNALFORMATI64V _ptr;
    _ptr = (PFN_GLGETINTERNALFORMATI64V)_getPrivateProcAddress("glGetInternalformati64v");
    if (!_ptr) {
        _ptr = &_fail_glGetInternalformati64v;
    }
    _glGetInternalformati64v = _ptr;
    _glGetInternalformati64v(target, internalformat, pname, bufSize, params);
}

PFN_GLGETINTERNALFORMATI64V _glGetInternalformati64v = &_get_glGetInternalformati64v;

static void APIENTRY _fail_glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth) {
    const char *_name = "glInvalidateTexSubImage";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth) {
    PFN_GLINVALIDATETEXSUBIMAGE _ptr;
    _ptr = (PFN_GLINVALIDATETEXSUBIMAGE)_getPrivateProcAddress("glInvalidateTexSubImage");
    if (!_ptr) {
        _ptr = &_fail_glInvalidateTexSubImage;
    }
    _glInvalidateTexSubImage = _ptr;
    _glInvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth);
}

PFN_GLINVALIDATETEXSUBIMAGE _glInvalidateTexSubImage = &_get_glInvalidateTexSubImage;

static void APIENTRY _fail_glInvalidateTexImage(GLuint texture, GLint level) {
    const char *_name = "glInvalidateTexImage";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glInvalidateTexImage(GLuint texture, GLint level) {
    PFN_GLINVALIDATETEXIMAGE _ptr;
    _ptr = (PFN_GLINVALIDATETEXIMAGE)_getPrivateProcAddress("glInvalidateTexImage");
    if (!_ptr) {
        _ptr = &_fail_glInvalidateTexImage;
    }
    _glInvalidateTexImage = _ptr;
    _glInvalidateTexImage(texture, level);
}

PFN_GLINVALIDATETEXIMAGE _glInvalidateTexImage = &_get_glInvalidateTexImage;

static void APIENTRY _fail_glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length) {
    const char *_name = "glInvalidateBufferSubData";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length) {
    PFN_GLINVALIDATEBUFFERSUBDATA _ptr;
    _ptr = (PFN_GLINVALIDATEBUFFERSUBDATA)_getPrivateProcAddress("glInvalidateBufferSubData");
    if (!_ptr) {
        _ptr = &_fail_glInvalidateBufferSubData;
    }
    _glInvalidateBufferSubData = _ptr;
    _glInvalidateBufferSubData(buffer, offset, length);
}

PFN_GLINVALIDATEBUFFERSUBDATA _glInvalidateBufferSubData = &_get_glInvalidateBufferSubData;

static void APIENTRY _fail_glInvalidateBufferData(GLuint buffer) {
    const char *_name = "glInvalidateBufferData";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glInvalidateBufferData(GLuint buffer) {
    PFN_GLINVALIDATEBUFFERDATA _ptr;
    _ptr = (PFN_GLINVALIDATEBUFFERDATA)_getPrivateProcAddress("glInvalidateBufferData");
    if (!_ptr) {
        _ptr = &_fail_glInvalidateBufferData;
    }
    _glInvalidateBufferData = _ptr;
    _glInvalidateBufferData(buffer);
}

PFN_GLINVALIDATEBUFFERDATA _glInvalidateBufferData = &_get_glInvalidateBufferData;

static void APIENTRY _fail_glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments) {
    const char *_name = "glInvalidateFramebuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments) {
    PFN_GLINVALIDATEFRAMEBUFFER _ptr;
    _ptr = (PFN_GLINVALIDATEFRAMEBUFFER)_getPrivateProcAddress("glInvalidateFramebuffer");
    if (!_ptr) {
        _ptr = &_fail_glInvalidateFramebuffer;
    }
    _glInvalidateFramebuffer = _ptr;
    _glInvalidateFramebuffer(target, numAttachments, attachments);
}

PFN_GLINVALIDATEFRAMEBUFFER _glInvalidateFramebuffer = &_get_glInvalidateFramebuffer;

static void APIENTRY _fail_glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glInvalidateSubFramebuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLINVALIDATESUBFRAMEBUFFER _ptr;
    _ptr = (PFN_GLINVALIDATESUBFRAMEBUFFER)_getPrivateProcAddress("glInvalidateSubFramebuffer");
    if (!_ptr) {
        _ptr = &_fail_glInvalidateSubFramebuffer;
    }
    _glInvalidateSubFramebuffer = _ptr;
    _glInvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height);
}

PFN_GLINVALIDATESUBFRAMEBUFFER _glInvalidateSubFramebuffer = &_get_glInvalidateSubFramebuffer;

static GLvoid * APIENTRY _fail_glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) {
    const char *_name = "glMapBufferRange";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLvoid * APIENTRY _get_glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) {
    PFN_GLMAPBUFFERRANGE _ptr;
    _ptr = (PFN_GLMAPBUFFERRANGE)_getPrivateProcAddress("glMapBufferRange");
    if (!_ptr) {
        _ptr = &_fail_glMapBufferRange;
    }
    _glMapBufferRange = _ptr;
    return _glMapBufferRange(target, offset, length, access);
}

PFN_GLMAPBUFFERRANGE _glMapBufferRange = &_get_glMapBufferRange;

static void APIENTRY _fail_glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length) {
    const char *_name = "glFlushMappedBufferRange";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length) {
    PFN_GLFLUSHMAPPEDBUFFERRANGE _ptr;
    _ptr = (PFN_GLFLUSHMAPPEDBUFFERRANGE)_getPrivateProcAddress("glFlushMappedBufferRange");
    if (!_ptr) {
        _ptr = &_fail_glFlushMappedBufferRange;
    }
    _glFlushMappedBufferRange = _ptr;
    _glFlushMappedBufferRange(target, offset, length);
}

PFN_GLFLUSHMAPPEDBUFFERRANGE _glFlushMappedBufferRange = &_get_glFlushMappedBufferRange;

static void APIENTRY _fail_glCurrentPaletteMatrixARB(GLint index) {
    const char *_name = "glCurrentPaletteMatrixARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCurrentPaletteMatrixARB(GLint index) {
    PFN_GLCURRENTPALETTEMATRIXARB _ptr;
    _ptr = (PFN_GLCURRENTPALETTEMATRIXARB)_getPrivateProcAddress("glCurrentPaletteMatrixARB");
    if (!_ptr) {
        _ptr = &_fail_glCurrentPaletteMatrixARB;
    }
    _glCurrentPaletteMatrixARB = _ptr;
    _glCurrentPaletteMatrixARB(index);
}

PFN_GLCURRENTPALETTEMATRIXARB _glCurrentPaletteMatrixARB = &_get_glCurrentPaletteMatrixARB;

static void APIENTRY _fail_glMatrixIndexubvARB(GLint size, const GLubyte * indices) {
    const char *_name = "glMatrixIndexubvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixIndexubvARB(GLint size, const GLubyte * indices) {
    PFN_GLMATRIXINDEXUBVARB _ptr;
    _ptr = (PFN_GLMATRIXINDEXUBVARB)_getPrivateProcAddress("glMatrixIndexubvARB");
    if (!_ptr) {
        _ptr = &_fail_glMatrixIndexubvARB;
    }
    _glMatrixIndexubvARB = _ptr;
    _glMatrixIndexubvARB(size, indices);
}

PFN_GLMATRIXINDEXUBVARB _glMatrixIndexubvARB = &_get_glMatrixIndexubvARB;

static void APIENTRY _fail_glMatrixIndexusvARB(GLint size, const GLushort * indices) {
    const char *_name = "glMatrixIndexusvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixIndexusvARB(GLint size, const GLushort * indices) {
    PFN_GLMATRIXINDEXUSVARB _ptr;
    _ptr = (PFN_GLMATRIXINDEXUSVARB)_getPrivateProcAddress("glMatrixIndexusvARB");
    if (!_ptr) {
        _ptr = &_fail_glMatrixIndexusvARB;
    }
    _glMatrixIndexusvARB = _ptr;
    _glMatrixIndexusvARB(size, indices);
}

PFN_GLMATRIXINDEXUSVARB _glMatrixIndexusvARB = &_get_glMatrixIndexusvARB;

static void APIENTRY _fail_glMatrixIndexuivARB(GLint size, const GLuint * indices) {
    const char *_name = "glMatrixIndexuivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixIndexuivARB(GLint size, const GLuint * indices) {
    PFN_GLMATRIXINDEXUIVARB _ptr;
    _ptr = (PFN_GLMATRIXINDEXUIVARB)_getPrivateProcAddress("glMatrixIndexuivARB");
    if (!_ptr) {
        _ptr = &_fail_glMatrixIndexuivARB;
    }
    _glMatrixIndexuivARB = _ptr;
    _glMatrixIndexuivARB(size, indices);
}

PFN_GLMATRIXINDEXUIVARB _glMatrixIndexuivARB = &_get_glMatrixIndexuivARB;

static void APIENTRY _fail_glMatrixIndexPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glMatrixIndexPointerARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixIndexPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLMATRIXINDEXPOINTERARB _ptr;
    _ptr = (PFN_GLMATRIXINDEXPOINTERARB)_getPrivateProcAddress("glMatrixIndexPointerARB");
    if (!_ptr) {
        _ptr = &_fail_glMatrixIndexPointerARB;
    }
    _glMatrixIndexPointerARB = _ptr;
    _glMatrixIndexPointerARB(size, type, stride, pointer);
}

PFN_GLMATRIXINDEXPOINTERARB _glMatrixIndexPointerARB = &_get_glMatrixIndexPointerARB;

static void APIENTRY _fail_glBindBuffersBase(GLenum target, GLuint first, GLsizei count, const GLuint * buffers) {
    const char *_name = "glBindBuffersBase";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindBuffersBase(GLenum target, GLuint first, GLsizei count, const GLuint * buffers) {
    PFN_GLBINDBUFFERSBASE _ptr;
    _ptr = (PFN_GLBINDBUFFERSBASE)_getPrivateProcAddress("glBindBuffersBase");
    if (!_ptr) {
        _ptr = &_fail_glBindBuffersBase;
    }
    _glBindBuffersBase = _ptr;
    _glBindBuffersBase(target, first, count, buffers);
}

PFN_GLBINDBUFFERSBASE _glBindBuffersBase = &_get_glBindBuffersBase;

static void APIENTRY _fail_glBindBuffersRange(GLenum target, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizeiptr * sizes) {
    const char *_name = "glBindBuffersRange";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindBuffersRange(GLenum target, GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizeiptr * sizes) {
    PFN_GLBINDBUFFERSRANGE _ptr;
    _ptr = (PFN_GLBINDBUFFERSRANGE)_getPrivateProcAddress("glBindBuffersRange");
    if (!_ptr) {
        _ptr = &_fail_glBindBuffersRange;
    }
    _glBindBuffersRange = _ptr;
    _glBindBuffersRange(target, first, count, buffers, offsets, sizes);
}

PFN_GLBINDBUFFERSRANGE _glBindBuffersRange = &_get_glBindBuffersRange;

static void APIENTRY _fail_glBindTextures(GLuint first, GLsizei count, const GLuint * textures) {
    const char *_name = "glBindTextures";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindTextures(GLuint first, GLsizei count, const GLuint * textures) {
    PFN_GLBINDTEXTURES _ptr;
    _ptr = (PFN_GLBINDTEXTURES)_getPrivateProcAddress("glBindTextures");
    if (!_ptr) {
        _ptr = &_fail_glBindTextures;
    }
    _glBindTextures = _ptr;
    _glBindTextures(first, count, textures);
}

PFN_GLBINDTEXTURES _glBindTextures = &_get_glBindTextures;

static void APIENTRY _fail_glBindSamplers(GLuint first, GLsizei count, const GLuint * samplers) {
    const char *_name = "glBindSamplers";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindSamplers(GLuint first, GLsizei count, const GLuint * samplers) {
    PFN_GLBINDSAMPLERS _ptr;
    _ptr = (PFN_GLBINDSAMPLERS)_getPrivateProcAddress("glBindSamplers");
    if (!_ptr) {
        _ptr = &_fail_glBindSamplers;
    }
    _glBindSamplers = _ptr;
    _glBindSamplers(first, count, samplers);
}

PFN_GLBINDSAMPLERS _glBindSamplers = &_get_glBindSamplers;

static void APIENTRY _fail_glBindImageTextures(GLuint first, GLsizei count, const GLuint * textures) {
    const char *_name = "glBindImageTextures";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindImageTextures(GLuint first, GLsizei count, const GLuint * textures) {
    PFN_GLBINDIMAGETEXTURES _ptr;
    _ptr = (PFN_GLBINDIMAGETEXTURES)_getPrivateProcAddress("glBindImageTextures");
    if (!_ptr) {
        _ptr = &_fail_glBindImageTextures;
    }
    _glBindImageTextures = _ptr;
    _glBindImageTextures(first, count, textures);
}

PFN_GLBINDIMAGETEXTURES _glBindImageTextures = &_get_glBindImageTextures;

static void APIENTRY _fail_glBindVertexBuffers(GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides) {
    const char *_name = "glBindVertexBuffers";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindVertexBuffers(GLuint first, GLsizei count, const GLuint * buffers, const GLintptr * offsets, const GLsizei * strides) {
    PFN_GLBINDVERTEXBUFFERS _ptr;
    _ptr = (PFN_GLBINDVERTEXBUFFERS)_getPrivateProcAddress("glBindVertexBuffers");
    if (!_ptr) {
        _ptr = &_fail_glBindVertexBuffers;
    }
    _glBindVertexBuffers = _ptr;
    _glBindVertexBuffers(first, count, buffers, offsets, strides);
}

PFN_GLBINDVERTEXBUFFERS _glBindVertexBuffers = &_get_glBindVertexBuffers;

static void APIENTRY _fail_glMultiDrawArraysIndirect(GLenum mode, const void * indirect, GLsizei drawcount, GLsizei stride) {
    const char *_name = "glMultiDrawArraysIndirect";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiDrawArraysIndirect(GLenum mode, const void * indirect, GLsizei drawcount, GLsizei stride) {
    PFN_GLMULTIDRAWARRAYSINDIRECT _ptr;
    _ptr = (PFN_GLMULTIDRAWARRAYSINDIRECT)_getPrivateProcAddress("glMultiDrawArraysIndirect");
    if (!_ptr) {
        _ptr = &_fail_glMultiDrawArraysIndirect;
    }
    _glMultiDrawArraysIndirect = _ptr;
    _glMultiDrawArraysIndirect(mode, indirect, drawcount, stride);
}

PFN_GLMULTIDRAWARRAYSINDIRECT _glMultiDrawArraysIndirect = &_get_glMultiDrawArraysIndirect;

static void APIENTRY _fail_glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect, GLsizei drawcount, GLsizei stride) {
    const char *_name = "glMultiDrawElementsIndirect";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void * indirect, GLsizei drawcount, GLsizei stride) {
    PFN_GLMULTIDRAWELEMENTSINDIRECT _ptr;
    _ptr = (PFN_GLMULTIDRAWELEMENTSINDIRECT)_getPrivateProcAddress("glMultiDrawElementsIndirect");
    if (!_ptr) {
        _ptr = &_fail_glMultiDrawElementsIndirect;
    }
    _glMultiDrawElementsIndirect = _ptr;
    _glMultiDrawElementsIndirect(mode, type, indirect, drawcount, stride);
}

PFN_GLMULTIDRAWELEMENTSINDIRECT _glMultiDrawElementsIndirect = &_get_glMultiDrawElementsIndirect;

static void APIENTRY _fail_glSampleCoverageARB(GLfloat value, GLboolean invert) {
    const char *_name = "glSampleCoverageARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSampleCoverageARB(GLfloat value, GLboolean invert) {
    PFN_GLSAMPLECOVERAGEARB _ptr;
    _ptr = (PFN_GLSAMPLECOVERAGEARB)_getPrivateProcAddress("glSampleCoverageARB");
    if (!_ptr) {
        _ptr = &_fail_glSampleCoverageARB;
    }
    _glSampleCoverageARB = _ptr;
    _glSampleCoverageARB(value, invert);
}

PFN_GLSAMPLECOVERAGEARB _glSampleCoverageARB = &_get_glSampleCoverageARB;

static void APIENTRY _fail_glActiveTextureARB(GLenum texture) {
    const char *_name = "glActiveTextureARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glActiveTextureARB(GLenum texture) {
    PFN_GLACTIVETEXTUREARB _ptr;
    _ptr = (PFN_GLACTIVETEXTUREARB)_getPrivateProcAddress("glActiveTextureARB");
    if (!_ptr) {
        _ptr = &_fail_glActiveTextureARB;
    }
    _glActiveTextureARB = _ptr;
    _glActiveTextureARB(texture);
}

PFN_GLACTIVETEXTUREARB _glActiveTextureARB = &_get_glActiveTextureARB;

static void APIENTRY _fail_glClientActiveTextureARB(GLenum texture) {
    const char *_name = "glClientActiveTextureARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClientActiveTextureARB(GLenum texture) {
    PFN_GLCLIENTACTIVETEXTUREARB _ptr;
    _ptr = (PFN_GLCLIENTACTIVETEXTUREARB)_getPrivateProcAddress("glClientActiveTextureARB");
    if (!_ptr) {
        _ptr = &_fail_glClientActiveTextureARB;
    }
    _glClientActiveTextureARB = _ptr;
    _glClientActiveTextureARB(texture);
}

PFN_GLCLIENTACTIVETEXTUREARB _glClientActiveTextureARB = &_get_glClientActiveTextureARB;

static void APIENTRY _fail_glMultiTexCoord1dARB(GLenum target, GLdouble s) {
    const char *_name = "glMultiTexCoord1dARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord1dARB(GLenum target, GLdouble s) {
    PFN_GLMULTITEXCOORD1DARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD1DARB)_getPrivateProcAddress("glMultiTexCoord1dARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord1dARB;
    }
    _glMultiTexCoord1dARB = _ptr;
    _glMultiTexCoord1dARB(target, s);
}

PFN_GLMULTITEXCOORD1DARB _glMultiTexCoord1dARB = &_get_glMultiTexCoord1dARB;

static void APIENTRY _fail_glMultiTexCoord1dvARB(GLenum target, const GLdouble * v) {
    const char *_name = "glMultiTexCoord1dvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord1dvARB(GLenum target, const GLdouble * v) {
    PFN_GLMULTITEXCOORD1DVARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD1DVARB)_getPrivateProcAddress("glMultiTexCoord1dvARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord1dvARB;
    }
    _glMultiTexCoord1dvARB = _ptr;
    _glMultiTexCoord1dvARB(target, v);
}

PFN_GLMULTITEXCOORD1DVARB _glMultiTexCoord1dvARB = &_get_glMultiTexCoord1dvARB;

static void APIENTRY _fail_glMultiTexCoord1fARB(GLenum target, GLfloat s) {
    const char *_name = "glMultiTexCoord1fARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord1fARB(GLenum target, GLfloat s) {
    PFN_GLMULTITEXCOORD1FARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD1FARB)_getPrivateProcAddress("glMultiTexCoord1fARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord1fARB;
    }
    _glMultiTexCoord1fARB = _ptr;
    _glMultiTexCoord1fARB(target, s);
}

PFN_GLMULTITEXCOORD1FARB _glMultiTexCoord1fARB = &_get_glMultiTexCoord1fARB;

static void APIENTRY _fail_glMultiTexCoord1fvARB(GLenum target, const GLfloat * v) {
    const char *_name = "glMultiTexCoord1fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord1fvARB(GLenum target, const GLfloat * v) {
    PFN_GLMULTITEXCOORD1FVARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD1FVARB)_getPrivateProcAddress("glMultiTexCoord1fvARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord1fvARB;
    }
    _glMultiTexCoord1fvARB = _ptr;
    _glMultiTexCoord1fvARB(target, v);
}

PFN_GLMULTITEXCOORD1FVARB _glMultiTexCoord1fvARB = &_get_glMultiTexCoord1fvARB;

static void APIENTRY _fail_glMultiTexCoord1iARB(GLenum target, GLint s) {
    const char *_name = "glMultiTexCoord1iARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord1iARB(GLenum target, GLint s) {
    PFN_GLMULTITEXCOORD1IARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD1IARB)_getPrivateProcAddress("glMultiTexCoord1iARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord1iARB;
    }
    _glMultiTexCoord1iARB = _ptr;
    _glMultiTexCoord1iARB(target, s);
}

PFN_GLMULTITEXCOORD1IARB _glMultiTexCoord1iARB = &_get_glMultiTexCoord1iARB;

static void APIENTRY _fail_glMultiTexCoord1ivARB(GLenum target, const GLint * v) {
    const char *_name = "glMultiTexCoord1ivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord1ivARB(GLenum target, const GLint * v) {
    PFN_GLMULTITEXCOORD1IVARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD1IVARB)_getPrivateProcAddress("glMultiTexCoord1ivARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord1ivARB;
    }
    _glMultiTexCoord1ivARB = _ptr;
    _glMultiTexCoord1ivARB(target, v);
}

PFN_GLMULTITEXCOORD1IVARB _glMultiTexCoord1ivARB = &_get_glMultiTexCoord1ivARB;

static void APIENTRY _fail_glMultiTexCoord1sARB(GLenum target, GLshort s) {
    const char *_name = "glMultiTexCoord1sARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord1sARB(GLenum target, GLshort s) {
    PFN_GLMULTITEXCOORD1SARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD1SARB)_getPrivateProcAddress("glMultiTexCoord1sARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord1sARB;
    }
    _glMultiTexCoord1sARB = _ptr;
    _glMultiTexCoord1sARB(target, s);
}

PFN_GLMULTITEXCOORD1SARB _glMultiTexCoord1sARB = &_get_glMultiTexCoord1sARB;

static void APIENTRY _fail_glMultiTexCoord1svARB(GLenum target, const GLshort * v) {
    const char *_name = "glMultiTexCoord1svARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord1svARB(GLenum target, const GLshort * v) {
    PFN_GLMULTITEXCOORD1SVARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD1SVARB)_getPrivateProcAddress("glMultiTexCoord1svARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord1svARB;
    }
    _glMultiTexCoord1svARB = _ptr;
    _glMultiTexCoord1svARB(target, v);
}

PFN_GLMULTITEXCOORD1SVARB _glMultiTexCoord1svARB = &_get_glMultiTexCoord1svARB;

static void APIENTRY _fail_glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t) {
    const char *_name = "glMultiTexCoord2dARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t) {
    PFN_GLMULTITEXCOORD2DARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD2DARB)_getPrivateProcAddress("glMultiTexCoord2dARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord2dARB;
    }
    _glMultiTexCoord2dARB = _ptr;
    _glMultiTexCoord2dARB(target, s, t);
}

PFN_GLMULTITEXCOORD2DARB _glMultiTexCoord2dARB = &_get_glMultiTexCoord2dARB;

static void APIENTRY _fail_glMultiTexCoord2dvARB(GLenum target, const GLdouble * v) {
    const char *_name = "glMultiTexCoord2dvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord2dvARB(GLenum target, const GLdouble * v) {
    PFN_GLMULTITEXCOORD2DVARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD2DVARB)_getPrivateProcAddress("glMultiTexCoord2dvARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord2dvARB;
    }
    _glMultiTexCoord2dvARB = _ptr;
    _glMultiTexCoord2dvARB(target, v);
}

PFN_GLMULTITEXCOORD2DVARB _glMultiTexCoord2dvARB = &_get_glMultiTexCoord2dvARB;

static void APIENTRY _fail_glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t) {
    const char *_name = "glMultiTexCoord2fARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t) {
    PFN_GLMULTITEXCOORD2FARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD2FARB)_getPrivateProcAddress("glMultiTexCoord2fARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord2fARB;
    }
    _glMultiTexCoord2fARB = _ptr;
    _glMultiTexCoord2fARB(target, s, t);
}

PFN_GLMULTITEXCOORD2FARB _glMultiTexCoord2fARB = &_get_glMultiTexCoord2fARB;

static void APIENTRY _fail_glMultiTexCoord2fvARB(GLenum target, const GLfloat * v) {
    const char *_name = "glMultiTexCoord2fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord2fvARB(GLenum target, const GLfloat * v) {
    PFN_GLMULTITEXCOORD2FVARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD2FVARB)_getPrivateProcAddress("glMultiTexCoord2fvARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord2fvARB;
    }
    _glMultiTexCoord2fvARB = _ptr;
    _glMultiTexCoord2fvARB(target, v);
}

PFN_GLMULTITEXCOORD2FVARB _glMultiTexCoord2fvARB = &_get_glMultiTexCoord2fvARB;

static void APIENTRY _fail_glMultiTexCoord2iARB(GLenum target, GLint s, GLint t) {
    const char *_name = "glMultiTexCoord2iARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord2iARB(GLenum target, GLint s, GLint t) {
    PFN_GLMULTITEXCOORD2IARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD2IARB)_getPrivateProcAddress("glMultiTexCoord2iARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord2iARB;
    }
    _glMultiTexCoord2iARB = _ptr;
    _glMultiTexCoord2iARB(target, s, t);
}

PFN_GLMULTITEXCOORD2IARB _glMultiTexCoord2iARB = &_get_glMultiTexCoord2iARB;

static void APIENTRY _fail_glMultiTexCoord2ivARB(GLenum target, const GLint * v) {
    const char *_name = "glMultiTexCoord2ivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord2ivARB(GLenum target, const GLint * v) {
    PFN_GLMULTITEXCOORD2IVARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD2IVARB)_getPrivateProcAddress("glMultiTexCoord2ivARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord2ivARB;
    }
    _glMultiTexCoord2ivARB = _ptr;
    _glMultiTexCoord2ivARB(target, v);
}

PFN_GLMULTITEXCOORD2IVARB _glMultiTexCoord2ivARB = &_get_glMultiTexCoord2ivARB;

static void APIENTRY _fail_glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t) {
    const char *_name = "glMultiTexCoord2sARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t) {
    PFN_GLMULTITEXCOORD2SARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD2SARB)_getPrivateProcAddress("glMultiTexCoord2sARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord2sARB;
    }
    _glMultiTexCoord2sARB = _ptr;
    _glMultiTexCoord2sARB(target, s, t);
}

PFN_GLMULTITEXCOORD2SARB _glMultiTexCoord2sARB = &_get_glMultiTexCoord2sARB;

static void APIENTRY _fail_glMultiTexCoord2svARB(GLenum target, const GLshort * v) {
    const char *_name = "glMultiTexCoord2svARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord2svARB(GLenum target, const GLshort * v) {
    PFN_GLMULTITEXCOORD2SVARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD2SVARB)_getPrivateProcAddress("glMultiTexCoord2svARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord2svARB;
    }
    _glMultiTexCoord2svARB = _ptr;
    _glMultiTexCoord2svARB(target, v);
}

PFN_GLMULTITEXCOORD2SVARB _glMultiTexCoord2svARB = &_get_glMultiTexCoord2svARB;

static void APIENTRY _fail_glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r) {
    const char *_name = "glMultiTexCoord3dARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r) {
    PFN_GLMULTITEXCOORD3DARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD3DARB)_getPrivateProcAddress("glMultiTexCoord3dARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord3dARB;
    }
    _glMultiTexCoord3dARB = _ptr;
    _glMultiTexCoord3dARB(target, s, t, r);
}

PFN_GLMULTITEXCOORD3DARB _glMultiTexCoord3dARB = &_get_glMultiTexCoord3dARB;

static void APIENTRY _fail_glMultiTexCoord3dvARB(GLenum target, const GLdouble * v) {
    const char *_name = "glMultiTexCoord3dvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord3dvARB(GLenum target, const GLdouble * v) {
    PFN_GLMULTITEXCOORD3DVARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD3DVARB)_getPrivateProcAddress("glMultiTexCoord3dvARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord3dvARB;
    }
    _glMultiTexCoord3dvARB = _ptr;
    _glMultiTexCoord3dvARB(target, v);
}

PFN_GLMULTITEXCOORD3DVARB _glMultiTexCoord3dvARB = &_get_glMultiTexCoord3dvARB;

static void APIENTRY _fail_glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r) {
    const char *_name = "glMultiTexCoord3fARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r) {
    PFN_GLMULTITEXCOORD3FARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD3FARB)_getPrivateProcAddress("glMultiTexCoord3fARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord3fARB;
    }
    _glMultiTexCoord3fARB = _ptr;
    _glMultiTexCoord3fARB(target, s, t, r);
}

PFN_GLMULTITEXCOORD3FARB _glMultiTexCoord3fARB = &_get_glMultiTexCoord3fARB;

static void APIENTRY _fail_glMultiTexCoord3fvARB(GLenum target, const GLfloat * v) {
    const char *_name = "glMultiTexCoord3fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord3fvARB(GLenum target, const GLfloat * v) {
    PFN_GLMULTITEXCOORD3FVARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD3FVARB)_getPrivateProcAddress("glMultiTexCoord3fvARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord3fvARB;
    }
    _glMultiTexCoord3fvARB = _ptr;
    _glMultiTexCoord3fvARB(target, v);
}

PFN_GLMULTITEXCOORD3FVARB _glMultiTexCoord3fvARB = &_get_glMultiTexCoord3fvARB;

static void APIENTRY _fail_glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r) {
    const char *_name = "glMultiTexCoord3iARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r) {
    PFN_GLMULTITEXCOORD3IARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD3IARB)_getPrivateProcAddress("glMultiTexCoord3iARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord3iARB;
    }
    _glMultiTexCoord3iARB = _ptr;
    _glMultiTexCoord3iARB(target, s, t, r);
}

PFN_GLMULTITEXCOORD3IARB _glMultiTexCoord3iARB = &_get_glMultiTexCoord3iARB;

static void APIENTRY _fail_glMultiTexCoord3ivARB(GLenum target, const GLint * v) {
    const char *_name = "glMultiTexCoord3ivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord3ivARB(GLenum target, const GLint * v) {
    PFN_GLMULTITEXCOORD3IVARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD3IVARB)_getPrivateProcAddress("glMultiTexCoord3ivARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord3ivARB;
    }
    _glMultiTexCoord3ivARB = _ptr;
    _glMultiTexCoord3ivARB(target, v);
}

PFN_GLMULTITEXCOORD3IVARB _glMultiTexCoord3ivARB = &_get_glMultiTexCoord3ivARB;

static void APIENTRY _fail_glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r) {
    const char *_name = "glMultiTexCoord3sARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r) {
    PFN_GLMULTITEXCOORD3SARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD3SARB)_getPrivateProcAddress("glMultiTexCoord3sARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord3sARB;
    }
    _glMultiTexCoord3sARB = _ptr;
    _glMultiTexCoord3sARB(target, s, t, r);
}

PFN_GLMULTITEXCOORD3SARB _glMultiTexCoord3sARB = &_get_glMultiTexCoord3sARB;

static void APIENTRY _fail_glMultiTexCoord3svARB(GLenum target, const GLshort * v) {
    const char *_name = "glMultiTexCoord3svARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord3svARB(GLenum target, const GLshort * v) {
    PFN_GLMULTITEXCOORD3SVARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD3SVARB)_getPrivateProcAddress("glMultiTexCoord3svARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord3svARB;
    }
    _glMultiTexCoord3svARB = _ptr;
    _glMultiTexCoord3svARB(target, v);
}

PFN_GLMULTITEXCOORD3SVARB _glMultiTexCoord3svARB = &_get_glMultiTexCoord3svARB;

static void APIENTRY _fail_glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q) {
    const char *_name = "glMultiTexCoord4dARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q) {
    PFN_GLMULTITEXCOORD4DARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4DARB)_getPrivateProcAddress("glMultiTexCoord4dARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4dARB;
    }
    _glMultiTexCoord4dARB = _ptr;
    _glMultiTexCoord4dARB(target, s, t, r, q);
}

PFN_GLMULTITEXCOORD4DARB _glMultiTexCoord4dARB = &_get_glMultiTexCoord4dARB;

static void APIENTRY _fail_glMultiTexCoord4dvARB(GLenum target, const GLdouble * v) {
    const char *_name = "glMultiTexCoord4dvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4dvARB(GLenum target, const GLdouble * v) {
    PFN_GLMULTITEXCOORD4DVARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4DVARB)_getPrivateProcAddress("glMultiTexCoord4dvARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4dvARB;
    }
    _glMultiTexCoord4dvARB = _ptr;
    _glMultiTexCoord4dvARB(target, v);
}

PFN_GLMULTITEXCOORD4DVARB _glMultiTexCoord4dvARB = &_get_glMultiTexCoord4dvARB;

static void APIENTRY _fail_glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
    const char *_name = "glMultiTexCoord4fARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
    PFN_GLMULTITEXCOORD4FARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4FARB)_getPrivateProcAddress("glMultiTexCoord4fARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4fARB;
    }
    _glMultiTexCoord4fARB = _ptr;
    _glMultiTexCoord4fARB(target, s, t, r, q);
}

PFN_GLMULTITEXCOORD4FARB _glMultiTexCoord4fARB = &_get_glMultiTexCoord4fARB;

static void APIENTRY _fail_glMultiTexCoord4fvARB(GLenum target, const GLfloat * v) {
    const char *_name = "glMultiTexCoord4fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4fvARB(GLenum target, const GLfloat * v) {
    PFN_GLMULTITEXCOORD4FVARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4FVARB)_getPrivateProcAddress("glMultiTexCoord4fvARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4fvARB;
    }
    _glMultiTexCoord4fvARB = _ptr;
    _glMultiTexCoord4fvARB(target, v);
}

PFN_GLMULTITEXCOORD4FVARB _glMultiTexCoord4fvARB = &_get_glMultiTexCoord4fvARB;

static void APIENTRY _fail_glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q) {
    const char *_name = "glMultiTexCoord4iARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q) {
    PFN_GLMULTITEXCOORD4IARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4IARB)_getPrivateProcAddress("glMultiTexCoord4iARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4iARB;
    }
    _glMultiTexCoord4iARB = _ptr;
    _glMultiTexCoord4iARB(target, s, t, r, q);
}

PFN_GLMULTITEXCOORD4IARB _glMultiTexCoord4iARB = &_get_glMultiTexCoord4iARB;

static void APIENTRY _fail_glMultiTexCoord4ivARB(GLenum target, const GLint * v) {
    const char *_name = "glMultiTexCoord4ivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4ivARB(GLenum target, const GLint * v) {
    PFN_GLMULTITEXCOORD4IVARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4IVARB)_getPrivateProcAddress("glMultiTexCoord4ivARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4ivARB;
    }
    _glMultiTexCoord4ivARB = _ptr;
    _glMultiTexCoord4ivARB(target, v);
}

PFN_GLMULTITEXCOORD4IVARB _glMultiTexCoord4ivARB = &_get_glMultiTexCoord4ivARB;

static void APIENTRY _fail_glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q) {
    const char *_name = "glMultiTexCoord4sARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q) {
    PFN_GLMULTITEXCOORD4SARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4SARB)_getPrivateProcAddress("glMultiTexCoord4sARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4sARB;
    }
    _glMultiTexCoord4sARB = _ptr;
    _glMultiTexCoord4sARB(target, s, t, r, q);
}

PFN_GLMULTITEXCOORD4SARB _glMultiTexCoord4sARB = &_get_glMultiTexCoord4sARB;

static void APIENTRY _fail_glMultiTexCoord4svARB(GLenum target, const GLshort * v) {
    const char *_name = "glMultiTexCoord4svARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4svARB(GLenum target, const GLshort * v) {
    PFN_GLMULTITEXCOORD4SVARB _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4SVARB)_getPrivateProcAddress("glMultiTexCoord4svARB");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4svARB;
    }
    _glMultiTexCoord4svARB = _ptr;
    _glMultiTexCoord4svARB(target, v);
}

PFN_GLMULTITEXCOORD4SVARB _glMultiTexCoord4svARB = &_get_glMultiTexCoord4svARB;

static void APIENTRY _fail_glGenQueriesARB(GLsizei n, GLuint * ids) {
    const char *_name = "glGenQueriesARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenQueriesARB(GLsizei n, GLuint * ids) {
    PFN_GLGENQUERIESARB _ptr;
    _ptr = (PFN_GLGENQUERIESARB)_getPrivateProcAddress("glGenQueriesARB");
    if (!_ptr) {
        _ptr = &_fail_glGenQueriesARB;
    }
    _glGenQueriesARB = _ptr;
    _glGenQueriesARB(n, ids);
}

PFN_GLGENQUERIESARB _glGenQueriesARB = &_get_glGenQueriesARB;

static void APIENTRY _fail_glDeleteQueriesARB(GLsizei n, const GLuint * ids) {
    const char *_name = "glDeleteQueriesARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteQueriesARB(GLsizei n, const GLuint * ids) {
    PFN_GLDELETEQUERIESARB _ptr;
    _ptr = (PFN_GLDELETEQUERIESARB)_getPrivateProcAddress("glDeleteQueriesARB");
    if (!_ptr) {
        _ptr = &_fail_glDeleteQueriesARB;
    }
    _glDeleteQueriesARB = _ptr;
    _glDeleteQueriesARB(n, ids);
}

PFN_GLDELETEQUERIESARB _glDeleteQueriesARB = &_get_glDeleteQueriesARB;

static GLboolean APIENTRY _fail_glIsQueryARB(GLuint id) {
    const char *_name = "glIsQueryARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsQueryARB(GLuint id) {
    PFN_GLISQUERYARB _ptr;
    _ptr = (PFN_GLISQUERYARB)_getPrivateProcAddress("glIsQueryARB");
    if (!_ptr) {
        _ptr = &_fail_glIsQueryARB;
    }
    _glIsQueryARB = _ptr;
    return _glIsQueryARB(id);
}

PFN_GLISQUERYARB _glIsQueryARB = &_get_glIsQueryARB;

static void APIENTRY _fail_glBeginQueryARB(GLenum target, GLuint id) {
    const char *_name = "glBeginQueryARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBeginQueryARB(GLenum target, GLuint id) {
    PFN_GLBEGINQUERYARB _ptr;
    _ptr = (PFN_GLBEGINQUERYARB)_getPrivateProcAddress("glBeginQueryARB");
    if (!_ptr) {
        _ptr = &_fail_glBeginQueryARB;
    }
    _glBeginQueryARB = _ptr;
    _glBeginQueryARB(target, id);
}

PFN_GLBEGINQUERYARB _glBeginQueryARB = &_get_glBeginQueryARB;

static void APIENTRY _fail_glEndQueryARB(GLenum target) {
    const char *_name = "glEndQueryARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEndQueryARB(GLenum target) {
    PFN_GLENDQUERYARB _ptr;
    _ptr = (PFN_GLENDQUERYARB)_getPrivateProcAddress("glEndQueryARB");
    if (!_ptr) {
        _ptr = &_fail_glEndQueryARB;
    }
    _glEndQueryARB = _ptr;
    _glEndQueryARB(target);
}

PFN_GLENDQUERYARB _glEndQueryARB = &_get_glEndQueryARB;

static void APIENTRY _fail_glGetQueryivARB(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetQueryivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryivARB(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETQUERYIVARB _ptr;
    _ptr = (PFN_GLGETQUERYIVARB)_getPrivateProcAddress("glGetQueryivARB");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryivARB;
    }
    _glGetQueryivARB = _ptr;
    _glGetQueryivARB(target, pname, params);
}

PFN_GLGETQUERYIVARB _glGetQueryivARB = &_get_glGetQueryivARB;

static void APIENTRY _fail_glGetQueryObjectivARB(GLuint id, GLenum pname, GLint * params) {
    const char *_name = "glGetQueryObjectivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryObjectivARB(GLuint id, GLenum pname, GLint * params) {
    PFN_GLGETQUERYOBJECTIVARB _ptr;
    _ptr = (PFN_GLGETQUERYOBJECTIVARB)_getPrivateProcAddress("glGetQueryObjectivARB");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryObjectivARB;
    }
    _glGetQueryObjectivARB = _ptr;
    _glGetQueryObjectivARB(id, pname, params);
}

PFN_GLGETQUERYOBJECTIVARB _glGetQueryObjectivARB = &_get_glGetQueryObjectivARB;

static void APIENTRY _fail_glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint * params) {
    const char *_name = "glGetQueryObjectuivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint * params) {
    PFN_GLGETQUERYOBJECTUIVARB _ptr;
    _ptr = (PFN_GLGETQUERYOBJECTUIVARB)_getPrivateProcAddress("glGetQueryObjectuivARB");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryObjectuivARB;
    }
    _glGetQueryObjectuivARB = _ptr;
    _glGetQueryObjectuivARB(id, pname, params);
}

PFN_GLGETQUERYOBJECTUIVARB _glGetQueryObjectuivARB = &_get_glGetQueryObjectuivARB;

static void APIENTRY _fail_glMaxShaderCompilerThreadsARB(GLuint count) {
    const char *_name = "glMaxShaderCompilerThreadsARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMaxShaderCompilerThreadsARB(GLuint count) {
    PFN_GLMAXSHADERCOMPILERTHREADSARB _ptr;
    _ptr = (PFN_GLMAXSHADERCOMPILERTHREADSARB)_getPrivateProcAddress("glMaxShaderCompilerThreadsARB");
    if (!_ptr) {
        _ptr = &_fail_glMaxShaderCompilerThreadsARB;
    }
    _glMaxShaderCompilerThreadsARB = _ptr;
    _glMaxShaderCompilerThreadsARB(count);
}

PFN_GLMAXSHADERCOMPILERTHREADSARB _glMaxShaderCompilerThreadsARB = &_get_glMaxShaderCompilerThreadsARB;

static void APIENTRY _fail_glPointParameterfARB(GLenum pname, GLfloat param) {
    const char *_name = "glPointParameterfARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPointParameterfARB(GLenum pname, GLfloat param) {
    PFN_GLPOINTPARAMETERFARB _ptr;
    _ptr = (PFN_GLPOINTPARAMETERFARB)_getPrivateProcAddress("glPointParameterfARB");
    if (!_ptr) {
        _ptr = &_fail_glPointParameterfARB;
    }
    _glPointParameterfARB = _ptr;
    _glPointParameterfARB(pname, param);
}

PFN_GLPOINTPARAMETERFARB _glPointParameterfARB = &_get_glPointParameterfARB;

static void APIENTRY _fail_glPointParameterfvARB(GLenum pname, const GLfloat * params) {
    const char *_name = "glPointParameterfvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPointParameterfvARB(GLenum pname, const GLfloat * params) {
    PFN_GLPOINTPARAMETERFVARB _ptr;
    _ptr = (PFN_GLPOINTPARAMETERFVARB)_getPrivateProcAddress("glPointParameterfvARB");
    if (!_ptr) {
        _ptr = &_fail_glPointParameterfvARB;
    }
    _glPointParameterfvARB = _ptr;
    _glPointParameterfvARB(pname, params);
}

PFN_GLPOINTPARAMETERFVARB _glPointParameterfvARB = &_get_glPointParameterfvARB;

static void APIENTRY _fail_glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint * params) {
    const char *_name = "glGetProgramInterfaceiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint * params) {
    PFN_GLGETPROGRAMINTERFACEIV _ptr;
    _ptr = (PFN_GLGETPROGRAMINTERFACEIV)_getPrivateProcAddress("glGetProgramInterfaceiv");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramInterfaceiv;
    }
    _glGetProgramInterfaceiv = _ptr;
    _glGetProgramInterfaceiv(program, programInterface, pname, params);
}

PFN_GLGETPROGRAMINTERFACEIV _glGetProgramInterfaceiv = &_get_glGetProgramInterfaceiv;

static GLuint APIENTRY _fail_glGetProgramResourceIndex(GLuint program, GLenum programInterface, const GLchar * name) {
    const char *_name = "glGetProgramResourceIndex";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glGetProgramResourceIndex(GLuint program, GLenum programInterface, const GLchar * name) {
    PFN_GLGETPROGRAMRESOURCEINDEX _ptr;
    _ptr = (PFN_GLGETPROGRAMRESOURCEINDEX)_getPrivateProcAddress("glGetProgramResourceIndex");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramResourceIndex;
    }
    _glGetProgramResourceIndex = _ptr;
    return _glGetProgramResourceIndex(program, programInterface, name);
}

PFN_GLGETPROGRAMRESOURCEINDEX _glGetProgramResourceIndex = &_get_glGetProgramResourceIndex;

static void APIENTRY _fail_glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name) {
    const char *_name = "glGetProgramResourceName";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name) {
    PFN_GLGETPROGRAMRESOURCENAME _ptr;
    _ptr = (PFN_GLGETPROGRAMRESOURCENAME)_getPrivateProcAddress("glGetProgramResourceName");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramResourceName;
    }
    _glGetProgramResourceName = _ptr;
    _glGetProgramResourceName(program, programInterface, index, bufSize, length, name);
}

PFN_GLGETPROGRAMRESOURCENAME _glGetProgramResourceName = &_get_glGetProgramResourceName;

static void APIENTRY _fail_glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei bufSize, GLsizei * length, GLint * params) {
    const char *_name = "glGetProgramResourceiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei bufSize, GLsizei * length, GLint * params) {
    PFN_GLGETPROGRAMRESOURCEIV _ptr;
    _ptr = (PFN_GLGETPROGRAMRESOURCEIV)_getPrivateProcAddress("glGetProgramResourceiv");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramResourceiv;
    }
    _glGetProgramResourceiv = _ptr;
    _glGetProgramResourceiv(program, programInterface, index, propCount, props, bufSize, length, params);
}

PFN_GLGETPROGRAMRESOURCEIV _glGetProgramResourceiv = &_get_glGetProgramResourceiv;

static GLint APIENTRY _fail_glGetProgramResourceLocation(GLuint program, GLenum programInterface, const GLchar * name) {
    const char *_name = "glGetProgramResourceLocation";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLint APIENTRY _get_glGetProgramResourceLocation(GLuint program, GLenum programInterface, const GLchar * name) {
    PFN_GLGETPROGRAMRESOURCELOCATION _ptr;
    _ptr = (PFN_GLGETPROGRAMRESOURCELOCATION)_getPrivateProcAddress("glGetProgramResourceLocation");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramResourceLocation;
    }
    _glGetProgramResourceLocation = _ptr;
    return _glGetProgramResourceLocation(program, programInterface, name);
}

PFN_GLGETPROGRAMRESOURCELOCATION _glGetProgramResourceLocation = &_get_glGetProgramResourceLocation;

static GLint APIENTRY _fail_glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const GLchar * name) {
    const char *_name = "glGetProgramResourceLocationIndex";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLint APIENTRY _get_glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const GLchar * name) {
    PFN_GLGETPROGRAMRESOURCELOCATIONINDEX _ptr;
    _ptr = (PFN_GLGETPROGRAMRESOURCELOCATIONINDEX)_getPrivateProcAddress("glGetProgramResourceLocationIndex");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramResourceLocationIndex;
    }
    _glGetProgramResourceLocationIndex = _ptr;
    return _glGetProgramResourceLocationIndex(program, programInterface, name);
}

PFN_GLGETPROGRAMRESOURCELOCATIONINDEX _glGetProgramResourceLocationIndex = &_get_glGetProgramResourceLocationIndex;

static void APIENTRY _fail_glProvokingVertex(GLenum mode) {
    const char *_name = "glProvokingVertex";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProvokingVertex(GLenum mode) {
    PFN_GLPROVOKINGVERTEX _ptr;
    _ptr = (PFN_GLPROVOKINGVERTEX)_getPrivateProcAddress("glProvokingVertex");
    if (!_ptr) {
        _ptr = &_fail_glProvokingVertex;
    }
    _glProvokingVertex = _ptr;
    _glProvokingVertex(mode);
}

PFN_GLPROVOKINGVERTEX _glProvokingVertex = &_get_glProvokingVertex;

static GLenum APIENTRY _fail_glGetGraphicsResetStatusARB(void) {
    const char *_name = "glGetGraphicsResetStatusARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLenum APIENTRY _get_glGetGraphicsResetStatusARB(void) {
    PFN_GLGETGRAPHICSRESETSTATUSARB _ptr;
    _ptr = (PFN_GLGETGRAPHICSRESETSTATUSARB)_getPrivateProcAddress("glGetGraphicsResetStatusARB");
    if (!_ptr) {
        _ptr = &_fail_glGetGraphicsResetStatusARB;
    }
    _glGetGraphicsResetStatusARB = _ptr;
    return _glGetGraphicsResetStatusARB();
}

PFN_GLGETGRAPHICSRESETSTATUSARB _glGetGraphicsResetStatusARB = &_get_glGetGraphicsResetStatusARB;

static void APIENTRY _fail_glGetnMapdvARB(GLenum target, GLenum query, GLsizei bufSize, GLdouble * v) {
    const char *_name = "glGetnMapdvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnMapdvARB(GLenum target, GLenum query, GLsizei bufSize, GLdouble * v) {
    PFN_GLGETNMAPDVARB _ptr;
    _ptr = (PFN_GLGETNMAPDVARB)_getPrivateProcAddress("glGetnMapdvARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnMapdvARB;
    }
    _glGetnMapdvARB = _ptr;
    _glGetnMapdvARB(target, query, bufSize, v);
}

PFN_GLGETNMAPDVARB _glGetnMapdvARB = &_get_glGetnMapdvARB;

static void APIENTRY _fail_glGetnMapfvARB(GLenum target, GLenum query, GLsizei bufSize, GLfloat * v) {
    const char *_name = "glGetnMapfvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnMapfvARB(GLenum target, GLenum query, GLsizei bufSize, GLfloat * v) {
    PFN_GLGETNMAPFVARB _ptr;
    _ptr = (PFN_GLGETNMAPFVARB)_getPrivateProcAddress("glGetnMapfvARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnMapfvARB;
    }
    _glGetnMapfvARB = _ptr;
    _glGetnMapfvARB(target, query, bufSize, v);
}

PFN_GLGETNMAPFVARB _glGetnMapfvARB = &_get_glGetnMapfvARB;

static void APIENTRY _fail_glGetnMapivARB(GLenum target, GLenum query, GLsizei bufSize, GLint * v) {
    const char *_name = "glGetnMapivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnMapivARB(GLenum target, GLenum query, GLsizei bufSize, GLint * v) {
    PFN_GLGETNMAPIVARB _ptr;
    _ptr = (PFN_GLGETNMAPIVARB)_getPrivateProcAddress("glGetnMapivARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnMapivARB;
    }
    _glGetnMapivARB = _ptr;
    _glGetnMapivARB(target, query, bufSize, v);
}

PFN_GLGETNMAPIVARB _glGetnMapivARB = &_get_glGetnMapivARB;

static void APIENTRY _fail_glGetnPixelMapfvARB(GLenum map, GLsizei bufSize, GLfloat * values) {
    const char *_name = "glGetnPixelMapfvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnPixelMapfvARB(GLenum map, GLsizei bufSize, GLfloat * values) {
    PFN_GLGETNPIXELMAPFVARB _ptr;
    _ptr = (PFN_GLGETNPIXELMAPFVARB)_getPrivateProcAddress("glGetnPixelMapfvARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnPixelMapfvARB;
    }
    _glGetnPixelMapfvARB = _ptr;
    _glGetnPixelMapfvARB(map, bufSize, values);
}

PFN_GLGETNPIXELMAPFVARB _glGetnPixelMapfvARB = &_get_glGetnPixelMapfvARB;

static void APIENTRY _fail_glGetnPixelMapuivARB(GLenum map, GLsizei bufSize, GLuint * values) {
    const char *_name = "glGetnPixelMapuivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnPixelMapuivARB(GLenum map, GLsizei bufSize, GLuint * values) {
    PFN_GLGETNPIXELMAPUIVARB _ptr;
    _ptr = (PFN_GLGETNPIXELMAPUIVARB)_getPrivateProcAddress("glGetnPixelMapuivARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnPixelMapuivARB;
    }
    _glGetnPixelMapuivARB = _ptr;
    _glGetnPixelMapuivARB(map, bufSize, values);
}

PFN_GLGETNPIXELMAPUIVARB _glGetnPixelMapuivARB = &_get_glGetnPixelMapuivARB;

static void APIENTRY _fail_glGetnPixelMapusvARB(GLenum map, GLsizei bufSize, GLushort * values) {
    const char *_name = "glGetnPixelMapusvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnPixelMapusvARB(GLenum map, GLsizei bufSize, GLushort * values) {
    PFN_GLGETNPIXELMAPUSVARB _ptr;
    _ptr = (PFN_GLGETNPIXELMAPUSVARB)_getPrivateProcAddress("glGetnPixelMapusvARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnPixelMapusvARB;
    }
    _glGetnPixelMapusvARB = _ptr;
    _glGetnPixelMapusvARB(map, bufSize, values);
}

PFN_GLGETNPIXELMAPUSVARB _glGetnPixelMapusvARB = &_get_glGetnPixelMapusvARB;

static void APIENTRY _fail_glGetnPolygonStippleARB(GLsizei bufSize, GLubyte * pattern) {
    const char *_name = "glGetnPolygonStippleARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnPolygonStippleARB(GLsizei bufSize, GLubyte * pattern) {
    PFN_GLGETNPOLYGONSTIPPLEARB _ptr;
    _ptr = (PFN_GLGETNPOLYGONSTIPPLEARB)_getPrivateProcAddress("glGetnPolygonStippleARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnPolygonStippleARB;
    }
    _glGetnPolygonStippleARB = _ptr;
    _glGetnPolygonStippleARB(bufSize, pattern);
}

PFN_GLGETNPOLYGONSTIPPLEARB _glGetnPolygonStippleARB = &_get_glGetnPolygonStippleARB;

static void APIENTRY _fail_glGetnColorTableARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid * table) {
    const char *_name = "glGetnColorTableARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnColorTableARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid * table) {
    PFN_GLGETNCOLORTABLEARB _ptr;
    _ptr = (PFN_GLGETNCOLORTABLEARB)_getPrivateProcAddress("glGetnColorTableARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnColorTableARB;
    }
    _glGetnColorTableARB = _ptr;
    _glGetnColorTableARB(target, format, type, bufSize, table);
}

PFN_GLGETNCOLORTABLEARB _glGetnColorTableARB = &_get_glGetnColorTableARB;

static void APIENTRY _fail_glGetnConvolutionFilterARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid * image) {
    const char *_name = "glGetnConvolutionFilterARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnConvolutionFilterARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid * image) {
    PFN_GLGETNCONVOLUTIONFILTERARB _ptr;
    _ptr = (PFN_GLGETNCONVOLUTIONFILTERARB)_getPrivateProcAddress("glGetnConvolutionFilterARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnConvolutionFilterARB;
    }
    _glGetnConvolutionFilterARB = _ptr;
    _glGetnConvolutionFilterARB(target, format, type, bufSize, image);
}

PFN_GLGETNCONVOLUTIONFILTERARB _glGetnConvolutionFilterARB = &_get_glGetnConvolutionFilterARB;

static void APIENTRY _fail_glGetnSeparableFilterARB(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid * row, GLsizei columnBufSize, GLvoid * column, GLvoid * span) {
    const char *_name = "glGetnSeparableFilterARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnSeparableFilterARB(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid * row, GLsizei columnBufSize, GLvoid * column, GLvoid * span) {
    PFN_GLGETNSEPARABLEFILTERARB _ptr;
    _ptr = (PFN_GLGETNSEPARABLEFILTERARB)_getPrivateProcAddress("glGetnSeparableFilterARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnSeparableFilterARB;
    }
    _glGetnSeparableFilterARB = _ptr;
    _glGetnSeparableFilterARB(target, format, type, rowBufSize, row, columnBufSize, column, span);
}

PFN_GLGETNSEPARABLEFILTERARB _glGetnSeparableFilterARB = &_get_glGetnSeparableFilterARB;

static void APIENTRY _fail_glGetnHistogramARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid * values) {
    const char *_name = "glGetnHistogramARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnHistogramARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid * values) {
    PFN_GLGETNHISTOGRAMARB _ptr;
    _ptr = (PFN_GLGETNHISTOGRAMARB)_getPrivateProcAddress("glGetnHistogramARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnHistogramARB;
    }
    _glGetnHistogramARB = _ptr;
    _glGetnHistogramARB(target, reset, format, type, bufSize, values);
}

PFN_GLGETNHISTOGRAMARB _glGetnHistogramARB = &_get_glGetnHistogramARB;

static void APIENTRY _fail_glGetnMinmaxARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid * values) {
    const char *_name = "glGetnMinmaxARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnMinmaxARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid * values) {
    PFN_GLGETNMINMAXARB _ptr;
    _ptr = (PFN_GLGETNMINMAXARB)_getPrivateProcAddress("glGetnMinmaxARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnMinmaxARB;
    }
    _glGetnMinmaxARB = _ptr;
    _glGetnMinmaxARB(target, reset, format, type, bufSize, values);
}

PFN_GLGETNMINMAXARB _glGetnMinmaxARB = &_get_glGetnMinmaxARB;

static void APIENTRY _fail_glGetnTexImageARB(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid * img) {
    const char *_name = "glGetnTexImageARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnTexImageARB(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid * img) {
    PFN_GLGETNTEXIMAGEARB _ptr;
    _ptr = (PFN_GLGETNTEXIMAGEARB)_getPrivateProcAddress("glGetnTexImageARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnTexImageARB;
    }
    _glGetnTexImageARB = _ptr;
    _glGetnTexImageARB(target, level, format, type, bufSize, img);
}

PFN_GLGETNTEXIMAGEARB _glGetnTexImageARB = &_get_glGetnTexImageARB;

static void APIENTRY _fail_glReadnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid * data) {
    const char *_name = "glReadnPixelsARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReadnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid * data) {
    PFN_GLREADNPIXELSARB _ptr;
    _ptr = (PFN_GLREADNPIXELSARB)_getPrivateProcAddress("glReadnPixelsARB");
    if (!_ptr) {
        _ptr = &_fail_glReadnPixelsARB;
    }
    _glReadnPixelsARB = _ptr;
    _glReadnPixelsARB(x, y, width, height, format, type, bufSize, data);
}

PFN_GLREADNPIXELSARB _glReadnPixelsARB = &_get_glReadnPixelsARB;

static void APIENTRY _fail_glGetnCompressedTexImageARB(GLenum target, GLint lod, GLsizei bufSize, GLvoid * img) {
    const char *_name = "glGetnCompressedTexImageARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnCompressedTexImageARB(GLenum target, GLint lod, GLsizei bufSize, GLvoid * img) {
    PFN_GLGETNCOMPRESSEDTEXIMAGEARB _ptr;
    _ptr = (PFN_GLGETNCOMPRESSEDTEXIMAGEARB)_getPrivateProcAddress("glGetnCompressedTexImageARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnCompressedTexImageARB;
    }
    _glGetnCompressedTexImageARB = _ptr;
    _glGetnCompressedTexImageARB(target, lod, bufSize, img);
}

PFN_GLGETNCOMPRESSEDTEXIMAGEARB _glGetnCompressedTexImageARB = &_get_glGetnCompressedTexImageARB;

static void APIENTRY _fail_glGetnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat * params) {
    const char *_name = "glGetnUniformfvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat * params) {
    PFN_GLGETNUNIFORMFVARB _ptr;
    _ptr = (PFN_GLGETNUNIFORMFVARB)_getPrivateProcAddress("glGetnUniformfvARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnUniformfvARB;
    }
    _glGetnUniformfvARB = _ptr;
    _glGetnUniformfvARB(program, location, bufSize, params);
}

PFN_GLGETNUNIFORMFVARB _glGetnUniformfvARB = &_get_glGetnUniformfvARB;

static void APIENTRY _fail_glGetnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint * params) {
    const char *_name = "glGetnUniformivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint * params) {
    PFN_GLGETNUNIFORMIVARB _ptr;
    _ptr = (PFN_GLGETNUNIFORMIVARB)_getPrivateProcAddress("glGetnUniformivARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnUniformivARB;
    }
    _glGetnUniformivARB = _ptr;
    _glGetnUniformivARB(program, location, bufSize, params);
}

PFN_GLGETNUNIFORMIVARB _glGetnUniformivARB = &_get_glGetnUniformivARB;

static void APIENTRY _fail_glGetnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint * params) {
    const char *_name = "glGetnUniformuivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint * params) {
    PFN_GLGETNUNIFORMUIVARB _ptr;
    _ptr = (PFN_GLGETNUNIFORMUIVARB)_getPrivateProcAddress("glGetnUniformuivARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnUniformuivARB;
    }
    _glGetnUniformuivARB = _ptr;
    _glGetnUniformuivARB(program, location, bufSize, params);
}

PFN_GLGETNUNIFORMUIVARB _glGetnUniformuivARB = &_get_glGetnUniformuivARB;

static void APIENTRY _fail_glGetnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble * params) {
    const char *_name = "glGetnUniformdvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble * params) {
    PFN_GLGETNUNIFORMDVARB _ptr;
    _ptr = (PFN_GLGETNUNIFORMDVARB)_getPrivateProcAddress("glGetnUniformdvARB");
    if (!_ptr) {
        _ptr = &_fail_glGetnUniformdvARB;
    }
    _glGetnUniformdvARB = _ptr;
    _glGetnUniformdvARB(program, location, bufSize, params);
}

PFN_GLGETNUNIFORMDVARB _glGetnUniformdvARB = &_get_glGetnUniformdvARB;

static void APIENTRY _fail_glFramebufferSampleLocationsfvARB(GLenum target, GLuint start, GLsizei count, const GLfloat * v) {
    const char *_name = "glFramebufferSampleLocationsfvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferSampleLocationsfvARB(GLenum target, GLuint start, GLsizei count, const GLfloat * v) {
    PFN_GLFRAMEBUFFERSAMPLELOCATIONSFVARB _ptr;
    _ptr = (PFN_GLFRAMEBUFFERSAMPLELOCATIONSFVARB)_getPrivateProcAddress("glFramebufferSampleLocationsfvARB");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferSampleLocationsfvARB;
    }
    _glFramebufferSampleLocationsfvARB = _ptr;
    _glFramebufferSampleLocationsfvARB(target, start, count, v);
}

PFN_GLFRAMEBUFFERSAMPLELOCATIONSFVARB _glFramebufferSampleLocationsfvARB = &_get_glFramebufferSampleLocationsfvARB;

static void APIENTRY _fail_glNamedFramebufferSampleLocationsfvARB(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat * v) {
    const char *_name = "glNamedFramebufferSampleLocationsfvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedFramebufferSampleLocationsfvARB(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat * v) {
    PFN_GLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARB _ptr;
    _ptr = (PFN_GLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARB)_getPrivateProcAddress("glNamedFramebufferSampleLocationsfvARB");
    if (!_ptr) {
        _ptr = &_fail_glNamedFramebufferSampleLocationsfvARB;
    }
    _glNamedFramebufferSampleLocationsfvARB = _ptr;
    _glNamedFramebufferSampleLocationsfvARB(framebuffer, start, count, v);
}

PFN_GLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARB _glNamedFramebufferSampleLocationsfvARB = &_get_glNamedFramebufferSampleLocationsfvARB;

static void APIENTRY _fail_glEvaluateDepthValuesARB(void) {
    const char *_name = "glEvaluateDepthValuesARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEvaluateDepthValuesARB(void) {
    PFN_GLEVALUATEDEPTHVALUESARB _ptr;
    _ptr = (PFN_GLEVALUATEDEPTHVALUESARB)_getPrivateProcAddress("glEvaluateDepthValuesARB");
    if (!_ptr) {
        _ptr = &_fail_glEvaluateDepthValuesARB;
    }
    _glEvaluateDepthValuesARB = _ptr;
    _glEvaluateDepthValuesARB();
}

PFN_GLEVALUATEDEPTHVALUESARB _glEvaluateDepthValuesARB = &_get_glEvaluateDepthValuesARB;

static void APIENTRY _fail_glMinSampleShadingARB(GLfloat value) {
    const char *_name = "glMinSampleShadingARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMinSampleShadingARB(GLfloat value) {
    PFN_GLMINSAMPLESHADINGARB _ptr;
    _ptr = (PFN_GLMINSAMPLESHADINGARB)_getPrivateProcAddress("glMinSampleShadingARB");
    if (!_ptr) {
        _ptr = &_fail_glMinSampleShadingARB;
    }
    _glMinSampleShadingARB = _ptr;
    _glMinSampleShadingARB(value);
}

PFN_GLMINSAMPLESHADINGARB _glMinSampleShadingARB = &_get_glMinSampleShadingARB;

static void APIENTRY _fail_glGenSamplers(GLsizei count, GLuint * samplers) {
    const char *_name = "glGenSamplers";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenSamplers(GLsizei count, GLuint * samplers) {
    PFN_GLGENSAMPLERS _ptr;
    _ptr = (PFN_GLGENSAMPLERS)_getPrivateProcAddress("glGenSamplers");
    if (!_ptr) {
        _ptr = &_fail_glGenSamplers;
    }
    _glGenSamplers = _ptr;
    _glGenSamplers(count, samplers);
}

PFN_GLGENSAMPLERS _glGenSamplers = &_get_glGenSamplers;

static void APIENTRY _fail_glDeleteSamplers(GLsizei count, const GLuint * samplers) {
    const char *_name = "glDeleteSamplers";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteSamplers(GLsizei count, const GLuint * samplers) {
    PFN_GLDELETESAMPLERS _ptr;
    _ptr = (PFN_GLDELETESAMPLERS)_getPrivateProcAddress("glDeleteSamplers");
    if (!_ptr) {
        _ptr = &_fail_glDeleteSamplers;
    }
    _glDeleteSamplers = _ptr;
    _glDeleteSamplers(count, samplers);
}

PFN_GLDELETESAMPLERS _glDeleteSamplers = &_get_glDeleteSamplers;

static GLboolean APIENTRY _fail_glIsSampler(GLuint sampler) {
    const char *_name = "glIsSampler";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsSampler(GLuint sampler) {
    PFN_GLISSAMPLER _ptr;
    _ptr = (PFN_GLISSAMPLER)_getPrivateProcAddress("glIsSampler");
    if (!_ptr) {
        _ptr = &_fail_glIsSampler;
    }
    _glIsSampler = _ptr;
    return _glIsSampler(sampler);
}

PFN_GLISSAMPLER _glIsSampler = &_get_glIsSampler;

static void APIENTRY _fail_glBindSampler(GLuint unit, GLuint sampler) {
    const char *_name = "glBindSampler";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindSampler(GLuint unit, GLuint sampler) {
    PFN_GLBINDSAMPLER _ptr;
    _ptr = (PFN_GLBINDSAMPLER)_getPrivateProcAddress("glBindSampler");
    if (!_ptr) {
        _ptr = &_fail_glBindSampler;
    }
    _glBindSampler = _ptr;
    _glBindSampler(unit, sampler);
}

PFN_GLBINDSAMPLER _glBindSampler = &_get_glBindSampler;

static void APIENTRY _fail_glSamplerParameteri(GLuint sampler, GLenum pname, GLint param) {
    const char *_name = "glSamplerParameteri";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSamplerParameteri(GLuint sampler, GLenum pname, GLint param) {
    PFN_GLSAMPLERPARAMETERI _ptr;
    _ptr = (PFN_GLSAMPLERPARAMETERI)_getPrivateProcAddress("glSamplerParameteri");
    if (!_ptr) {
        _ptr = &_fail_glSamplerParameteri;
    }
    _glSamplerParameteri = _ptr;
    _glSamplerParameteri(sampler, pname, param);
}

PFN_GLSAMPLERPARAMETERI _glSamplerParameteri = &_get_glSamplerParameteri;

static void APIENTRY _fail_glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint * param) {
    const char *_name = "glSamplerParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint * param) {
    PFN_GLSAMPLERPARAMETERIV _ptr;
    _ptr = (PFN_GLSAMPLERPARAMETERIV)_getPrivateProcAddress("glSamplerParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glSamplerParameteriv;
    }
    _glSamplerParameteriv = _ptr;
    _glSamplerParameteriv(sampler, pname, param);
}

PFN_GLSAMPLERPARAMETERIV _glSamplerParameteriv = &_get_glSamplerParameteriv;

static void APIENTRY _fail_glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param) {
    const char *_name = "glSamplerParameterf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param) {
    PFN_GLSAMPLERPARAMETERF _ptr;
    _ptr = (PFN_GLSAMPLERPARAMETERF)_getPrivateProcAddress("glSamplerParameterf");
    if (!_ptr) {
        _ptr = &_fail_glSamplerParameterf;
    }
    _glSamplerParameterf = _ptr;
    _glSamplerParameterf(sampler, pname, param);
}

PFN_GLSAMPLERPARAMETERF _glSamplerParameterf = &_get_glSamplerParameterf;

static void APIENTRY _fail_glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat * param) {
    const char *_name = "glSamplerParameterfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat * param) {
    PFN_GLSAMPLERPARAMETERFV _ptr;
    _ptr = (PFN_GLSAMPLERPARAMETERFV)_getPrivateProcAddress("glSamplerParameterfv");
    if (!_ptr) {
        _ptr = &_fail_glSamplerParameterfv;
    }
    _glSamplerParameterfv = _ptr;
    _glSamplerParameterfv(sampler, pname, param);
}

PFN_GLSAMPLERPARAMETERFV _glSamplerParameterfv = &_get_glSamplerParameterfv;

static void APIENTRY _fail_glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint * param) {
    const char *_name = "glSamplerParameterIiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint * param) {
    PFN_GLSAMPLERPARAMETERIIV _ptr;
    _ptr = (PFN_GLSAMPLERPARAMETERIIV)_getPrivateProcAddress("glSamplerParameterIiv");
    if (!_ptr) {
        _ptr = &_fail_glSamplerParameterIiv;
    }
    _glSamplerParameterIiv = _ptr;
    _glSamplerParameterIiv(sampler, pname, param);
}

PFN_GLSAMPLERPARAMETERIIV _glSamplerParameterIiv = &_get_glSamplerParameterIiv;

static void APIENTRY _fail_glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint * param) {
    const char *_name = "glSamplerParameterIuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint * param) {
    PFN_GLSAMPLERPARAMETERIUIV _ptr;
    _ptr = (PFN_GLSAMPLERPARAMETERIUIV)_getPrivateProcAddress("glSamplerParameterIuiv");
    if (!_ptr) {
        _ptr = &_fail_glSamplerParameterIuiv;
    }
    _glSamplerParameterIuiv = _ptr;
    _glSamplerParameterIuiv(sampler, pname, param);
}

PFN_GLSAMPLERPARAMETERIUIV _glSamplerParameterIuiv = &_get_glSamplerParameterIuiv;

static void APIENTRY _fail_glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint * params) {
    const char *_name = "glGetSamplerParameteriv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint * params) {
    PFN_GLGETSAMPLERPARAMETERIV _ptr;
    _ptr = (PFN_GLGETSAMPLERPARAMETERIV)_getPrivateProcAddress("glGetSamplerParameteriv");
    if (!_ptr) {
        _ptr = &_fail_glGetSamplerParameteriv;
    }
    _glGetSamplerParameteriv = _ptr;
    _glGetSamplerParameteriv(sampler, pname, params);
}

PFN_GLGETSAMPLERPARAMETERIV _glGetSamplerParameteriv = &_get_glGetSamplerParameteriv;

static void APIENTRY _fail_glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint * params) {
    const char *_name = "glGetSamplerParameterIiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint * params) {
    PFN_GLGETSAMPLERPARAMETERIIV _ptr;
    _ptr = (PFN_GLGETSAMPLERPARAMETERIIV)_getPrivateProcAddress("glGetSamplerParameterIiv");
    if (!_ptr) {
        _ptr = &_fail_glGetSamplerParameterIiv;
    }
    _glGetSamplerParameterIiv = _ptr;
    _glGetSamplerParameterIiv(sampler, pname, params);
}

PFN_GLGETSAMPLERPARAMETERIIV _glGetSamplerParameterIiv = &_get_glGetSamplerParameterIiv;

static void APIENTRY _fail_glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat * params) {
    const char *_name = "glGetSamplerParameterfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat * params) {
    PFN_GLGETSAMPLERPARAMETERFV _ptr;
    _ptr = (PFN_GLGETSAMPLERPARAMETERFV)_getPrivateProcAddress("glGetSamplerParameterfv");
    if (!_ptr) {
        _ptr = &_fail_glGetSamplerParameterfv;
    }
    _glGetSamplerParameterfv = _ptr;
    _glGetSamplerParameterfv(sampler, pname, params);
}

PFN_GLGETSAMPLERPARAMETERFV _glGetSamplerParameterfv = &_get_glGetSamplerParameterfv;

static void APIENTRY _fail_glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint * params) {
    const char *_name = "glGetSamplerParameterIuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint * params) {
    PFN_GLGETSAMPLERPARAMETERIUIV _ptr;
    _ptr = (PFN_GLGETSAMPLERPARAMETERIUIV)_getPrivateProcAddress("glGetSamplerParameterIuiv");
    if (!_ptr) {
        _ptr = &_fail_glGetSamplerParameterIuiv;
    }
    _glGetSamplerParameterIuiv = _ptr;
    _glGetSamplerParameterIuiv(sampler, pname, params);
}

PFN_GLGETSAMPLERPARAMETERIUIV _glGetSamplerParameterIuiv = &_get_glGetSamplerParameterIuiv;

static void APIENTRY _fail_glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program) {
    const char *_name = "glUseProgramStages";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program) {
    PFN_GLUSEPROGRAMSTAGES _ptr;
    _ptr = (PFN_GLUSEPROGRAMSTAGES)_getPrivateProcAddress("glUseProgramStages");
    if (!_ptr) {
        _ptr = &_fail_glUseProgramStages;
    }
    _glUseProgramStages = _ptr;
    _glUseProgramStages(pipeline, stages, program);
}

PFN_GLUSEPROGRAMSTAGES _glUseProgramStages = &_get_glUseProgramStages;

static void APIENTRY _fail_glActiveShaderProgram(GLuint pipeline, GLuint program) {
    const char *_name = "glActiveShaderProgram";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glActiveShaderProgram(GLuint pipeline, GLuint program) {
    PFN_GLACTIVESHADERPROGRAM _ptr;
    _ptr = (PFN_GLACTIVESHADERPROGRAM)_getPrivateProcAddress("glActiveShaderProgram");
    if (!_ptr) {
        _ptr = &_fail_glActiveShaderProgram;
    }
    _glActiveShaderProgram = _ptr;
    _glActiveShaderProgram(pipeline, program);
}

PFN_GLACTIVESHADERPROGRAM _glActiveShaderProgram = &_get_glActiveShaderProgram;

static GLuint APIENTRY _fail_glCreateShaderProgramv(GLenum type, GLsizei count, const GLchar * const * strings) {
    const char *_name = "glCreateShaderProgramv";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glCreateShaderProgramv(GLenum type, GLsizei count, const GLchar * const * strings) {
    PFN_GLCREATESHADERPROGRAMV _ptr;
    _ptr = (PFN_GLCREATESHADERPROGRAMV)_getPrivateProcAddress("glCreateShaderProgramv");
    if (!_ptr) {
        _ptr = &_fail_glCreateShaderProgramv;
    }
    _glCreateShaderProgramv = _ptr;
    return _glCreateShaderProgramv(type, count, strings);
}

PFN_GLCREATESHADERPROGRAMV _glCreateShaderProgramv = &_get_glCreateShaderProgramv;

static void APIENTRY _fail_glBindProgramPipeline(GLuint pipeline) {
    const char *_name = "glBindProgramPipeline";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindProgramPipeline(GLuint pipeline) {
    PFN_GLBINDPROGRAMPIPELINE _ptr;
    _ptr = (PFN_GLBINDPROGRAMPIPELINE)_getPrivateProcAddress("glBindProgramPipeline");
    if (!_ptr) {
        _ptr = &_fail_glBindProgramPipeline;
    }
    _glBindProgramPipeline = _ptr;
    _glBindProgramPipeline(pipeline);
}

PFN_GLBINDPROGRAMPIPELINE _glBindProgramPipeline = &_get_glBindProgramPipeline;

static void APIENTRY _fail_glDeleteProgramPipelines(GLsizei n, const GLuint * pipelines) {
    const char *_name = "glDeleteProgramPipelines";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteProgramPipelines(GLsizei n, const GLuint * pipelines) {
    PFN_GLDELETEPROGRAMPIPELINES _ptr;
    _ptr = (PFN_GLDELETEPROGRAMPIPELINES)_getPrivateProcAddress("glDeleteProgramPipelines");
    if (!_ptr) {
        _ptr = &_fail_glDeleteProgramPipelines;
    }
    _glDeleteProgramPipelines = _ptr;
    _glDeleteProgramPipelines(n, pipelines);
}

PFN_GLDELETEPROGRAMPIPELINES _glDeleteProgramPipelines = &_get_glDeleteProgramPipelines;

static void APIENTRY _fail_glGenProgramPipelines(GLsizei n, GLuint * pipelines) {
    const char *_name = "glGenProgramPipelines";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenProgramPipelines(GLsizei n, GLuint * pipelines) {
    PFN_GLGENPROGRAMPIPELINES _ptr;
    _ptr = (PFN_GLGENPROGRAMPIPELINES)_getPrivateProcAddress("glGenProgramPipelines");
    if (!_ptr) {
        _ptr = &_fail_glGenProgramPipelines;
    }
    _glGenProgramPipelines = _ptr;
    _glGenProgramPipelines(n, pipelines);
}

PFN_GLGENPROGRAMPIPELINES _glGenProgramPipelines = &_get_glGenProgramPipelines;

static GLboolean APIENTRY _fail_glIsProgramPipeline(GLuint pipeline) {
    const char *_name = "glIsProgramPipeline";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsProgramPipeline(GLuint pipeline) {
    PFN_GLISPROGRAMPIPELINE _ptr;
    _ptr = (PFN_GLISPROGRAMPIPELINE)_getPrivateProcAddress("glIsProgramPipeline");
    if (!_ptr) {
        _ptr = &_fail_glIsProgramPipeline;
    }
    _glIsProgramPipeline = _ptr;
    return _glIsProgramPipeline(pipeline);
}

PFN_GLISPROGRAMPIPELINE _glIsProgramPipeline = &_get_glIsProgramPipeline;

static void APIENTRY _fail_glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint * params) {
    const char *_name = "glGetProgramPipelineiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint * params) {
    PFN_GLGETPROGRAMPIPELINEIV _ptr;
    _ptr = (PFN_GLGETPROGRAMPIPELINEIV)_getPrivateProcAddress("glGetProgramPipelineiv");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramPipelineiv;
    }
    _glGetProgramPipelineiv = _ptr;
    _glGetProgramPipelineiv(pipeline, pname, params);
}

PFN_GLGETPROGRAMPIPELINEIV _glGetProgramPipelineiv = &_get_glGetProgramPipelineiv;

static void APIENTRY _fail_glProgramUniform1i(GLuint program, GLint location, GLint v0) {
    const char *_name = "glProgramUniform1i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1i(GLuint program, GLint location, GLint v0) {
    PFN_GLPROGRAMUNIFORM1I _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1I)_getPrivateProcAddress("glProgramUniform1i");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1i;
    }
    _glProgramUniform1i = _ptr;
    _glProgramUniform1i(program, location, v0);
}

PFN_GLPROGRAMUNIFORM1I _glProgramUniform1i = &_get_glProgramUniform1i;

static void APIENTRY _fail_glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glProgramUniform1iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint * value) {
    PFN_GLPROGRAMUNIFORM1IV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1IV)_getPrivateProcAddress("glProgramUniform1iv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1iv;
    }
    _glProgramUniform1iv = _ptr;
    _glProgramUniform1iv(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM1IV _glProgramUniform1iv = &_get_glProgramUniform1iv;

static void APIENTRY _fail_glProgramUniform1f(GLuint program, GLint location, GLfloat v0) {
    const char *_name = "glProgramUniform1f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1f(GLuint program, GLint location, GLfloat v0) {
    PFN_GLPROGRAMUNIFORM1F _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1F)_getPrivateProcAddress("glProgramUniform1f");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1f;
    }
    _glProgramUniform1f = _ptr;
    _glProgramUniform1f(program, location, v0);
}

PFN_GLPROGRAMUNIFORM1F _glProgramUniform1f = &_get_glProgramUniform1f;

static void APIENTRY _fail_glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glProgramUniform1fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORM1FV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1FV)_getPrivateProcAddress("glProgramUniform1fv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1fv;
    }
    _glProgramUniform1fv = _ptr;
    _glProgramUniform1fv(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM1FV _glProgramUniform1fv = &_get_glProgramUniform1fv;

static void APIENTRY _fail_glProgramUniform1d(GLuint program, GLint location, GLdouble v0) {
    const char *_name = "glProgramUniform1d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1d(GLuint program, GLint location, GLdouble v0) {
    PFN_GLPROGRAMUNIFORM1D _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1D)_getPrivateProcAddress("glProgramUniform1d");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1d;
    }
    _glProgramUniform1d = _ptr;
    _glProgramUniform1d(program, location, v0);
}

PFN_GLPROGRAMUNIFORM1D _glProgramUniform1d = &_get_glProgramUniform1d;

static void APIENTRY _fail_glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glProgramUniform1dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORM1DV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1DV)_getPrivateProcAddress("glProgramUniform1dv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1dv;
    }
    _glProgramUniform1dv = _ptr;
    _glProgramUniform1dv(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM1DV _glProgramUniform1dv = &_get_glProgramUniform1dv;

static void APIENTRY _fail_glProgramUniform1ui(GLuint program, GLint location, GLuint v0) {
    const char *_name = "glProgramUniform1ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1ui(GLuint program, GLint location, GLuint v0) {
    PFN_GLPROGRAMUNIFORM1UI _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1UI)_getPrivateProcAddress("glProgramUniform1ui");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1ui;
    }
    _glProgramUniform1ui = _ptr;
    _glProgramUniform1ui(program, location, v0);
}

PFN_GLPROGRAMUNIFORM1UI _glProgramUniform1ui = &_get_glProgramUniform1ui;

static void APIENTRY _fail_glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glProgramUniform1uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    PFN_GLPROGRAMUNIFORM1UIV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1UIV)_getPrivateProcAddress("glProgramUniform1uiv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1uiv;
    }
    _glProgramUniform1uiv = _ptr;
    _glProgramUniform1uiv(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM1UIV _glProgramUniform1uiv = &_get_glProgramUniform1uiv;

static void APIENTRY _fail_glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1) {
    const char *_name = "glProgramUniform2i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1) {
    PFN_GLPROGRAMUNIFORM2I _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2I)_getPrivateProcAddress("glProgramUniform2i");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2i;
    }
    _glProgramUniform2i = _ptr;
    _glProgramUniform2i(program, location, v0, v1);
}

PFN_GLPROGRAMUNIFORM2I _glProgramUniform2i = &_get_glProgramUniform2i;

static void APIENTRY _fail_glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glProgramUniform2iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint * value) {
    PFN_GLPROGRAMUNIFORM2IV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2IV)_getPrivateProcAddress("glProgramUniform2iv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2iv;
    }
    _glProgramUniform2iv = _ptr;
    _glProgramUniform2iv(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM2IV _glProgramUniform2iv = &_get_glProgramUniform2iv;

static void APIENTRY _fail_glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1) {
    const char *_name = "glProgramUniform2f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1) {
    PFN_GLPROGRAMUNIFORM2F _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2F)_getPrivateProcAddress("glProgramUniform2f");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2f;
    }
    _glProgramUniform2f = _ptr;
    _glProgramUniform2f(program, location, v0, v1);
}

PFN_GLPROGRAMUNIFORM2F _glProgramUniform2f = &_get_glProgramUniform2f;

static void APIENTRY _fail_glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glProgramUniform2fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORM2FV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2FV)_getPrivateProcAddress("glProgramUniform2fv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2fv;
    }
    _glProgramUniform2fv = _ptr;
    _glProgramUniform2fv(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM2FV _glProgramUniform2fv = &_get_glProgramUniform2fv;

static void APIENTRY _fail_glProgramUniform2d(GLuint program, GLint location, GLdouble v0, GLdouble v1) {
    const char *_name = "glProgramUniform2d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2d(GLuint program, GLint location, GLdouble v0, GLdouble v1) {
    PFN_GLPROGRAMUNIFORM2D _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2D)_getPrivateProcAddress("glProgramUniform2d");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2d;
    }
    _glProgramUniform2d = _ptr;
    _glProgramUniform2d(program, location, v0, v1);
}

PFN_GLPROGRAMUNIFORM2D _glProgramUniform2d = &_get_glProgramUniform2d;

static void APIENTRY _fail_glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glProgramUniform2dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORM2DV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2DV)_getPrivateProcAddress("glProgramUniform2dv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2dv;
    }
    _glProgramUniform2dv = _ptr;
    _glProgramUniform2dv(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM2DV _glProgramUniform2dv = &_get_glProgramUniform2dv;

static void APIENTRY _fail_glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1) {
    const char *_name = "glProgramUniform2ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1) {
    PFN_GLPROGRAMUNIFORM2UI _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2UI)_getPrivateProcAddress("glProgramUniform2ui");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2ui;
    }
    _glProgramUniform2ui = _ptr;
    _glProgramUniform2ui(program, location, v0, v1);
}

PFN_GLPROGRAMUNIFORM2UI _glProgramUniform2ui = &_get_glProgramUniform2ui;

static void APIENTRY _fail_glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glProgramUniform2uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    PFN_GLPROGRAMUNIFORM2UIV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2UIV)_getPrivateProcAddress("glProgramUniform2uiv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2uiv;
    }
    _glProgramUniform2uiv = _ptr;
    _glProgramUniform2uiv(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM2UIV _glProgramUniform2uiv = &_get_glProgramUniform2uiv;

static void APIENTRY _fail_glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) {
    const char *_name = "glProgramUniform3i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) {
    PFN_GLPROGRAMUNIFORM3I _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3I)_getPrivateProcAddress("glProgramUniform3i");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3i;
    }
    _glProgramUniform3i = _ptr;
    _glProgramUniform3i(program, location, v0, v1, v2);
}

PFN_GLPROGRAMUNIFORM3I _glProgramUniform3i = &_get_glProgramUniform3i;

static void APIENTRY _fail_glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glProgramUniform3iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint * value) {
    PFN_GLPROGRAMUNIFORM3IV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3IV)_getPrivateProcAddress("glProgramUniform3iv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3iv;
    }
    _glProgramUniform3iv = _ptr;
    _glProgramUniform3iv(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM3IV _glProgramUniform3iv = &_get_glProgramUniform3iv;

static void APIENTRY _fail_glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
    const char *_name = "glProgramUniform3f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
    PFN_GLPROGRAMUNIFORM3F _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3F)_getPrivateProcAddress("glProgramUniform3f");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3f;
    }
    _glProgramUniform3f = _ptr;
    _glProgramUniform3f(program, location, v0, v1, v2);
}

PFN_GLPROGRAMUNIFORM3F _glProgramUniform3f = &_get_glProgramUniform3f;

static void APIENTRY _fail_glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glProgramUniform3fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORM3FV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3FV)_getPrivateProcAddress("glProgramUniform3fv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3fv;
    }
    _glProgramUniform3fv = _ptr;
    _glProgramUniform3fv(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM3FV _glProgramUniform3fv = &_get_glProgramUniform3fv;

static void APIENTRY _fail_glProgramUniform3d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2) {
    const char *_name = "glProgramUniform3d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2) {
    PFN_GLPROGRAMUNIFORM3D _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3D)_getPrivateProcAddress("glProgramUniform3d");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3d;
    }
    _glProgramUniform3d = _ptr;
    _glProgramUniform3d(program, location, v0, v1, v2);
}

PFN_GLPROGRAMUNIFORM3D _glProgramUniform3d = &_get_glProgramUniform3d;

static void APIENTRY _fail_glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glProgramUniform3dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORM3DV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3DV)_getPrivateProcAddress("glProgramUniform3dv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3dv;
    }
    _glProgramUniform3dv = _ptr;
    _glProgramUniform3dv(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM3DV _glProgramUniform3dv = &_get_glProgramUniform3dv;

static void APIENTRY _fail_glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2) {
    const char *_name = "glProgramUniform3ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2) {
    PFN_GLPROGRAMUNIFORM3UI _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3UI)_getPrivateProcAddress("glProgramUniform3ui");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3ui;
    }
    _glProgramUniform3ui = _ptr;
    _glProgramUniform3ui(program, location, v0, v1, v2);
}

PFN_GLPROGRAMUNIFORM3UI _glProgramUniform3ui = &_get_glProgramUniform3ui;

static void APIENTRY _fail_glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glProgramUniform3uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    PFN_GLPROGRAMUNIFORM3UIV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3UIV)_getPrivateProcAddress("glProgramUniform3uiv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3uiv;
    }
    _glProgramUniform3uiv = _ptr;
    _glProgramUniform3uiv(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM3UIV _glProgramUniform3uiv = &_get_glProgramUniform3uiv;

static void APIENTRY _fail_glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
    const char *_name = "glProgramUniform4i";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
    PFN_GLPROGRAMUNIFORM4I _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4I)_getPrivateProcAddress("glProgramUniform4i");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4i;
    }
    _glProgramUniform4i = _ptr;
    _glProgramUniform4i(program, location, v0, v1, v2, v3);
}

PFN_GLPROGRAMUNIFORM4I _glProgramUniform4i = &_get_glProgramUniform4i;

static void APIENTRY _fail_glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glProgramUniform4iv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint * value) {
    PFN_GLPROGRAMUNIFORM4IV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4IV)_getPrivateProcAddress("glProgramUniform4iv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4iv;
    }
    _glProgramUniform4iv = _ptr;
    _glProgramUniform4iv(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM4IV _glProgramUniform4iv = &_get_glProgramUniform4iv;

static void APIENTRY _fail_glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
    const char *_name = "glProgramUniform4f";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
    PFN_GLPROGRAMUNIFORM4F _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4F)_getPrivateProcAddress("glProgramUniform4f");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4f;
    }
    _glProgramUniform4f = _ptr;
    _glProgramUniform4f(program, location, v0, v1, v2, v3);
}

PFN_GLPROGRAMUNIFORM4F _glProgramUniform4f = &_get_glProgramUniform4f;

static void APIENTRY _fail_glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glProgramUniform4fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORM4FV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4FV)_getPrivateProcAddress("glProgramUniform4fv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4fv;
    }
    _glProgramUniform4fv = _ptr;
    _glProgramUniform4fv(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM4FV _glProgramUniform4fv = &_get_glProgramUniform4fv;

static void APIENTRY _fail_glProgramUniform4d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3) {
    const char *_name = "glProgramUniform4d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3) {
    PFN_GLPROGRAMUNIFORM4D _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4D)_getPrivateProcAddress("glProgramUniform4d");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4d;
    }
    _glProgramUniform4d = _ptr;
    _glProgramUniform4d(program, location, v0, v1, v2, v3);
}

PFN_GLPROGRAMUNIFORM4D _glProgramUniform4d = &_get_glProgramUniform4d;

static void APIENTRY _fail_glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glProgramUniform4dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORM4DV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4DV)_getPrivateProcAddress("glProgramUniform4dv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4dv;
    }
    _glProgramUniform4dv = _ptr;
    _glProgramUniform4dv(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM4DV _glProgramUniform4dv = &_get_glProgramUniform4dv;

static void APIENTRY _fail_glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
    const char *_name = "glProgramUniform4ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
    PFN_GLPROGRAMUNIFORM4UI _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4UI)_getPrivateProcAddress("glProgramUniform4ui");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4ui;
    }
    _glProgramUniform4ui = _ptr;
    _glProgramUniform4ui(program, location, v0, v1, v2, v3);
}

PFN_GLPROGRAMUNIFORM4UI _glProgramUniform4ui = &_get_glProgramUniform4ui;

static void APIENTRY _fail_glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glProgramUniform4uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    PFN_GLPROGRAMUNIFORM4UIV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4UIV)_getPrivateProcAddress("glProgramUniform4uiv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4uiv;
    }
    _glProgramUniform4uiv = _ptr;
    _glProgramUniform4uiv(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM4UIV _glProgramUniform4uiv = &_get_glProgramUniform4uiv;

static void APIENTRY _fail_glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix2fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORMMATRIX2FV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX2FV)_getPrivateProcAddress("glProgramUniformMatrix2fv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix2fv;
    }
    _glProgramUniformMatrix2fv = _ptr;
    _glProgramUniformMatrix2fv(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX2FV _glProgramUniformMatrix2fv = &_get_glProgramUniformMatrix2fv;

static void APIENTRY _fail_glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix3fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORMMATRIX3FV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX3FV)_getPrivateProcAddress("glProgramUniformMatrix3fv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix3fv;
    }
    _glProgramUniformMatrix3fv = _ptr;
    _glProgramUniformMatrix3fv(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX3FV _glProgramUniformMatrix3fv = &_get_glProgramUniformMatrix3fv;

static void APIENTRY _fail_glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix4fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORMMATRIX4FV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX4FV)_getPrivateProcAddress("glProgramUniformMatrix4fv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix4fv;
    }
    _glProgramUniformMatrix4fv = _ptr;
    _glProgramUniformMatrix4fv(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX4FV _glProgramUniformMatrix4fv = &_get_glProgramUniformMatrix4fv;

static void APIENTRY _fail_glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix2dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORMMATRIX2DV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX2DV)_getPrivateProcAddress("glProgramUniformMatrix2dv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix2dv;
    }
    _glProgramUniformMatrix2dv = _ptr;
    _glProgramUniformMatrix2dv(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX2DV _glProgramUniformMatrix2dv = &_get_glProgramUniformMatrix2dv;

static void APIENTRY _fail_glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix3dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORMMATRIX3DV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX3DV)_getPrivateProcAddress("glProgramUniformMatrix3dv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix3dv;
    }
    _glProgramUniformMatrix3dv = _ptr;
    _glProgramUniformMatrix3dv(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX3DV _glProgramUniformMatrix3dv = &_get_glProgramUniformMatrix3dv;

static void APIENTRY _fail_glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix4dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORMMATRIX4DV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX4DV)_getPrivateProcAddress("glProgramUniformMatrix4dv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix4dv;
    }
    _glProgramUniformMatrix4dv = _ptr;
    _glProgramUniformMatrix4dv(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX4DV _glProgramUniformMatrix4dv = &_get_glProgramUniformMatrix4dv;

static void APIENTRY _fail_glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix2x3fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORMMATRIX2X3FV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX2X3FV)_getPrivateProcAddress("glProgramUniformMatrix2x3fv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix2x3fv;
    }
    _glProgramUniformMatrix2x3fv = _ptr;
    _glProgramUniformMatrix2x3fv(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX2X3FV _glProgramUniformMatrix2x3fv = &_get_glProgramUniformMatrix2x3fv;

static void APIENTRY _fail_glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix3x2fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORMMATRIX3X2FV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX3X2FV)_getPrivateProcAddress("glProgramUniformMatrix3x2fv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix3x2fv;
    }
    _glProgramUniformMatrix3x2fv = _ptr;
    _glProgramUniformMatrix3x2fv(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX3X2FV _glProgramUniformMatrix3x2fv = &_get_glProgramUniformMatrix3x2fv;

static void APIENTRY _fail_glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix2x4fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORMMATRIX2X4FV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX2X4FV)_getPrivateProcAddress("glProgramUniformMatrix2x4fv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix2x4fv;
    }
    _glProgramUniformMatrix2x4fv = _ptr;
    _glProgramUniformMatrix2x4fv(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX2X4FV _glProgramUniformMatrix2x4fv = &_get_glProgramUniformMatrix2x4fv;

static void APIENTRY _fail_glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix4x2fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORMMATRIX4X2FV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX4X2FV)_getPrivateProcAddress("glProgramUniformMatrix4x2fv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix4x2fv;
    }
    _glProgramUniformMatrix4x2fv = _ptr;
    _glProgramUniformMatrix4x2fv(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX4X2FV _glProgramUniformMatrix4x2fv = &_get_glProgramUniformMatrix4x2fv;

static void APIENTRY _fail_glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix3x4fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORMMATRIX3X4FV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX3X4FV)_getPrivateProcAddress("glProgramUniformMatrix3x4fv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix3x4fv;
    }
    _glProgramUniformMatrix3x4fv = _ptr;
    _glProgramUniformMatrix3x4fv(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX3X4FV _glProgramUniformMatrix3x4fv = &_get_glProgramUniformMatrix3x4fv;

static void APIENTRY _fail_glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix4x3fv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORMMATRIX4X3FV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX4X3FV)_getPrivateProcAddress("glProgramUniformMatrix4x3fv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix4x3fv;
    }
    _glProgramUniformMatrix4x3fv = _ptr;
    _glProgramUniformMatrix4x3fv(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX4X3FV _glProgramUniformMatrix4x3fv = &_get_glProgramUniformMatrix4x3fv;

static void APIENTRY _fail_glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix2x3dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORMMATRIX2X3DV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX2X3DV)_getPrivateProcAddress("glProgramUniformMatrix2x3dv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix2x3dv;
    }
    _glProgramUniformMatrix2x3dv = _ptr;
    _glProgramUniformMatrix2x3dv(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX2X3DV _glProgramUniformMatrix2x3dv = &_get_glProgramUniformMatrix2x3dv;

static void APIENTRY _fail_glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix3x2dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORMMATRIX3X2DV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX3X2DV)_getPrivateProcAddress("glProgramUniformMatrix3x2dv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix3x2dv;
    }
    _glProgramUniformMatrix3x2dv = _ptr;
    _glProgramUniformMatrix3x2dv(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX3X2DV _glProgramUniformMatrix3x2dv = &_get_glProgramUniformMatrix3x2dv;

static void APIENTRY _fail_glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix2x4dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORMMATRIX2X4DV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX2X4DV)_getPrivateProcAddress("glProgramUniformMatrix2x4dv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix2x4dv;
    }
    _glProgramUniformMatrix2x4dv = _ptr;
    _glProgramUniformMatrix2x4dv(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX2X4DV _glProgramUniformMatrix2x4dv = &_get_glProgramUniformMatrix2x4dv;

static void APIENTRY _fail_glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix4x2dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORMMATRIX4X2DV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX4X2DV)_getPrivateProcAddress("glProgramUniformMatrix4x2dv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix4x2dv;
    }
    _glProgramUniformMatrix4x2dv = _ptr;
    _glProgramUniformMatrix4x2dv(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX4X2DV _glProgramUniformMatrix4x2dv = &_get_glProgramUniformMatrix4x2dv;

static void APIENTRY _fail_glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix3x4dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORMMATRIX3X4DV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX3X4DV)_getPrivateProcAddress("glProgramUniformMatrix3x4dv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix3x4dv;
    }
    _glProgramUniformMatrix3x4dv = _ptr;
    _glProgramUniformMatrix3x4dv(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX3X4DV _glProgramUniformMatrix3x4dv = &_get_glProgramUniformMatrix3x4dv;

static void APIENTRY _fail_glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix4x3dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORMMATRIX4X3DV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX4X3DV)_getPrivateProcAddress("glProgramUniformMatrix4x3dv");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix4x3dv;
    }
    _glProgramUniformMatrix4x3dv = _ptr;
    _glProgramUniformMatrix4x3dv(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX4X3DV _glProgramUniformMatrix4x3dv = &_get_glProgramUniformMatrix4x3dv;

static void APIENTRY _fail_glValidateProgramPipeline(GLuint pipeline) {
    const char *_name = "glValidateProgramPipeline";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glValidateProgramPipeline(GLuint pipeline) {
    PFN_GLVALIDATEPROGRAMPIPELINE _ptr;
    _ptr = (PFN_GLVALIDATEPROGRAMPIPELINE)_getPrivateProcAddress("glValidateProgramPipeline");
    if (!_ptr) {
        _ptr = &_fail_glValidateProgramPipeline;
    }
    _glValidateProgramPipeline = _ptr;
    _glValidateProgramPipeline(pipeline);
}

PFN_GLVALIDATEPROGRAMPIPELINE _glValidateProgramPipeline = &_get_glValidateProgramPipeline;

static void APIENTRY _fail_glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog) {
    const char *_name = "glGetProgramPipelineInfoLog";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog) {
    PFN_GLGETPROGRAMPIPELINEINFOLOG _ptr;
    _ptr = (PFN_GLGETPROGRAMPIPELINEINFOLOG)_getPrivateProcAddress("glGetProgramPipelineInfoLog");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramPipelineInfoLog;
    }
    _glGetProgramPipelineInfoLog = _ptr;
    _glGetProgramPipelineInfoLog(pipeline, bufSize, length, infoLog);
}

PFN_GLGETPROGRAMPIPELINEINFOLOG _glGetProgramPipelineInfoLog = &_get_glGetProgramPipelineInfoLog;

static void APIENTRY _fail_glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint * params) {
    const char *_name = "glGetActiveAtomicCounterBufferiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint * params) {
    PFN_GLGETACTIVEATOMICCOUNTERBUFFERIV _ptr;
    _ptr = (PFN_GLGETACTIVEATOMICCOUNTERBUFFERIV)_getPrivateProcAddress("glGetActiveAtomicCounterBufferiv");
    if (!_ptr) {
        _ptr = &_fail_glGetActiveAtomicCounterBufferiv;
    }
    _glGetActiveAtomicCounterBufferiv = _ptr;
    _glGetActiveAtomicCounterBufferiv(program, bufferIndex, pname, params);
}

PFN_GLGETACTIVEATOMICCOUNTERBUFFERIV _glGetActiveAtomicCounterBufferiv = &_get_glGetActiveAtomicCounterBufferiv;

static void APIENTRY _fail_glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format) {
    const char *_name = "glBindImageTexture";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format) {
    PFN_GLBINDIMAGETEXTURE _ptr;
    _ptr = (PFN_GLBINDIMAGETEXTURE)_getPrivateProcAddress("glBindImageTexture");
    if (!_ptr) {
        _ptr = &_fail_glBindImageTexture;
    }
    _glBindImageTexture = _ptr;
    _glBindImageTexture(unit, texture, level, layered, layer, access, format);
}

PFN_GLBINDIMAGETEXTURE _glBindImageTexture = &_get_glBindImageTexture;

static void APIENTRY _fail_glMemoryBarrier(GLbitfield barriers) {
    const char *_name = "glMemoryBarrier";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMemoryBarrier(GLbitfield barriers) {
    PFN_GLMEMORYBARRIER _ptr;
    _ptr = (PFN_GLMEMORYBARRIER)_getPrivateProcAddress("glMemoryBarrier");
    if (!_ptr) {
        _ptr = &_fail_glMemoryBarrier;
    }
    _glMemoryBarrier = _ptr;
    _glMemoryBarrier(barriers);
}

PFN_GLMEMORYBARRIER _glMemoryBarrier = &_get_glMemoryBarrier;

static void APIENTRY _fail_glDeleteObjectARB(GLhandleARB obj) {
    const char *_name = "glDeleteObjectARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteObjectARB(GLhandleARB obj) {
    PFN_GLDELETEOBJECTARB _ptr;
    _ptr = (PFN_GLDELETEOBJECTARB)_getPrivateProcAddress("glDeleteObjectARB");
    if (!_ptr) {
        _ptr = &_fail_glDeleteObjectARB;
    }
    _glDeleteObjectARB = _ptr;
    _glDeleteObjectARB(obj);
}

PFN_GLDELETEOBJECTARB _glDeleteObjectARB = &_get_glDeleteObjectARB;

static GLhandleARB APIENTRY _fail_glGetHandleARB(GLenum pname) {
    const char *_name = "glGetHandleARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLhandleARB APIENTRY _get_glGetHandleARB(GLenum pname) {
    PFN_GLGETHANDLEARB _ptr;
    _ptr = (PFN_GLGETHANDLEARB)_getPrivateProcAddress("glGetHandleARB");
    if (!_ptr) {
        _ptr = &_fail_glGetHandleARB;
    }
    _glGetHandleARB = _ptr;
    return _glGetHandleARB(pname);
}

PFN_GLGETHANDLEARB _glGetHandleARB = &_get_glGetHandleARB;

static void APIENTRY _fail_glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj) {
    const char *_name = "glDetachObjectARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj) {
    PFN_GLDETACHOBJECTARB _ptr;
    _ptr = (PFN_GLDETACHOBJECTARB)_getPrivateProcAddress("glDetachObjectARB");
    if (!_ptr) {
        _ptr = &_fail_glDetachObjectARB;
    }
    _glDetachObjectARB = _ptr;
    _glDetachObjectARB(containerObj, attachedObj);
}

PFN_GLDETACHOBJECTARB _glDetachObjectARB = &_get_glDetachObjectARB;

static GLhandleARB APIENTRY _fail_glCreateShaderObjectARB(GLenum shaderType) {
    const char *_name = "glCreateShaderObjectARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLhandleARB APIENTRY _get_glCreateShaderObjectARB(GLenum shaderType) {
    PFN_GLCREATESHADEROBJECTARB _ptr;
    _ptr = (PFN_GLCREATESHADEROBJECTARB)_getPrivateProcAddress("glCreateShaderObjectARB");
    if (!_ptr) {
        _ptr = &_fail_glCreateShaderObjectARB;
    }
    _glCreateShaderObjectARB = _ptr;
    return _glCreateShaderObjectARB(shaderType);
}

PFN_GLCREATESHADEROBJECTARB _glCreateShaderObjectARB = &_get_glCreateShaderObjectARB;

static void APIENTRY _fail_glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB * * const string, const GLint * length) {
    const char *_name = "glShaderSourceARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB * * const string, const GLint * length) {
    PFN_GLSHADERSOURCEARB _ptr;
    _ptr = (PFN_GLSHADERSOURCEARB)_getPrivateProcAddress("glShaderSourceARB");
    if (!_ptr) {
        _ptr = &_fail_glShaderSourceARB;
    }
    _glShaderSourceARB = _ptr;
    _glShaderSourceARB(shaderObj, count, string, length);
}

PFN_GLSHADERSOURCEARB _glShaderSourceARB = &_get_glShaderSourceARB;

static void APIENTRY _fail_glCompileShaderARB(GLhandleARB shaderObj) {
    const char *_name = "glCompileShaderARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompileShaderARB(GLhandleARB shaderObj) {
    PFN_GLCOMPILESHADERARB _ptr;
    _ptr = (PFN_GLCOMPILESHADERARB)_getPrivateProcAddress("glCompileShaderARB");
    if (!_ptr) {
        _ptr = &_fail_glCompileShaderARB;
    }
    _glCompileShaderARB = _ptr;
    _glCompileShaderARB(shaderObj);
}

PFN_GLCOMPILESHADERARB _glCompileShaderARB = &_get_glCompileShaderARB;

static GLhandleARB APIENTRY _fail_glCreateProgramObjectARB(void) {
    const char *_name = "glCreateProgramObjectARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLhandleARB APIENTRY _get_glCreateProgramObjectARB(void) {
    PFN_GLCREATEPROGRAMOBJECTARB _ptr;
    _ptr = (PFN_GLCREATEPROGRAMOBJECTARB)_getPrivateProcAddress("glCreateProgramObjectARB");
    if (!_ptr) {
        _ptr = &_fail_glCreateProgramObjectARB;
    }
    _glCreateProgramObjectARB = _ptr;
    return _glCreateProgramObjectARB();
}

PFN_GLCREATEPROGRAMOBJECTARB _glCreateProgramObjectARB = &_get_glCreateProgramObjectARB;

static void APIENTRY _fail_glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj) {
    const char *_name = "glAttachObjectARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj) {
    PFN_GLATTACHOBJECTARB _ptr;
    _ptr = (PFN_GLATTACHOBJECTARB)_getPrivateProcAddress("glAttachObjectARB");
    if (!_ptr) {
        _ptr = &_fail_glAttachObjectARB;
    }
    _glAttachObjectARB = _ptr;
    _glAttachObjectARB(containerObj, obj);
}

PFN_GLATTACHOBJECTARB _glAttachObjectARB = &_get_glAttachObjectARB;

static void APIENTRY _fail_glLinkProgramARB(GLhandleARB programObj) {
    const char *_name = "glLinkProgramARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLinkProgramARB(GLhandleARB programObj) {
    PFN_GLLINKPROGRAMARB _ptr;
    _ptr = (PFN_GLLINKPROGRAMARB)_getPrivateProcAddress("glLinkProgramARB");
    if (!_ptr) {
        _ptr = &_fail_glLinkProgramARB;
    }
    _glLinkProgramARB = _ptr;
    _glLinkProgramARB(programObj);
}

PFN_GLLINKPROGRAMARB _glLinkProgramARB = &_get_glLinkProgramARB;

static void APIENTRY _fail_glUseProgramObjectARB(GLhandleARB programObj) {
    const char *_name = "glUseProgramObjectARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUseProgramObjectARB(GLhandleARB programObj) {
    PFN_GLUSEPROGRAMOBJECTARB _ptr;
    _ptr = (PFN_GLUSEPROGRAMOBJECTARB)_getPrivateProcAddress("glUseProgramObjectARB");
    if (!_ptr) {
        _ptr = &_fail_glUseProgramObjectARB;
    }
    _glUseProgramObjectARB = _ptr;
    _glUseProgramObjectARB(programObj);
}

PFN_GLUSEPROGRAMOBJECTARB _glUseProgramObjectARB = &_get_glUseProgramObjectARB;

static void APIENTRY _fail_glValidateProgramARB(GLhandleARB programObj) {
    const char *_name = "glValidateProgramARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glValidateProgramARB(GLhandleARB programObj) {
    PFN_GLVALIDATEPROGRAMARB _ptr;
    _ptr = (PFN_GLVALIDATEPROGRAMARB)_getPrivateProcAddress("glValidateProgramARB");
    if (!_ptr) {
        _ptr = &_fail_glValidateProgramARB;
    }
    _glValidateProgramARB = _ptr;
    _glValidateProgramARB(programObj);
}

PFN_GLVALIDATEPROGRAMARB _glValidateProgramARB = &_get_glValidateProgramARB;

static void APIENTRY _fail_glUniform1fARB(GLint location, GLfloat v0) {
    const char *_name = "glUniform1fARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1fARB(GLint location, GLfloat v0) {
    PFN_GLUNIFORM1FARB _ptr;
    _ptr = (PFN_GLUNIFORM1FARB)_getPrivateProcAddress("glUniform1fARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform1fARB;
    }
    _glUniform1fARB = _ptr;
    _glUniform1fARB(location, v0);
}

PFN_GLUNIFORM1FARB _glUniform1fARB = &_get_glUniform1fARB;

static void APIENTRY _fail_glUniform2fARB(GLint location, GLfloat v0, GLfloat v1) {
    const char *_name = "glUniform2fARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2fARB(GLint location, GLfloat v0, GLfloat v1) {
    PFN_GLUNIFORM2FARB _ptr;
    _ptr = (PFN_GLUNIFORM2FARB)_getPrivateProcAddress("glUniform2fARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform2fARB;
    }
    _glUniform2fARB = _ptr;
    _glUniform2fARB(location, v0, v1);
}

PFN_GLUNIFORM2FARB _glUniform2fARB = &_get_glUniform2fARB;

static void APIENTRY _fail_glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
    const char *_name = "glUniform3fARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
    PFN_GLUNIFORM3FARB _ptr;
    _ptr = (PFN_GLUNIFORM3FARB)_getPrivateProcAddress("glUniform3fARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform3fARB;
    }
    _glUniform3fARB = _ptr;
    _glUniform3fARB(location, v0, v1, v2);
}

PFN_GLUNIFORM3FARB _glUniform3fARB = &_get_glUniform3fARB;

static void APIENTRY _fail_glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
    const char *_name = "glUniform4fARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
    PFN_GLUNIFORM4FARB _ptr;
    _ptr = (PFN_GLUNIFORM4FARB)_getPrivateProcAddress("glUniform4fARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform4fARB;
    }
    _glUniform4fARB = _ptr;
    _glUniform4fARB(location, v0, v1, v2, v3);
}

PFN_GLUNIFORM4FARB _glUniform4fARB = &_get_glUniform4fARB;

static void APIENTRY _fail_glUniform1iARB(GLint location, GLint v0) {
    const char *_name = "glUniform1iARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1iARB(GLint location, GLint v0) {
    PFN_GLUNIFORM1IARB _ptr;
    _ptr = (PFN_GLUNIFORM1IARB)_getPrivateProcAddress("glUniform1iARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform1iARB;
    }
    _glUniform1iARB = _ptr;
    _glUniform1iARB(location, v0);
}

PFN_GLUNIFORM1IARB _glUniform1iARB = &_get_glUniform1iARB;

static void APIENTRY _fail_glUniform2iARB(GLint location, GLint v0, GLint v1) {
    const char *_name = "glUniform2iARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2iARB(GLint location, GLint v0, GLint v1) {
    PFN_GLUNIFORM2IARB _ptr;
    _ptr = (PFN_GLUNIFORM2IARB)_getPrivateProcAddress("glUniform2iARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform2iARB;
    }
    _glUniform2iARB = _ptr;
    _glUniform2iARB(location, v0, v1);
}

PFN_GLUNIFORM2IARB _glUniform2iARB = &_get_glUniform2iARB;

static void APIENTRY _fail_glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2) {
    const char *_name = "glUniform3iARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2) {
    PFN_GLUNIFORM3IARB _ptr;
    _ptr = (PFN_GLUNIFORM3IARB)_getPrivateProcAddress("glUniform3iARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform3iARB;
    }
    _glUniform3iARB = _ptr;
    _glUniform3iARB(location, v0, v1, v2);
}

PFN_GLUNIFORM3IARB _glUniform3iARB = &_get_glUniform3iARB;

static void APIENTRY _fail_glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
    const char *_name = "glUniform4iARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
    PFN_GLUNIFORM4IARB _ptr;
    _ptr = (PFN_GLUNIFORM4IARB)_getPrivateProcAddress("glUniform4iARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform4iARB;
    }
    _glUniform4iARB = _ptr;
    _glUniform4iARB(location, v0, v1, v2, v3);
}

PFN_GLUNIFORM4IARB _glUniform4iARB = &_get_glUniform4iARB;

static void APIENTRY _fail_glUniform1fvARB(GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glUniform1fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1fvARB(GLint location, GLsizei count, const GLfloat * value) {
    PFN_GLUNIFORM1FVARB _ptr;
    _ptr = (PFN_GLUNIFORM1FVARB)_getPrivateProcAddress("glUniform1fvARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform1fvARB;
    }
    _glUniform1fvARB = _ptr;
    _glUniform1fvARB(location, count, value);
}

PFN_GLUNIFORM1FVARB _glUniform1fvARB = &_get_glUniform1fvARB;

static void APIENTRY _fail_glUniform2fvARB(GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glUniform2fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2fvARB(GLint location, GLsizei count, const GLfloat * value) {
    PFN_GLUNIFORM2FVARB _ptr;
    _ptr = (PFN_GLUNIFORM2FVARB)_getPrivateProcAddress("glUniform2fvARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform2fvARB;
    }
    _glUniform2fvARB = _ptr;
    _glUniform2fvARB(location, count, value);
}

PFN_GLUNIFORM2FVARB _glUniform2fvARB = &_get_glUniform2fvARB;

static void APIENTRY _fail_glUniform3fvARB(GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glUniform3fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3fvARB(GLint location, GLsizei count, const GLfloat * value) {
    PFN_GLUNIFORM3FVARB _ptr;
    _ptr = (PFN_GLUNIFORM3FVARB)_getPrivateProcAddress("glUniform3fvARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform3fvARB;
    }
    _glUniform3fvARB = _ptr;
    _glUniform3fvARB(location, count, value);
}

PFN_GLUNIFORM3FVARB _glUniform3fvARB = &_get_glUniform3fvARB;

static void APIENTRY _fail_glUniform4fvARB(GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glUniform4fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4fvARB(GLint location, GLsizei count, const GLfloat * value) {
    PFN_GLUNIFORM4FVARB _ptr;
    _ptr = (PFN_GLUNIFORM4FVARB)_getPrivateProcAddress("glUniform4fvARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform4fvARB;
    }
    _glUniform4fvARB = _ptr;
    _glUniform4fvARB(location, count, value);
}

PFN_GLUNIFORM4FVARB _glUniform4fvARB = &_get_glUniform4fvARB;

static void APIENTRY _fail_glUniform1ivARB(GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glUniform1ivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1ivARB(GLint location, GLsizei count, const GLint * value) {
    PFN_GLUNIFORM1IVARB _ptr;
    _ptr = (PFN_GLUNIFORM1IVARB)_getPrivateProcAddress("glUniform1ivARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform1ivARB;
    }
    _glUniform1ivARB = _ptr;
    _glUniform1ivARB(location, count, value);
}

PFN_GLUNIFORM1IVARB _glUniform1ivARB = &_get_glUniform1ivARB;

static void APIENTRY _fail_glUniform2ivARB(GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glUniform2ivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2ivARB(GLint location, GLsizei count, const GLint * value) {
    PFN_GLUNIFORM2IVARB _ptr;
    _ptr = (PFN_GLUNIFORM2IVARB)_getPrivateProcAddress("glUniform2ivARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform2ivARB;
    }
    _glUniform2ivARB = _ptr;
    _glUniform2ivARB(location, count, value);
}

PFN_GLUNIFORM2IVARB _glUniform2ivARB = &_get_glUniform2ivARB;

static void APIENTRY _fail_glUniform3ivARB(GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glUniform3ivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3ivARB(GLint location, GLsizei count, const GLint * value) {
    PFN_GLUNIFORM3IVARB _ptr;
    _ptr = (PFN_GLUNIFORM3IVARB)_getPrivateProcAddress("glUniform3ivARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform3ivARB;
    }
    _glUniform3ivARB = _ptr;
    _glUniform3ivARB(location, count, value);
}

PFN_GLUNIFORM3IVARB _glUniform3ivARB = &_get_glUniform3ivARB;

static void APIENTRY _fail_glUniform4ivARB(GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glUniform4ivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4ivARB(GLint location, GLsizei count, const GLint * value) {
    PFN_GLUNIFORM4IVARB _ptr;
    _ptr = (PFN_GLUNIFORM4IVARB)_getPrivateProcAddress("glUniform4ivARB");
    if (!_ptr) {
        _ptr = &_fail_glUniform4ivARB;
    }
    _glUniform4ivARB = _ptr;
    _glUniform4ivARB(location, count, value);
}

PFN_GLUNIFORM4IVARB _glUniform4ivARB = &_get_glUniform4ivARB;

static void APIENTRY _fail_glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix2fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLUNIFORMMATRIX2FVARB _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX2FVARB)_getPrivateProcAddress("glUniformMatrix2fvARB");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix2fvARB;
    }
    _glUniformMatrix2fvARB = _ptr;
    _glUniformMatrix2fvARB(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX2FVARB _glUniformMatrix2fvARB = &_get_glUniformMatrix2fvARB;

static void APIENTRY _fail_glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix3fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLUNIFORMMATRIX3FVARB _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX3FVARB)_getPrivateProcAddress("glUniformMatrix3fvARB");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix3fvARB;
    }
    _glUniformMatrix3fvARB = _ptr;
    _glUniformMatrix3fvARB(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX3FVARB _glUniformMatrix3fvARB = &_get_glUniformMatrix3fvARB;

static void APIENTRY _fail_glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glUniformMatrix4fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLUNIFORMMATRIX4FVARB _ptr;
    _ptr = (PFN_GLUNIFORMMATRIX4FVARB)_getPrivateProcAddress("glUniformMatrix4fvARB");
    if (!_ptr) {
        _ptr = &_fail_glUniformMatrix4fvARB;
    }
    _glUniformMatrix4fvARB = _ptr;
    _glUniformMatrix4fvARB(location, count, transpose, value);
}

PFN_GLUNIFORMMATRIX4FVARB _glUniformMatrix4fvARB = &_get_glUniformMatrix4fvARB;

static void APIENTRY _fail_glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat * params) {
    const char *_name = "glGetObjectParameterfvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat * params) {
    PFN_GLGETOBJECTPARAMETERFVARB _ptr;
    _ptr = (PFN_GLGETOBJECTPARAMETERFVARB)_getPrivateProcAddress("glGetObjectParameterfvARB");
    if (!_ptr) {
        _ptr = &_fail_glGetObjectParameterfvARB;
    }
    _glGetObjectParameterfvARB = _ptr;
    _glGetObjectParameterfvARB(obj, pname, params);
}

PFN_GLGETOBJECTPARAMETERFVARB _glGetObjectParameterfvARB = &_get_glGetObjectParameterfvARB;

static void APIENTRY _fail_glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint * params) {
    const char *_name = "glGetObjectParameterivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint * params) {
    PFN_GLGETOBJECTPARAMETERIVARB _ptr;
    _ptr = (PFN_GLGETOBJECTPARAMETERIVARB)_getPrivateProcAddress("glGetObjectParameterivARB");
    if (!_ptr) {
        _ptr = &_fail_glGetObjectParameterivARB;
    }
    _glGetObjectParameterivARB = _ptr;
    _glGetObjectParameterivARB(obj, pname, params);
}

PFN_GLGETOBJECTPARAMETERIVARB _glGetObjectParameterivARB = &_get_glGetObjectParameterivARB;

static void APIENTRY _fail_glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * infoLog) {
    const char *_name = "glGetInfoLogARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * infoLog) {
    PFN_GLGETINFOLOGARB _ptr;
    _ptr = (PFN_GLGETINFOLOGARB)_getPrivateProcAddress("glGetInfoLogARB");
    if (!_ptr) {
        _ptr = &_fail_glGetInfoLogARB;
    }
    _glGetInfoLogARB = _ptr;
    _glGetInfoLogARB(obj, maxLength, length, infoLog);
}

PFN_GLGETINFOLOGARB _glGetInfoLogARB = &_get_glGetInfoLogARB;

static void APIENTRY _fail_glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei * count, GLhandleARB * obj) {
    const char *_name = "glGetAttachedObjectsARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei * count, GLhandleARB * obj) {
    PFN_GLGETATTACHEDOBJECTSARB _ptr;
    _ptr = (PFN_GLGETATTACHEDOBJECTSARB)_getPrivateProcAddress("glGetAttachedObjectsARB");
    if (!_ptr) {
        _ptr = &_fail_glGetAttachedObjectsARB;
    }
    _glGetAttachedObjectsARB = _ptr;
    _glGetAttachedObjectsARB(containerObj, maxCount, count, obj);
}

PFN_GLGETATTACHEDOBJECTSARB _glGetAttachedObjectsARB = &_get_glGetAttachedObjectsARB;

static GLint APIENTRY _fail_glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB * name) {
    const char *_name = "glGetUniformLocationARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLint APIENTRY _get_glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB * name) {
    PFN_GLGETUNIFORMLOCATIONARB _ptr;
    _ptr = (PFN_GLGETUNIFORMLOCATIONARB)_getPrivateProcAddress("glGetUniformLocationARB");
    if (!_ptr) {
        _ptr = &_fail_glGetUniformLocationARB;
    }
    _glGetUniformLocationARB = _ptr;
    return _glGetUniformLocationARB(programObj, name);
}

PFN_GLGETUNIFORMLOCATIONARB _glGetUniformLocationARB = &_get_glGetUniformLocationARB;

static void APIENTRY _fail_glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name) {
    const char *_name = "glGetActiveUniformARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name) {
    PFN_GLGETACTIVEUNIFORMARB _ptr;
    _ptr = (PFN_GLGETACTIVEUNIFORMARB)_getPrivateProcAddress("glGetActiveUniformARB");
    if (!_ptr) {
        _ptr = &_fail_glGetActiveUniformARB;
    }
    _glGetActiveUniformARB = _ptr;
    _glGetActiveUniformARB(programObj, index, bufSize, length, size, type, name);
}

PFN_GLGETACTIVEUNIFORMARB _glGetActiveUniformARB = &_get_glGetActiveUniformARB;

static void APIENTRY _fail_glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat * params) {
    const char *_name = "glGetUniformfvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat * params) {
    PFN_GLGETUNIFORMFVARB _ptr;
    _ptr = (PFN_GLGETUNIFORMFVARB)_getPrivateProcAddress("glGetUniformfvARB");
    if (!_ptr) {
        _ptr = &_fail_glGetUniformfvARB;
    }
    _glGetUniformfvARB = _ptr;
    _glGetUniformfvARB(programObj, location, params);
}

PFN_GLGETUNIFORMFVARB _glGetUniformfvARB = &_get_glGetUniformfvARB;

static void APIENTRY _fail_glGetUniformivARB(GLhandleARB programObj, GLint location, GLint * params) {
    const char *_name = "glGetUniformivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetUniformivARB(GLhandleARB programObj, GLint location, GLint * params) {
    PFN_GLGETUNIFORMIVARB _ptr;
    _ptr = (PFN_GLGETUNIFORMIVARB)_getPrivateProcAddress("glGetUniformivARB");
    if (!_ptr) {
        _ptr = &_fail_glGetUniformivARB;
    }
    _glGetUniformivARB = _ptr;
    _glGetUniformivARB(programObj, location, params);
}

PFN_GLGETUNIFORMIVARB _glGetUniformivARB = &_get_glGetUniformivARB;

static void APIENTRY _fail_glGetShaderSourceARB(GLhandleARB obj, GLsizei bufSize, GLsizei * length, GLcharARB * source) {
    const char *_name = "glGetShaderSourceARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetShaderSourceARB(GLhandleARB obj, GLsizei bufSize, GLsizei * length, GLcharARB * source) {
    PFN_GLGETSHADERSOURCEARB _ptr;
    _ptr = (PFN_GLGETSHADERSOURCEARB)_getPrivateProcAddress("glGetShaderSourceARB");
    if (!_ptr) {
        _ptr = &_fail_glGetShaderSourceARB;
    }
    _glGetShaderSourceARB = _ptr;
    _glGetShaderSourceARB(obj, bufSize, length, source);
}

PFN_GLGETSHADERSOURCEARB _glGetShaderSourceARB = &_get_glGetShaderSourceARB;

static void APIENTRY _fail_glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding) {
    const char *_name = "glShaderStorageBlockBinding";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding) {
    PFN_GLSHADERSTORAGEBLOCKBINDING _ptr;
    _ptr = (PFN_GLSHADERSTORAGEBLOCKBINDING)_getPrivateProcAddress("glShaderStorageBlockBinding");
    if (!_ptr) {
        _ptr = &_fail_glShaderStorageBlockBinding;
    }
    _glShaderStorageBlockBinding = _ptr;
    _glShaderStorageBlockBinding(program, storageBlockIndex, storageBlockBinding);
}

PFN_GLSHADERSTORAGEBLOCKBINDING _glShaderStorageBlockBinding = &_get_glShaderStorageBlockBinding;

static GLint APIENTRY _fail_glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar * name) {
    const char *_name = "glGetSubroutineUniformLocation";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLint APIENTRY _get_glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar * name) {
    PFN_GLGETSUBROUTINEUNIFORMLOCATION _ptr;
    _ptr = (PFN_GLGETSUBROUTINEUNIFORMLOCATION)_getPrivateProcAddress("glGetSubroutineUniformLocation");
    if (!_ptr) {
        _ptr = &_fail_glGetSubroutineUniformLocation;
    }
    _glGetSubroutineUniformLocation = _ptr;
    return _glGetSubroutineUniformLocation(program, shadertype, name);
}

PFN_GLGETSUBROUTINEUNIFORMLOCATION _glGetSubroutineUniformLocation = &_get_glGetSubroutineUniformLocation;

static GLuint APIENTRY _fail_glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar * name) {
    const char *_name = "glGetSubroutineIndex";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar * name) {
    PFN_GLGETSUBROUTINEINDEX _ptr;
    _ptr = (PFN_GLGETSUBROUTINEINDEX)_getPrivateProcAddress("glGetSubroutineIndex");
    if (!_ptr) {
        _ptr = &_fail_glGetSubroutineIndex;
    }
    _glGetSubroutineIndex = _ptr;
    return _glGetSubroutineIndex(program, shadertype, name);
}

PFN_GLGETSUBROUTINEINDEX _glGetSubroutineIndex = &_get_glGetSubroutineIndex;

static void APIENTRY _fail_glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint * values) {
    const char *_name = "glGetActiveSubroutineUniformiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint * values) {
    PFN_GLGETACTIVESUBROUTINEUNIFORMIV _ptr;
    _ptr = (PFN_GLGETACTIVESUBROUTINEUNIFORMIV)_getPrivateProcAddress("glGetActiveSubroutineUniformiv");
    if (!_ptr) {
        _ptr = &_fail_glGetActiveSubroutineUniformiv;
    }
    _glGetActiveSubroutineUniformiv = _ptr;
    _glGetActiveSubroutineUniformiv(program, shadertype, index, pname, values);
}

PFN_GLGETACTIVESUBROUTINEUNIFORMIV _glGetActiveSubroutineUniformiv = &_get_glGetActiveSubroutineUniformiv;

static void APIENTRY _fail_glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei * length, GLchar * name) {
    const char *_name = "glGetActiveSubroutineUniformName";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei * length, GLchar * name) {
    PFN_GLGETACTIVESUBROUTINEUNIFORMNAME _ptr;
    _ptr = (PFN_GLGETACTIVESUBROUTINEUNIFORMNAME)_getPrivateProcAddress("glGetActiveSubroutineUniformName");
    if (!_ptr) {
        _ptr = &_fail_glGetActiveSubroutineUniformName;
    }
    _glGetActiveSubroutineUniformName = _ptr;
    _glGetActiveSubroutineUniformName(program, shadertype, index, bufsize, length, name);
}

PFN_GLGETACTIVESUBROUTINEUNIFORMNAME _glGetActiveSubroutineUniformName = &_get_glGetActiveSubroutineUniformName;

static void APIENTRY _fail_glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei * length, GLchar * name) {
    const char *_name = "glGetActiveSubroutineName";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei * length, GLchar * name) {
    PFN_GLGETACTIVESUBROUTINENAME _ptr;
    _ptr = (PFN_GLGETACTIVESUBROUTINENAME)_getPrivateProcAddress("glGetActiveSubroutineName");
    if (!_ptr) {
        _ptr = &_fail_glGetActiveSubroutineName;
    }
    _glGetActiveSubroutineName = _ptr;
    _glGetActiveSubroutineName(program, shadertype, index, bufsize, length, name);
}

PFN_GLGETACTIVESUBROUTINENAME _glGetActiveSubroutineName = &_get_glGetActiveSubroutineName;

static void APIENTRY _fail_glUniformSubroutinesuiv(GLenum shadertype, GLsizei count, const GLuint * indices) {
    const char *_name = "glUniformSubroutinesuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformSubroutinesuiv(GLenum shadertype, GLsizei count, const GLuint * indices) {
    PFN_GLUNIFORMSUBROUTINESUIV _ptr;
    _ptr = (PFN_GLUNIFORMSUBROUTINESUIV)_getPrivateProcAddress("glUniformSubroutinesuiv");
    if (!_ptr) {
        _ptr = &_fail_glUniformSubroutinesuiv;
    }
    _glUniformSubroutinesuiv = _ptr;
    _glUniformSubroutinesuiv(shadertype, count, indices);
}

PFN_GLUNIFORMSUBROUTINESUIV _glUniformSubroutinesuiv = &_get_glUniformSubroutinesuiv;

static void APIENTRY _fail_glGetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint * params) {
    const char *_name = "glGetUniformSubroutineuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint * params) {
    PFN_GLGETUNIFORMSUBROUTINEUIV _ptr;
    _ptr = (PFN_GLGETUNIFORMSUBROUTINEUIV)_getPrivateProcAddress("glGetUniformSubroutineuiv");
    if (!_ptr) {
        _ptr = &_fail_glGetUniformSubroutineuiv;
    }
    _glGetUniformSubroutineuiv = _ptr;
    _glGetUniformSubroutineuiv(shadertype, location, params);
}

PFN_GLGETUNIFORMSUBROUTINEUIV _glGetUniformSubroutineuiv = &_get_glGetUniformSubroutineuiv;

static void APIENTRY _fail_glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint * values) {
    const char *_name = "glGetProgramStageiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint * values) {
    PFN_GLGETPROGRAMSTAGEIV _ptr;
    _ptr = (PFN_GLGETPROGRAMSTAGEIV)_getPrivateProcAddress("glGetProgramStageiv");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramStageiv;
    }
    _glGetProgramStageiv = _ptr;
    _glGetProgramStageiv(program, shadertype, pname, values);
}

PFN_GLGETPROGRAMSTAGEIV _glGetProgramStageiv = &_get_glGetProgramStageiv;

static void APIENTRY _fail_glNamedStringARB(GLenum type, GLint namelen, const GLchar * name, GLint stringlen, const GLchar * string) {
    const char *_name = "glNamedStringARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedStringARB(GLenum type, GLint namelen, const GLchar * name, GLint stringlen, const GLchar * string) {
    PFN_GLNAMEDSTRINGARB _ptr;
    _ptr = (PFN_GLNAMEDSTRINGARB)_getPrivateProcAddress("glNamedStringARB");
    if (!_ptr) {
        _ptr = &_fail_glNamedStringARB;
    }
    _glNamedStringARB = _ptr;
    _glNamedStringARB(type, namelen, name, stringlen, string);
}

PFN_GLNAMEDSTRINGARB _glNamedStringARB = &_get_glNamedStringARB;

static void APIENTRY _fail_glDeleteNamedStringARB(GLint namelen, const GLchar * name) {
    const char *_name = "glDeleteNamedStringARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteNamedStringARB(GLint namelen, const GLchar * name) {
    PFN_GLDELETENAMEDSTRINGARB _ptr;
    _ptr = (PFN_GLDELETENAMEDSTRINGARB)_getPrivateProcAddress("glDeleteNamedStringARB");
    if (!_ptr) {
        _ptr = &_fail_glDeleteNamedStringARB;
    }
    _glDeleteNamedStringARB = _ptr;
    _glDeleteNamedStringARB(namelen, name);
}

PFN_GLDELETENAMEDSTRINGARB _glDeleteNamedStringARB = &_get_glDeleteNamedStringARB;

static void APIENTRY _fail_glCompileShaderIncludeARB(GLuint shader, GLsizei count, const GLchar * const * path, const GLint * length) {
    const char *_name = "glCompileShaderIncludeARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompileShaderIncludeARB(GLuint shader, GLsizei count, const GLchar * const * path, const GLint * length) {
    PFN_GLCOMPILESHADERINCLUDEARB _ptr;
    _ptr = (PFN_GLCOMPILESHADERINCLUDEARB)_getPrivateProcAddress("glCompileShaderIncludeARB");
    if (!_ptr) {
        _ptr = &_fail_glCompileShaderIncludeARB;
    }
    _glCompileShaderIncludeARB = _ptr;
    _glCompileShaderIncludeARB(shader, count, path, length);
}

PFN_GLCOMPILESHADERINCLUDEARB _glCompileShaderIncludeARB = &_get_glCompileShaderIncludeARB;

static GLboolean APIENTRY _fail_glIsNamedStringARB(GLint namelen, const GLchar * name) {
    const char *_name = "glIsNamedStringARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsNamedStringARB(GLint namelen, const GLchar * name) {
    PFN_GLISNAMEDSTRINGARB _ptr;
    _ptr = (PFN_GLISNAMEDSTRINGARB)_getPrivateProcAddress("glIsNamedStringARB");
    if (!_ptr) {
        _ptr = &_fail_glIsNamedStringARB;
    }
    _glIsNamedStringARB = _ptr;
    return _glIsNamedStringARB(namelen, name);
}

PFN_GLISNAMEDSTRINGARB _glIsNamedStringARB = &_get_glIsNamedStringARB;

static void APIENTRY _fail_glGetNamedStringARB(GLint namelen, const GLchar * name, GLsizei bufSize, GLint * stringlen, GLchar * string) {
    const char *_name = "glGetNamedStringARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedStringARB(GLint namelen, const GLchar * name, GLsizei bufSize, GLint * stringlen, GLchar * string) {
    PFN_GLGETNAMEDSTRINGARB _ptr;
    _ptr = (PFN_GLGETNAMEDSTRINGARB)_getPrivateProcAddress("glGetNamedStringARB");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedStringARB;
    }
    _glGetNamedStringARB = _ptr;
    _glGetNamedStringARB(namelen, name, bufSize, stringlen, string);
}

PFN_GLGETNAMEDSTRINGARB _glGetNamedStringARB = &_get_glGetNamedStringARB;

static void APIENTRY _fail_glGetNamedStringivARB(GLint namelen, const GLchar * name, GLenum pname, GLint * params) {
    const char *_name = "glGetNamedStringivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedStringivARB(GLint namelen, const GLchar * name, GLenum pname, GLint * params) {
    PFN_GLGETNAMEDSTRINGIVARB _ptr;
    _ptr = (PFN_GLGETNAMEDSTRINGIVARB)_getPrivateProcAddress("glGetNamedStringivARB");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedStringivARB;
    }
    _glGetNamedStringivARB = _ptr;
    _glGetNamedStringivARB(namelen, name, pname, params);
}

PFN_GLGETNAMEDSTRINGIVARB _glGetNamedStringivARB = &_get_glGetNamedStringivARB;

static void APIENTRY _fail_glBufferPageCommitmentARB(GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit) {
    const char *_name = "glBufferPageCommitmentARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBufferPageCommitmentARB(GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit) {
    PFN_GLBUFFERPAGECOMMITMENTARB _ptr;
    _ptr = (PFN_GLBUFFERPAGECOMMITMENTARB)_getPrivateProcAddress("glBufferPageCommitmentARB");
    if (!_ptr) {
        _ptr = &_fail_glBufferPageCommitmentARB;
    }
    _glBufferPageCommitmentARB = _ptr;
    _glBufferPageCommitmentARB(target, offset, size, commit);
}

PFN_GLBUFFERPAGECOMMITMENTARB _glBufferPageCommitmentARB = &_get_glBufferPageCommitmentARB;

static void APIENTRY _fail_glNamedBufferPageCommitmentEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit) {
    const char *_name = "glNamedBufferPageCommitmentEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedBufferPageCommitmentEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit) {
    PFN_GLNAMEDBUFFERPAGECOMMITMENTEXT _ptr;
    _ptr = (PFN_GLNAMEDBUFFERPAGECOMMITMENTEXT)_getPrivateProcAddress("glNamedBufferPageCommitmentEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedBufferPageCommitmentEXT;
    }
    _glNamedBufferPageCommitmentEXT = _ptr;
    _glNamedBufferPageCommitmentEXT(buffer, offset, size, commit);
}

PFN_GLNAMEDBUFFERPAGECOMMITMENTEXT _glNamedBufferPageCommitmentEXT = &_get_glNamedBufferPageCommitmentEXT;

static void APIENTRY _fail_glNamedBufferPageCommitmentARB(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit) {
    const char *_name = "glNamedBufferPageCommitmentARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedBufferPageCommitmentARB(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit) {
    PFN_GLNAMEDBUFFERPAGECOMMITMENTARB _ptr;
    _ptr = (PFN_GLNAMEDBUFFERPAGECOMMITMENTARB)_getPrivateProcAddress("glNamedBufferPageCommitmentARB");
    if (!_ptr) {
        _ptr = &_fail_glNamedBufferPageCommitmentARB;
    }
    _glNamedBufferPageCommitmentARB = _ptr;
    _glNamedBufferPageCommitmentARB(buffer, offset, size, commit);
}

PFN_GLNAMEDBUFFERPAGECOMMITMENTARB _glNamedBufferPageCommitmentARB = &_get_glNamedBufferPageCommitmentARB;

static void APIENTRY _fail_glTexPageCommitmentARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean resident) {
    const char *_name = "glTexPageCommitmentARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexPageCommitmentARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean resident) {
    PFN_GLTEXPAGECOMMITMENTARB _ptr;
    _ptr = (PFN_GLTEXPAGECOMMITMENTARB)_getPrivateProcAddress("glTexPageCommitmentARB");
    if (!_ptr) {
        _ptr = &_fail_glTexPageCommitmentARB;
    }
    _glTexPageCommitmentARB = _ptr;
    _glTexPageCommitmentARB(target, level, xoffset, yoffset, zoffset, width, height, depth, resident);
}

PFN_GLTEXPAGECOMMITMENTARB _glTexPageCommitmentARB = &_get_glTexPageCommitmentARB;

static GLsync APIENTRY _fail_glFenceSync(GLenum condition, GLbitfield flags) {
    const char *_name = "glFenceSync";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLsync APIENTRY _get_glFenceSync(GLenum condition, GLbitfield flags) {
    PFN_GLFENCESYNC _ptr;
    _ptr = (PFN_GLFENCESYNC)_getPrivateProcAddress("glFenceSync");
    if (!_ptr) {
        _ptr = &_fail_glFenceSync;
    }
    _glFenceSync = _ptr;
    return _glFenceSync(condition, flags);
}

PFN_GLFENCESYNC _glFenceSync = &_get_glFenceSync;

static GLboolean APIENTRY _fail_glIsSync(GLsync sync) {
    const char *_name = "glIsSync";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsSync(GLsync sync) {
    PFN_GLISSYNC _ptr;
    _ptr = (PFN_GLISSYNC)_getPrivateProcAddress("glIsSync");
    if (!_ptr) {
        _ptr = &_fail_glIsSync;
    }
    _glIsSync = _ptr;
    return _glIsSync(sync);
}

PFN_GLISSYNC _glIsSync = &_get_glIsSync;

static void APIENTRY _fail_glDeleteSync(GLsync sync) {
    const char *_name = "glDeleteSync";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteSync(GLsync sync) {
    PFN_GLDELETESYNC _ptr;
    _ptr = (PFN_GLDELETESYNC)_getPrivateProcAddress("glDeleteSync");
    if (!_ptr) {
        _ptr = &_fail_glDeleteSync;
    }
    _glDeleteSync = _ptr;
    _glDeleteSync(sync);
}

PFN_GLDELETESYNC _glDeleteSync = &_get_glDeleteSync;

static GLenum APIENTRY _fail_glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout) {
    const char *_name = "glClientWaitSync";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLenum APIENTRY _get_glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout) {
    PFN_GLCLIENTWAITSYNC _ptr;
    _ptr = (PFN_GLCLIENTWAITSYNC)_getPrivateProcAddress("glClientWaitSync");
    if (!_ptr) {
        _ptr = &_fail_glClientWaitSync;
    }
    _glClientWaitSync = _ptr;
    return _glClientWaitSync(sync, flags, timeout);
}

PFN_GLCLIENTWAITSYNC _glClientWaitSync = &_get_glClientWaitSync;

static void APIENTRY _fail_glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout) {
    const char *_name = "glWaitSync";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout) {
    PFN_GLWAITSYNC _ptr;
    _ptr = (PFN_GLWAITSYNC)_getPrivateProcAddress("glWaitSync");
    if (!_ptr) {
        _ptr = &_fail_glWaitSync;
    }
    _glWaitSync = _ptr;
    _glWaitSync(sync, flags, timeout);
}

PFN_GLWAITSYNC _glWaitSync = &_get_glWaitSync;

static void APIENTRY _fail_glGetInteger64v(GLenum pname, GLint64 * params) {
    const char *_name = "glGetInteger64v";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetInteger64v(GLenum pname, GLint64 * params) {
    PFN_GLGETINTEGER64V _ptr;
    _ptr = (PFN_GLGETINTEGER64V)_getPrivateProcAddress("glGetInteger64v");
    if (!_ptr) {
        _ptr = &_fail_glGetInteger64v;
    }
    _glGetInteger64v = _ptr;
    _glGetInteger64v(pname, params);
}

PFN_GLGETINTEGER64V _glGetInteger64v = &_get_glGetInteger64v;

static void APIENTRY _fail_glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values) {
    const char *_name = "glGetSynciv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values) {
    PFN_GLGETSYNCIV _ptr;
    _ptr = (PFN_GLGETSYNCIV)_getPrivateProcAddress("glGetSynciv");
    if (!_ptr) {
        _ptr = &_fail_glGetSynciv;
    }
    _glGetSynciv = _ptr;
    _glGetSynciv(sync, pname, bufSize, length, values);
}

PFN_GLGETSYNCIV _glGetSynciv = &_get_glGetSynciv;

static void APIENTRY _fail_glPatchParameteri(GLenum pname, GLint value) {
    const char *_name = "glPatchParameteri";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPatchParameteri(GLenum pname, GLint value) {
    PFN_GLPATCHPARAMETERI _ptr;
    _ptr = (PFN_GLPATCHPARAMETERI)_getPrivateProcAddress("glPatchParameteri");
    if (!_ptr) {
        _ptr = &_fail_glPatchParameteri;
    }
    _glPatchParameteri = _ptr;
    _glPatchParameteri(pname, value);
}

PFN_GLPATCHPARAMETERI _glPatchParameteri = &_get_glPatchParameteri;

static void APIENTRY _fail_glPatchParameterfv(GLenum pname, const GLfloat * values) {
    const char *_name = "glPatchParameterfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPatchParameterfv(GLenum pname, const GLfloat * values) {
    PFN_GLPATCHPARAMETERFV _ptr;
    _ptr = (PFN_GLPATCHPARAMETERFV)_getPrivateProcAddress("glPatchParameterfv");
    if (!_ptr) {
        _ptr = &_fail_glPatchParameterfv;
    }
    _glPatchParameterfv = _ptr;
    _glPatchParameterfv(pname, values);
}

PFN_GLPATCHPARAMETERFV _glPatchParameterfv = &_get_glPatchParameterfv;

static void APIENTRY _fail_glTextureBarrier(void) {
    const char *_name = "glTextureBarrier";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureBarrier(void) {
    PFN_GLTEXTUREBARRIER _ptr;
    _ptr = (PFN_GLTEXTUREBARRIER)_getPrivateProcAddress("glTextureBarrier");
    if (!_ptr) {
        _ptr = &_fail_glTextureBarrier;
    }
    _glTextureBarrier = _ptr;
    _glTextureBarrier();
}

PFN_GLTEXTUREBARRIER _glTextureBarrier = &_get_glTextureBarrier;

static void APIENTRY _fail_glTexBufferARB(GLenum target, GLenum internalformat, GLuint buffer) {
    const char *_name = "glTexBufferARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexBufferARB(GLenum target, GLenum internalformat, GLuint buffer) {
    PFN_GLTEXBUFFERARB _ptr;
    _ptr = (PFN_GLTEXBUFFERARB)_getPrivateProcAddress("glTexBufferARB");
    if (!_ptr) {
        _ptr = &_fail_glTexBufferARB;
    }
    _glTexBufferARB = _ptr;
    _glTexBufferARB(target, internalformat, buffer);
}

PFN_GLTEXBUFFERARB _glTexBufferARB = &_get_glTexBufferARB;

static void APIENTRY _fail_glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    const char *_name = "glTexBufferRange";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    PFN_GLTEXBUFFERRANGE _ptr;
    _ptr = (PFN_GLTEXBUFFERRANGE)_getPrivateProcAddress("glTexBufferRange");
    if (!_ptr) {
        _ptr = &_fail_glTexBufferRange;
    }
    _glTexBufferRange = _ptr;
    _glTexBufferRange(target, internalformat, buffer, offset, size);
}

PFN_GLTEXBUFFERRANGE _glTexBufferRange = &_get_glTexBufferRange;

static void APIENTRY _fail_glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexImage3DARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data) {
    PFN_GLCOMPRESSEDTEXIMAGE3DARB _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXIMAGE3DARB)_getPrivateProcAddress("glCompressedTexImage3DARB");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTexImage3DARB;
    }
    _glCompressedTexImage3DARB = _ptr;
    _glCompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data);
}

PFN_GLCOMPRESSEDTEXIMAGE3DARB _glCompressedTexImage3DARB = &_get_glCompressedTexImage3DARB;

static void APIENTRY _fail_glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexImage2DARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data) {
    PFN_GLCOMPRESSEDTEXIMAGE2DARB _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXIMAGE2DARB)_getPrivateProcAddress("glCompressedTexImage2DARB");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTexImage2DARB;
    }
    _glCompressedTexImage2DARB = _ptr;
    _glCompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data);
}

PFN_GLCOMPRESSEDTEXIMAGE2DARB _glCompressedTexImage2DARB = &_get_glCompressedTexImage2DARB;

static void APIENTRY _fail_glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexImage1DARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data) {
    PFN_GLCOMPRESSEDTEXIMAGE1DARB _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXIMAGE1DARB)_getPrivateProcAddress("glCompressedTexImage1DARB");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTexImage1DARB;
    }
    _glCompressedTexImage1DARB = _ptr;
    _glCompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data);
}

PFN_GLCOMPRESSEDTEXIMAGE1DARB _glCompressedTexImage1DARB = &_get_glCompressedTexImage1DARB;

static void APIENTRY _fail_glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexSubImage3DARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data) {
    PFN_GLCOMPRESSEDTEXSUBIMAGE3DARB _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXSUBIMAGE3DARB)_getPrivateProcAddress("glCompressedTexSubImage3DARB");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTexSubImage3DARB;
    }
    _glCompressedTexSubImage3DARB = _ptr;
    _glCompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

PFN_GLCOMPRESSEDTEXSUBIMAGE3DARB _glCompressedTexSubImage3DARB = &_get_glCompressedTexSubImage3DARB;

static void APIENTRY _fail_glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexSubImage2DARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data) {
    PFN_GLCOMPRESSEDTEXSUBIMAGE2DARB _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXSUBIMAGE2DARB)_getPrivateProcAddress("glCompressedTexSubImage2DARB");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTexSubImage2DARB;
    }
    _glCompressedTexSubImage2DARB = _ptr;
    _glCompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

PFN_GLCOMPRESSEDTEXSUBIMAGE2DARB _glCompressedTexSubImage2DARB = &_get_glCompressedTexSubImage2DARB;

static void APIENTRY _fail_glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexSubImage1DARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data) {
    PFN_GLCOMPRESSEDTEXSUBIMAGE1DARB _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXSUBIMAGE1DARB)_getPrivateProcAddress("glCompressedTexSubImage1DARB");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTexSubImage1DARB;
    }
    _glCompressedTexSubImage1DARB = _ptr;
    _glCompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data);
}

PFN_GLCOMPRESSEDTEXSUBIMAGE1DARB _glCompressedTexSubImage1DARB = &_get_glCompressedTexSubImage1DARB;

static void APIENTRY _fail_glGetCompressedTexImageARB(GLenum target, GLint level, GLvoid * img) {
    const char *_name = "glGetCompressedTexImageARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetCompressedTexImageARB(GLenum target, GLint level, GLvoid * img) {
    PFN_GLGETCOMPRESSEDTEXIMAGEARB _ptr;
    _ptr = (PFN_GLGETCOMPRESSEDTEXIMAGEARB)_getPrivateProcAddress("glGetCompressedTexImageARB");
    if (!_ptr) {
        _ptr = &_fail_glGetCompressedTexImageARB;
    }
    _glGetCompressedTexImageARB = _ptr;
    _glGetCompressedTexImageARB(target, level, img);
}

PFN_GLGETCOMPRESSEDTEXIMAGEARB _glGetCompressedTexImageARB = &_get_glGetCompressedTexImageARB;

static void APIENTRY _fail_glTexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
    const char *_name = "glTexImage2DMultisample";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
    PFN_GLTEXIMAGE2DMULTISAMPLE _ptr;
    _ptr = (PFN_GLTEXIMAGE2DMULTISAMPLE)_getPrivateProcAddress("glTexImage2DMultisample");
    if (!_ptr) {
        _ptr = &_fail_glTexImage2DMultisample;
    }
    _glTexImage2DMultisample = _ptr;
    _glTexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
}

PFN_GLTEXIMAGE2DMULTISAMPLE _glTexImage2DMultisample = &_get_glTexImage2DMultisample;

static void APIENTRY _fail_glTexImage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
    const char *_name = "glTexImage3DMultisample";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexImage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
    PFN_GLTEXIMAGE3DMULTISAMPLE _ptr;
    _ptr = (PFN_GLTEXIMAGE3DMULTISAMPLE)_getPrivateProcAddress("glTexImage3DMultisample");
    if (!_ptr) {
        _ptr = &_fail_glTexImage3DMultisample;
    }
    _glTexImage3DMultisample = _ptr;
    _glTexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
}

PFN_GLTEXIMAGE3DMULTISAMPLE _glTexImage3DMultisample = &_get_glTexImage3DMultisample;

static void APIENTRY _fail_glGetMultisamplefv(GLenum pname, GLuint index, GLfloat * val) {
    const char *_name = "glGetMultisamplefv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMultisamplefv(GLenum pname, GLuint index, GLfloat * val) {
    PFN_GLGETMULTISAMPLEFV _ptr;
    _ptr = (PFN_GLGETMULTISAMPLEFV)_getPrivateProcAddress("glGetMultisamplefv");
    if (!_ptr) {
        _ptr = &_fail_glGetMultisamplefv;
    }
    _glGetMultisamplefv = _ptr;
    _glGetMultisamplefv(pname, index, val);
}

PFN_GLGETMULTISAMPLEFV _glGetMultisamplefv = &_get_glGetMultisamplefv;

static void APIENTRY _fail_glSampleMaski(GLuint index, GLbitfield mask) {
    const char *_name = "glSampleMaski";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSampleMaski(GLuint index, GLbitfield mask) {
    PFN_GLSAMPLEMASKI _ptr;
    _ptr = (PFN_GLSAMPLEMASKI)_getPrivateProcAddress("glSampleMaski");
    if (!_ptr) {
        _ptr = &_fail_glSampleMaski;
    }
    _glSampleMaski = _ptr;
    _glSampleMaski(index, mask);
}

PFN_GLSAMPLEMASKI _glSampleMaski = &_get_glSampleMaski;

static void APIENTRY _fail_glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) {
    const char *_name = "glTexStorage1D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) {
    PFN_GLTEXSTORAGE1D _ptr;
    _ptr = (PFN_GLTEXSTORAGE1D)_getPrivateProcAddress("glTexStorage1D");
    if (!_ptr) {
        _ptr = &_fail_glTexStorage1D;
    }
    _glTexStorage1D = _ptr;
    _glTexStorage1D(target, levels, internalformat, width);
}

PFN_GLTEXSTORAGE1D _glTexStorage1D = &_get_glTexStorage1D;

static void APIENTRY _fail_glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glTexStorage2D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) {
    PFN_GLTEXSTORAGE2D _ptr;
    _ptr = (PFN_GLTEXSTORAGE2D)_getPrivateProcAddress("glTexStorage2D");
    if (!_ptr) {
        _ptr = &_fail_glTexStorage2D;
    }
    _glTexStorage2D = _ptr;
    _glTexStorage2D(target, levels, internalformat, width, height);
}

PFN_GLTEXSTORAGE2D _glTexStorage2D = &_get_glTexStorage2D;

static void APIENTRY _fail_glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) {
    const char *_name = "glTexStorage3D";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) {
    PFN_GLTEXSTORAGE3D _ptr;
    _ptr = (PFN_GLTEXSTORAGE3D)_getPrivateProcAddress("glTexStorage3D");
    if (!_ptr) {
        _ptr = &_fail_glTexStorage3D;
    }
    _glTexStorage3D = _ptr;
    _glTexStorage3D(target, levels, internalformat, width, height, depth);
}

PFN_GLTEXSTORAGE3D _glTexStorage3D = &_get_glTexStorage3D;

static void APIENTRY _fail_glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
    const char *_name = "glTexStorage2DMultisample";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
    PFN_GLTEXSTORAGE2DMULTISAMPLE _ptr;
    _ptr = (PFN_GLTEXSTORAGE2DMULTISAMPLE)_getPrivateProcAddress("glTexStorage2DMultisample");
    if (!_ptr) {
        _ptr = &_fail_glTexStorage2DMultisample;
    }
    _glTexStorage2DMultisample = _ptr;
    _glTexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
}

PFN_GLTEXSTORAGE2DMULTISAMPLE _glTexStorage2DMultisample = &_get_glTexStorage2DMultisample;

static void APIENTRY _fail_glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
    const char *_name = "glTexStorage3DMultisample";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
    PFN_GLTEXSTORAGE3DMULTISAMPLE _ptr;
    _ptr = (PFN_GLTEXSTORAGE3DMULTISAMPLE)_getPrivateProcAddress("glTexStorage3DMultisample");
    if (!_ptr) {
        _ptr = &_fail_glTexStorage3DMultisample;
    }
    _glTexStorage3DMultisample = _ptr;
    _glTexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
}

PFN_GLTEXSTORAGE3DMULTISAMPLE _glTexStorage3DMultisample = &_get_glTexStorage3DMultisample;

static void APIENTRY _fail_glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) {
    const char *_name = "glTextureView";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) {
    PFN_GLTEXTUREVIEW _ptr;
    _ptr = (PFN_GLTEXTUREVIEW)_getPrivateProcAddress("glTextureView");
    if (!_ptr) {
        _ptr = &_fail_glTextureView;
    }
    _glTextureView = _ptr;
    _glTextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
}

PFN_GLTEXTUREVIEW _glTextureView = &_get_glTextureView;

static void APIENTRY _fail_glQueryCounter(GLuint id, GLenum target) {
    const char *_name = "glQueryCounter";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glQueryCounter(GLuint id, GLenum target) {
    PFN_GLQUERYCOUNTER _ptr;
    _ptr = (PFN_GLQUERYCOUNTER)_getPrivateProcAddress("glQueryCounter");
    if (!_ptr) {
        _ptr = &_fail_glQueryCounter;
    }
    _glQueryCounter = _ptr;
    _glQueryCounter(id, target);
}

PFN_GLQUERYCOUNTER _glQueryCounter = &_get_glQueryCounter;

static void APIENTRY _fail_glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 * params) {
    const char *_name = "glGetQueryObjecti64v";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 * params) {
    PFN_GLGETQUERYOBJECTI64V _ptr;
    _ptr = (PFN_GLGETQUERYOBJECTI64V)_getPrivateProcAddress("glGetQueryObjecti64v");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryObjecti64v;
    }
    _glGetQueryObjecti64v = _ptr;
    _glGetQueryObjecti64v(id, pname, params);
}

PFN_GLGETQUERYOBJECTI64V _glGetQueryObjecti64v = &_get_glGetQueryObjecti64v;

static void APIENTRY _fail_glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 * params) {
    const char *_name = "glGetQueryObjectui64v";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 * params) {
    PFN_GLGETQUERYOBJECTUI64V _ptr;
    _ptr = (PFN_GLGETQUERYOBJECTUI64V)_getPrivateProcAddress("glGetQueryObjectui64v");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryObjectui64v;
    }
    _glGetQueryObjectui64v = _ptr;
    _glGetQueryObjectui64v(id, pname, params);
}

PFN_GLGETQUERYOBJECTUI64V _glGetQueryObjectui64v = &_get_glGetQueryObjectui64v;

static void APIENTRY _fail_glBindTransformFeedback(GLenum target, GLuint id) {
    const char *_name = "glBindTransformFeedback";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindTransformFeedback(GLenum target, GLuint id) {
    PFN_GLBINDTRANSFORMFEEDBACK _ptr;
    _ptr = (PFN_GLBINDTRANSFORMFEEDBACK)_getPrivateProcAddress("glBindTransformFeedback");
    if (!_ptr) {
        _ptr = &_fail_glBindTransformFeedback;
    }
    _glBindTransformFeedback = _ptr;
    _glBindTransformFeedback(target, id);
}

PFN_GLBINDTRANSFORMFEEDBACK _glBindTransformFeedback = &_get_glBindTransformFeedback;

static void APIENTRY _fail_glDeleteTransformFeedbacks(GLsizei n, const GLuint * ids) {
    const char *_name = "glDeleteTransformFeedbacks";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteTransformFeedbacks(GLsizei n, const GLuint * ids) {
    PFN_GLDELETETRANSFORMFEEDBACKS _ptr;
    _ptr = (PFN_GLDELETETRANSFORMFEEDBACKS)_getPrivateProcAddress("glDeleteTransformFeedbacks");
    if (!_ptr) {
        _ptr = &_fail_glDeleteTransformFeedbacks;
    }
    _glDeleteTransformFeedbacks = _ptr;
    _glDeleteTransformFeedbacks(n, ids);
}

PFN_GLDELETETRANSFORMFEEDBACKS _glDeleteTransformFeedbacks = &_get_glDeleteTransformFeedbacks;

static void APIENTRY _fail_glGenTransformFeedbacks(GLsizei n, GLuint * ids) {
    const char *_name = "glGenTransformFeedbacks";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenTransformFeedbacks(GLsizei n, GLuint * ids) {
    PFN_GLGENTRANSFORMFEEDBACKS _ptr;
    _ptr = (PFN_GLGENTRANSFORMFEEDBACKS)_getPrivateProcAddress("glGenTransformFeedbacks");
    if (!_ptr) {
        _ptr = &_fail_glGenTransformFeedbacks;
    }
    _glGenTransformFeedbacks = _ptr;
    _glGenTransformFeedbacks(n, ids);
}

PFN_GLGENTRANSFORMFEEDBACKS _glGenTransformFeedbacks = &_get_glGenTransformFeedbacks;

static GLboolean APIENTRY _fail_glIsTransformFeedback(GLuint id) {
    const char *_name = "glIsTransformFeedback";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsTransformFeedback(GLuint id) {
    PFN_GLISTRANSFORMFEEDBACK _ptr;
    _ptr = (PFN_GLISTRANSFORMFEEDBACK)_getPrivateProcAddress("glIsTransformFeedback");
    if (!_ptr) {
        _ptr = &_fail_glIsTransformFeedback;
    }
    _glIsTransformFeedback = _ptr;
    return _glIsTransformFeedback(id);
}

PFN_GLISTRANSFORMFEEDBACK _glIsTransformFeedback = &_get_glIsTransformFeedback;

static void APIENTRY _fail_glPauseTransformFeedback(void) {
    const char *_name = "glPauseTransformFeedback";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPauseTransformFeedback(void) {
    PFN_GLPAUSETRANSFORMFEEDBACK _ptr;
    _ptr = (PFN_GLPAUSETRANSFORMFEEDBACK)_getPrivateProcAddress("glPauseTransformFeedback");
    if (!_ptr) {
        _ptr = &_fail_glPauseTransformFeedback;
    }
    _glPauseTransformFeedback = _ptr;
    _glPauseTransformFeedback();
}

PFN_GLPAUSETRANSFORMFEEDBACK _glPauseTransformFeedback = &_get_glPauseTransformFeedback;

static void APIENTRY _fail_glResumeTransformFeedback(void) {
    const char *_name = "glResumeTransformFeedback";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glResumeTransformFeedback(void) {
    PFN_GLRESUMETRANSFORMFEEDBACK _ptr;
    _ptr = (PFN_GLRESUMETRANSFORMFEEDBACK)_getPrivateProcAddress("glResumeTransformFeedback");
    if (!_ptr) {
        _ptr = &_fail_glResumeTransformFeedback;
    }
    _glResumeTransformFeedback = _ptr;
    _glResumeTransformFeedback();
}

PFN_GLRESUMETRANSFORMFEEDBACK _glResumeTransformFeedback = &_get_glResumeTransformFeedback;

static void APIENTRY _fail_glDrawTransformFeedback(GLenum mode, GLuint id) {
    const char *_name = "glDrawTransformFeedback";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawTransformFeedback(GLenum mode, GLuint id) {
    PFN_GLDRAWTRANSFORMFEEDBACK _ptr;
    _ptr = (PFN_GLDRAWTRANSFORMFEEDBACK)_getPrivateProcAddress("glDrawTransformFeedback");
    if (!_ptr) {
        _ptr = &_fail_glDrawTransformFeedback;
    }
    _glDrawTransformFeedback = _ptr;
    _glDrawTransformFeedback(mode, id);
}

PFN_GLDRAWTRANSFORMFEEDBACK _glDrawTransformFeedback = &_get_glDrawTransformFeedback;

static void APIENTRY _fail_glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream) {
    const char *_name = "glDrawTransformFeedbackStream";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream) {
    PFN_GLDRAWTRANSFORMFEEDBACKSTREAM _ptr;
    _ptr = (PFN_GLDRAWTRANSFORMFEEDBACKSTREAM)_getPrivateProcAddress("glDrawTransformFeedbackStream");
    if (!_ptr) {
        _ptr = &_fail_glDrawTransformFeedbackStream;
    }
    _glDrawTransformFeedbackStream = _ptr;
    _glDrawTransformFeedbackStream(mode, id, stream);
}

PFN_GLDRAWTRANSFORMFEEDBACKSTREAM _glDrawTransformFeedbackStream = &_get_glDrawTransformFeedbackStream;

static void APIENTRY _fail_glBeginQueryIndexed(GLenum target, GLuint index, GLuint id) {
    const char *_name = "glBeginQueryIndexed";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBeginQueryIndexed(GLenum target, GLuint index, GLuint id) {
    PFN_GLBEGINQUERYINDEXED _ptr;
    _ptr = (PFN_GLBEGINQUERYINDEXED)_getPrivateProcAddress("glBeginQueryIndexed");
    if (!_ptr) {
        _ptr = &_fail_glBeginQueryIndexed;
    }
    _glBeginQueryIndexed = _ptr;
    _glBeginQueryIndexed(target, index, id);
}

PFN_GLBEGINQUERYINDEXED _glBeginQueryIndexed = &_get_glBeginQueryIndexed;

static void APIENTRY _fail_glEndQueryIndexed(GLenum target, GLuint index) {
    const char *_name = "glEndQueryIndexed";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEndQueryIndexed(GLenum target, GLuint index) {
    PFN_GLENDQUERYINDEXED _ptr;
    _ptr = (PFN_GLENDQUERYINDEXED)_getPrivateProcAddress("glEndQueryIndexed");
    if (!_ptr) {
        _ptr = &_fail_glEndQueryIndexed;
    }
    _glEndQueryIndexed = _ptr;
    _glEndQueryIndexed(target, index);
}

PFN_GLENDQUERYINDEXED _glEndQueryIndexed = &_get_glEndQueryIndexed;

static void APIENTRY _fail_glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint * params) {
    const char *_name = "glGetQueryIndexediv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint * params) {
    PFN_GLGETQUERYINDEXEDIV _ptr;
    _ptr = (PFN_GLGETQUERYINDEXEDIV)_getPrivateProcAddress("glGetQueryIndexediv");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryIndexediv;
    }
    _glGetQueryIndexediv = _ptr;
    _glGetQueryIndexediv(target, index, pname, params);
}

PFN_GLGETQUERYINDEXEDIV _glGetQueryIndexediv = &_get_glGetQueryIndexediv;

static void APIENTRY _fail_glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei primcount) {
    const char *_name = "glDrawTransformFeedbackInstanced";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei primcount) {
    PFN_GLDRAWTRANSFORMFEEDBACKINSTANCED _ptr;
    _ptr = (PFN_GLDRAWTRANSFORMFEEDBACKINSTANCED)_getPrivateProcAddress("glDrawTransformFeedbackInstanced");
    if (!_ptr) {
        _ptr = &_fail_glDrawTransformFeedbackInstanced;
    }
    _glDrawTransformFeedbackInstanced = _ptr;
    _glDrawTransformFeedbackInstanced(mode, id, primcount);
}

PFN_GLDRAWTRANSFORMFEEDBACKINSTANCED _glDrawTransformFeedbackInstanced = &_get_glDrawTransformFeedbackInstanced;

static void APIENTRY _fail_glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei primcount) {
    const char *_name = "glDrawTransformFeedbackStreamInstanced";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei primcount) {
    PFN_GLDRAWTRANSFORMFEEDBACKSTREAMINSTANCED _ptr;
    _ptr = (PFN_GLDRAWTRANSFORMFEEDBACKSTREAMINSTANCED)_getPrivateProcAddress("glDrawTransformFeedbackStreamInstanced");
    if (!_ptr) {
        _ptr = &_fail_glDrawTransformFeedbackStreamInstanced;
    }
    _glDrawTransformFeedbackStreamInstanced = _ptr;
    _glDrawTransformFeedbackStreamInstanced(mode, id, stream, primcount);
}

PFN_GLDRAWTRANSFORMFEEDBACKSTREAMINSTANCED _glDrawTransformFeedbackStreamInstanced = &_get_glDrawTransformFeedbackStreamInstanced;

static void APIENTRY _fail_glLoadTransposeMatrixfARB(const GLfloat * m) {
    const char *_name = "glLoadTransposeMatrixfARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLoadTransposeMatrixfARB(const GLfloat * m) {
    PFN_GLLOADTRANSPOSEMATRIXFARB _ptr;
    _ptr = (PFN_GLLOADTRANSPOSEMATRIXFARB)_getPrivateProcAddress("glLoadTransposeMatrixfARB");
    if (!_ptr) {
        _ptr = &_fail_glLoadTransposeMatrixfARB;
    }
    _glLoadTransposeMatrixfARB = _ptr;
    _glLoadTransposeMatrixfARB(m);
}

PFN_GLLOADTRANSPOSEMATRIXFARB _glLoadTransposeMatrixfARB = &_get_glLoadTransposeMatrixfARB;

static void APIENTRY _fail_glLoadTransposeMatrixdARB(const GLdouble * m) {
    const char *_name = "glLoadTransposeMatrixdARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLoadTransposeMatrixdARB(const GLdouble * m) {
    PFN_GLLOADTRANSPOSEMATRIXDARB _ptr;
    _ptr = (PFN_GLLOADTRANSPOSEMATRIXDARB)_getPrivateProcAddress("glLoadTransposeMatrixdARB");
    if (!_ptr) {
        _ptr = &_fail_glLoadTransposeMatrixdARB;
    }
    _glLoadTransposeMatrixdARB = _ptr;
    _glLoadTransposeMatrixdARB(m);
}

PFN_GLLOADTRANSPOSEMATRIXDARB _glLoadTransposeMatrixdARB = &_get_glLoadTransposeMatrixdARB;

static void APIENTRY _fail_glMultTransposeMatrixfARB(const GLfloat * m) {
    const char *_name = "glMultTransposeMatrixfARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultTransposeMatrixfARB(const GLfloat * m) {
    PFN_GLMULTTRANSPOSEMATRIXFARB _ptr;
    _ptr = (PFN_GLMULTTRANSPOSEMATRIXFARB)_getPrivateProcAddress("glMultTransposeMatrixfARB");
    if (!_ptr) {
        _ptr = &_fail_glMultTransposeMatrixfARB;
    }
    _glMultTransposeMatrixfARB = _ptr;
    _glMultTransposeMatrixfARB(m);
}

PFN_GLMULTTRANSPOSEMATRIXFARB _glMultTransposeMatrixfARB = &_get_glMultTransposeMatrixfARB;

static void APIENTRY _fail_glMultTransposeMatrixdARB(const GLdouble * m) {
    const char *_name = "glMultTransposeMatrixdARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultTransposeMatrixdARB(const GLdouble * m) {
    PFN_GLMULTTRANSPOSEMATRIXDARB _ptr;
    _ptr = (PFN_GLMULTTRANSPOSEMATRIXDARB)_getPrivateProcAddress("glMultTransposeMatrixdARB");
    if (!_ptr) {
        _ptr = &_fail_glMultTransposeMatrixdARB;
    }
    _glMultTransposeMatrixdARB = _ptr;
    _glMultTransposeMatrixdARB(m);
}

PFN_GLMULTTRANSPOSEMATRIXDARB _glMultTransposeMatrixdARB = &_get_glMultTransposeMatrixdARB;

static void APIENTRY _fail_glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar * const * uniformNames, GLuint * uniformIndices) {
    const char *_name = "glGetUniformIndices";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar * const * uniformNames, GLuint * uniformIndices) {
    PFN_GLGETUNIFORMINDICES _ptr;
    _ptr = (PFN_GLGETUNIFORMINDICES)_getPrivateProcAddress("glGetUniformIndices");
    if (!_ptr) {
        _ptr = &_fail_glGetUniformIndices;
    }
    _glGetUniformIndices = _ptr;
    _glGetUniformIndices(program, uniformCount, uniformNames, uniformIndices);
}

PFN_GLGETUNIFORMINDICES _glGetUniformIndices = &_get_glGetUniformIndices;

static void APIENTRY _fail_glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params) {
    const char *_name = "glGetActiveUniformsiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params) {
    PFN_GLGETACTIVEUNIFORMSIV _ptr;
    _ptr = (PFN_GLGETACTIVEUNIFORMSIV)_getPrivateProcAddress("glGetActiveUniformsiv");
    if (!_ptr) {
        _ptr = &_fail_glGetActiveUniformsiv;
    }
    _glGetActiveUniformsiv = _ptr;
    _glGetActiveUniformsiv(program, uniformCount, uniformIndices, pname, params);
}

PFN_GLGETACTIVEUNIFORMSIV _glGetActiveUniformsiv = &_get_glGetActiveUniformsiv;

static void APIENTRY _fail_glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName) {
    const char *_name = "glGetActiveUniformName";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName) {
    PFN_GLGETACTIVEUNIFORMNAME _ptr;
    _ptr = (PFN_GLGETACTIVEUNIFORMNAME)_getPrivateProcAddress("glGetActiveUniformName");
    if (!_ptr) {
        _ptr = &_fail_glGetActiveUniformName;
    }
    _glGetActiveUniformName = _ptr;
    _glGetActiveUniformName(program, uniformIndex, bufSize, length, uniformName);
}

PFN_GLGETACTIVEUNIFORMNAME _glGetActiveUniformName = &_get_glGetActiveUniformName;

static GLuint APIENTRY _fail_glGetUniformBlockIndex(GLuint program, const GLchar * uniformBlockName) {
    const char *_name = "glGetUniformBlockIndex";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glGetUniformBlockIndex(GLuint program, const GLchar * uniformBlockName) {
    PFN_GLGETUNIFORMBLOCKINDEX _ptr;
    _ptr = (PFN_GLGETUNIFORMBLOCKINDEX)_getPrivateProcAddress("glGetUniformBlockIndex");
    if (!_ptr) {
        _ptr = &_fail_glGetUniformBlockIndex;
    }
    _glGetUniformBlockIndex = _ptr;
    return _glGetUniformBlockIndex(program, uniformBlockName);
}

PFN_GLGETUNIFORMBLOCKINDEX _glGetUniformBlockIndex = &_get_glGetUniformBlockIndex;

static void APIENTRY _fail_glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params) {
    const char *_name = "glGetActiveUniformBlockiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params) {
    PFN_GLGETACTIVEUNIFORMBLOCKIV _ptr;
    _ptr = (PFN_GLGETACTIVEUNIFORMBLOCKIV)_getPrivateProcAddress("glGetActiveUniformBlockiv");
    if (!_ptr) {
        _ptr = &_fail_glGetActiveUniformBlockiv;
    }
    _glGetActiveUniformBlockiv = _ptr;
    _glGetActiveUniformBlockiv(program, uniformBlockIndex, pname, params);
}

PFN_GLGETACTIVEUNIFORMBLOCKIV _glGetActiveUniformBlockiv = &_get_glGetActiveUniformBlockiv;

static void APIENTRY _fail_glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName) {
    const char *_name = "glGetActiveUniformBlockName";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName) {
    PFN_GLGETACTIVEUNIFORMBLOCKNAME _ptr;
    _ptr = (PFN_GLGETACTIVEUNIFORMBLOCKNAME)_getPrivateProcAddress("glGetActiveUniformBlockName");
    if (!_ptr) {
        _ptr = &_fail_glGetActiveUniformBlockName;
    }
    _glGetActiveUniformBlockName = _ptr;
    _glGetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName);
}

PFN_GLGETACTIVEUNIFORMBLOCKNAME _glGetActiveUniformBlockName = &_get_glGetActiveUniformBlockName;

static void APIENTRY _fail_glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding) {
    const char *_name = "glUniformBlockBinding";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding) {
    PFN_GLUNIFORMBLOCKBINDING _ptr;
    _ptr = (PFN_GLUNIFORMBLOCKBINDING)_getPrivateProcAddress("glUniformBlockBinding");
    if (!_ptr) {
        _ptr = &_fail_glUniformBlockBinding;
    }
    _glUniformBlockBinding = _ptr;
    _glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
}

PFN_GLUNIFORMBLOCKBINDING _glUniformBlockBinding = &_get_glUniformBlockBinding;

static void APIENTRY _fail_glBindVertexArray(GLuint array) {
    const char *_name = "glBindVertexArray";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindVertexArray(GLuint array) {
    PFN_GLBINDVERTEXARRAY _ptr;
    _ptr = (PFN_GLBINDVERTEXARRAY)_getPrivateProcAddress("glBindVertexArray");
    if (!_ptr) {
        _ptr = &_fail_glBindVertexArray;
    }
    _glBindVertexArray = _ptr;
    _glBindVertexArray(array);
}

PFN_GLBINDVERTEXARRAY _glBindVertexArray = &_get_glBindVertexArray;

static void APIENTRY _fail_glDeleteVertexArrays(GLsizei n, const GLuint * arrays) {
    const char *_name = "glDeleteVertexArrays";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteVertexArrays(GLsizei n, const GLuint * arrays) {
    PFN_GLDELETEVERTEXARRAYS _ptr;
    _ptr = (PFN_GLDELETEVERTEXARRAYS)_getPrivateProcAddress("glDeleteVertexArrays");
    if (!_ptr) {
        _ptr = &_fail_glDeleteVertexArrays;
    }
    _glDeleteVertexArrays = _ptr;
    _glDeleteVertexArrays(n, arrays);
}

PFN_GLDELETEVERTEXARRAYS _glDeleteVertexArrays = &_get_glDeleteVertexArrays;

static void APIENTRY _fail_glGenVertexArrays(GLsizei n, GLuint * arrays) {
    const char *_name = "glGenVertexArrays";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenVertexArrays(GLsizei n, GLuint * arrays) {
    PFN_GLGENVERTEXARRAYS _ptr;
    _ptr = (PFN_GLGENVERTEXARRAYS)_getPrivateProcAddress("glGenVertexArrays");
    if (!_ptr) {
        _ptr = &_fail_glGenVertexArrays;
    }
    _glGenVertexArrays = _ptr;
    _glGenVertexArrays(n, arrays);
}

PFN_GLGENVERTEXARRAYS _glGenVertexArrays = &_get_glGenVertexArrays;

static GLboolean APIENTRY _fail_glIsVertexArray(GLuint array) {
    const char *_name = "glIsVertexArray";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsVertexArray(GLuint array) {
    PFN_GLISVERTEXARRAY _ptr;
    _ptr = (PFN_GLISVERTEXARRAY)_getPrivateProcAddress("glIsVertexArray");
    if (!_ptr) {
        _ptr = &_fail_glIsVertexArray;
    }
    _glIsVertexArray = _ptr;
    return _glIsVertexArray(array);
}

PFN_GLISVERTEXARRAY _glIsVertexArray = &_get_glIsVertexArray;

static void APIENTRY _fail_glVertexAttribL1d(GLuint index, GLdouble x) {
    const char *_name = "glVertexAttribL1d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL1d(GLuint index, GLdouble x) {
    PFN_GLVERTEXATTRIBL1D _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL1D)_getPrivateProcAddress("glVertexAttribL1d");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL1d;
    }
    _glVertexAttribL1d = _ptr;
    _glVertexAttribL1d(index, x);
}

PFN_GLVERTEXATTRIBL1D _glVertexAttribL1d = &_get_glVertexAttribL1d;

static void APIENTRY _fail_glVertexAttribL2d(GLuint index, GLdouble x, GLdouble y) {
    const char *_name = "glVertexAttribL2d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL2d(GLuint index, GLdouble x, GLdouble y) {
    PFN_GLVERTEXATTRIBL2D _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL2D)_getPrivateProcAddress("glVertexAttribL2d");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL2d;
    }
    _glVertexAttribL2d = _ptr;
    _glVertexAttribL2d(index, x, y);
}

PFN_GLVERTEXATTRIBL2D _glVertexAttribL2d = &_get_glVertexAttribL2d;

static void APIENTRY _fail_glVertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glVertexAttribL3d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLVERTEXATTRIBL3D _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL3D)_getPrivateProcAddress("glVertexAttribL3d");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL3d;
    }
    _glVertexAttribL3d = _ptr;
    _glVertexAttribL3d(index, x, y, z);
}

PFN_GLVERTEXATTRIBL3D _glVertexAttribL3d = &_get_glVertexAttribL3d;

static void APIENTRY _fail_glVertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glVertexAttribL4d";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    PFN_GLVERTEXATTRIBL4D _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL4D)_getPrivateProcAddress("glVertexAttribL4d");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL4d;
    }
    _glVertexAttribL4d = _ptr;
    _glVertexAttribL4d(index, x, y, z, w);
}

PFN_GLVERTEXATTRIBL4D _glVertexAttribL4d = &_get_glVertexAttribL4d;

static void APIENTRY _fail_glVertexAttribL1dv(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttribL1dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL1dv(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIBL1DV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL1DV)_getPrivateProcAddress("glVertexAttribL1dv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL1dv;
    }
    _glVertexAttribL1dv = _ptr;
    _glVertexAttribL1dv(index, v);
}

PFN_GLVERTEXATTRIBL1DV _glVertexAttribL1dv = &_get_glVertexAttribL1dv;

static void APIENTRY _fail_glVertexAttribL2dv(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttribL2dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL2dv(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIBL2DV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL2DV)_getPrivateProcAddress("glVertexAttribL2dv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL2dv;
    }
    _glVertexAttribL2dv = _ptr;
    _glVertexAttribL2dv(index, v);
}

PFN_GLVERTEXATTRIBL2DV _glVertexAttribL2dv = &_get_glVertexAttribL2dv;

static void APIENTRY _fail_glVertexAttribL3dv(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttribL3dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL3dv(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIBL3DV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL3DV)_getPrivateProcAddress("glVertexAttribL3dv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL3dv;
    }
    _glVertexAttribL3dv = _ptr;
    _glVertexAttribL3dv(index, v);
}

PFN_GLVERTEXATTRIBL3DV _glVertexAttribL3dv = &_get_glVertexAttribL3dv;

static void APIENTRY _fail_glVertexAttribL4dv(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttribL4dv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL4dv(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIBL4DV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL4DV)_getPrivateProcAddress("glVertexAttribL4dv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL4dv;
    }
    _glVertexAttribL4dv = _ptr;
    _glVertexAttribL4dv(index, v);
}

PFN_GLVERTEXATTRIBL4DV _glVertexAttribL4dv = &_get_glVertexAttribL4dv;

static void APIENTRY _fail_glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glVertexAttribLPointer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLVERTEXATTRIBLPOINTER _ptr;
    _ptr = (PFN_GLVERTEXATTRIBLPOINTER)_getPrivateProcAddress("glVertexAttribLPointer");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribLPointer;
    }
    _glVertexAttribLPointer = _ptr;
    _glVertexAttribLPointer(index, size, type, stride, pointer);
}

PFN_GLVERTEXATTRIBLPOINTER _glVertexAttribLPointer = &_get_glVertexAttribLPointer;

static void APIENTRY _fail_glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble * params) {
    const char *_name = "glGetVertexAttribLdv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble * params) {
    PFN_GLGETVERTEXATTRIBLDV _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBLDV)_getPrivateProcAddress("glGetVertexAttribLdv");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribLdv;
    }
    _glGetVertexAttribLdv = _ptr;
    _glGetVertexAttribLdv(index, pname, params);
}

PFN_GLGETVERTEXATTRIBLDV _glGetVertexAttribLdv = &_get_glGetVertexAttribLdv;

static void APIENTRY _fail_glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) {
    const char *_name = "glBindVertexBuffer";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) {
    PFN_GLBINDVERTEXBUFFER _ptr;
    _ptr = (PFN_GLBINDVERTEXBUFFER)_getPrivateProcAddress("glBindVertexBuffer");
    if (!_ptr) {
        _ptr = &_fail_glBindVertexBuffer;
    }
    _glBindVertexBuffer = _ptr;
    _glBindVertexBuffer(bindingindex, buffer, offset, stride);
}

PFN_GLBINDVERTEXBUFFER _glBindVertexBuffer = &_get_glBindVertexBuffer;

static void APIENTRY _fail_glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) {
    const char *_name = "glVertexAttribFormat";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) {
    PFN_GLVERTEXATTRIBFORMAT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBFORMAT)_getPrivateProcAddress("glVertexAttribFormat");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribFormat;
    }
    _glVertexAttribFormat = _ptr;
    _glVertexAttribFormat(attribindex, size, type, normalized, relativeoffset);
}

PFN_GLVERTEXATTRIBFORMAT _glVertexAttribFormat = &_get_glVertexAttribFormat;

static void APIENTRY _fail_glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
    const char *_name = "glVertexAttribIFormat";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
    PFN_GLVERTEXATTRIBIFORMAT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBIFORMAT)_getPrivateProcAddress("glVertexAttribIFormat");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribIFormat;
    }
    _glVertexAttribIFormat = _ptr;
    _glVertexAttribIFormat(attribindex, size, type, relativeoffset);
}

PFN_GLVERTEXATTRIBIFORMAT _glVertexAttribIFormat = &_get_glVertexAttribIFormat;

static void APIENTRY _fail_glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
    const char *_name = "glVertexAttribLFormat";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
    PFN_GLVERTEXATTRIBLFORMAT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBLFORMAT)_getPrivateProcAddress("glVertexAttribLFormat");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribLFormat;
    }
    _glVertexAttribLFormat = _ptr;
    _glVertexAttribLFormat(attribindex, size, type, relativeoffset);
}

PFN_GLVERTEXATTRIBLFORMAT _glVertexAttribLFormat = &_get_glVertexAttribLFormat;

static void APIENTRY _fail_glVertexAttribBinding(GLuint attribindex, GLuint bindingindex) {
    const char *_name = "glVertexAttribBinding";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribBinding(GLuint attribindex, GLuint bindingindex) {
    PFN_GLVERTEXATTRIBBINDING _ptr;
    _ptr = (PFN_GLVERTEXATTRIBBINDING)_getPrivateProcAddress("glVertexAttribBinding");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribBinding;
    }
    _glVertexAttribBinding = _ptr;
    _glVertexAttribBinding(attribindex, bindingindex);
}

PFN_GLVERTEXATTRIBBINDING _glVertexAttribBinding = &_get_glVertexAttribBinding;

static void APIENTRY _fail_glVertexBindingDivisor(GLuint bindingindex, GLuint divisor) {
    const char *_name = "glVertexBindingDivisor";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexBindingDivisor(GLuint bindingindex, GLuint divisor) {
    PFN_GLVERTEXBINDINGDIVISOR _ptr;
    _ptr = (PFN_GLVERTEXBINDINGDIVISOR)_getPrivateProcAddress("glVertexBindingDivisor");
    if (!_ptr) {
        _ptr = &_fail_glVertexBindingDivisor;
    }
    _glVertexBindingDivisor = _ptr;
    _glVertexBindingDivisor(bindingindex, divisor);
}

PFN_GLVERTEXBINDINGDIVISOR _glVertexBindingDivisor = &_get_glVertexBindingDivisor;

static void APIENTRY _fail_glWeightbvARB(GLint size, const GLbyte * weights) {
    const char *_name = "glWeightbvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWeightbvARB(GLint size, const GLbyte * weights) {
    PFN_GLWEIGHTBVARB _ptr;
    _ptr = (PFN_GLWEIGHTBVARB)_getPrivateProcAddress("glWeightbvARB");
    if (!_ptr) {
        _ptr = &_fail_glWeightbvARB;
    }
    _glWeightbvARB = _ptr;
    _glWeightbvARB(size, weights);
}

PFN_GLWEIGHTBVARB _glWeightbvARB = &_get_glWeightbvARB;

static void APIENTRY _fail_glWeightsvARB(GLint size, const GLshort * weights) {
    const char *_name = "glWeightsvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWeightsvARB(GLint size, const GLshort * weights) {
    PFN_GLWEIGHTSVARB _ptr;
    _ptr = (PFN_GLWEIGHTSVARB)_getPrivateProcAddress("glWeightsvARB");
    if (!_ptr) {
        _ptr = &_fail_glWeightsvARB;
    }
    _glWeightsvARB = _ptr;
    _glWeightsvARB(size, weights);
}

PFN_GLWEIGHTSVARB _glWeightsvARB = &_get_glWeightsvARB;

static void APIENTRY _fail_glWeightivARB(GLint size, const GLint * weights) {
    const char *_name = "glWeightivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWeightivARB(GLint size, const GLint * weights) {
    PFN_GLWEIGHTIVARB _ptr;
    _ptr = (PFN_GLWEIGHTIVARB)_getPrivateProcAddress("glWeightivARB");
    if (!_ptr) {
        _ptr = &_fail_glWeightivARB;
    }
    _glWeightivARB = _ptr;
    _glWeightivARB(size, weights);
}

PFN_GLWEIGHTIVARB _glWeightivARB = &_get_glWeightivARB;

static void APIENTRY _fail_glWeightfvARB(GLint size, const GLfloat * weights) {
    const char *_name = "glWeightfvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWeightfvARB(GLint size, const GLfloat * weights) {
    PFN_GLWEIGHTFVARB _ptr;
    _ptr = (PFN_GLWEIGHTFVARB)_getPrivateProcAddress("glWeightfvARB");
    if (!_ptr) {
        _ptr = &_fail_glWeightfvARB;
    }
    _glWeightfvARB = _ptr;
    _glWeightfvARB(size, weights);
}

PFN_GLWEIGHTFVARB _glWeightfvARB = &_get_glWeightfvARB;

static void APIENTRY _fail_glWeightdvARB(GLint size, const GLdouble * weights) {
    const char *_name = "glWeightdvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWeightdvARB(GLint size, const GLdouble * weights) {
    PFN_GLWEIGHTDVARB _ptr;
    _ptr = (PFN_GLWEIGHTDVARB)_getPrivateProcAddress("glWeightdvARB");
    if (!_ptr) {
        _ptr = &_fail_glWeightdvARB;
    }
    _glWeightdvARB = _ptr;
    _glWeightdvARB(size, weights);
}

PFN_GLWEIGHTDVARB _glWeightdvARB = &_get_glWeightdvARB;

static void APIENTRY _fail_glWeightubvARB(GLint size, const GLubyte * weights) {
    const char *_name = "glWeightubvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWeightubvARB(GLint size, const GLubyte * weights) {
    PFN_GLWEIGHTUBVARB _ptr;
    _ptr = (PFN_GLWEIGHTUBVARB)_getPrivateProcAddress("glWeightubvARB");
    if (!_ptr) {
        _ptr = &_fail_glWeightubvARB;
    }
    _glWeightubvARB = _ptr;
    _glWeightubvARB(size, weights);
}

PFN_GLWEIGHTUBVARB _glWeightubvARB = &_get_glWeightubvARB;

static void APIENTRY _fail_glWeightusvARB(GLint size, const GLushort * weights) {
    const char *_name = "glWeightusvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWeightusvARB(GLint size, const GLushort * weights) {
    PFN_GLWEIGHTUSVARB _ptr;
    _ptr = (PFN_GLWEIGHTUSVARB)_getPrivateProcAddress("glWeightusvARB");
    if (!_ptr) {
        _ptr = &_fail_glWeightusvARB;
    }
    _glWeightusvARB = _ptr;
    _glWeightusvARB(size, weights);
}

PFN_GLWEIGHTUSVARB _glWeightusvARB = &_get_glWeightusvARB;

static void APIENTRY _fail_glWeightuivARB(GLint size, const GLuint * weights) {
    const char *_name = "glWeightuivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWeightuivARB(GLint size, const GLuint * weights) {
    PFN_GLWEIGHTUIVARB _ptr;
    _ptr = (PFN_GLWEIGHTUIVARB)_getPrivateProcAddress("glWeightuivARB");
    if (!_ptr) {
        _ptr = &_fail_glWeightuivARB;
    }
    _glWeightuivARB = _ptr;
    _glWeightuivARB(size, weights);
}

PFN_GLWEIGHTUIVARB _glWeightuivARB = &_get_glWeightuivARB;

static void APIENTRY _fail_glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glWeightPointerARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLWEIGHTPOINTERARB _ptr;
    _ptr = (PFN_GLWEIGHTPOINTERARB)_getPrivateProcAddress("glWeightPointerARB");
    if (!_ptr) {
        _ptr = &_fail_glWeightPointerARB;
    }
    _glWeightPointerARB = _ptr;
    _glWeightPointerARB(size, type, stride, pointer);
}

PFN_GLWEIGHTPOINTERARB _glWeightPointerARB = &_get_glWeightPointerARB;

static void APIENTRY _fail_glVertexBlendARB(GLint count) {
    const char *_name = "glVertexBlendARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexBlendARB(GLint count) {
    PFN_GLVERTEXBLENDARB _ptr;
    _ptr = (PFN_GLVERTEXBLENDARB)_getPrivateProcAddress("glVertexBlendARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexBlendARB;
    }
    _glVertexBlendARB = _ptr;
    _glVertexBlendARB(count);
}

PFN_GLVERTEXBLENDARB _glVertexBlendARB = &_get_glVertexBlendARB;

static void APIENTRY _fail_glBindBufferARB(GLenum target, GLuint buffer) {
    const char *_name = "glBindBufferARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindBufferARB(GLenum target, GLuint buffer) {
    PFN_GLBINDBUFFERARB _ptr;
    _ptr = (PFN_GLBINDBUFFERARB)_getPrivateProcAddress("glBindBufferARB");
    if (!_ptr) {
        _ptr = &_fail_glBindBufferARB;
    }
    _glBindBufferARB = _ptr;
    _glBindBufferARB(target, buffer);
}

PFN_GLBINDBUFFERARB _glBindBufferARB = &_get_glBindBufferARB;

static void APIENTRY _fail_glDeleteBuffersARB(GLsizei n, const GLuint * buffers) {
    const char *_name = "glDeleteBuffersARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteBuffersARB(GLsizei n, const GLuint * buffers) {
    PFN_GLDELETEBUFFERSARB _ptr;
    _ptr = (PFN_GLDELETEBUFFERSARB)_getPrivateProcAddress("glDeleteBuffersARB");
    if (!_ptr) {
        _ptr = &_fail_glDeleteBuffersARB;
    }
    _glDeleteBuffersARB = _ptr;
    _glDeleteBuffersARB(n, buffers);
}

PFN_GLDELETEBUFFERSARB _glDeleteBuffersARB = &_get_glDeleteBuffersARB;

static void APIENTRY _fail_glGenBuffersARB(GLsizei n, GLuint * buffers) {
    const char *_name = "glGenBuffersARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenBuffersARB(GLsizei n, GLuint * buffers) {
    PFN_GLGENBUFFERSARB _ptr;
    _ptr = (PFN_GLGENBUFFERSARB)_getPrivateProcAddress("glGenBuffersARB");
    if (!_ptr) {
        _ptr = &_fail_glGenBuffersARB;
    }
    _glGenBuffersARB = _ptr;
    _glGenBuffersARB(n, buffers);
}

PFN_GLGENBUFFERSARB _glGenBuffersARB = &_get_glGenBuffersARB;

static GLboolean APIENTRY _fail_glIsBufferARB(GLuint buffer) {
    const char *_name = "glIsBufferARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsBufferARB(GLuint buffer) {
    PFN_GLISBUFFERARB _ptr;
    _ptr = (PFN_GLISBUFFERARB)_getPrivateProcAddress("glIsBufferARB");
    if (!_ptr) {
        _ptr = &_fail_glIsBufferARB;
    }
    _glIsBufferARB = _ptr;
    return _glIsBufferARB(buffer);
}

PFN_GLISBUFFERARB _glIsBufferARB = &_get_glIsBufferARB;

static void APIENTRY _fail_glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid * data, GLenum usage) {
    const char *_name = "glBufferDataARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid * data, GLenum usage) {
    PFN_GLBUFFERDATAARB _ptr;
    _ptr = (PFN_GLBUFFERDATAARB)_getPrivateProcAddress("glBufferDataARB");
    if (!_ptr) {
        _ptr = &_fail_glBufferDataARB;
    }
    _glBufferDataARB = _ptr;
    _glBufferDataARB(target, size, data, usage);
}

PFN_GLBUFFERDATAARB _glBufferDataARB = &_get_glBufferDataARB;

static void APIENTRY _fail_glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid * data) {
    const char *_name = "glBufferSubDataARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid * data) {
    PFN_GLBUFFERSUBDATAARB _ptr;
    _ptr = (PFN_GLBUFFERSUBDATAARB)_getPrivateProcAddress("glBufferSubDataARB");
    if (!_ptr) {
        _ptr = &_fail_glBufferSubDataARB;
    }
    _glBufferSubDataARB = _ptr;
    _glBufferSubDataARB(target, offset, size, data);
}

PFN_GLBUFFERSUBDATAARB _glBufferSubDataARB = &_get_glBufferSubDataARB;

static void APIENTRY _fail_glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid * data) {
    const char *_name = "glGetBufferSubDataARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid * data) {
    PFN_GLGETBUFFERSUBDATAARB _ptr;
    _ptr = (PFN_GLGETBUFFERSUBDATAARB)_getPrivateProcAddress("glGetBufferSubDataARB");
    if (!_ptr) {
        _ptr = &_fail_glGetBufferSubDataARB;
    }
    _glGetBufferSubDataARB = _ptr;
    _glGetBufferSubDataARB(target, offset, size, data);
}

PFN_GLGETBUFFERSUBDATAARB _glGetBufferSubDataARB = &_get_glGetBufferSubDataARB;

static GLvoid * APIENTRY _fail_glMapBufferARB(GLenum target, GLenum access) {
    const char *_name = "glMapBufferARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLvoid * APIENTRY _get_glMapBufferARB(GLenum target, GLenum access) {
    PFN_GLMAPBUFFERARB _ptr;
    _ptr = (PFN_GLMAPBUFFERARB)_getPrivateProcAddress("glMapBufferARB");
    if (!_ptr) {
        _ptr = &_fail_glMapBufferARB;
    }
    _glMapBufferARB = _ptr;
    return _glMapBufferARB(target, access);
}

PFN_GLMAPBUFFERARB _glMapBufferARB = &_get_glMapBufferARB;

static GLboolean APIENTRY _fail_glUnmapBufferARB(GLenum target) {
    const char *_name = "glUnmapBufferARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glUnmapBufferARB(GLenum target) {
    PFN_GLUNMAPBUFFERARB _ptr;
    _ptr = (PFN_GLUNMAPBUFFERARB)_getPrivateProcAddress("glUnmapBufferARB");
    if (!_ptr) {
        _ptr = &_fail_glUnmapBufferARB;
    }
    _glUnmapBufferARB = _ptr;
    return _glUnmapBufferARB(target);
}

PFN_GLUNMAPBUFFERARB _glUnmapBufferARB = &_get_glUnmapBufferARB;

static void APIENTRY _fail_glGetBufferParameterivARB(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetBufferParameterivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetBufferParameterivARB(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETBUFFERPARAMETERIVARB _ptr;
    _ptr = (PFN_GLGETBUFFERPARAMETERIVARB)_getPrivateProcAddress("glGetBufferParameterivARB");
    if (!_ptr) {
        _ptr = &_fail_glGetBufferParameterivARB;
    }
    _glGetBufferParameterivARB = _ptr;
    _glGetBufferParameterivARB(target, pname, params);
}

PFN_GLGETBUFFERPARAMETERIVARB _glGetBufferParameterivARB = &_get_glGetBufferParameterivARB;

static void APIENTRY _fail_glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid * * params) {
    const char *_name = "glGetBufferPointervARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid * * params) {
    PFN_GLGETBUFFERPOINTERVARB _ptr;
    _ptr = (PFN_GLGETBUFFERPOINTERVARB)_getPrivateProcAddress("glGetBufferPointervARB");
    if (!_ptr) {
        _ptr = &_fail_glGetBufferPointervARB;
    }
    _glGetBufferPointervARB = _ptr;
    _glGetBufferPointervARB(target, pname, params);
}

PFN_GLGETBUFFERPOINTERVARB _glGetBufferPointervARB = &_get_glGetBufferPointervARB;

static void APIENTRY _fail_glVertexAttrib1dARB(GLuint index, GLdouble x) {
    const char *_name = "glVertexAttrib1dARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1dARB(GLuint index, GLdouble x) {
    PFN_GLVERTEXATTRIB1DARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1DARB)_getPrivateProcAddress("glVertexAttrib1dARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1dARB;
    }
    _glVertexAttrib1dARB = _ptr;
    _glVertexAttrib1dARB(index, x);
}

PFN_GLVERTEXATTRIB1DARB _glVertexAttrib1dARB = &_get_glVertexAttrib1dARB;

static void APIENTRY _fail_glVertexAttrib1dvARB(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib1dvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1dvARB(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIB1DVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1DVARB)_getPrivateProcAddress("glVertexAttrib1dvARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1dvARB;
    }
    _glVertexAttrib1dvARB = _ptr;
    _glVertexAttrib1dvARB(index, v);
}

PFN_GLVERTEXATTRIB1DVARB _glVertexAttrib1dvARB = &_get_glVertexAttrib1dvARB;

static void APIENTRY _fail_glVertexAttrib1fARB(GLuint index, GLfloat x) {
    const char *_name = "glVertexAttrib1fARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1fARB(GLuint index, GLfloat x) {
    PFN_GLVERTEXATTRIB1FARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1FARB)_getPrivateProcAddress("glVertexAttrib1fARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1fARB;
    }
    _glVertexAttrib1fARB = _ptr;
    _glVertexAttrib1fARB(index, x);
}

PFN_GLVERTEXATTRIB1FARB _glVertexAttrib1fARB = &_get_glVertexAttrib1fARB;

static void APIENTRY _fail_glVertexAttrib1fvARB(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib1fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1fvARB(GLuint index, const GLfloat * v) {
    PFN_GLVERTEXATTRIB1FVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1FVARB)_getPrivateProcAddress("glVertexAttrib1fvARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1fvARB;
    }
    _glVertexAttrib1fvARB = _ptr;
    _glVertexAttrib1fvARB(index, v);
}

PFN_GLVERTEXATTRIB1FVARB _glVertexAttrib1fvARB = &_get_glVertexAttrib1fvARB;

static void APIENTRY _fail_glVertexAttrib1sARB(GLuint index, GLshort x) {
    const char *_name = "glVertexAttrib1sARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1sARB(GLuint index, GLshort x) {
    PFN_GLVERTEXATTRIB1SARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1SARB)_getPrivateProcAddress("glVertexAttrib1sARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1sARB;
    }
    _glVertexAttrib1sARB = _ptr;
    _glVertexAttrib1sARB(index, x);
}

PFN_GLVERTEXATTRIB1SARB _glVertexAttrib1sARB = &_get_glVertexAttrib1sARB;

static void APIENTRY _fail_glVertexAttrib1svARB(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib1svARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1svARB(GLuint index, const GLshort * v) {
    PFN_GLVERTEXATTRIB1SVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1SVARB)_getPrivateProcAddress("glVertexAttrib1svARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1svARB;
    }
    _glVertexAttrib1svARB = _ptr;
    _glVertexAttrib1svARB(index, v);
}

PFN_GLVERTEXATTRIB1SVARB _glVertexAttrib1svARB = &_get_glVertexAttrib1svARB;

static void APIENTRY _fail_glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y) {
    const char *_name = "glVertexAttrib2dARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y) {
    PFN_GLVERTEXATTRIB2DARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2DARB)_getPrivateProcAddress("glVertexAttrib2dARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2dARB;
    }
    _glVertexAttrib2dARB = _ptr;
    _glVertexAttrib2dARB(index, x, y);
}

PFN_GLVERTEXATTRIB2DARB _glVertexAttrib2dARB = &_get_glVertexAttrib2dARB;

static void APIENTRY _fail_glVertexAttrib2dvARB(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib2dvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2dvARB(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIB2DVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2DVARB)_getPrivateProcAddress("glVertexAttrib2dvARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2dvARB;
    }
    _glVertexAttrib2dvARB = _ptr;
    _glVertexAttrib2dvARB(index, v);
}

PFN_GLVERTEXATTRIB2DVARB _glVertexAttrib2dvARB = &_get_glVertexAttrib2dvARB;

static void APIENTRY _fail_glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y) {
    const char *_name = "glVertexAttrib2fARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y) {
    PFN_GLVERTEXATTRIB2FARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2FARB)_getPrivateProcAddress("glVertexAttrib2fARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2fARB;
    }
    _glVertexAttrib2fARB = _ptr;
    _glVertexAttrib2fARB(index, x, y);
}

PFN_GLVERTEXATTRIB2FARB _glVertexAttrib2fARB = &_get_glVertexAttrib2fARB;

static void APIENTRY _fail_glVertexAttrib2fvARB(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib2fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2fvARB(GLuint index, const GLfloat * v) {
    PFN_GLVERTEXATTRIB2FVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2FVARB)_getPrivateProcAddress("glVertexAttrib2fvARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2fvARB;
    }
    _glVertexAttrib2fvARB = _ptr;
    _glVertexAttrib2fvARB(index, v);
}

PFN_GLVERTEXATTRIB2FVARB _glVertexAttrib2fvARB = &_get_glVertexAttrib2fvARB;

static void APIENTRY _fail_glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y) {
    const char *_name = "glVertexAttrib2sARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y) {
    PFN_GLVERTEXATTRIB2SARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2SARB)_getPrivateProcAddress("glVertexAttrib2sARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2sARB;
    }
    _glVertexAttrib2sARB = _ptr;
    _glVertexAttrib2sARB(index, x, y);
}

PFN_GLVERTEXATTRIB2SARB _glVertexAttrib2sARB = &_get_glVertexAttrib2sARB;

static void APIENTRY _fail_glVertexAttrib2svARB(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib2svARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2svARB(GLuint index, const GLshort * v) {
    PFN_GLVERTEXATTRIB2SVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2SVARB)_getPrivateProcAddress("glVertexAttrib2svARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2svARB;
    }
    _glVertexAttrib2svARB = _ptr;
    _glVertexAttrib2svARB(index, v);
}

PFN_GLVERTEXATTRIB2SVARB _glVertexAttrib2svARB = &_get_glVertexAttrib2svARB;

static void APIENTRY _fail_glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glVertexAttrib3dARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLVERTEXATTRIB3DARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3DARB)_getPrivateProcAddress("glVertexAttrib3dARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3dARB;
    }
    _glVertexAttrib3dARB = _ptr;
    _glVertexAttrib3dARB(index, x, y, z);
}

PFN_GLVERTEXATTRIB3DARB _glVertexAttrib3dARB = &_get_glVertexAttrib3dARB;

static void APIENTRY _fail_glVertexAttrib3dvARB(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib3dvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3dvARB(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIB3DVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3DVARB)_getPrivateProcAddress("glVertexAttrib3dvARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3dvARB;
    }
    _glVertexAttrib3dvARB = _ptr;
    _glVertexAttrib3dvARB(index, v);
}

PFN_GLVERTEXATTRIB3DVARB _glVertexAttrib3dvARB = &_get_glVertexAttrib3dvARB;

static void APIENTRY _fail_glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glVertexAttrib3fARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLVERTEXATTRIB3FARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3FARB)_getPrivateProcAddress("glVertexAttrib3fARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3fARB;
    }
    _glVertexAttrib3fARB = _ptr;
    _glVertexAttrib3fARB(index, x, y, z);
}

PFN_GLVERTEXATTRIB3FARB _glVertexAttrib3fARB = &_get_glVertexAttrib3fARB;

static void APIENTRY _fail_glVertexAttrib3fvARB(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib3fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3fvARB(GLuint index, const GLfloat * v) {
    PFN_GLVERTEXATTRIB3FVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3FVARB)_getPrivateProcAddress("glVertexAttrib3fvARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3fvARB;
    }
    _glVertexAttrib3fvARB = _ptr;
    _glVertexAttrib3fvARB(index, v);
}

PFN_GLVERTEXATTRIB3FVARB _glVertexAttrib3fvARB = &_get_glVertexAttrib3fvARB;

static void APIENTRY _fail_glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z) {
    const char *_name = "glVertexAttrib3sARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z) {
    PFN_GLVERTEXATTRIB3SARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3SARB)_getPrivateProcAddress("glVertexAttrib3sARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3sARB;
    }
    _glVertexAttrib3sARB = _ptr;
    _glVertexAttrib3sARB(index, x, y, z);
}

PFN_GLVERTEXATTRIB3SARB _glVertexAttrib3sARB = &_get_glVertexAttrib3sARB;

static void APIENTRY _fail_glVertexAttrib3svARB(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib3svARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3svARB(GLuint index, const GLshort * v) {
    PFN_GLVERTEXATTRIB3SVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3SVARB)_getPrivateProcAddress("glVertexAttrib3svARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3svARB;
    }
    _glVertexAttrib3svARB = _ptr;
    _glVertexAttrib3svARB(index, v);
}

PFN_GLVERTEXATTRIB3SVARB _glVertexAttrib3svARB = &_get_glVertexAttrib3svARB;

static void APIENTRY _fail_glVertexAttrib4NbvARB(GLuint index, const GLbyte * v) {
    const char *_name = "glVertexAttrib4NbvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4NbvARB(GLuint index, const GLbyte * v) {
    PFN_GLVERTEXATTRIB4NBVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4NBVARB)_getPrivateProcAddress("glVertexAttrib4NbvARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4NbvARB;
    }
    _glVertexAttrib4NbvARB = _ptr;
    _glVertexAttrib4NbvARB(index, v);
}

PFN_GLVERTEXATTRIB4NBVARB _glVertexAttrib4NbvARB = &_get_glVertexAttrib4NbvARB;

static void APIENTRY _fail_glVertexAttrib4NivARB(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttrib4NivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4NivARB(GLuint index, const GLint * v) {
    PFN_GLVERTEXATTRIB4NIVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4NIVARB)_getPrivateProcAddress("glVertexAttrib4NivARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4NivARB;
    }
    _glVertexAttrib4NivARB = _ptr;
    _glVertexAttrib4NivARB(index, v);
}

PFN_GLVERTEXATTRIB4NIVARB _glVertexAttrib4NivARB = &_get_glVertexAttrib4NivARB;

static void APIENTRY _fail_glVertexAttrib4NsvARB(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib4NsvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4NsvARB(GLuint index, const GLshort * v) {
    PFN_GLVERTEXATTRIB4NSVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4NSVARB)_getPrivateProcAddress("glVertexAttrib4NsvARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4NsvARB;
    }
    _glVertexAttrib4NsvARB = _ptr;
    _glVertexAttrib4NsvARB(index, v);
}

PFN_GLVERTEXATTRIB4NSVARB _glVertexAttrib4NsvARB = &_get_glVertexAttrib4NsvARB;

static void APIENTRY _fail_glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) {
    const char *_name = "glVertexAttrib4NubARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) {
    PFN_GLVERTEXATTRIB4NUBARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4NUBARB)_getPrivateProcAddress("glVertexAttrib4NubARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4NubARB;
    }
    _glVertexAttrib4NubARB = _ptr;
    _glVertexAttrib4NubARB(index, x, y, z, w);
}

PFN_GLVERTEXATTRIB4NUBARB _glVertexAttrib4NubARB = &_get_glVertexAttrib4NubARB;

static void APIENTRY _fail_glVertexAttrib4NubvARB(GLuint index, const GLubyte * v) {
    const char *_name = "glVertexAttrib4NubvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4NubvARB(GLuint index, const GLubyte * v) {
    PFN_GLVERTEXATTRIB4NUBVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4NUBVARB)_getPrivateProcAddress("glVertexAttrib4NubvARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4NubvARB;
    }
    _glVertexAttrib4NubvARB = _ptr;
    _glVertexAttrib4NubvARB(index, v);
}

PFN_GLVERTEXATTRIB4NUBVARB _glVertexAttrib4NubvARB = &_get_glVertexAttrib4NubvARB;

static void APIENTRY _fail_glVertexAttrib4NuivARB(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttrib4NuivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4NuivARB(GLuint index, const GLuint * v) {
    PFN_GLVERTEXATTRIB4NUIVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4NUIVARB)_getPrivateProcAddress("glVertexAttrib4NuivARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4NuivARB;
    }
    _glVertexAttrib4NuivARB = _ptr;
    _glVertexAttrib4NuivARB(index, v);
}

PFN_GLVERTEXATTRIB4NUIVARB _glVertexAttrib4NuivARB = &_get_glVertexAttrib4NuivARB;

static void APIENTRY _fail_glVertexAttrib4NusvARB(GLuint index, const GLushort * v) {
    const char *_name = "glVertexAttrib4NusvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4NusvARB(GLuint index, const GLushort * v) {
    PFN_GLVERTEXATTRIB4NUSVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4NUSVARB)_getPrivateProcAddress("glVertexAttrib4NusvARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4NusvARB;
    }
    _glVertexAttrib4NusvARB = _ptr;
    _glVertexAttrib4NusvARB(index, v);
}

PFN_GLVERTEXATTRIB4NUSVARB _glVertexAttrib4NusvARB = &_get_glVertexAttrib4NusvARB;

static void APIENTRY _fail_glVertexAttrib4bvARB(GLuint index, const GLbyte * v) {
    const char *_name = "glVertexAttrib4bvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4bvARB(GLuint index, const GLbyte * v) {
    PFN_GLVERTEXATTRIB4BVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4BVARB)_getPrivateProcAddress("glVertexAttrib4bvARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4bvARB;
    }
    _glVertexAttrib4bvARB = _ptr;
    _glVertexAttrib4bvARB(index, v);
}

PFN_GLVERTEXATTRIB4BVARB _glVertexAttrib4bvARB = &_get_glVertexAttrib4bvARB;

static void APIENTRY _fail_glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glVertexAttrib4dARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    PFN_GLVERTEXATTRIB4DARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4DARB)_getPrivateProcAddress("glVertexAttrib4dARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4dARB;
    }
    _glVertexAttrib4dARB = _ptr;
    _glVertexAttrib4dARB(index, x, y, z, w);
}

PFN_GLVERTEXATTRIB4DARB _glVertexAttrib4dARB = &_get_glVertexAttrib4dARB;

static void APIENTRY _fail_glVertexAttrib4dvARB(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib4dvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4dvARB(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIB4DVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4DVARB)_getPrivateProcAddress("glVertexAttrib4dvARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4dvARB;
    }
    _glVertexAttrib4dvARB = _ptr;
    _glVertexAttrib4dvARB(index, v);
}

PFN_GLVERTEXATTRIB4DVARB _glVertexAttrib4dvARB = &_get_glVertexAttrib4dvARB;

static void APIENTRY _fail_glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glVertexAttrib4fARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    PFN_GLVERTEXATTRIB4FARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4FARB)_getPrivateProcAddress("glVertexAttrib4fARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4fARB;
    }
    _glVertexAttrib4fARB = _ptr;
    _glVertexAttrib4fARB(index, x, y, z, w);
}

PFN_GLVERTEXATTRIB4FARB _glVertexAttrib4fARB = &_get_glVertexAttrib4fARB;

static void APIENTRY _fail_glVertexAttrib4fvARB(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib4fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4fvARB(GLuint index, const GLfloat * v) {
    PFN_GLVERTEXATTRIB4FVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4FVARB)_getPrivateProcAddress("glVertexAttrib4fvARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4fvARB;
    }
    _glVertexAttrib4fvARB = _ptr;
    _glVertexAttrib4fvARB(index, v);
}

PFN_GLVERTEXATTRIB4FVARB _glVertexAttrib4fvARB = &_get_glVertexAttrib4fvARB;

static void APIENTRY _fail_glVertexAttrib4ivARB(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttrib4ivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4ivARB(GLuint index, const GLint * v) {
    PFN_GLVERTEXATTRIB4IVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4IVARB)_getPrivateProcAddress("glVertexAttrib4ivARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4ivARB;
    }
    _glVertexAttrib4ivARB = _ptr;
    _glVertexAttrib4ivARB(index, v);
}

PFN_GLVERTEXATTRIB4IVARB _glVertexAttrib4ivARB = &_get_glVertexAttrib4ivARB;

static void APIENTRY _fail_glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) {
    const char *_name = "glVertexAttrib4sARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) {
    PFN_GLVERTEXATTRIB4SARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4SARB)_getPrivateProcAddress("glVertexAttrib4sARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4sARB;
    }
    _glVertexAttrib4sARB = _ptr;
    _glVertexAttrib4sARB(index, x, y, z, w);
}

PFN_GLVERTEXATTRIB4SARB _glVertexAttrib4sARB = &_get_glVertexAttrib4sARB;

static void APIENTRY _fail_glVertexAttrib4svARB(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib4svARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4svARB(GLuint index, const GLshort * v) {
    PFN_GLVERTEXATTRIB4SVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4SVARB)_getPrivateProcAddress("glVertexAttrib4svARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4svARB;
    }
    _glVertexAttrib4svARB = _ptr;
    _glVertexAttrib4svARB(index, v);
}

PFN_GLVERTEXATTRIB4SVARB _glVertexAttrib4svARB = &_get_glVertexAttrib4svARB;

static void APIENTRY _fail_glVertexAttrib4ubvARB(GLuint index, const GLubyte * v) {
    const char *_name = "glVertexAttrib4ubvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4ubvARB(GLuint index, const GLubyte * v) {
    PFN_GLVERTEXATTRIB4UBVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4UBVARB)_getPrivateProcAddress("glVertexAttrib4ubvARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4ubvARB;
    }
    _glVertexAttrib4ubvARB = _ptr;
    _glVertexAttrib4ubvARB(index, v);
}

PFN_GLVERTEXATTRIB4UBVARB _glVertexAttrib4ubvARB = &_get_glVertexAttrib4ubvARB;

static void APIENTRY _fail_glVertexAttrib4uivARB(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttrib4uivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4uivARB(GLuint index, const GLuint * v) {
    PFN_GLVERTEXATTRIB4UIVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4UIVARB)_getPrivateProcAddress("glVertexAttrib4uivARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4uivARB;
    }
    _glVertexAttrib4uivARB = _ptr;
    _glVertexAttrib4uivARB(index, v);
}

PFN_GLVERTEXATTRIB4UIVARB _glVertexAttrib4uivARB = &_get_glVertexAttrib4uivARB;

static void APIENTRY _fail_glVertexAttrib4usvARB(GLuint index, const GLushort * v) {
    const char *_name = "glVertexAttrib4usvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4usvARB(GLuint index, const GLushort * v) {
    PFN_GLVERTEXATTRIB4USVARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4USVARB)_getPrivateProcAddress("glVertexAttrib4usvARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4usvARB;
    }
    _glVertexAttrib4usvARB = _ptr;
    _glVertexAttrib4usvARB(index, v);
}

PFN_GLVERTEXATTRIB4USVARB _glVertexAttrib4usvARB = &_get_glVertexAttrib4usvARB;

static void APIENTRY _fail_glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glVertexAttribPointerARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer) {
    PFN_GLVERTEXATTRIBPOINTERARB _ptr;
    _ptr = (PFN_GLVERTEXATTRIBPOINTERARB)_getPrivateProcAddress("glVertexAttribPointerARB");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribPointerARB;
    }
    _glVertexAttribPointerARB = _ptr;
    _glVertexAttribPointerARB(index, size, type, normalized, stride, pointer);
}

PFN_GLVERTEXATTRIBPOINTERARB _glVertexAttribPointerARB = &_get_glVertexAttribPointerARB;

static void APIENTRY _fail_glEnableVertexAttribArrayARB(GLuint index) {
    const char *_name = "glEnableVertexAttribArrayARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEnableVertexAttribArrayARB(GLuint index) {
    PFN_GLENABLEVERTEXATTRIBARRAYARB _ptr;
    _ptr = (PFN_GLENABLEVERTEXATTRIBARRAYARB)_getPrivateProcAddress("glEnableVertexAttribArrayARB");
    if (!_ptr) {
        _ptr = &_fail_glEnableVertexAttribArrayARB;
    }
    _glEnableVertexAttribArrayARB = _ptr;
    _glEnableVertexAttribArrayARB(index);
}

PFN_GLENABLEVERTEXATTRIBARRAYARB _glEnableVertexAttribArrayARB = &_get_glEnableVertexAttribArrayARB;

static void APIENTRY _fail_glDisableVertexAttribArrayARB(GLuint index) {
    const char *_name = "glDisableVertexAttribArrayARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDisableVertexAttribArrayARB(GLuint index) {
    PFN_GLDISABLEVERTEXATTRIBARRAYARB _ptr;
    _ptr = (PFN_GLDISABLEVERTEXATTRIBARRAYARB)_getPrivateProcAddress("glDisableVertexAttribArrayARB");
    if (!_ptr) {
        _ptr = &_fail_glDisableVertexAttribArrayARB;
    }
    _glDisableVertexAttribArrayARB = _ptr;
    _glDisableVertexAttribArrayARB(index);
}

PFN_GLDISABLEVERTEXATTRIBARRAYARB _glDisableVertexAttribArrayARB = &_get_glDisableVertexAttribArrayARB;

static void APIENTRY _fail_glProgramStringARB(GLenum target, GLenum format, GLsizei len, const void * string) {
    const char *_name = "glProgramStringARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramStringARB(GLenum target, GLenum format, GLsizei len, const void * string) {
    PFN_GLPROGRAMSTRINGARB _ptr;
    _ptr = (PFN_GLPROGRAMSTRINGARB)_getPrivateProcAddress("glProgramStringARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramStringARB;
    }
    _glProgramStringARB = _ptr;
    _glProgramStringARB(target, format, len, string);
}

PFN_GLPROGRAMSTRINGARB _glProgramStringARB = &_get_glProgramStringARB;

static void APIENTRY _fail_glBindProgramARB(GLenum target, GLuint program) {
    const char *_name = "glBindProgramARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindProgramARB(GLenum target, GLuint program) {
    PFN_GLBINDPROGRAMARB _ptr;
    _ptr = (PFN_GLBINDPROGRAMARB)_getPrivateProcAddress("glBindProgramARB");
    if (!_ptr) {
        _ptr = &_fail_glBindProgramARB;
    }
    _glBindProgramARB = _ptr;
    _glBindProgramARB(target, program);
}

PFN_GLBINDPROGRAMARB _glBindProgramARB = &_get_glBindProgramARB;

static void APIENTRY _fail_glDeleteProgramsARB(GLsizei n, const GLuint * programs) {
    const char *_name = "glDeleteProgramsARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteProgramsARB(GLsizei n, const GLuint * programs) {
    PFN_GLDELETEPROGRAMSARB _ptr;
    _ptr = (PFN_GLDELETEPROGRAMSARB)_getPrivateProcAddress("glDeleteProgramsARB");
    if (!_ptr) {
        _ptr = &_fail_glDeleteProgramsARB;
    }
    _glDeleteProgramsARB = _ptr;
    _glDeleteProgramsARB(n, programs);
}

PFN_GLDELETEPROGRAMSARB _glDeleteProgramsARB = &_get_glDeleteProgramsARB;

static void APIENTRY _fail_glGenProgramsARB(GLsizei n, GLuint * programs) {
    const char *_name = "glGenProgramsARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenProgramsARB(GLsizei n, GLuint * programs) {
    PFN_GLGENPROGRAMSARB _ptr;
    _ptr = (PFN_GLGENPROGRAMSARB)_getPrivateProcAddress("glGenProgramsARB");
    if (!_ptr) {
        _ptr = &_fail_glGenProgramsARB;
    }
    _glGenProgramsARB = _ptr;
    _glGenProgramsARB(n, programs);
}

PFN_GLGENPROGRAMSARB _glGenProgramsARB = &_get_glGenProgramsARB;

static void APIENTRY _fail_glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glProgramEnvParameter4dARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    PFN_GLPROGRAMENVPARAMETER4DARB _ptr;
    _ptr = (PFN_GLPROGRAMENVPARAMETER4DARB)_getPrivateProcAddress("glProgramEnvParameter4dARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramEnvParameter4dARB;
    }
    _glProgramEnvParameter4dARB = _ptr;
    _glProgramEnvParameter4dARB(target, index, x, y, z, w);
}

PFN_GLPROGRAMENVPARAMETER4DARB _glProgramEnvParameter4dARB = &_get_glProgramEnvParameter4dARB;

static void APIENTRY _fail_glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble * params) {
    const char *_name = "glProgramEnvParameter4dvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble * params) {
    PFN_GLPROGRAMENVPARAMETER4DVARB _ptr;
    _ptr = (PFN_GLPROGRAMENVPARAMETER4DVARB)_getPrivateProcAddress("glProgramEnvParameter4dvARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramEnvParameter4dvARB;
    }
    _glProgramEnvParameter4dvARB = _ptr;
    _glProgramEnvParameter4dvARB(target, index, params);
}

PFN_GLPROGRAMENVPARAMETER4DVARB _glProgramEnvParameter4dvARB = &_get_glProgramEnvParameter4dvARB;

static void APIENTRY _fail_glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glProgramEnvParameter4fARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    PFN_GLPROGRAMENVPARAMETER4FARB _ptr;
    _ptr = (PFN_GLPROGRAMENVPARAMETER4FARB)_getPrivateProcAddress("glProgramEnvParameter4fARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramEnvParameter4fARB;
    }
    _glProgramEnvParameter4fARB = _ptr;
    _glProgramEnvParameter4fARB(target, index, x, y, z, w);
}

PFN_GLPROGRAMENVPARAMETER4FARB _glProgramEnvParameter4fARB = &_get_glProgramEnvParameter4fARB;

static void APIENTRY _fail_glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat * params) {
    const char *_name = "glProgramEnvParameter4fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat * params) {
    PFN_GLPROGRAMENVPARAMETER4FVARB _ptr;
    _ptr = (PFN_GLPROGRAMENVPARAMETER4FVARB)_getPrivateProcAddress("glProgramEnvParameter4fvARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramEnvParameter4fvARB;
    }
    _glProgramEnvParameter4fvARB = _ptr;
    _glProgramEnvParameter4fvARB(target, index, params);
}

PFN_GLPROGRAMENVPARAMETER4FVARB _glProgramEnvParameter4fvARB = &_get_glProgramEnvParameter4fvARB;

static void APIENTRY _fail_glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glProgramLocalParameter4dARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    PFN_GLPROGRAMLOCALPARAMETER4DARB _ptr;
    _ptr = (PFN_GLPROGRAMLOCALPARAMETER4DARB)_getPrivateProcAddress("glProgramLocalParameter4dARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramLocalParameter4dARB;
    }
    _glProgramLocalParameter4dARB = _ptr;
    _glProgramLocalParameter4dARB(target, index, x, y, z, w);
}

PFN_GLPROGRAMLOCALPARAMETER4DARB _glProgramLocalParameter4dARB = &_get_glProgramLocalParameter4dARB;

static void APIENTRY _fail_glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble * params) {
    const char *_name = "glProgramLocalParameter4dvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble * params) {
    PFN_GLPROGRAMLOCALPARAMETER4DVARB _ptr;
    _ptr = (PFN_GLPROGRAMLOCALPARAMETER4DVARB)_getPrivateProcAddress("glProgramLocalParameter4dvARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramLocalParameter4dvARB;
    }
    _glProgramLocalParameter4dvARB = _ptr;
    _glProgramLocalParameter4dvARB(target, index, params);
}

PFN_GLPROGRAMLOCALPARAMETER4DVARB _glProgramLocalParameter4dvARB = &_get_glProgramLocalParameter4dvARB;

static void APIENTRY _fail_glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glProgramLocalParameter4fARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    PFN_GLPROGRAMLOCALPARAMETER4FARB _ptr;
    _ptr = (PFN_GLPROGRAMLOCALPARAMETER4FARB)_getPrivateProcAddress("glProgramLocalParameter4fARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramLocalParameter4fARB;
    }
    _glProgramLocalParameter4fARB = _ptr;
    _glProgramLocalParameter4fARB(target, index, x, y, z, w);
}

PFN_GLPROGRAMLOCALPARAMETER4FARB _glProgramLocalParameter4fARB = &_get_glProgramLocalParameter4fARB;

static void APIENTRY _fail_glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat * params) {
    const char *_name = "glProgramLocalParameter4fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat * params) {
    PFN_GLPROGRAMLOCALPARAMETER4FVARB _ptr;
    _ptr = (PFN_GLPROGRAMLOCALPARAMETER4FVARB)_getPrivateProcAddress("glProgramLocalParameter4fvARB");
    if (!_ptr) {
        _ptr = &_fail_glProgramLocalParameter4fvARB;
    }
    _glProgramLocalParameter4fvARB = _ptr;
    _glProgramLocalParameter4fvARB(target, index, params);
}

PFN_GLPROGRAMLOCALPARAMETER4FVARB _glProgramLocalParameter4fvARB = &_get_glProgramLocalParameter4fvARB;

static void APIENTRY _fail_glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble * params) {
    const char *_name = "glGetProgramEnvParameterdvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble * params) {
    PFN_GLGETPROGRAMENVPARAMETERDVARB _ptr;
    _ptr = (PFN_GLGETPROGRAMENVPARAMETERDVARB)_getPrivateProcAddress("glGetProgramEnvParameterdvARB");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramEnvParameterdvARB;
    }
    _glGetProgramEnvParameterdvARB = _ptr;
    _glGetProgramEnvParameterdvARB(target, index, params);
}

PFN_GLGETPROGRAMENVPARAMETERDVARB _glGetProgramEnvParameterdvARB = &_get_glGetProgramEnvParameterdvARB;

static void APIENTRY _fail_glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat * params) {
    const char *_name = "glGetProgramEnvParameterfvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat * params) {
    PFN_GLGETPROGRAMENVPARAMETERFVARB _ptr;
    _ptr = (PFN_GLGETPROGRAMENVPARAMETERFVARB)_getPrivateProcAddress("glGetProgramEnvParameterfvARB");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramEnvParameterfvARB;
    }
    _glGetProgramEnvParameterfvARB = _ptr;
    _glGetProgramEnvParameterfvARB(target, index, params);
}

PFN_GLGETPROGRAMENVPARAMETERFVARB _glGetProgramEnvParameterfvARB = &_get_glGetProgramEnvParameterfvARB;

static void APIENTRY _fail_glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble * params) {
    const char *_name = "glGetProgramLocalParameterdvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble * params) {
    PFN_GLGETPROGRAMLOCALPARAMETERDVARB _ptr;
    _ptr = (PFN_GLGETPROGRAMLOCALPARAMETERDVARB)_getPrivateProcAddress("glGetProgramLocalParameterdvARB");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramLocalParameterdvARB;
    }
    _glGetProgramLocalParameterdvARB = _ptr;
    _glGetProgramLocalParameterdvARB(target, index, params);
}

PFN_GLGETPROGRAMLOCALPARAMETERDVARB _glGetProgramLocalParameterdvARB = &_get_glGetProgramLocalParameterdvARB;

static void APIENTRY _fail_glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat * params) {
    const char *_name = "glGetProgramLocalParameterfvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat * params) {
    PFN_GLGETPROGRAMLOCALPARAMETERFVARB _ptr;
    _ptr = (PFN_GLGETPROGRAMLOCALPARAMETERFVARB)_getPrivateProcAddress("glGetProgramLocalParameterfvARB");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramLocalParameterfvARB;
    }
    _glGetProgramLocalParameterfvARB = _ptr;
    _glGetProgramLocalParameterfvARB(target, index, params);
}

PFN_GLGETPROGRAMLOCALPARAMETERFVARB _glGetProgramLocalParameterfvARB = &_get_glGetProgramLocalParameterfvARB;

static void APIENTRY _fail_glGetProgramivARB(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetProgramivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramivARB(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETPROGRAMIVARB _ptr;
    _ptr = (PFN_GLGETPROGRAMIVARB)_getPrivateProcAddress("glGetProgramivARB");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramivARB;
    }
    _glGetProgramivARB = _ptr;
    _glGetProgramivARB(target, pname, params);
}

PFN_GLGETPROGRAMIVARB _glGetProgramivARB = &_get_glGetProgramivARB;

static void APIENTRY _fail_glGetProgramStringARB(GLenum target, GLenum pname, GLvoid * string) {
    const char *_name = "glGetProgramStringARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramStringARB(GLenum target, GLenum pname, GLvoid * string) {
    PFN_GLGETPROGRAMSTRINGARB _ptr;
    _ptr = (PFN_GLGETPROGRAMSTRINGARB)_getPrivateProcAddress("glGetProgramStringARB");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramStringARB;
    }
    _glGetProgramStringARB = _ptr;
    _glGetProgramStringARB(target, pname, string);
}

PFN_GLGETPROGRAMSTRINGARB _glGetProgramStringARB = &_get_glGetProgramStringARB;

static void APIENTRY _fail_glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble * params) {
    const char *_name = "glGetVertexAttribdvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble * params) {
    PFN_GLGETVERTEXATTRIBDVARB _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBDVARB)_getPrivateProcAddress("glGetVertexAttribdvARB");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribdvARB;
    }
    _glGetVertexAttribdvARB = _ptr;
    _glGetVertexAttribdvARB(index, pname, params);
}

PFN_GLGETVERTEXATTRIBDVARB _glGetVertexAttribdvARB = &_get_glGetVertexAttribdvARB;

static void APIENTRY _fail_glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat * params) {
    const char *_name = "glGetVertexAttribfvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat * params) {
    PFN_GLGETVERTEXATTRIBFVARB _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBFVARB)_getPrivateProcAddress("glGetVertexAttribfvARB");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribfvARB;
    }
    _glGetVertexAttribfvARB = _ptr;
    _glGetVertexAttribfvARB(index, pname, params);
}

PFN_GLGETVERTEXATTRIBFVARB _glGetVertexAttribfvARB = &_get_glGetVertexAttribfvARB;

static void APIENTRY _fail_glGetVertexAttribivARB(GLuint index, GLenum pname, GLint * params) {
    const char *_name = "glGetVertexAttribivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribivARB(GLuint index, GLenum pname, GLint * params) {
    PFN_GLGETVERTEXATTRIBIVARB _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBIVARB)_getPrivateProcAddress("glGetVertexAttribivARB");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribivARB;
    }
    _glGetVertexAttribivARB = _ptr;
    _glGetVertexAttribivARB(index, pname, params);
}

PFN_GLGETVERTEXATTRIBIVARB _glGetVertexAttribivARB = &_get_glGetVertexAttribivARB;

static void APIENTRY _fail_glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid * * pointer) {
    const char *_name = "glGetVertexAttribPointervARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid * * pointer) {
    PFN_GLGETVERTEXATTRIBPOINTERVARB _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBPOINTERVARB)_getPrivateProcAddress("glGetVertexAttribPointervARB");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribPointervARB;
    }
    _glGetVertexAttribPointervARB = _ptr;
    _glGetVertexAttribPointervARB(index, pname, pointer);
}

PFN_GLGETVERTEXATTRIBPOINTERVARB _glGetVertexAttribPointervARB = &_get_glGetVertexAttribPointervARB;

static GLboolean APIENTRY _fail_glIsProgramARB(GLuint program) {
    const char *_name = "glIsProgramARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsProgramARB(GLuint program) {
    PFN_GLISPROGRAMARB _ptr;
    _ptr = (PFN_GLISPROGRAMARB)_getPrivateProcAddress("glIsProgramARB");
    if (!_ptr) {
        _ptr = &_fail_glIsProgramARB;
    }
    _glIsProgramARB = _ptr;
    return _glIsProgramARB(program);
}

PFN_GLISPROGRAMARB _glIsProgramARB = &_get_glIsProgramARB;

static void APIENTRY _fail_glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB * name) {
    const char *_name = "glBindAttribLocationARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB * name) {
    PFN_GLBINDATTRIBLOCATIONARB _ptr;
    _ptr = (PFN_GLBINDATTRIBLOCATIONARB)_getPrivateProcAddress("glBindAttribLocationARB");
    if (!_ptr) {
        _ptr = &_fail_glBindAttribLocationARB;
    }
    _glBindAttribLocationARB = _ptr;
    _glBindAttribLocationARB(programObj, index, name);
}

PFN_GLBINDATTRIBLOCATIONARB _glBindAttribLocationARB = &_get_glBindAttribLocationARB;

static void APIENTRY _fail_glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name) {
    const char *_name = "glGetActiveAttribARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name) {
    PFN_GLGETACTIVEATTRIBARB _ptr;
    _ptr = (PFN_GLGETACTIVEATTRIBARB)_getPrivateProcAddress("glGetActiveAttribARB");
    if (!_ptr) {
        _ptr = &_fail_glGetActiveAttribARB;
    }
    _glGetActiveAttribARB = _ptr;
    _glGetActiveAttribARB(programObj, index, maxLength, length, size, type, name);
}

PFN_GLGETACTIVEATTRIBARB _glGetActiveAttribARB = &_get_glGetActiveAttribARB;

static GLint APIENTRY _fail_glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB * name) {
    const char *_name = "glGetAttribLocationARB";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLint APIENTRY _get_glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB * name) {
    PFN_GLGETATTRIBLOCATIONARB _ptr;
    _ptr = (PFN_GLGETATTRIBLOCATIONARB)_getPrivateProcAddress("glGetAttribLocationARB");
    if (!_ptr) {
        _ptr = &_fail_glGetAttribLocationARB;
    }
    _glGetAttribLocationARB = _ptr;
    return _glGetAttribLocationARB(programObj, name);
}

PFN_GLGETATTRIBLOCATIONARB _glGetAttribLocationARB = &_get_glGetAttribLocationARB;

static void APIENTRY _fail_glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) {
    const char *_name = "glVertexAttribP1ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) {
    PFN_GLVERTEXATTRIBP1UI _ptr;
    _ptr = (PFN_GLVERTEXATTRIBP1UI)_getPrivateProcAddress("glVertexAttribP1ui");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribP1ui;
    }
    _glVertexAttribP1ui = _ptr;
    _glVertexAttribP1ui(index, type, normalized, value);
}

PFN_GLVERTEXATTRIBP1UI _glVertexAttribP1ui = &_get_glVertexAttribP1ui;

static void APIENTRY _fail_glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value) {
    const char *_name = "glVertexAttribP1uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value) {
    PFN_GLVERTEXATTRIBP1UIV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBP1UIV)_getPrivateProcAddress("glVertexAttribP1uiv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribP1uiv;
    }
    _glVertexAttribP1uiv = _ptr;
    _glVertexAttribP1uiv(index, type, normalized, value);
}

PFN_GLVERTEXATTRIBP1UIV _glVertexAttribP1uiv = &_get_glVertexAttribP1uiv;

static void APIENTRY _fail_glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) {
    const char *_name = "glVertexAttribP2ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) {
    PFN_GLVERTEXATTRIBP2UI _ptr;
    _ptr = (PFN_GLVERTEXATTRIBP2UI)_getPrivateProcAddress("glVertexAttribP2ui");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribP2ui;
    }
    _glVertexAttribP2ui = _ptr;
    _glVertexAttribP2ui(index, type, normalized, value);
}

PFN_GLVERTEXATTRIBP2UI _glVertexAttribP2ui = &_get_glVertexAttribP2ui;

static void APIENTRY _fail_glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value) {
    const char *_name = "glVertexAttribP2uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value) {
    PFN_GLVERTEXATTRIBP2UIV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBP2UIV)_getPrivateProcAddress("glVertexAttribP2uiv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribP2uiv;
    }
    _glVertexAttribP2uiv = _ptr;
    _glVertexAttribP2uiv(index, type, normalized, value);
}

PFN_GLVERTEXATTRIBP2UIV _glVertexAttribP2uiv = &_get_glVertexAttribP2uiv;

static void APIENTRY _fail_glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) {
    const char *_name = "glVertexAttribP3ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) {
    PFN_GLVERTEXATTRIBP3UI _ptr;
    _ptr = (PFN_GLVERTEXATTRIBP3UI)_getPrivateProcAddress("glVertexAttribP3ui");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribP3ui;
    }
    _glVertexAttribP3ui = _ptr;
    _glVertexAttribP3ui(index, type, normalized, value);
}

PFN_GLVERTEXATTRIBP3UI _glVertexAttribP3ui = &_get_glVertexAttribP3ui;

static void APIENTRY _fail_glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value) {
    const char *_name = "glVertexAttribP3uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value) {
    PFN_GLVERTEXATTRIBP3UIV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBP3UIV)_getPrivateProcAddress("glVertexAttribP3uiv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribP3uiv;
    }
    _glVertexAttribP3uiv = _ptr;
    _glVertexAttribP3uiv(index, type, normalized, value);
}

PFN_GLVERTEXATTRIBP3UIV _glVertexAttribP3uiv = &_get_glVertexAttribP3uiv;

static void APIENTRY _fail_glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) {
    const char *_name = "glVertexAttribP4ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) {
    PFN_GLVERTEXATTRIBP4UI _ptr;
    _ptr = (PFN_GLVERTEXATTRIBP4UI)_getPrivateProcAddress("glVertexAttribP4ui");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribP4ui;
    }
    _glVertexAttribP4ui = _ptr;
    _glVertexAttribP4ui(index, type, normalized, value);
}

PFN_GLVERTEXATTRIBP4UI _glVertexAttribP4ui = &_get_glVertexAttribP4ui;

static void APIENTRY _fail_glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value) {
    const char *_name = "glVertexAttribP4uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint * value) {
    PFN_GLVERTEXATTRIBP4UIV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBP4UIV)_getPrivateProcAddress("glVertexAttribP4uiv");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribP4uiv;
    }
    _glVertexAttribP4uiv = _ptr;
    _glVertexAttribP4uiv(index, type, normalized, value);
}

PFN_GLVERTEXATTRIBP4UIV _glVertexAttribP4uiv = &_get_glVertexAttribP4uiv;

static void APIENTRY _fail_glVertexP2ui(GLenum type, GLuint value) {
    const char *_name = "glVertexP2ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexP2ui(GLenum type, GLuint value) {
    PFN_GLVERTEXP2UI _ptr;
    _ptr = (PFN_GLVERTEXP2UI)_getPrivateProcAddress("glVertexP2ui");
    if (!_ptr) {
        _ptr = &_fail_glVertexP2ui;
    }
    _glVertexP2ui = _ptr;
    _glVertexP2ui(type, value);
}

PFN_GLVERTEXP2UI _glVertexP2ui = &_get_glVertexP2ui;

static void APIENTRY _fail_glVertexP2uiv(GLenum type, const GLuint * value) {
    const char *_name = "glVertexP2uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexP2uiv(GLenum type, const GLuint * value) {
    PFN_GLVERTEXP2UIV _ptr;
    _ptr = (PFN_GLVERTEXP2UIV)_getPrivateProcAddress("glVertexP2uiv");
    if (!_ptr) {
        _ptr = &_fail_glVertexP2uiv;
    }
    _glVertexP2uiv = _ptr;
    _glVertexP2uiv(type, value);
}

PFN_GLVERTEXP2UIV _glVertexP2uiv = &_get_glVertexP2uiv;

static void APIENTRY _fail_glVertexP3ui(GLenum type, GLuint value) {
    const char *_name = "glVertexP3ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexP3ui(GLenum type, GLuint value) {
    PFN_GLVERTEXP3UI _ptr;
    _ptr = (PFN_GLVERTEXP3UI)_getPrivateProcAddress("glVertexP3ui");
    if (!_ptr) {
        _ptr = &_fail_glVertexP3ui;
    }
    _glVertexP3ui = _ptr;
    _glVertexP3ui(type, value);
}

PFN_GLVERTEXP3UI _glVertexP3ui = &_get_glVertexP3ui;

static void APIENTRY _fail_glVertexP3uiv(GLenum type, const GLuint * value) {
    const char *_name = "glVertexP3uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexP3uiv(GLenum type, const GLuint * value) {
    PFN_GLVERTEXP3UIV _ptr;
    _ptr = (PFN_GLVERTEXP3UIV)_getPrivateProcAddress("glVertexP3uiv");
    if (!_ptr) {
        _ptr = &_fail_glVertexP3uiv;
    }
    _glVertexP3uiv = _ptr;
    _glVertexP3uiv(type, value);
}

PFN_GLVERTEXP3UIV _glVertexP3uiv = &_get_glVertexP3uiv;

static void APIENTRY _fail_glVertexP4ui(GLenum type, GLuint value) {
    const char *_name = "glVertexP4ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexP4ui(GLenum type, GLuint value) {
    PFN_GLVERTEXP4UI _ptr;
    _ptr = (PFN_GLVERTEXP4UI)_getPrivateProcAddress("glVertexP4ui");
    if (!_ptr) {
        _ptr = &_fail_glVertexP4ui;
    }
    _glVertexP4ui = _ptr;
    _glVertexP4ui(type, value);
}

PFN_GLVERTEXP4UI _glVertexP4ui = &_get_glVertexP4ui;

static void APIENTRY _fail_glVertexP4uiv(GLenum type, const GLuint * value) {
    const char *_name = "glVertexP4uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexP4uiv(GLenum type, const GLuint * value) {
    PFN_GLVERTEXP4UIV _ptr;
    _ptr = (PFN_GLVERTEXP4UIV)_getPrivateProcAddress("glVertexP4uiv");
    if (!_ptr) {
        _ptr = &_fail_glVertexP4uiv;
    }
    _glVertexP4uiv = _ptr;
    _glVertexP4uiv(type, value);
}

PFN_GLVERTEXP4UIV _glVertexP4uiv = &_get_glVertexP4uiv;

static void APIENTRY _fail_glTexCoordP1ui(GLenum type, GLuint coords) {
    const char *_name = "glTexCoordP1ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoordP1ui(GLenum type, GLuint coords) {
    PFN_GLTEXCOORDP1UI _ptr;
    _ptr = (PFN_GLTEXCOORDP1UI)_getPrivateProcAddress("glTexCoordP1ui");
    if (!_ptr) {
        _ptr = &_fail_glTexCoordP1ui;
    }
    _glTexCoordP1ui = _ptr;
    _glTexCoordP1ui(type, coords);
}

PFN_GLTEXCOORDP1UI _glTexCoordP1ui = &_get_glTexCoordP1ui;

static void APIENTRY _fail_glTexCoordP1uiv(GLenum type, const GLuint * coords) {
    const char *_name = "glTexCoordP1uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoordP1uiv(GLenum type, const GLuint * coords) {
    PFN_GLTEXCOORDP1UIV _ptr;
    _ptr = (PFN_GLTEXCOORDP1UIV)_getPrivateProcAddress("glTexCoordP1uiv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoordP1uiv;
    }
    _glTexCoordP1uiv = _ptr;
    _glTexCoordP1uiv(type, coords);
}

PFN_GLTEXCOORDP1UIV _glTexCoordP1uiv = &_get_glTexCoordP1uiv;

static void APIENTRY _fail_glTexCoordP2ui(GLenum type, GLuint coords) {
    const char *_name = "glTexCoordP2ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoordP2ui(GLenum type, GLuint coords) {
    PFN_GLTEXCOORDP2UI _ptr;
    _ptr = (PFN_GLTEXCOORDP2UI)_getPrivateProcAddress("glTexCoordP2ui");
    if (!_ptr) {
        _ptr = &_fail_glTexCoordP2ui;
    }
    _glTexCoordP2ui = _ptr;
    _glTexCoordP2ui(type, coords);
}

PFN_GLTEXCOORDP2UI _glTexCoordP2ui = &_get_glTexCoordP2ui;

static void APIENTRY _fail_glTexCoordP2uiv(GLenum type, const GLuint * coords) {
    const char *_name = "glTexCoordP2uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoordP2uiv(GLenum type, const GLuint * coords) {
    PFN_GLTEXCOORDP2UIV _ptr;
    _ptr = (PFN_GLTEXCOORDP2UIV)_getPrivateProcAddress("glTexCoordP2uiv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoordP2uiv;
    }
    _glTexCoordP2uiv = _ptr;
    _glTexCoordP2uiv(type, coords);
}

PFN_GLTEXCOORDP2UIV _glTexCoordP2uiv = &_get_glTexCoordP2uiv;

static void APIENTRY _fail_glTexCoordP3ui(GLenum type, GLuint coords) {
    const char *_name = "glTexCoordP3ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoordP3ui(GLenum type, GLuint coords) {
    PFN_GLTEXCOORDP3UI _ptr;
    _ptr = (PFN_GLTEXCOORDP3UI)_getPrivateProcAddress("glTexCoordP3ui");
    if (!_ptr) {
        _ptr = &_fail_glTexCoordP3ui;
    }
    _glTexCoordP3ui = _ptr;
    _glTexCoordP3ui(type, coords);
}

PFN_GLTEXCOORDP3UI _glTexCoordP3ui = &_get_glTexCoordP3ui;

static void APIENTRY _fail_glTexCoordP3uiv(GLenum type, const GLuint * coords) {
    const char *_name = "glTexCoordP3uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoordP3uiv(GLenum type, const GLuint * coords) {
    PFN_GLTEXCOORDP3UIV _ptr;
    _ptr = (PFN_GLTEXCOORDP3UIV)_getPrivateProcAddress("glTexCoordP3uiv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoordP3uiv;
    }
    _glTexCoordP3uiv = _ptr;
    _glTexCoordP3uiv(type, coords);
}

PFN_GLTEXCOORDP3UIV _glTexCoordP3uiv = &_get_glTexCoordP3uiv;

static void APIENTRY _fail_glTexCoordP4ui(GLenum type, GLuint coords) {
    const char *_name = "glTexCoordP4ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoordP4ui(GLenum type, GLuint coords) {
    PFN_GLTEXCOORDP4UI _ptr;
    _ptr = (PFN_GLTEXCOORDP4UI)_getPrivateProcAddress("glTexCoordP4ui");
    if (!_ptr) {
        _ptr = &_fail_glTexCoordP4ui;
    }
    _glTexCoordP4ui = _ptr;
    _glTexCoordP4ui(type, coords);
}

PFN_GLTEXCOORDP4UI _glTexCoordP4ui = &_get_glTexCoordP4ui;

static void APIENTRY _fail_glTexCoordP4uiv(GLenum type, const GLuint * coords) {
    const char *_name = "glTexCoordP4uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoordP4uiv(GLenum type, const GLuint * coords) {
    PFN_GLTEXCOORDP4UIV _ptr;
    _ptr = (PFN_GLTEXCOORDP4UIV)_getPrivateProcAddress("glTexCoordP4uiv");
    if (!_ptr) {
        _ptr = &_fail_glTexCoordP4uiv;
    }
    _glTexCoordP4uiv = _ptr;
    _glTexCoordP4uiv(type, coords);
}

PFN_GLTEXCOORDP4UIV _glTexCoordP4uiv = &_get_glTexCoordP4uiv;

static void APIENTRY _fail_glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords) {
    const char *_name = "glMultiTexCoordP1ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords) {
    PFN_GLMULTITEXCOORDP1UI _ptr;
    _ptr = (PFN_GLMULTITEXCOORDP1UI)_getPrivateProcAddress("glMultiTexCoordP1ui");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoordP1ui;
    }
    _glMultiTexCoordP1ui = _ptr;
    _glMultiTexCoordP1ui(texture, type, coords);
}

PFN_GLMULTITEXCOORDP1UI _glMultiTexCoordP1ui = &_get_glMultiTexCoordP1ui;

static void APIENTRY _fail_glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint * coords) {
    const char *_name = "glMultiTexCoordP1uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint * coords) {
    PFN_GLMULTITEXCOORDP1UIV _ptr;
    _ptr = (PFN_GLMULTITEXCOORDP1UIV)_getPrivateProcAddress("glMultiTexCoordP1uiv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoordP1uiv;
    }
    _glMultiTexCoordP1uiv = _ptr;
    _glMultiTexCoordP1uiv(texture, type, coords);
}

PFN_GLMULTITEXCOORDP1UIV _glMultiTexCoordP1uiv = &_get_glMultiTexCoordP1uiv;

static void APIENTRY _fail_glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords) {
    const char *_name = "glMultiTexCoordP2ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords) {
    PFN_GLMULTITEXCOORDP2UI _ptr;
    _ptr = (PFN_GLMULTITEXCOORDP2UI)_getPrivateProcAddress("glMultiTexCoordP2ui");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoordP2ui;
    }
    _glMultiTexCoordP2ui = _ptr;
    _glMultiTexCoordP2ui(texture, type, coords);
}

PFN_GLMULTITEXCOORDP2UI _glMultiTexCoordP2ui = &_get_glMultiTexCoordP2ui;

static void APIENTRY _fail_glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint * coords) {
    const char *_name = "glMultiTexCoordP2uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint * coords) {
    PFN_GLMULTITEXCOORDP2UIV _ptr;
    _ptr = (PFN_GLMULTITEXCOORDP2UIV)_getPrivateProcAddress("glMultiTexCoordP2uiv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoordP2uiv;
    }
    _glMultiTexCoordP2uiv = _ptr;
    _glMultiTexCoordP2uiv(texture, type, coords);
}

PFN_GLMULTITEXCOORDP2UIV _glMultiTexCoordP2uiv = &_get_glMultiTexCoordP2uiv;

static void APIENTRY _fail_glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords) {
    const char *_name = "glMultiTexCoordP3ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords) {
    PFN_GLMULTITEXCOORDP3UI _ptr;
    _ptr = (PFN_GLMULTITEXCOORDP3UI)_getPrivateProcAddress("glMultiTexCoordP3ui");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoordP3ui;
    }
    _glMultiTexCoordP3ui = _ptr;
    _glMultiTexCoordP3ui(texture, type, coords);
}

PFN_GLMULTITEXCOORDP3UI _glMultiTexCoordP3ui = &_get_glMultiTexCoordP3ui;

static void APIENTRY _fail_glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint * coords) {
    const char *_name = "glMultiTexCoordP3uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint * coords) {
    PFN_GLMULTITEXCOORDP3UIV _ptr;
    _ptr = (PFN_GLMULTITEXCOORDP3UIV)_getPrivateProcAddress("glMultiTexCoordP3uiv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoordP3uiv;
    }
    _glMultiTexCoordP3uiv = _ptr;
    _glMultiTexCoordP3uiv(texture, type, coords);
}

PFN_GLMULTITEXCOORDP3UIV _glMultiTexCoordP3uiv = &_get_glMultiTexCoordP3uiv;

static void APIENTRY _fail_glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords) {
    const char *_name = "glMultiTexCoordP4ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords) {
    PFN_GLMULTITEXCOORDP4UI _ptr;
    _ptr = (PFN_GLMULTITEXCOORDP4UI)_getPrivateProcAddress("glMultiTexCoordP4ui");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoordP4ui;
    }
    _glMultiTexCoordP4ui = _ptr;
    _glMultiTexCoordP4ui(texture, type, coords);
}

PFN_GLMULTITEXCOORDP4UI _glMultiTexCoordP4ui = &_get_glMultiTexCoordP4ui;

static void APIENTRY _fail_glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint * coords) {
    const char *_name = "glMultiTexCoordP4uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint * coords) {
    PFN_GLMULTITEXCOORDP4UIV _ptr;
    _ptr = (PFN_GLMULTITEXCOORDP4UIV)_getPrivateProcAddress("glMultiTexCoordP4uiv");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoordP4uiv;
    }
    _glMultiTexCoordP4uiv = _ptr;
    _glMultiTexCoordP4uiv(texture, type, coords);
}

PFN_GLMULTITEXCOORDP4UIV _glMultiTexCoordP4uiv = &_get_glMultiTexCoordP4uiv;

static void APIENTRY _fail_glNormalP3ui(GLenum type, GLuint coords) {
    const char *_name = "glNormalP3ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormalP3ui(GLenum type, GLuint coords) {
    PFN_GLNORMALP3UI _ptr;
    _ptr = (PFN_GLNORMALP3UI)_getPrivateProcAddress("glNormalP3ui");
    if (!_ptr) {
        _ptr = &_fail_glNormalP3ui;
    }
    _glNormalP3ui = _ptr;
    _glNormalP3ui(type, coords);
}

PFN_GLNORMALP3UI _glNormalP3ui = &_get_glNormalP3ui;

static void APIENTRY _fail_glNormalP3uiv(GLenum type, const GLuint * coords) {
    const char *_name = "glNormalP3uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormalP3uiv(GLenum type, const GLuint * coords) {
    PFN_GLNORMALP3UIV _ptr;
    _ptr = (PFN_GLNORMALP3UIV)_getPrivateProcAddress("glNormalP3uiv");
    if (!_ptr) {
        _ptr = &_fail_glNormalP3uiv;
    }
    _glNormalP3uiv = _ptr;
    _glNormalP3uiv(type, coords);
}

PFN_GLNORMALP3UIV _glNormalP3uiv = &_get_glNormalP3uiv;

static void APIENTRY _fail_glColorP3ui(GLenum type, GLuint color) {
    const char *_name = "glColorP3ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorP3ui(GLenum type, GLuint color) {
    PFN_GLCOLORP3UI _ptr;
    _ptr = (PFN_GLCOLORP3UI)_getPrivateProcAddress("glColorP3ui");
    if (!_ptr) {
        _ptr = &_fail_glColorP3ui;
    }
    _glColorP3ui = _ptr;
    _glColorP3ui(type, color);
}

PFN_GLCOLORP3UI _glColorP3ui = &_get_glColorP3ui;

static void APIENTRY _fail_glColorP3uiv(GLenum type, const GLuint * color) {
    const char *_name = "glColorP3uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorP3uiv(GLenum type, const GLuint * color) {
    PFN_GLCOLORP3UIV _ptr;
    _ptr = (PFN_GLCOLORP3UIV)_getPrivateProcAddress("glColorP3uiv");
    if (!_ptr) {
        _ptr = &_fail_glColorP3uiv;
    }
    _glColorP3uiv = _ptr;
    _glColorP3uiv(type, color);
}

PFN_GLCOLORP3UIV _glColorP3uiv = &_get_glColorP3uiv;

static void APIENTRY _fail_glColorP4ui(GLenum type, GLuint color) {
    const char *_name = "glColorP4ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorP4ui(GLenum type, GLuint color) {
    PFN_GLCOLORP4UI _ptr;
    _ptr = (PFN_GLCOLORP4UI)_getPrivateProcAddress("glColorP4ui");
    if (!_ptr) {
        _ptr = &_fail_glColorP4ui;
    }
    _glColorP4ui = _ptr;
    _glColorP4ui(type, color);
}

PFN_GLCOLORP4UI _glColorP4ui = &_get_glColorP4ui;

static void APIENTRY _fail_glColorP4uiv(GLenum type, const GLuint * color) {
    const char *_name = "glColorP4uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorP4uiv(GLenum type, const GLuint * color) {
    PFN_GLCOLORP4UIV _ptr;
    _ptr = (PFN_GLCOLORP4UIV)_getPrivateProcAddress("glColorP4uiv");
    if (!_ptr) {
        _ptr = &_fail_glColorP4uiv;
    }
    _glColorP4uiv = _ptr;
    _glColorP4uiv(type, color);
}

PFN_GLCOLORP4UIV _glColorP4uiv = &_get_glColorP4uiv;

static void APIENTRY _fail_glSecondaryColorP3ui(GLenum type, GLuint color) {
    const char *_name = "glSecondaryColorP3ui";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColorP3ui(GLenum type, GLuint color) {
    PFN_GLSECONDARYCOLORP3UI _ptr;
    _ptr = (PFN_GLSECONDARYCOLORP3UI)_getPrivateProcAddress("glSecondaryColorP3ui");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColorP3ui;
    }
    _glSecondaryColorP3ui = _ptr;
    _glSecondaryColorP3ui(type, color);
}

PFN_GLSECONDARYCOLORP3UI _glSecondaryColorP3ui = &_get_glSecondaryColorP3ui;

static void APIENTRY _fail_glSecondaryColorP3uiv(GLenum type, const GLuint * color) {
    const char *_name = "glSecondaryColorP3uiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColorP3uiv(GLenum type, const GLuint * color) {
    PFN_GLSECONDARYCOLORP3UIV _ptr;
    _ptr = (PFN_GLSECONDARYCOLORP3UIV)_getPrivateProcAddress("glSecondaryColorP3uiv");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColorP3uiv;
    }
    _glSecondaryColorP3uiv = _ptr;
    _glSecondaryColorP3uiv(type, color);
}

PFN_GLSECONDARYCOLORP3UIV _glSecondaryColorP3uiv = &_get_glSecondaryColorP3uiv;

static void APIENTRY _fail_glViewportArrayv(GLuint first, GLsizei count, const GLfloat * v) {
    const char *_name = "glViewportArrayv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glViewportArrayv(GLuint first, GLsizei count, const GLfloat * v) {
    PFN_GLVIEWPORTARRAYV _ptr;
    _ptr = (PFN_GLVIEWPORTARRAYV)_getPrivateProcAddress("glViewportArrayv");
    if (!_ptr) {
        _ptr = &_fail_glViewportArrayv;
    }
    _glViewportArrayv = _ptr;
    _glViewportArrayv(first, count, v);
}

PFN_GLVIEWPORTARRAYV _glViewportArrayv = &_get_glViewportArrayv;

static void APIENTRY _fail_glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) {
    const char *_name = "glViewportIndexedf";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) {
    PFN_GLVIEWPORTINDEXEDF _ptr;
    _ptr = (PFN_GLVIEWPORTINDEXEDF)_getPrivateProcAddress("glViewportIndexedf");
    if (!_ptr) {
        _ptr = &_fail_glViewportIndexedf;
    }
    _glViewportIndexedf = _ptr;
    _glViewportIndexedf(index, x, y, w, h);
}

PFN_GLVIEWPORTINDEXEDF _glViewportIndexedf = &_get_glViewportIndexedf;

static void APIENTRY _fail_glViewportIndexedfv(GLuint index, const GLfloat * v) {
    const char *_name = "glViewportIndexedfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glViewportIndexedfv(GLuint index, const GLfloat * v) {
    PFN_GLVIEWPORTINDEXEDFV _ptr;
    _ptr = (PFN_GLVIEWPORTINDEXEDFV)_getPrivateProcAddress("glViewportIndexedfv");
    if (!_ptr) {
        _ptr = &_fail_glViewportIndexedfv;
    }
    _glViewportIndexedfv = _ptr;
    _glViewportIndexedfv(index, v);
}

PFN_GLVIEWPORTINDEXEDFV _glViewportIndexedfv = &_get_glViewportIndexedfv;

static void APIENTRY _fail_glScissorArrayv(GLuint first, GLsizei count, const GLint * v) {
    const char *_name = "glScissorArrayv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glScissorArrayv(GLuint first, GLsizei count, const GLint * v) {
    PFN_GLSCISSORARRAYV _ptr;
    _ptr = (PFN_GLSCISSORARRAYV)_getPrivateProcAddress("glScissorArrayv");
    if (!_ptr) {
        _ptr = &_fail_glScissorArrayv;
    }
    _glScissorArrayv = _ptr;
    _glScissorArrayv(first, count, v);
}

PFN_GLSCISSORARRAYV _glScissorArrayv = &_get_glScissorArrayv;

static void APIENTRY _fail_glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) {
    const char *_name = "glScissorIndexed";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) {
    PFN_GLSCISSORINDEXED _ptr;
    _ptr = (PFN_GLSCISSORINDEXED)_getPrivateProcAddress("glScissorIndexed");
    if (!_ptr) {
        _ptr = &_fail_glScissorIndexed;
    }
    _glScissorIndexed = _ptr;
    _glScissorIndexed(index, left, bottom, width, height);
}

PFN_GLSCISSORINDEXED _glScissorIndexed = &_get_glScissorIndexed;

static void APIENTRY _fail_glScissorIndexedv(GLuint index, const GLint * v) {
    const char *_name = "glScissorIndexedv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glScissorIndexedv(GLuint index, const GLint * v) {
    PFN_GLSCISSORINDEXEDV _ptr;
    _ptr = (PFN_GLSCISSORINDEXEDV)_getPrivateProcAddress("glScissorIndexedv");
    if (!_ptr) {
        _ptr = &_fail_glScissorIndexedv;
    }
    _glScissorIndexedv = _ptr;
    _glScissorIndexedv(index, v);
}

PFN_GLSCISSORINDEXEDV _glScissorIndexedv = &_get_glScissorIndexedv;

static void APIENTRY _fail_glDepthRangeArrayv(GLuint first, GLsizei count, const GLdouble * v) {
    const char *_name = "glDepthRangeArrayv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDepthRangeArrayv(GLuint first, GLsizei count, const GLdouble * v) {
    PFN_GLDEPTHRANGEARRAYV _ptr;
    _ptr = (PFN_GLDEPTHRANGEARRAYV)_getPrivateProcAddress("glDepthRangeArrayv");
    if (!_ptr) {
        _ptr = &_fail_glDepthRangeArrayv;
    }
    _glDepthRangeArrayv = _ptr;
    _glDepthRangeArrayv(first, count, v);
}

PFN_GLDEPTHRANGEARRAYV _glDepthRangeArrayv = &_get_glDepthRangeArrayv;

static void APIENTRY _fail_glDepthRangeIndexed(GLuint index, GLdouble n, GLdouble f) {
    const char *_name = "glDepthRangeIndexed";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDepthRangeIndexed(GLuint index, GLdouble n, GLdouble f) {
    PFN_GLDEPTHRANGEINDEXED _ptr;
    _ptr = (PFN_GLDEPTHRANGEINDEXED)_getPrivateProcAddress("glDepthRangeIndexed");
    if (!_ptr) {
        _ptr = &_fail_glDepthRangeIndexed;
    }
    _glDepthRangeIndexed = _ptr;
    _glDepthRangeIndexed(index, n, f);
}

PFN_GLDEPTHRANGEINDEXED _glDepthRangeIndexed = &_get_glDepthRangeIndexed;

static void APIENTRY _fail_glGetFloati_v(GLenum target, GLuint index, GLfloat * data) {
    const char *_name = "glGetFloati_v";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFloati_v(GLenum target, GLuint index, GLfloat * data) {
    PFN_GLGETFLOATI_V _ptr;
    _ptr = (PFN_GLGETFLOATI_V)_getPrivateProcAddress("glGetFloati_v");
    if (!_ptr) {
        _ptr = &_fail_glGetFloati_v;
    }
    _glGetFloati_v = _ptr;
    _glGetFloati_v(target, index, data);
}

PFN_GLGETFLOATI_V _glGetFloati_v = &_get_glGetFloati_v;

static void APIENTRY _fail_glGetDoublei_v(GLenum target, GLuint index, GLdouble * data) {
    const char *_name = "glGetDoublei_v";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetDoublei_v(GLenum target, GLuint index, GLdouble * data) {
    PFN_GLGETDOUBLEI_V _ptr;
    _ptr = (PFN_GLGETDOUBLEI_V)_getPrivateProcAddress("glGetDoublei_v");
    if (!_ptr) {
        _ptr = &_fail_glGetDoublei_v;
    }
    _glGetDoublei_v = _ptr;
    _glGetDoublei_v(target, index, data);
}

PFN_GLGETDOUBLEI_V _glGetDoublei_v = &_get_glGetDoublei_v;

static void APIENTRY _fail_glWindowPos2dARB(GLdouble x, GLdouble y) {
    const char *_name = "glWindowPos2dARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2dARB(GLdouble x, GLdouble y) {
    PFN_GLWINDOWPOS2DARB _ptr;
    _ptr = (PFN_GLWINDOWPOS2DARB)_getPrivateProcAddress("glWindowPos2dARB");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2dARB;
    }
    _glWindowPos2dARB = _ptr;
    _glWindowPos2dARB(x, y);
}

PFN_GLWINDOWPOS2DARB _glWindowPos2dARB = &_get_glWindowPos2dARB;

static void APIENTRY _fail_glWindowPos2dvARB(const GLdouble * v) {
    const char *_name = "glWindowPos2dvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2dvARB(const GLdouble * v) {
    PFN_GLWINDOWPOS2DVARB _ptr;
    _ptr = (PFN_GLWINDOWPOS2DVARB)_getPrivateProcAddress("glWindowPos2dvARB");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2dvARB;
    }
    _glWindowPos2dvARB = _ptr;
    _glWindowPos2dvARB(v);
}

PFN_GLWINDOWPOS2DVARB _glWindowPos2dvARB = &_get_glWindowPos2dvARB;

static void APIENTRY _fail_glWindowPos2fARB(GLfloat x, GLfloat y) {
    const char *_name = "glWindowPos2fARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2fARB(GLfloat x, GLfloat y) {
    PFN_GLWINDOWPOS2FARB _ptr;
    _ptr = (PFN_GLWINDOWPOS2FARB)_getPrivateProcAddress("glWindowPos2fARB");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2fARB;
    }
    _glWindowPos2fARB = _ptr;
    _glWindowPos2fARB(x, y);
}

PFN_GLWINDOWPOS2FARB _glWindowPos2fARB = &_get_glWindowPos2fARB;

static void APIENTRY _fail_glWindowPos2fvARB(const GLfloat * v) {
    const char *_name = "glWindowPos2fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2fvARB(const GLfloat * v) {
    PFN_GLWINDOWPOS2FVARB _ptr;
    _ptr = (PFN_GLWINDOWPOS2FVARB)_getPrivateProcAddress("glWindowPos2fvARB");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2fvARB;
    }
    _glWindowPos2fvARB = _ptr;
    _glWindowPos2fvARB(v);
}

PFN_GLWINDOWPOS2FVARB _glWindowPos2fvARB = &_get_glWindowPos2fvARB;

static void APIENTRY _fail_glWindowPos2iARB(GLint x, GLint y) {
    const char *_name = "glWindowPos2iARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2iARB(GLint x, GLint y) {
    PFN_GLWINDOWPOS2IARB _ptr;
    _ptr = (PFN_GLWINDOWPOS2IARB)_getPrivateProcAddress("glWindowPos2iARB");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2iARB;
    }
    _glWindowPos2iARB = _ptr;
    _glWindowPos2iARB(x, y);
}

PFN_GLWINDOWPOS2IARB _glWindowPos2iARB = &_get_glWindowPos2iARB;

static void APIENTRY _fail_glWindowPos2ivARB(const GLint * v) {
    const char *_name = "glWindowPos2ivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2ivARB(const GLint * v) {
    PFN_GLWINDOWPOS2IVARB _ptr;
    _ptr = (PFN_GLWINDOWPOS2IVARB)_getPrivateProcAddress("glWindowPos2ivARB");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2ivARB;
    }
    _glWindowPos2ivARB = _ptr;
    _glWindowPos2ivARB(v);
}

PFN_GLWINDOWPOS2IVARB _glWindowPos2ivARB = &_get_glWindowPos2ivARB;

static void APIENTRY _fail_glWindowPos2sARB(GLshort x, GLshort y) {
    const char *_name = "glWindowPos2sARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2sARB(GLshort x, GLshort y) {
    PFN_GLWINDOWPOS2SARB _ptr;
    _ptr = (PFN_GLWINDOWPOS2SARB)_getPrivateProcAddress("glWindowPos2sARB");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2sARB;
    }
    _glWindowPos2sARB = _ptr;
    _glWindowPos2sARB(x, y);
}

PFN_GLWINDOWPOS2SARB _glWindowPos2sARB = &_get_glWindowPos2sARB;

static void APIENTRY _fail_glWindowPos2svARB(const GLshort * v) {
    const char *_name = "glWindowPos2svARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2svARB(const GLshort * v) {
    PFN_GLWINDOWPOS2SVARB _ptr;
    _ptr = (PFN_GLWINDOWPOS2SVARB)_getPrivateProcAddress("glWindowPos2svARB");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2svARB;
    }
    _glWindowPos2svARB = _ptr;
    _glWindowPos2svARB(v);
}

PFN_GLWINDOWPOS2SVARB _glWindowPos2svARB = &_get_glWindowPos2svARB;

static void APIENTRY _fail_glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glWindowPos3dARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLWINDOWPOS3DARB _ptr;
    _ptr = (PFN_GLWINDOWPOS3DARB)_getPrivateProcAddress("glWindowPos3dARB");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3dARB;
    }
    _glWindowPos3dARB = _ptr;
    _glWindowPos3dARB(x, y, z);
}

PFN_GLWINDOWPOS3DARB _glWindowPos3dARB = &_get_glWindowPos3dARB;

static void APIENTRY _fail_glWindowPos3dvARB(const GLdouble * v) {
    const char *_name = "glWindowPos3dvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3dvARB(const GLdouble * v) {
    PFN_GLWINDOWPOS3DVARB _ptr;
    _ptr = (PFN_GLWINDOWPOS3DVARB)_getPrivateProcAddress("glWindowPos3dvARB");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3dvARB;
    }
    _glWindowPos3dvARB = _ptr;
    _glWindowPos3dvARB(v);
}

PFN_GLWINDOWPOS3DVARB _glWindowPos3dvARB = &_get_glWindowPos3dvARB;

static void APIENTRY _fail_glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glWindowPos3fARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLWINDOWPOS3FARB _ptr;
    _ptr = (PFN_GLWINDOWPOS3FARB)_getPrivateProcAddress("glWindowPos3fARB");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3fARB;
    }
    _glWindowPos3fARB = _ptr;
    _glWindowPos3fARB(x, y, z);
}

PFN_GLWINDOWPOS3FARB _glWindowPos3fARB = &_get_glWindowPos3fARB;

static void APIENTRY _fail_glWindowPos3fvARB(const GLfloat * v) {
    const char *_name = "glWindowPos3fvARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3fvARB(const GLfloat * v) {
    PFN_GLWINDOWPOS3FVARB _ptr;
    _ptr = (PFN_GLWINDOWPOS3FVARB)_getPrivateProcAddress("glWindowPos3fvARB");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3fvARB;
    }
    _glWindowPos3fvARB = _ptr;
    _glWindowPos3fvARB(v);
}

PFN_GLWINDOWPOS3FVARB _glWindowPos3fvARB = &_get_glWindowPos3fvARB;

static void APIENTRY _fail_glWindowPos3iARB(GLint x, GLint y, GLint z) {
    const char *_name = "glWindowPos3iARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3iARB(GLint x, GLint y, GLint z) {
    PFN_GLWINDOWPOS3IARB _ptr;
    _ptr = (PFN_GLWINDOWPOS3IARB)_getPrivateProcAddress("glWindowPos3iARB");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3iARB;
    }
    _glWindowPos3iARB = _ptr;
    _glWindowPos3iARB(x, y, z);
}

PFN_GLWINDOWPOS3IARB _glWindowPos3iARB = &_get_glWindowPos3iARB;

static void APIENTRY _fail_glWindowPos3ivARB(const GLint * v) {
    const char *_name = "glWindowPos3ivARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3ivARB(const GLint * v) {
    PFN_GLWINDOWPOS3IVARB _ptr;
    _ptr = (PFN_GLWINDOWPOS3IVARB)_getPrivateProcAddress("glWindowPos3ivARB");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3ivARB;
    }
    _glWindowPos3ivARB = _ptr;
    _glWindowPos3ivARB(v);
}

PFN_GLWINDOWPOS3IVARB _glWindowPos3ivARB = &_get_glWindowPos3ivARB;

static void APIENTRY _fail_glWindowPos3sARB(GLshort x, GLshort y, GLshort z) {
    const char *_name = "glWindowPos3sARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3sARB(GLshort x, GLshort y, GLshort z) {
    PFN_GLWINDOWPOS3SARB _ptr;
    _ptr = (PFN_GLWINDOWPOS3SARB)_getPrivateProcAddress("glWindowPos3sARB");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3sARB;
    }
    _glWindowPos3sARB = _ptr;
    _glWindowPos3sARB(x, y, z);
}

PFN_GLWINDOWPOS3SARB _glWindowPos3sARB = &_get_glWindowPos3sARB;

static void APIENTRY _fail_glWindowPos3svARB(const GLshort * v) {
    const char *_name = "glWindowPos3svARB";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3svARB(const GLshort * v) {
    PFN_GLWINDOWPOS3SVARB _ptr;
    _ptr = (PFN_GLWINDOWPOS3SVARB)_getPrivateProcAddress("glWindowPos3svARB");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3svARB;
    }
    _glWindowPos3svARB = _ptr;
    _glWindowPos3svARB(v);
}

PFN_GLWINDOWPOS3SVARB _glWindowPos3svARB = &_get_glWindowPos3svARB;

static void APIENTRY _fail_glDrawBuffersATI(GLsizei n, const GLenum * bufs) {
    const char *_name = "glDrawBuffersATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawBuffersATI(GLsizei n, const GLenum * bufs) {
    PFN_GLDRAWBUFFERSATI _ptr;
    _ptr = (PFN_GLDRAWBUFFERSATI)_getPrivateProcAddress("glDrawBuffersATI");
    if (!_ptr) {
        _ptr = &_fail_glDrawBuffersATI;
    }
    _glDrawBuffersATI = _ptr;
    _glDrawBuffersATI(n, bufs);
}

PFN_GLDRAWBUFFERSATI _glDrawBuffersATI = &_get_glDrawBuffersATI;

static void APIENTRY _fail_glElementPointerATI(GLenum type, const GLvoid * pointer) {
    const char *_name = "glElementPointerATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glElementPointerATI(GLenum type, const GLvoid * pointer) {
    PFN_GLELEMENTPOINTERATI _ptr;
    _ptr = (PFN_GLELEMENTPOINTERATI)_getPrivateProcAddress("glElementPointerATI");
    if (!_ptr) {
        _ptr = &_fail_glElementPointerATI;
    }
    _glElementPointerATI = _ptr;
    _glElementPointerATI(type, pointer);
}

PFN_GLELEMENTPOINTERATI _glElementPointerATI = &_get_glElementPointerATI;

static void APIENTRY _fail_glDrawElementArrayATI(GLenum mode, GLsizei count) {
    const char *_name = "glDrawElementArrayATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawElementArrayATI(GLenum mode, GLsizei count) {
    PFN_GLDRAWELEMENTARRAYATI _ptr;
    _ptr = (PFN_GLDRAWELEMENTARRAYATI)_getPrivateProcAddress("glDrawElementArrayATI");
    if (!_ptr) {
        _ptr = &_fail_glDrawElementArrayATI;
    }
    _glDrawElementArrayATI = _ptr;
    _glDrawElementArrayATI(mode, count);
}

PFN_GLDRAWELEMENTARRAYATI _glDrawElementArrayATI = &_get_glDrawElementArrayATI;

static void APIENTRY _fail_glDrawRangeElementArrayATI(GLenum mode, GLuint start, GLuint end, GLsizei count) {
    const char *_name = "glDrawRangeElementArrayATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawRangeElementArrayATI(GLenum mode, GLuint start, GLuint end, GLsizei count) {
    PFN_GLDRAWRANGEELEMENTARRAYATI _ptr;
    _ptr = (PFN_GLDRAWRANGEELEMENTARRAYATI)_getPrivateProcAddress("glDrawRangeElementArrayATI");
    if (!_ptr) {
        _ptr = &_fail_glDrawRangeElementArrayATI;
    }
    _glDrawRangeElementArrayATI = _ptr;
    _glDrawRangeElementArrayATI(mode, start, end, count);
}

PFN_GLDRAWRANGEELEMENTARRAYATI _glDrawRangeElementArrayATI = &_get_glDrawRangeElementArrayATI;

static void APIENTRY _fail_glTexBumpParameterivATI(GLenum pname, const GLint * param) {
    const char *_name = "glTexBumpParameterivATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexBumpParameterivATI(GLenum pname, const GLint * param) {
    PFN_GLTEXBUMPPARAMETERIVATI _ptr;
    _ptr = (PFN_GLTEXBUMPPARAMETERIVATI)_getPrivateProcAddress("glTexBumpParameterivATI");
    if (!_ptr) {
        _ptr = &_fail_glTexBumpParameterivATI;
    }
    _glTexBumpParameterivATI = _ptr;
    _glTexBumpParameterivATI(pname, param);
}

PFN_GLTEXBUMPPARAMETERIVATI _glTexBumpParameterivATI = &_get_glTexBumpParameterivATI;

static void APIENTRY _fail_glTexBumpParameterfvATI(GLenum pname, const GLfloat * param) {
    const char *_name = "glTexBumpParameterfvATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexBumpParameterfvATI(GLenum pname, const GLfloat * param) {
    PFN_GLTEXBUMPPARAMETERFVATI _ptr;
    _ptr = (PFN_GLTEXBUMPPARAMETERFVATI)_getPrivateProcAddress("glTexBumpParameterfvATI");
    if (!_ptr) {
        _ptr = &_fail_glTexBumpParameterfvATI;
    }
    _glTexBumpParameterfvATI = _ptr;
    _glTexBumpParameterfvATI(pname, param);
}

PFN_GLTEXBUMPPARAMETERFVATI _glTexBumpParameterfvATI = &_get_glTexBumpParameterfvATI;

static void APIENTRY _fail_glGetTexBumpParameterivATI(GLenum pname, GLint * param) {
    const char *_name = "glGetTexBumpParameterivATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexBumpParameterivATI(GLenum pname, GLint * param) {
    PFN_GLGETTEXBUMPPARAMETERIVATI _ptr;
    _ptr = (PFN_GLGETTEXBUMPPARAMETERIVATI)_getPrivateProcAddress("glGetTexBumpParameterivATI");
    if (!_ptr) {
        _ptr = &_fail_glGetTexBumpParameterivATI;
    }
    _glGetTexBumpParameterivATI = _ptr;
    _glGetTexBumpParameterivATI(pname, param);
}

PFN_GLGETTEXBUMPPARAMETERIVATI _glGetTexBumpParameterivATI = &_get_glGetTexBumpParameterivATI;

static void APIENTRY _fail_glGetTexBumpParameterfvATI(GLenum pname, GLfloat * param) {
    const char *_name = "glGetTexBumpParameterfvATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexBumpParameterfvATI(GLenum pname, GLfloat * param) {
    PFN_GLGETTEXBUMPPARAMETERFVATI _ptr;
    _ptr = (PFN_GLGETTEXBUMPPARAMETERFVATI)_getPrivateProcAddress("glGetTexBumpParameterfvATI");
    if (!_ptr) {
        _ptr = &_fail_glGetTexBumpParameterfvATI;
    }
    _glGetTexBumpParameterfvATI = _ptr;
    _glGetTexBumpParameterfvATI(pname, param);
}

PFN_GLGETTEXBUMPPARAMETERFVATI _glGetTexBumpParameterfvATI = &_get_glGetTexBumpParameterfvATI;

static GLuint APIENTRY _fail_glGenFragmentShadersATI(GLuint range) {
    const char *_name = "glGenFragmentShadersATI";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glGenFragmentShadersATI(GLuint range) {
    PFN_GLGENFRAGMENTSHADERSATI _ptr;
    _ptr = (PFN_GLGENFRAGMENTSHADERSATI)_getPrivateProcAddress("glGenFragmentShadersATI");
    if (!_ptr) {
        _ptr = &_fail_glGenFragmentShadersATI;
    }
    _glGenFragmentShadersATI = _ptr;
    return _glGenFragmentShadersATI(range);
}

PFN_GLGENFRAGMENTSHADERSATI _glGenFragmentShadersATI = &_get_glGenFragmentShadersATI;

static void APIENTRY _fail_glBindFragmentShaderATI(GLuint id) {
    const char *_name = "glBindFragmentShaderATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindFragmentShaderATI(GLuint id) {
    PFN_GLBINDFRAGMENTSHADERATI _ptr;
    _ptr = (PFN_GLBINDFRAGMENTSHADERATI)_getPrivateProcAddress("glBindFragmentShaderATI");
    if (!_ptr) {
        _ptr = &_fail_glBindFragmentShaderATI;
    }
    _glBindFragmentShaderATI = _ptr;
    _glBindFragmentShaderATI(id);
}

PFN_GLBINDFRAGMENTSHADERATI _glBindFragmentShaderATI = &_get_glBindFragmentShaderATI;

static void APIENTRY _fail_glDeleteFragmentShaderATI(GLuint id) {
    const char *_name = "glDeleteFragmentShaderATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteFragmentShaderATI(GLuint id) {
    PFN_GLDELETEFRAGMENTSHADERATI _ptr;
    _ptr = (PFN_GLDELETEFRAGMENTSHADERATI)_getPrivateProcAddress("glDeleteFragmentShaderATI");
    if (!_ptr) {
        _ptr = &_fail_glDeleteFragmentShaderATI;
    }
    _glDeleteFragmentShaderATI = _ptr;
    _glDeleteFragmentShaderATI(id);
}

PFN_GLDELETEFRAGMENTSHADERATI _glDeleteFragmentShaderATI = &_get_glDeleteFragmentShaderATI;

static void APIENTRY _fail_glBeginFragmentShaderATI(void) {
    const char *_name = "glBeginFragmentShaderATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBeginFragmentShaderATI(void) {
    PFN_GLBEGINFRAGMENTSHADERATI _ptr;
    _ptr = (PFN_GLBEGINFRAGMENTSHADERATI)_getPrivateProcAddress("glBeginFragmentShaderATI");
    if (!_ptr) {
        _ptr = &_fail_glBeginFragmentShaderATI;
    }
    _glBeginFragmentShaderATI = _ptr;
    _glBeginFragmentShaderATI();
}

PFN_GLBEGINFRAGMENTSHADERATI _glBeginFragmentShaderATI = &_get_glBeginFragmentShaderATI;

static void APIENTRY _fail_glEndFragmentShaderATI(void) {
    const char *_name = "glEndFragmentShaderATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEndFragmentShaderATI(void) {
    PFN_GLENDFRAGMENTSHADERATI _ptr;
    _ptr = (PFN_GLENDFRAGMENTSHADERATI)_getPrivateProcAddress("glEndFragmentShaderATI");
    if (!_ptr) {
        _ptr = &_fail_glEndFragmentShaderATI;
    }
    _glEndFragmentShaderATI = _ptr;
    _glEndFragmentShaderATI();
}

PFN_GLENDFRAGMENTSHADERATI _glEndFragmentShaderATI = &_get_glEndFragmentShaderATI;

static void APIENTRY _fail_glPassTexCoordATI(GLuint dst, GLuint coord, GLenum swizzle) {
    const char *_name = "glPassTexCoordATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPassTexCoordATI(GLuint dst, GLuint coord, GLenum swizzle) {
    PFN_GLPASSTEXCOORDATI _ptr;
    _ptr = (PFN_GLPASSTEXCOORDATI)_getPrivateProcAddress("glPassTexCoordATI");
    if (!_ptr) {
        _ptr = &_fail_glPassTexCoordATI;
    }
    _glPassTexCoordATI = _ptr;
    _glPassTexCoordATI(dst, coord, swizzle);
}

PFN_GLPASSTEXCOORDATI _glPassTexCoordATI = &_get_glPassTexCoordATI;

static void APIENTRY _fail_glSampleMapATI(GLuint dst, GLuint interp, GLenum swizzle) {
    const char *_name = "glSampleMapATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSampleMapATI(GLuint dst, GLuint interp, GLenum swizzle) {
    PFN_GLSAMPLEMAPATI _ptr;
    _ptr = (PFN_GLSAMPLEMAPATI)_getPrivateProcAddress("glSampleMapATI");
    if (!_ptr) {
        _ptr = &_fail_glSampleMapATI;
    }
    _glSampleMapATI = _ptr;
    _glSampleMapATI(dst, interp, swizzle);
}

PFN_GLSAMPLEMAPATI _glSampleMapATI = &_get_glSampleMapATI;

static void APIENTRY _fail_glColorFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod) {
    const char *_name = "glColorFragmentOp1ATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod) {
    PFN_GLCOLORFRAGMENTOP1ATI _ptr;
    _ptr = (PFN_GLCOLORFRAGMENTOP1ATI)_getPrivateProcAddress("glColorFragmentOp1ATI");
    if (!_ptr) {
        _ptr = &_fail_glColorFragmentOp1ATI;
    }
    _glColorFragmentOp1ATI = _ptr;
    _glColorFragmentOp1ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
}

PFN_GLCOLORFRAGMENTOP1ATI _glColorFragmentOp1ATI = &_get_glColorFragmentOp1ATI;

static void APIENTRY _fail_glColorFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod) {
    const char *_name = "glColorFragmentOp2ATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod) {
    PFN_GLCOLORFRAGMENTOP2ATI _ptr;
    _ptr = (PFN_GLCOLORFRAGMENTOP2ATI)_getPrivateProcAddress("glColorFragmentOp2ATI");
    if (!_ptr) {
        _ptr = &_fail_glColorFragmentOp2ATI;
    }
    _glColorFragmentOp2ATI = _ptr;
    _glColorFragmentOp2ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
}

PFN_GLCOLORFRAGMENTOP2ATI _glColorFragmentOp2ATI = &_get_glColorFragmentOp2ATI;

static void APIENTRY _fail_glColorFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod) {
    const char *_name = "glColorFragmentOp3ATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod) {
    PFN_GLCOLORFRAGMENTOP3ATI _ptr;
    _ptr = (PFN_GLCOLORFRAGMENTOP3ATI)_getPrivateProcAddress("glColorFragmentOp3ATI");
    if (!_ptr) {
        _ptr = &_fail_glColorFragmentOp3ATI;
    }
    _glColorFragmentOp3ATI = _ptr;
    _glColorFragmentOp3ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
}

PFN_GLCOLORFRAGMENTOP3ATI _glColorFragmentOp3ATI = &_get_glColorFragmentOp3ATI;

static void APIENTRY _fail_glAlphaFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod) {
    const char *_name = "glAlphaFragmentOp1ATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glAlphaFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod) {
    PFN_GLALPHAFRAGMENTOP1ATI _ptr;
    _ptr = (PFN_GLALPHAFRAGMENTOP1ATI)_getPrivateProcAddress("glAlphaFragmentOp1ATI");
    if (!_ptr) {
        _ptr = &_fail_glAlphaFragmentOp1ATI;
    }
    _glAlphaFragmentOp1ATI = _ptr;
    _glAlphaFragmentOp1ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
}

PFN_GLALPHAFRAGMENTOP1ATI _glAlphaFragmentOp1ATI = &_get_glAlphaFragmentOp1ATI;

static void APIENTRY _fail_glAlphaFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod) {
    const char *_name = "glAlphaFragmentOp2ATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glAlphaFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod) {
    PFN_GLALPHAFRAGMENTOP2ATI _ptr;
    _ptr = (PFN_GLALPHAFRAGMENTOP2ATI)_getPrivateProcAddress("glAlphaFragmentOp2ATI");
    if (!_ptr) {
        _ptr = &_fail_glAlphaFragmentOp2ATI;
    }
    _glAlphaFragmentOp2ATI = _ptr;
    _glAlphaFragmentOp2ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
}

PFN_GLALPHAFRAGMENTOP2ATI _glAlphaFragmentOp2ATI = &_get_glAlphaFragmentOp2ATI;

static void APIENTRY _fail_glAlphaFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod) {
    const char *_name = "glAlphaFragmentOp3ATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glAlphaFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod) {
    PFN_GLALPHAFRAGMENTOP3ATI _ptr;
    _ptr = (PFN_GLALPHAFRAGMENTOP3ATI)_getPrivateProcAddress("glAlphaFragmentOp3ATI");
    if (!_ptr) {
        _ptr = &_fail_glAlphaFragmentOp3ATI;
    }
    _glAlphaFragmentOp3ATI = _ptr;
    _glAlphaFragmentOp3ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
}

PFN_GLALPHAFRAGMENTOP3ATI _glAlphaFragmentOp3ATI = &_get_glAlphaFragmentOp3ATI;

static void APIENTRY _fail_glSetFragmentShaderConstantATI(GLuint dst, const GLfloat * value) {
    const char *_name = "glSetFragmentShaderConstantATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSetFragmentShaderConstantATI(GLuint dst, const GLfloat * value) {
    PFN_GLSETFRAGMENTSHADERCONSTANTATI _ptr;
    _ptr = (PFN_GLSETFRAGMENTSHADERCONSTANTATI)_getPrivateProcAddress("glSetFragmentShaderConstantATI");
    if (!_ptr) {
        _ptr = &_fail_glSetFragmentShaderConstantATI;
    }
    _glSetFragmentShaderConstantATI = _ptr;
    _glSetFragmentShaderConstantATI(dst, value);
}

PFN_GLSETFRAGMENTSHADERCONSTANTATI _glSetFragmentShaderConstantATI = &_get_glSetFragmentShaderConstantATI;

static GLvoid * APIENTRY _fail_glMapObjectBufferATI(GLuint buffer) {
    const char *_name = "glMapObjectBufferATI";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLvoid * APIENTRY _get_glMapObjectBufferATI(GLuint buffer) {
    PFN_GLMAPOBJECTBUFFERATI _ptr;
    _ptr = (PFN_GLMAPOBJECTBUFFERATI)_getPrivateProcAddress("glMapObjectBufferATI");
    if (!_ptr) {
        _ptr = &_fail_glMapObjectBufferATI;
    }
    _glMapObjectBufferATI = _ptr;
    return _glMapObjectBufferATI(buffer);
}

PFN_GLMAPOBJECTBUFFERATI _glMapObjectBufferATI = &_get_glMapObjectBufferATI;

static void APIENTRY _fail_glUnmapObjectBufferATI(GLuint buffer) {
    const char *_name = "glUnmapObjectBufferATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUnmapObjectBufferATI(GLuint buffer) {
    PFN_GLUNMAPOBJECTBUFFERATI _ptr;
    _ptr = (PFN_GLUNMAPOBJECTBUFFERATI)_getPrivateProcAddress("glUnmapObjectBufferATI");
    if (!_ptr) {
        _ptr = &_fail_glUnmapObjectBufferATI;
    }
    _glUnmapObjectBufferATI = _ptr;
    _glUnmapObjectBufferATI(buffer);
}

PFN_GLUNMAPOBJECTBUFFERATI _glUnmapObjectBufferATI = &_get_glUnmapObjectBufferATI;

static void APIENTRY _fail_glPNTrianglesiATI(GLenum pname, GLint param) {
    const char *_name = "glPNTrianglesiATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPNTrianglesiATI(GLenum pname, GLint param) {
    PFN_GLPNTRIANGLESIATI _ptr;
    _ptr = (PFN_GLPNTRIANGLESIATI)_getPrivateProcAddress("glPNTrianglesiATI");
    if (!_ptr) {
        _ptr = &_fail_glPNTrianglesiATI;
    }
    _glPNTrianglesiATI = _ptr;
    _glPNTrianglesiATI(pname, param);
}

PFN_GLPNTRIANGLESIATI _glPNTrianglesiATI = &_get_glPNTrianglesiATI;

static void APIENTRY _fail_glPNTrianglesfATI(GLenum pname, GLfloat param) {
    const char *_name = "glPNTrianglesfATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPNTrianglesfATI(GLenum pname, GLfloat param) {
    PFN_GLPNTRIANGLESFATI _ptr;
    _ptr = (PFN_GLPNTRIANGLESFATI)_getPrivateProcAddress("glPNTrianglesfATI");
    if (!_ptr) {
        _ptr = &_fail_glPNTrianglesfATI;
    }
    _glPNTrianglesfATI = _ptr;
    _glPNTrianglesfATI(pname, param);
}

PFN_GLPNTRIANGLESFATI _glPNTrianglesfATI = &_get_glPNTrianglesfATI;

static void APIENTRY _fail_glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) {
    const char *_name = "glStencilOpSeparateATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) {
    PFN_GLSTENCILOPSEPARATEATI _ptr;
    _ptr = (PFN_GLSTENCILOPSEPARATEATI)_getPrivateProcAddress("glStencilOpSeparateATI");
    if (!_ptr) {
        _ptr = &_fail_glStencilOpSeparateATI;
    }
    _glStencilOpSeparateATI = _ptr;
    _glStencilOpSeparateATI(face, sfail, dpfail, dppass);
}

PFN_GLSTENCILOPSEPARATEATI _glStencilOpSeparateATI = &_get_glStencilOpSeparateATI;

static void APIENTRY _fail_glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask) {
    const char *_name = "glStencilFuncSeparateATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask) {
    PFN_GLSTENCILFUNCSEPARATEATI _ptr;
    _ptr = (PFN_GLSTENCILFUNCSEPARATEATI)_getPrivateProcAddress("glStencilFuncSeparateATI");
    if (!_ptr) {
        _ptr = &_fail_glStencilFuncSeparateATI;
    }
    _glStencilFuncSeparateATI = _ptr;
    _glStencilFuncSeparateATI(frontfunc, backfunc, ref, mask);
}

PFN_GLSTENCILFUNCSEPARATEATI _glStencilFuncSeparateATI = &_get_glStencilFuncSeparateATI;

static GLuint APIENTRY _fail_glNewObjectBufferATI(GLsizei size, const GLvoid * pointer, GLenum usage) {
    const char *_name = "glNewObjectBufferATI";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glNewObjectBufferATI(GLsizei size, const GLvoid * pointer, GLenum usage) {
    PFN_GLNEWOBJECTBUFFERATI _ptr;
    _ptr = (PFN_GLNEWOBJECTBUFFERATI)_getPrivateProcAddress("glNewObjectBufferATI");
    if (!_ptr) {
        _ptr = &_fail_glNewObjectBufferATI;
    }
    _glNewObjectBufferATI = _ptr;
    return _glNewObjectBufferATI(size, pointer, usage);
}

PFN_GLNEWOBJECTBUFFERATI _glNewObjectBufferATI = &_get_glNewObjectBufferATI;

static GLboolean APIENTRY _fail_glIsObjectBufferATI(GLuint buffer) {
    const char *_name = "glIsObjectBufferATI";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsObjectBufferATI(GLuint buffer) {
    PFN_GLISOBJECTBUFFERATI _ptr;
    _ptr = (PFN_GLISOBJECTBUFFERATI)_getPrivateProcAddress("glIsObjectBufferATI");
    if (!_ptr) {
        _ptr = &_fail_glIsObjectBufferATI;
    }
    _glIsObjectBufferATI = _ptr;
    return _glIsObjectBufferATI(buffer);
}

PFN_GLISOBJECTBUFFERATI _glIsObjectBufferATI = &_get_glIsObjectBufferATI;

static void APIENTRY _fail_glUpdateObjectBufferATI(GLuint buffer, GLuint offset, GLsizei size, const GLvoid * pointer, GLenum preserve) {
    const char *_name = "glUpdateObjectBufferATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUpdateObjectBufferATI(GLuint buffer, GLuint offset, GLsizei size, const GLvoid * pointer, GLenum preserve) {
    PFN_GLUPDATEOBJECTBUFFERATI _ptr;
    _ptr = (PFN_GLUPDATEOBJECTBUFFERATI)_getPrivateProcAddress("glUpdateObjectBufferATI");
    if (!_ptr) {
        _ptr = &_fail_glUpdateObjectBufferATI;
    }
    _glUpdateObjectBufferATI = _ptr;
    _glUpdateObjectBufferATI(buffer, offset, size, pointer, preserve);
}

PFN_GLUPDATEOBJECTBUFFERATI _glUpdateObjectBufferATI = &_get_glUpdateObjectBufferATI;

static void APIENTRY _fail_glGetObjectBufferfvATI(GLuint buffer, GLenum pname, GLfloat * params) {
    const char *_name = "glGetObjectBufferfvATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetObjectBufferfvATI(GLuint buffer, GLenum pname, GLfloat * params) {
    PFN_GLGETOBJECTBUFFERFVATI _ptr;
    _ptr = (PFN_GLGETOBJECTBUFFERFVATI)_getPrivateProcAddress("glGetObjectBufferfvATI");
    if (!_ptr) {
        _ptr = &_fail_glGetObjectBufferfvATI;
    }
    _glGetObjectBufferfvATI = _ptr;
    _glGetObjectBufferfvATI(buffer, pname, params);
}

PFN_GLGETOBJECTBUFFERFVATI _glGetObjectBufferfvATI = &_get_glGetObjectBufferfvATI;

static void APIENTRY _fail_glGetObjectBufferivATI(GLuint buffer, GLenum pname, GLint * params) {
    const char *_name = "glGetObjectBufferivATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetObjectBufferivATI(GLuint buffer, GLenum pname, GLint * params) {
    PFN_GLGETOBJECTBUFFERIVATI _ptr;
    _ptr = (PFN_GLGETOBJECTBUFFERIVATI)_getPrivateProcAddress("glGetObjectBufferivATI");
    if (!_ptr) {
        _ptr = &_fail_glGetObjectBufferivATI;
    }
    _glGetObjectBufferivATI = _ptr;
    _glGetObjectBufferivATI(buffer, pname, params);
}

PFN_GLGETOBJECTBUFFERIVATI _glGetObjectBufferivATI = &_get_glGetObjectBufferivATI;

static void APIENTRY _fail_glFreeObjectBufferATI(GLuint buffer) {
    const char *_name = "glFreeObjectBufferATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFreeObjectBufferATI(GLuint buffer) {
    PFN_GLFREEOBJECTBUFFERATI _ptr;
    _ptr = (PFN_GLFREEOBJECTBUFFERATI)_getPrivateProcAddress("glFreeObjectBufferATI");
    if (!_ptr) {
        _ptr = &_fail_glFreeObjectBufferATI;
    }
    _glFreeObjectBufferATI = _ptr;
    _glFreeObjectBufferATI(buffer);
}

PFN_GLFREEOBJECTBUFFERATI _glFreeObjectBufferATI = &_get_glFreeObjectBufferATI;

static void APIENTRY _fail_glArrayObjectATI(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset) {
    const char *_name = "glArrayObjectATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glArrayObjectATI(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset) {
    PFN_GLARRAYOBJECTATI _ptr;
    _ptr = (PFN_GLARRAYOBJECTATI)_getPrivateProcAddress("glArrayObjectATI");
    if (!_ptr) {
        _ptr = &_fail_glArrayObjectATI;
    }
    _glArrayObjectATI = _ptr;
    _glArrayObjectATI(array, size, type, stride, buffer, offset);
}

PFN_GLARRAYOBJECTATI _glArrayObjectATI = &_get_glArrayObjectATI;

static void APIENTRY _fail_glGetArrayObjectfvATI(GLenum array, GLenum pname, GLfloat * params) {
    const char *_name = "glGetArrayObjectfvATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetArrayObjectfvATI(GLenum array, GLenum pname, GLfloat * params) {
    PFN_GLGETARRAYOBJECTFVATI _ptr;
    _ptr = (PFN_GLGETARRAYOBJECTFVATI)_getPrivateProcAddress("glGetArrayObjectfvATI");
    if (!_ptr) {
        _ptr = &_fail_glGetArrayObjectfvATI;
    }
    _glGetArrayObjectfvATI = _ptr;
    _glGetArrayObjectfvATI(array, pname, params);
}

PFN_GLGETARRAYOBJECTFVATI _glGetArrayObjectfvATI = &_get_glGetArrayObjectfvATI;

static void APIENTRY _fail_glGetArrayObjectivATI(GLenum array, GLenum pname, GLint * params) {
    const char *_name = "glGetArrayObjectivATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetArrayObjectivATI(GLenum array, GLenum pname, GLint * params) {
    PFN_GLGETARRAYOBJECTIVATI _ptr;
    _ptr = (PFN_GLGETARRAYOBJECTIVATI)_getPrivateProcAddress("glGetArrayObjectivATI");
    if (!_ptr) {
        _ptr = &_fail_glGetArrayObjectivATI;
    }
    _glGetArrayObjectivATI = _ptr;
    _glGetArrayObjectivATI(array, pname, params);
}

PFN_GLGETARRAYOBJECTIVATI _glGetArrayObjectivATI = &_get_glGetArrayObjectivATI;

static void APIENTRY _fail_glVariantArrayObjectATI(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset) {
    const char *_name = "glVariantArrayObjectATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVariantArrayObjectATI(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset) {
    PFN_GLVARIANTARRAYOBJECTATI _ptr;
    _ptr = (PFN_GLVARIANTARRAYOBJECTATI)_getPrivateProcAddress("glVariantArrayObjectATI");
    if (!_ptr) {
        _ptr = &_fail_glVariantArrayObjectATI;
    }
    _glVariantArrayObjectATI = _ptr;
    _glVariantArrayObjectATI(id, type, stride, buffer, offset);
}

PFN_GLVARIANTARRAYOBJECTATI _glVariantArrayObjectATI = &_get_glVariantArrayObjectATI;

static void APIENTRY _fail_glGetVariantArrayObjectfvATI(GLuint id, GLenum pname, GLfloat * params) {
    const char *_name = "glGetVariantArrayObjectfvATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVariantArrayObjectfvATI(GLuint id, GLenum pname, GLfloat * params) {
    PFN_GLGETVARIANTARRAYOBJECTFVATI _ptr;
    _ptr = (PFN_GLGETVARIANTARRAYOBJECTFVATI)_getPrivateProcAddress("glGetVariantArrayObjectfvATI");
    if (!_ptr) {
        _ptr = &_fail_glGetVariantArrayObjectfvATI;
    }
    _glGetVariantArrayObjectfvATI = _ptr;
    _glGetVariantArrayObjectfvATI(id, pname, params);
}

PFN_GLGETVARIANTARRAYOBJECTFVATI _glGetVariantArrayObjectfvATI = &_get_glGetVariantArrayObjectfvATI;

static void APIENTRY _fail_glGetVariantArrayObjectivATI(GLuint id, GLenum pname, GLint * params) {
    const char *_name = "glGetVariantArrayObjectivATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVariantArrayObjectivATI(GLuint id, GLenum pname, GLint * params) {
    PFN_GLGETVARIANTARRAYOBJECTIVATI _ptr;
    _ptr = (PFN_GLGETVARIANTARRAYOBJECTIVATI)_getPrivateProcAddress("glGetVariantArrayObjectivATI");
    if (!_ptr) {
        _ptr = &_fail_glGetVariantArrayObjectivATI;
    }
    _glGetVariantArrayObjectivATI = _ptr;
    _glGetVariantArrayObjectivATI(id, pname, params);
}

PFN_GLGETVARIANTARRAYOBJECTIVATI _glGetVariantArrayObjectivATI = &_get_glGetVariantArrayObjectivATI;

static void APIENTRY _fail_glVertexAttribArrayObjectATI(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset) {
    const char *_name = "glVertexAttribArrayObjectATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribArrayObjectATI(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset) {
    PFN_GLVERTEXATTRIBARRAYOBJECTATI _ptr;
    _ptr = (PFN_GLVERTEXATTRIBARRAYOBJECTATI)_getPrivateProcAddress("glVertexAttribArrayObjectATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribArrayObjectATI;
    }
    _glVertexAttribArrayObjectATI = _ptr;
    _glVertexAttribArrayObjectATI(index, size, type, normalized, stride, buffer, offset);
}

PFN_GLVERTEXATTRIBARRAYOBJECTATI _glVertexAttribArrayObjectATI = &_get_glVertexAttribArrayObjectATI;

static void APIENTRY _fail_glGetVertexAttribArrayObjectfvATI(GLuint index, GLenum pname, GLfloat * params) {
    const char *_name = "glGetVertexAttribArrayObjectfvATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribArrayObjectfvATI(GLuint index, GLenum pname, GLfloat * params) {
    PFN_GLGETVERTEXATTRIBARRAYOBJECTFVATI _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBARRAYOBJECTFVATI)_getPrivateProcAddress("glGetVertexAttribArrayObjectfvATI");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribArrayObjectfvATI;
    }
    _glGetVertexAttribArrayObjectfvATI = _ptr;
    _glGetVertexAttribArrayObjectfvATI(index, pname, params);
}

PFN_GLGETVERTEXATTRIBARRAYOBJECTFVATI _glGetVertexAttribArrayObjectfvATI = &_get_glGetVertexAttribArrayObjectfvATI;

static void APIENTRY _fail_glGetVertexAttribArrayObjectivATI(GLuint index, GLenum pname, GLint * params) {
    const char *_name = "glGetVertexAttribArrayObjectivATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribArrayObjectivATI(GLuint index, GLenum pname, GLint * params) {
    PFN_GLGETVERTEXATTRIBARRAYOBJECTIVATI _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBARRAYOBJECTIVATI)_getPrivateProcAddress("glGetVertexAttribArrayObjectivATI");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribArrayObjectivATI;
    }
    _glGetVertexAttribArrayObjectivATI = _ptr;
    _glGetVertexAttribArrayObjectivATI(index, pname, params);
}

PFN_GLGETVERTEXATTRIBARRAYOBJECTIVATI _glGetVertexAttribArrayObjectivATI = &_get_glGetVertexAttribArrayObjectivATI;

static void APIENTRY _fail_glVertexStream1sATI(GLenum stream, GLshort x) {
    const char *_name = "glVertexStream1sATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream1sATI(GLenum stream, GLshort x) {
    PFN_GLVERTEXSTREAM1SATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM1SATI)_getPrivateProcAddress("glVertexStream1sATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream1sATI;
    }
    _glVertexStream1sATI = _ptr;
    _glVertexStream1sATI(stream, x);
}

PFN_GLVERTEXSTREAM1SATI _glVertexStream1sATI = &_get_glVertexStream1sATI;

static void APIENTRY _fail_glVertexStream1svATI(GLenum stream, const GLshort * coords) {
    const char *_name = "glVertexStream1svATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream1svATI(GLenum stream, const GLshort * coords) {
    PFN_GLVERTEXSTREAM1SVATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM1SVATI)_getPrivateProcAddress("glVertexStream1svATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream1svATI;
    }
    _glVertexStream1svATI = _ptr;
    _glVertexStream1svATI(stream, coords);
}

PFN_GLVERTEXSTREAM1SVATI _glVertexStream1svATI = &_get_glVertexStream1svATI;

static void APIENTRY _fail_glVertexStream1iATI(GLenum stream, GLint x) {
    const char *_name = "glVertexStream1iATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream1iATI(GLenum stream, GLint x) {
    PFN_GLVERTEXSTREAM1IATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM1IATI)_getPrivateProcAddress("glVertexStream1iATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream1iATI;
    }
    _glVertexStream1iATI = _ptr;
    _glVertexStream1iATI(stream, x);
}

PFN_GLVERTEXSTREAM1IATI _glVertexStream1iATI = &_get_glVertexStream1iATI;

static void APIENTRY _fail_glVertexStream1ivATI(GLenum stream, const GLint * coords) {
    const char *_name = "glVertexStream1ivATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream1ivATI(GLenum stream, const GLint * coords) {
    PFN_GLVERTEXSTREAM1IVATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM1IVATI)_getPrivateProcAddress("glVertexStream1ivATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream1ivATI;
    }
    _glVertexStream1ivATI = _ptr;
    _glVertexStream1ivATI(stream, coords);
}

PFN_GLVERTEXSTREAM1IVATI _glVertexStream1ivATI = &_get_glVertexStream1ivATI;

static void APIENTRY _fail_glVertexStream1fATI(GLenum stream, GLfloat x) {
    const char *_name = "glVertexStream1fATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream1fATI(GLenum stream, GLfloat x) {
    PFN_GLVERTEXSTREAM1FATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM1FATI)_getPrivateProcAddress("glVertexStream1fATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream1fATI;
    }
    _glVertexStream1fATI = _ptr;
    _glVertexStream1fATI(stream, x);
}

PFN_GLVERTEXSTREAM1FATI _glVertexStream1fATI = &_get_glVertexStream1fATI;

static void APIENTRY _fail_glVertexStream1fvATI(GLenum stream, const GLfloat * coords) {
    const char *_name = "glVertexStream1fvATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream1fvATI(GLenum stream, const GLfloat * coords) {
    PFN_GLVERTEXSTREAM1FVATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM1FVATI)_getPrivateProcAddress("glVertexStream1fvATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream1fvATI;
    }
    _glVertexStream1fvATI = _ptr;
    _glVertexStream1fvATI(stream, coords);
}

PFN_GLVERTEXSTREAM1FVATI _glVertexStream1fvATI = &_get_glVertexStream1fvATI;

static void APIENTRY _fail_glVertexStream1dATI(GLenum stream, GLdouble x) {
    const char *_name = "glVertexStream1dATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream1dATI(GLenum stream, GLdouble x) {
    PFN_GLVERTEXSTREAM1DATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM1DATI)_getPrivateProcAddress("glVertexStream1dATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream1dATI;
    }
    _glVertexStream1dATI = _ptr;
    _glVertexStream1dATI(stream, x);
}

PFN_GLVERTEXSTREAM1DATI _glVertexStream1dATI = &_get_glVertexStream1dATI;

static void APIENTRY _fail_glVertexStream1dvATI(GLenum stream, const GLdouble * coords) {
    const char *_name = "glVertexStream1dvATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream1dvATI(GLenum stream, const GLdouble * coords) {
    PFN_GLVERTEXSTREAM1DVATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM1DVATI)_getPrivateProcAddress("glVertexStream1dvATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream1dvATI;
    }
    _glVertexStream1dvATI = _ptr;
    _glVertexStream1dvATI(stream, coords);
}

PFN_GLVERTEXSTREAM1DVATI _glVertexStream1dvATI = &_get_glVertexStream1dvATI;

static void APIENTRY _fail_glVertexStream2sATI(GLenum stream, GLshort x, GLshort y) {
    const char *_name = "glVertexStream2sATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream2sATI(GLenum stream, GLshort x, GLshort y) {
    PFN_GLVERTEXSTREAM2SATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM2SATI)_getPrivateProcAddress("glVertexStream2sATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream2sATI;
    }
    _glVertexStream2sATI = _ptr;
    _glVertexStream2sATI(stream, x, y);
}

PFN_GLVERTEXSTREAM2SATI _glVertexStream2sATI = &_get_glVertexStream2sATI;

static void APIENTRY _fail_glVertexStream2svATI(GLenum stream, const GLshort * coords) {
    const char *_name = "glVertexStream2svATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream2svATI(GLenum stream, const GLshort * coords) {
    PFN_GLVERTEXSTREAM2SVATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM2SVATI)_getPrivateProcAddress("glVertexStream2svATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream2svATI;
    }
    _glVertexStream2svATI = _ptr;
    _glVertexStream2svATI(stream, coords);
}

PFN_GLVERTEXSTREAM2SVATI _glVertexStream2svATI = &_get_glVertexStream2svATI;

static void APIENTRY _fail_glVertexStream2iATI(GLenum stream, GLint x, GLint y) {
    const char *_name = "glVertexStream2iATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream2iATI(GLenum stream, GLint x, GLint y) {
    PFN_GLVERTEXSTREAM2IATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM2IATI)_getPrivateProcAddress("glVertexStream2iATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream2iATI;
    }
    _glVertexStream2iATI = _ptr;
    _glVertexStream2iATI(stream, x, y);
}

PFN_GLVERTEXSTREAM2IATI _glVertexStream2iATI = &_get_glVertexStream2iATI;

static void APIENTRY _fail_glVertexStream2ivATI(GLenum stream, const GLint * coords) {
    const char *_name = "glVertexStream2ivATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream2ivATI(GLenum stream, const GLint * coords) {
    PFN_GLVERTEXSTREAM2IVATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM2IVATI)_getPrivateProcAddress("glVertexStream2ivATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream2ivATI;
    }
    _glVertexStream2ivATI = _ptr;
    _glVertexStream2ivATI(stream, coords);
}

PFN_GLVERTEXSTREAM2IVATI _glVertexStream2ivATI = &_get_glVertexStream2ivATI;

static void APIENTRY _fail_glVertexStream2fATI(GLenum stream, GLfloat x, GLfloat y) {
    const char *_name = "glVertexStream2fATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream2fATI(GLenum stream, GLfloat x, GLfloat y) {
    PFN_GLVERTEXSTREAM2FATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM2FATI)_getPrivateProcAddress("glVertexStream2fATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream2fATI;
    }
    _glVertexStream2fATI = _ptr;
    _glVertexStream2fATI(stream, x, y);
}

PFN_GLVERTEXSTREAM2FATI _glVertexStream2fATI = &_get_glVertexStream2fATI;

static void APIENTRY _fail_glVertexStream2fvATI(GLenum stream, const GLfloat * coords) {
    const char *_name = "glVertexStream2fvATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream2fvATI(GLenum stream, const GLfloat * coords) {
    PFN_GLVERTEXSTREAM2FVATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM2FVATI)_getPrivateProcAddress("glVertexStream2fvATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream2fvATI;
    }
    _glVertexStream2fvATI = _ptr;
    _glVertexStream2fvATI(stream, coords);
}

PFN_GLVERTEXSTREAM2FVATI _glVertexStream2fvATI = &_get_glVertexStream2fvATI;

static void APIENTRY _fail_glVertexStream2dATI(GLenum stream, GLdouble x, GLdouble y) {
    const char *_name = "glVertexStream2dATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream2dATI(GLenum stream, GLdouble x, GLdouble y) {
    PFN_GLVERTEXSTREAM2DATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM2DATI)_getPrivateProcAddress("glVertexStream2dATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream2dATI;
    }
    _glVertexStream2dATI = _ptr;
    _glVertexStream2dATI(stream, x, y);
}

PFN_GLVERTEXSTREAM2DATI _glVertexStream2dATI = &_get_glVertexStream2dATI;

static void APIENTRY _fail_glVertexStream2dvATI(GLenum stream, const GLdouble * coords) {
    const char *_name = "glVertexStream2dvATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream2dvATI(GLenum stream, const GLdouble * coords) {
    PFN_GLVERTEXSTREAM2DVATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM2DVATI)_getPrivateProcAddress("glVertexStream2dvATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream2dvATI;
    }
    _glVertexStream2dvATI = _ptr;
    _glVertexStream2dvATI(stream, coords);
}

PFN_GLVERTEXSTREAM2DVATI _glVertexStream2dvATI = &_get_glVertexStream2dvATI;

static void APIENTRY _fail_glVertexStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z) {
    const char *_name = "glVertexStream3sATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z) {
    PFN_GLVERTEXSTREAM3SATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM3SATI)_getPrivateProcAddress("glVertexStream3sATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream3sATI;
    }
    _glVertexStream3sATI = _ptr;
    _glVertexStream3sATI(stream, x, y, z);
}

PFN_GLVERTEXSTREAM3SATI _glVertexStream3sATI = &_get_glVertexStream3sATI;

static void APIENTRY _fail_glVertexStream3svATI(GLenum stream, const GLshort * coords) {
    const char *_name = "glVertexStream3svATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream3svATI(GLenum stream, const GLshort * coords) {
    PFN_GLVERTEXSTREAM3SVATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM3SVATI)_getPrivateProcAddress("glVertexStream3svATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream3svATI;
    }
    _glVertexStream3svATI = _ptr;
    _glVertexStream3svATI(stream, coords);
}

PFN_GLVERTEXSTREAM3SVATI _glVertexStream3svATI = &_get_glVertexStream3svATI;

static void APIENTRY _fail_glVertexStream3iATI(GLenum stream, GLint x, GLint y, GLint z) {
    const char *_name = "glVertexStream3iATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream3iATI(GLenum stream, GLint x, GLint y, GLint z) {
    PFN_GLVERTEXSTREAM3IATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM3IATI)_getPrivateProcAddress("glVertexStream3iATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream3iATI;
    }
    _glVertexStream3iATI = _ptr;
    _glVertexStream3iATI(stream, x, y, z);
}

PFN_GLVERTEXSTREAM3IATI _glVertexStream3iATI = &_get_glVertexStream3iATI;

static void APIENTRY _fail_glVertexStream3ivATI(GLenum stream, const GLint * coords) {
    const char *_name = "glVertexStream3ivATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream3ivATI(GLenum stream, const GLint * coords) {
    PFN_GLVERTEXSTREAM3IVATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM3IVATI)_getPrivateProcAddress("glVertexStream3ivATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream3ivATI;
    }
    _glVertexStream3ivATI = _ptr;
    _glVertexStream3ivATI(stream, coords);
}

PFN_GLVERTEXSTREAM3IVATI _glVertexStream3ivATI = &_get_glVertexStream3ivATI;

static void APIENTRY _fail_glVertexStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glVertexStream3fATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLVERTEXSTREAM3FATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM3FATI)_getPrivateProcAddress("glVertexStream3fATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream3fATI;
    }
    _glVertexStream3fATI = _ptr;
    _glVertexStream3fATI(stream, x, y, z);
}

PFN_GLVERTEXSTREAM3FATI _glVertexStream3fATI = &_get_glVertexStream3fATI;

static void APIENTRY _fail_glVertexStream3fvATI(GLenum stream, const GLfloat * coords) {
    const char *_name = "glVertexStream3fvATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream3fvATI(GLenum stream, const GLfloat * coords) {
    PFN_GLVERTEXSTREAM3FVATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM3FVATI)_getPrivateProcAddress("glVertexStream3fvATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream3fvATI;
    }
    _glVertexStream3fvATI = _ptr;
    _glVertexStream3fvATI(stream, coords);
}

PFN_GLVERTEXSTREAM3FVATI _glVertexStream3fvATI = &_get_glVertexStream3fvATI;

static void APIENTRY _fail_glVertexStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glVertexStream3dATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLVERTEXSTREAM3DATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM3DATI)_getPrivateProcAddress("glVertexStream3dATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream3dATI;
    }
    _glVertexStream3dATI = _ptr;
    _glVertexStream3dATI(stream, x, y, z);
}

PFN_GLVERTEXSTREAM3DATI _glVertexStream3dATI = &_get_glVertexStream3dATI;

static void APIENTRY _fail_glVertexStream3dvATI(GLenum stream, const GLdouble * coords) {
    const char *_name = "glVertexStream3dvATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream3dvATI(GLenum stream, const GLdouble * coords) {
    PFN_GLVERTEXSTREAM3DVATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM3DVATI)_getPrivateProcAddress("glVertexStream3dvATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream3dvATI;
    }
    _glVertexStream3dvATI = _ptr;
    _glVertexStream3dvATI(stream, coords);
}

PFN_GLVERTEXSTREAM3DVATI _glVertexStream3dvATI = &_get_glVertexStream3dvATI;

static void APIENTRY _fail_glVertexStream4sATI(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w) {
    const char *_name = "glVertexStream4sATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream4sATI(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w) {
    PFN_GLVERTEXSTREAM4SATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM4SATI)_getPrivateProcAddress("glVertexStream4sATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream4sATI;
    }
    _glVertexStream4sATI = _ptr;
    _glVertexStream4sATI(stream, x, y, z, w);
}

PFN_GLVERTEXSTREAM4SATI _glVertexStream4sATI = &_get_glVertexStream4sATI;

static void APIENTRY _fail_glVertexStream4svATI(GLenum stream, const GLshort * coords) {
    const char *_name = "glVertexStream4svATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream4svATI(GLenum stream, const GLshort * coords) {
    PFN_GLVERTEXSTREAM4SVATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM4SVATI)_getPrivateProcAddress("glVertexStream4svATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream4svATI;
    }
    _glVertexStream4svATI = _ptr;
    _glVertexStream4svATI(stream, coords);
}

PFN_GLVERTEXSTREAM4SVATI _glVertexStream4svATI = &_get_glVertexStream4svATI;

static void APIENTRY _fail_glVertexStream4iATI(GLenum stream, GLint x, GLint y, GLint z, GLint w) {
    const char *_name = "glVertexStream4iATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream4iATI(GLenum stream, GLint x, GLint y, GLint z, GLint w) {
    PFN_GLVERTEXSTREAM4IATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM4IATI)_getPrivateProcAddress("glVertexStream4iATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream4iATI;
    }
    _glVertexStream4iATI = _ptr;
    _glVertexStream4iATI(stream, x, y, z, w);
}

PFN_GLVERTEXSTREAM4IATI _glVertexStream4iATI = &_get_glVertexStream4iATI;

static void APIENTRY _fail_glVertexStream4ivATI(GLenum stream, const GLint * coords) {
    const char *_name = "glVertexStream4ivATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream4ivATI(GLenum stream, const GLint * coords) {
    PFN_GLVERTEXSTREAM4IVATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM4IVATI)_getPrivateProcAddress("glVertexStream4ivATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream4ivATI;
    }
    _glVertexStream4ivATI = _ptr;
    _glVertexStream4ivATI(stream, coords);
}

PFN_GLVERTEXSTREAM4IVATI _glVertexStream4ivATI = &_get_glVertexStream4ivATI;

static void APIENTRY _fail_glVertexStream4fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glVertexStream4fATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream4fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    PFN_GLVERTEXSTREAM4FATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM4FATI)_getPrivateProcAddress("glVertexStream4fATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream4fATI;
    }
    _glVertexStream4fATI = _ptr;
    _glVertexStream4fATI(stream, x, y, z, w);
}

PFN_GLVERTEXSTREAM4FATI _glVertexStream4fATI = &_get_glVertexStream4fATI;

static void APIENTRY _fail_glVertexStream4fvATI(GLenum stream, const GLfloat * coords) {
    const char *_name = "glVertexStream4fvATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream4fvATI(GLenum stream, const GLfloat * coords) {
    PFN_GLVERTEXSTREAM4FVATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM4FVATI)_getPrivateProcAddress("glVertexStream4fvATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream4fvATI;
    }
    _glVertexStream4fvATI = _ptr;
    _glVertexStream4fvATI(stream, coords);
}

PFN_GLVERTEXSTREAM4FVATI _glVertexStream4fvATI = &_get_glVertexStream4fvATI;

static void APIENTRY _fail_glVertexStream4dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glVertexStream4dATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream4dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    PFN_GLVERTEXSTREAM4DATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM4DATI)_getPrivateProcAddress("glVertexStream4dATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream4dATI;
    }
    _glVertexStream4dATI = _ptr;
    _glVertexStream4dATI(stream, x, y, z, w);
}

PFN_GLVERTEXSTREAM4DATI _glVertexStream4dATI = &_get_glVertexStream4dATI;

static void APIENTRY _fail_glVertexStream4dvATI(GLenum stream, const GLdouble * coords) {
    const char *_name = "glVertexStream4dvATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexStream4dvATI(GLenum stream, const GLdouble * coords) {
    PFN_GLVERTEXSTREAM4DVATI _ptr;
    _ptr = (PFN_GLVERTEXSTREAM4DVATI)_getPrivateProcAddress("glVertexStream4dvATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexStream4dvATI;
    }
    _glVertexStream4dvATI = _ptr;
    _glVertexStream4dvATI(stream, coords);
}

PFN_GLVERTEXSTREAM4DVATI _glVertexStream4dvATI = &_get_glVertexStream4dvATI;

static void APIENTRY _fail_glNormalStream3bATI(GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz) {
    const char *_name = "glNormalStream3bATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormalStream3bATI(GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz) {
    PFN_GLNORMALSTREAM3BATI _ptr;
    _ptr = (PFN_GLNORMALSTREAM3BATI)_getPrivateProcAddress("glNormalStream3bATI");
    if (!_ptr) {
        _ptr = &_fail_glNormalStream3bATI;
    }
    _glNormalStream3bATI = _ptr;
    _glNormalStream3bATI(stream, nx, ny, nz);
}

PFN_GLNORMALSTREAM3BATI _glNormalStream3bATI = &_get_glNormalStream3bATI;

static void APIENTRY _fail_glNormalStream3bvATI(GLenum stream, const GLbyte * coords) {
    const char *_name = "glNormalStream3bvATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormalStream3bvATI(GLenum stream, const GLbyte * coords) {
    PFN_GLNORMALSTREAM3BVATI _ptr;
    _ptr = (PFN_GLNORMALSTREAM3BVATI)_getPrivateProcAddress("glNormalStream3bvATI");
    if (!_ptr) {
        _ptr = &_fail_glNormalStream3bvATI;
    }
    _glNormalStream3bvATI = _ptr;
    _glNormalStream3bvATI(stream, coords);
}

PFN_GLNORMALSTREAM3BVATI _glNormalStream3bvATI = &_get_glNormalStream3bvATI;

static void APIENTRY _fail_glNormalStream3sATI(GLenum stream, GLshort nx, GLshort ny, GLshort nz) {
    const char *_name = "glNormalStream3sATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormalStream3sATI(GLenum stream, GLshort nx, GLshort ny, GLshort nz) {
    PFN_GLNORMALSTREAM3SATI _ptr;
    _ptr = (PFN_GLNORMALSTREAM3SATI)_getPrivateProcAddress("glNormalStream3sATI");
    if (!_ptr) {
        _ptr = &_fail_glNormalStream3sATI;
    }
    _glNormalStream3sATI = _ptr;
    _glNormalStream3sATI(stream, nx, ny, nz);
}

PFN_GLNORMALSTREAM3SATI _glNormalStream3sATI = &_get_glNormalStream3sATI;

static void APIENTRY _fail_glNormalStream3svATI(GLenum stream, const GLshort * coords) {
    const char *_name = "glNormalStream3svATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormalStream3svATI(GLenum stream, const GLshort * coords) {
    PFN_GLNORMALSTREAM3SVATI _ptr;
    _ptr = (PFN_GLNORMALSTREAM3SVATI)_getPrivateProcAddress("glNormalStream3svATI");
    if (!_ptr) {
        _ptr = &_fail_glNormalStream3svATI;
    }
    _glNormalStream3svATI = _ptr;
    _glNormalStream3svATI(stream, coords);
}

PFN_GLNORMALSTREAM3SVATI _glNormalStream3svATI = &_get_glNormalStream3svATI;

static void APIENTRY _fail_glNormalStream3iATI(GLenum stream, GLint nx, GLint ny, GLint nz) {
    const char *_name = "glNormalStream3iATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormalStream3iATI(GLenum stream, GLint nx, GLint ny, GLint nz) {
    PFN_GLNORMALSTREAM3IATI _ptr;
    _ptr = (PFN_GLNORMALSTREAM3IATI)_getPrivateProcAddress("glNormalStream3iATI");
    if (!_ptr) {
        _ptr = &_fail_glNormalStream3iATI;
    }
    _glNormalStream3iATI = _ptr;
    _glNormalStream3iATI(stream, nx, ny, nz);
}

PFN_GLNORMALSTREAM3IATI _glNormalStream3iATI = &_get_glNormalStream3iATI;

static void APIENTRY _fail_glNormalStream3ivATI(GLenum stream, const GLint * coords) {
    const char *_name = "glNormalStream3ivATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormalStream3ivATI(GLenum stream, const GLint * coords) {
    PFN_GLNORMALSTREAM3IVATI _ptr;
    _ptr = (PFN_GLNORMALSTREAM3IVATI)_getPrivateProcAddress("glNormalStream3ivATI");
    if (!_ptr) {
        _ptr = &_fail_glNormalStream3ivATI;
    }
    _glNormalStream3ivATI = _ptr;
    _glNormalStream3ivATI(stream, coords);
}

PFN_GLNORMALSTREAM3IVATI _glNormalStream3ivATI = &_get_glNormalStream3ivATI;

static void APIENTRY _fail_glNormalStream3fATI(GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz) {
    const char *_name = "glNormalStream3fATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormalStream3fATI(GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz) {
    PFN_GLNORMALSTREAM3FATI _ptr;
    _ptr = (PFN_GLNORMALSTREAM3FATI)_getPrivateProcAddress("glNormalStream3fATI");
    if (!_ptr) {
        _ptr = &_fail_glNormalStream3fATI;
    }
    _glNormalStream3fATI = _ptr;
    _glNormalStream3fATI(stream, nx, ny, nz);
}

PFN_GLNORMALSTREAM3FATI _glNormalStream3fATI = &_get_glNormalStream3fATI;

static void APIENTRY _fail_glNormalStream3fvATI(GLenum stream, const GLfloat * coords) {
    const char *_name = "glNormalStream3fvATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormalStream3fvATI(GLenum stream, const GLfloat * coords) {
    PFN_GLNORMALSTREAM3FVATI _ptr;
    _ptr = (PFN_GLNORMALSTREAM3FVATI)_getPrivateProcAddress("glNormalStream3fvATI");
    if (!_ptr) {
        _ptr = &_fail_glNormalStream3fvATI;
    }
    _glNormalStream3fvATI = _ptr;
    _glNormalStream3fvATI(stream, coords);
}

PFN_GLNORMALSTREAM3FVATI _glNormalStream3fvATI = &_get_glNormalStream3fvATI;

static void APIENTRY _fail_glNormalStream3dATI(GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz) {
    const char *_name = "glNormalStream3dATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormalStream3dATI(GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz) {
    PFN_GLNORMALSTREAM3DATI _ptr;
    _ptr = (PFN_GLNORMALSTREAM3DATI)_getPrivateProcAddress("glNormalStream3dATI");
    if (!_ptr) {
        _ptr = &_fail_glNormalStream3dATI;
    }
    _glNormalStream3dATI = _ptr;
    _glNormalStream3dATI(stream, nx, ny, nz);
}

PFN_GLNORMALSTREAM3DATI _glNormalStream3dATI = &_get_glNormalStream3dATI;

static void APIENTRY _fail_glNormalStream3dvATI(GLenum stream, const GLdouble * coords) {
    const char *_name = "glNormalStream3dvATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormalStream3dvATI(GLenum stream, const GLdouble * coords) {
    PFN_GLNORMALSTREAM3DVATI _ptr;
    _ptr = (PFN_GLNORMALSTREAM3DVATI)_getPrivateProcAddress("glNormalStream3dvATI");
    if (!_ptr) {
        _ptr = &_fail_glNormalStream3dvATI;
    }
    _glNormalStream3dvATI = _ptr;
    _glNormalStream3dvATI(stream, coords);
}

PFN_GLNORMALSTREAM3DVATI _glNormalStream3dvATI = &_get_glNormalStream3dvATI;

static void APIENTRY _fail_glClientActiveVertexStreamATI(GLenum stream) {
    const char *_name = "glClientActiveVertexStreamATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClientActiveVertexStreamATI(GLenum stream) {
    PFN_GLCLIENTACTIVEVERTEXSTREAMATI _ptr;
    _ptr = (PFN_GLCLIENTACTIVEVERTEXSTREAMATI)_getPrivateProcAddress("glClientActiveVertexStreamATI");
    if (!_ptr) {
        _ptr = &_fail_glClientActiveVertexStreamATI;
    }
    _glClientActiveVertexStreamATI = _ptr;
    _glClientActiveVertexStreamATI(stream);
}

PFN_GLCLIENTACTIVEVERTEXSTREAMATI _glClientActiveVertexStreamATI = &_get_glClientActiveVertexStreamATI;

static void APIENTRY _fail_glVertexBlendEnviATI(GLenum pname, GLint param) {
    const char *_name = "glVertexBlendEnviATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexBlendEnviATI(GLenum pname, GLint param) {
    PFN_GLVERTEXBLENDENVIATI _ptr;
    _ptr = (PFN_GLVERTEXBLENDENVIATI)_getPrivateProcAddress("glVertexBlendEnviATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexBlendEnviATI;
    }
    _glVertexBlendEnviATI = _ptr;
    _glVertexBlendEnviATI(pname, param);
}

PFN_GLVERTEXBLENDENVIATI _glVertexBlendEnviATI = &_get_glVertexBlendEnviATI;

static void APIENTRY _fail_glVertexBlendEnvfATI(GLenum pname, GLfloat param) {
    const char *_name = "glVertexBlendEnvfATI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexBlendEnvfATI(GLenum pname, GLfloat param) {
    PFN_GLVERTEXBLENDENVFATI _ptr;
    _ptr = (PFN_GLVERTEXBLENDENVFATI)_getPrivateProcAddress("glVertexBlendEnvfATI");
    if (!_ptr) {
        _ptr = &_fail_glVertexBlendEnvfATI;
    }
    _glVertexBlendEnvfATI = _ptr;
    _glVertexBlendEnvfATI(pname, param);
}

PFN_GLVERTEXBLENDENVFATI _glVertexBlendEnvfATI = &_get_glVertexBlendEnvfATI;

static void APIENTRY _fail_glUniformBufferEXT(GLuint program, GLint location, GLuint buffer) {
    const char *_name = "glUniformBufferEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformBufferEXT(GLuint program, GLint location, GLuint buffer) {
    PFN_GLUNIFORMBUFFEREXT _ptr;
    _ptr = (PFN_GLUNIFORMBUFFEREXT)_getPrivateProcAddress("glUniformBufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glUniformBufferEXT;
    }
    _glUniformBufferEXT = _ptr;
    _glUniformBufferEXT(program, location, buffer);
}

PFN_GLUNIFORMBUFFEREXT _glUniformBufferEXT = &_get_glUniformBufferEXT;

static GLint APIENTRY _fail_glGetUniformBufferSizeEXT(GLuint program, GLint location) {
    const char *_name = "glGetUniformBufferSizeEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLint APIENTRY _get_glGetUniformBufferSizeEXT(GLuint program, GLint location) {
    PFN_GLGETUNIFORMBUFFERSIZEEXT _ptr;
    _ptr = (PFN_GLGETUNIFORMBUFFERSIZEEXT)_getPrivateProcAddress("glGetUniformBufferSizeEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetUniformBufferSizeEXT;
    }
    _glGetUniformBufferSizeEXT = _ptr;
    return _glGetUniformBufferSizeEXT(program, location);
}

PFN_GLGETUNIFORMBUFFERSIZEEXT _glGetUniformBufferSizeEXT = &_get_glGetUniformBufferSizeEXT;

static GLintptr APIENTRY _fail_glGetUniformOffsetEXT(GLuint program, GLint location) {
    const char *_name = "glGetUniformOffsetEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLintptr APIENTRY _get_glGetUniformOffsetEXT(GLuint program, GLint location) {
    PFN_GLGETUNIFORMOFFSETEXT _ptr;
    _ptr = (PFN_GLGETUNIFORMOFFSETEXT)_getPrivateProcAddress("glGetUniformOffsetEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetUniformOffsetEXT;
    }
    _glGetUniformOffsetEXT = _ptr;
    return _glGetUniformOffsetEXT(program, location);
}

PFN_GLGETUNIFORMOFFSETEXT _glGetUniformOffsetEXT = &_get_glGetUniformOffsetEXT;

static void APIENTRY _fail_glBlendColorEXT(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    const char *_name = "glBlendColorEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendColorEXT(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    PFN_GLBLENDCOLOREXT _ptr;
    _ptr = (PFN_GLBLENDCOLOREXT)_getPrivateProcAddress("glBlendColorEXT");
    if (!_ptr) {
        _ptr = &_fail_glBlendColorEXT;
    }
    _glBlendColorEXT = _ptr;
    _glBlendColorEXT(red, green, blue, alpha);
}

PFN_GLBLENDCOLOREXT _glBlendColorEXT = &_get_glBlendColorEXT;

static void APIENTRY _fail_glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha) {
    const char *_name = "glBlendEquationSeparateEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha) {
    PFN_GLBLENDEQUATIONSEPARATEEXT _ptr;
    _ptr = (PFN_GLBLENDEQUATIONSEPARATEEXT)_getPrivateProcAddress("glBlendEquationSeparateEXT");
    if (!_ptr) {
        _ptr = &_fail_glBlendEquationSeparateEXT;
    }
    _glBlendEquationSeparateEXT = _ptr;
    _glBlendEquationSeparateEXT(modeRGB, modeAlpha);
}

PFN_GLBLENDEQUATIONSEPARATEEXT _glBlendEquationSeparateEXT = &_get_glBlendEquationSeparateEXT;

static void APIENTRY _fail_glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) {
    const char *_name = "glBlendFuncSeparateEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) {
    PFN_GLBLENDFUNCSEPARATEEXT _ptr;
    _ptr = (PFN_GLBLENDFUNCSEPARATEEXT)_getPrivateProcAddress("glBlendFuncSeparateEXT");
    if (!_ptr) {
        _ptr = &_fail_glBlendFuncSeparateEXT;
    }
    _glBlendFuncSeparateEXT = _ptr;
    _glBlendFuncSeparateEXT(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

PFN_GLBLENDFUNCSEPARATEEXT _glBlendFuncSeparateEXT = &_get_glBlendFuncSeparateEXT;

static void APIENTRY _fail_glBlendEquationEXT(GLenum mode) {
    const char *_name = "glBlendEquationEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendEquationEXT(GLenum mode) {
    PFN_GLBLENDEQUATIONEXT _ptr;
    _ptr = (PFN_GLBLENDEQUATIONEXT)_getPrivateProcAddress("glBlendEquationEXT");
    if (!_ptr) {
        _ptr = &_fail_glBlendEquationEXT;
    }
    _glBlendEquationEXT = _ptr;
    _glBlendEquationEXT(mode);
}

PFN_GLBLENDEQUATIONEXT _glBlendEquationEXT = &_get_glBlendEquationEXT;

static void APIENTRY _fail_glColorSubTableEXT(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data) {
    const char *_name = "glColorSubTableEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorSubTableEXT(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data) {
    PFN_GLCOLORSUBTABLEEXT _ptr;
    _ptr = (PFN_GLCOLORSUBTABLEEXT)_getPrivateProcAddress("glColorSubTableEXT");
    if (!_ptr) {
        _ptr = &_fail_glColorSubTableEXT;
    }
    _glColorSubTableEXT = _ptr;
    _glColorSubTableEXT(target, start, count, format, type, data);
}

PFN_GLCOLORSUBTABLEEXT _glColorSubTableEXT = &_get_glColorSubTableEXT;

static void APIENTRY _fail_glCopyColorSubTableEXT(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyColorSubTableEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyColorSubTableEXT(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width) {
    PFN_GLCOPYCOLORSUBTABLEEXT _ptr;
    _ptr = (PFN_GLCOPYCOLORSUBTABLEEXT)_getPrivateProcAddress("glCopyColorSubTableEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyColorSubTableEXT;
    }
    _glCopyColorSubTableEXT = _ptr;
    _glCopyColorSubTableEXT(target, start, x, y, width);
}

PFN_GLCOPYCOLORSUBTABLEEXT _glCopyColorSubTableEXT = &_get_glCopyColorSubTableEXT;

static void APIENTRY _fail_glLockArraysEXT(GLint first, GLsizei count) {
    const char *_name = "glLockArraysEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLockArraysEXT(GLint first, GLsizei count) {
    PFN_GLLOCKARRAYSEXT _ptr;
    _ptr = (PFN_GLLOCKARRAYSEXT)_getPrivateProcAddress("glLockArraysEXT");
    if (!_ptr) {
        _ptr = &_fail_glLockArraysEXT;
    }
    _glLockArraysEXT = _ptr;
    _glLockArraysEXT(first, count);
}

PFN_GLLOCKARRAYSEXT _glLockArraysEXT = &_get_glLockArraysEXT;

static void APIENTRY _fail_glUnlockArraysEXT(void) {
    const char *_name = "glUnlockArraysEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUnlockArraysEXT(void) {
    PFN_GLUNLOCKARRAYSEXT _ptr;
    _ptr = (PFN_GLUNLOCKARRAYSEXT)_getPrivateProcAddress("glUnlockArraysEXT");
    if (!_ptr) {
        _ptr = &_fail_glUnlockArraysEXT;
    }
    _glUnlockArraysEXT = _ptr;
    _glUnlockArraysEXT();
}

PFN_GLUNLOCKARRAYSEXT _glUnlockArraysEXT = &_get_glUnlockArraysEXT;

static void APIENTRY _fail_glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image) {
    const char *_name = "glConvolutionFilter1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image) {
    PFN_GLCONVOLUTIONFILTER1DEXT _ptr;
    _ptr = (PFN_GLCONVOLUTIONFILTER1DEXT)_getPrivateProcAddress("glConvolutionFilter1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glConvolutionFilter1DEXT;
    }
    _glConvolutionFilter1DEXT = _ptr;
    _glConvolutionFilter1DEXT(target, internalformat, width, format, type, image);
}

PFN_GLCONVOLUTIONFILTER1DEXT _glConvolutionFilter1DEXT = &_get_glConvolutionFilter1DEXT;

static void APIENTRY _fail_glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image) {
    const char *_name = "glConvolutionFilter2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image) {
    PFN_GLCONVOLUTIONFILTER2DEXT _ptr;
    _ptr = (PFN_GLCONVOLUTIONFILTER2DEXT)_getPrivateProcAddress("glConvolutionFilter2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glConvolutionFilter2DEXT;
    }
    _glConvolutionFilter2DEXT = _ptr;
    _glConvolutionFilter2DEXT(target, internalformat, width, height, format, type, image);
}

PFN_GLCONVOLUTIONFILTER2DEXT _glConvolutionFilter2DEXT = &_get_glConvolutionFilter2DEXT;

static void APIENTRY _fail_glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params) {
    const char *_name = "glConvolutionParameterfEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params) {
    PFN_GLCONVOLUTIONPARAMETERFEXT _ptr;
    _ptr = (PFN_GLCONVOLUTIONPARAMETERFEXT)_getPrivateProcAddress("glConvolutionParameterfEXT");
    if (!_ptr) {
        _ptr = &_fail_glConvolutionParameterfEXT;
    }
    _glConvolutionParameterfEXT = _ptr;
    _glConvolutionParameterfEXT(target, pname, params);
}

PFN_GLCONVOLUTIONPARAMETERFEXT _glConvolutionParameterfEXT = &_get_glConvolutionParameterfEXT;

static void APIENTRY _fail_glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glConvolutionParameterfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat * params) {
    PFN_GLCONVOLUTIONPARAMETERFVEXT _ptr;
    _ptr = (PFN_GLCONVOLUTIONPARAMETERFVEXT)_getPrivateProcAddress("glConvolutionParameterfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glConvolutionParameterfvEXT;
    }
    _glConvolutionParameterfvEXT = _ptr;
    _glConvolutionParameterfvEXT(target, pname, params);
}

PFN_GLCONVOLUTIONPARAMETERFVEXT _glConvolutionParameterfvEXT = &_get_glConvolutionParameterfvEXT;

static void APIENTRY _fail_glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params) {
    const char *_name = "glConvolutionParameteriEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params) {
    PFN_GLCONVOLUTIONPARAMETERIEXT _ptr;
    _ptr = (PFN_GLCONVOLUTIONPARAMETERIEXT)_getPrivateProcAddress("glConvolutionParameteriEXT");
    if (!_ptr) {
        _ptr = &_fail_glConvolutionParameteriEXT;
    }
    _glConvolutionParameteriEXT = _ptr;
    _glConvolutionParameteriEXT(target, pname, params);
}

PFN_GLCONVOLUTIONPARAMETERIEXT _glConvolutionParameteriEXT = &_get_glConvolutionParameteriEXT;

static void APIENTRY _fail_glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glConvolutionParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint * params) {
    PFN_GLCONVOLUTIONPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLCONVOLUTIONPARAMETERIVEXT)_getPrivateProcAddress("glConvolutionParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glConvolutionParameterivEXT;
    }
    _glConvolutionParameterivEXT = _ptr;
    _glConvolutionParameterivEXT(target, pname, params);
}

PFN_GLCONVOLUTIONPARAMETERIVEXT _glConvolutionParameterivEXT = &_get_glConvolutionParameterivEXT;

static void APIENTRY _fail_glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyConvolutionFilter1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    PFN_GLCOPYCONVOLUTIONFILTER1DEXT _ptr;
    _ptr = (PFN_GLCOPYCONVOLUTIONFILTER1DEXT)_getPrivateProcAddress("glCopyConvolutionFilter1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyConvolutionFilter1DEXT;
    }
    _glCopyConvolutionFilter1DEXT = _ptr;
    _glCopyConvolutionFilter1DEXT(target, internalformat, x, y, width);
}

PFN_GLCOPYCONVOLUTIONFILTER1DEXT _glCopyConvolutionFilter1DEXT = &_get_glCopyConvolutionFilter1DEXT;

static void APIENTRY _fail_glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyConvolutionFilter2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLCOPYCONVOLUTIONFILTER2DEXT _ptr;
    _ptr = (PFN_GLCOPYCONVOLUTIONFILTER2DEXT)_getPrivateProcAddress("glCopyConvolutionFilter2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyConvolutionFilter2DEXT;
    }
    _glCopyConvolutionFilter2DEXT = _ptr;
    _glCopyConvolutionFilter2DEXT(target, internalformat, x, y, width, height);
}

PFN_GLCOPYCONVOLUTIONFILTER2DEXT _glCopyConvolutionFilter2DEXT = &_get_glCopyConvolutionFilter2DEXT;

static void APIENTRY _fail_glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid * image) {
    const char *_name = "glGetConvolutionFilterEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid * image) {
    PFN_GLGETCONVOLUTIONFILTEREXT _ptr;
    _ptr = (PFN_GLGETCONVOLUTIONFILTEREXT)_getPrivateProcAddress("glGetConvolutionFilterEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetConvolutionFilterEXT;
    }
    _glGetConvolutionFilterEXT = _ptr;
    _glGetConvolutionFilterEXT(target, format, type, image);
}

PFN_GLGETCONVOLUTIONFILTEREXT _glGetConvolutionFilterEXT = &_get_glGetConvolutionFilterEXT;

static void APIENTRY _fail_glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetConvolutionParameterfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat * params) {
    PFN_GLGETCONVOLUTIONPARAMETERFVEXT _ptr;
    _ptr = (PFN_GLGETCONVOLUTIONPARAMETERFVEXT)_getPrivateProcAddress("glGetConvolutionParameterfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetConvolutionParameterfvEXT;
    }
    _glGetConvolutionParameterfvEXT = _ptr;
    _glGetConvolutionParameterfvEXT(target, pname, params);
}

PFN_GLGETCONVOLUTIONPARAMETERFVEXT _glGetConvolutionParameterfvEXT = &_get_glGetConvolutionParameterfvEXT;

static void APIENTRY _fail_glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetConvolutionParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETCONVOLUTIONPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLGETCONVOLUTIONPARAMETERIVEXT)_getPrivateProcAddress("glGetConvolutionParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetConvolutionParameterivEXT;
    }
    _glGetConvolutionParameterivEXT = _ptr;
    _glGetConvolutionParameterivEXT(target, pname, params);
}

PFN_GLGETCONVOLUTIONPARAMETERIVEXT _glGetConvolutionParameterivEXT = &_get_glGetConvolutionParameterivEXT;

static void APIENTRY _fail_glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid * row, GLvoid * column, GLvoid * span) {
    const char *_name = "glGetSeparableFilterEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid * row, GLvoid * column, GLvoid * span) {
    PFN_GLGETSEPARABLEFILTEREXT _ptr;
    _ptr = (PFN_GLGETSEPARABLEFILTEREXT)_getPrivateProcAddress("glGetSeparableFilterEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetSeparableFilterEXT;
    }
    _glGetSeparableFilterEXT = _ptr;
    _glGetSeparableFilterEXT(target, format, type, row, column, span);
}

PFN_GLGETSEPARABLEFILTEREXT _glGetSeparableFilterEXT = &_get_glGetSeparableFilterEXT;

static void APIENTRY _fail_glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * row, const GLvoid * column) {
    const char *_name = "glSeparableFilter2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * row, const GLvoid * column) {
    PFN_GLSEPARABLEFILTER2DEXT _ptr;
    _ptr = (PFN_GLSEPARABLEFILTER2DEXT)_getPrivateProcAddress("glSeparableFilter2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glSeparableFilter2DEXT;
    }
    _glSeparableFilter2DEXT = _ptr;
    _glSeparableFilter2DEXT(target, internalformat, width, height, format, type, row, column);
}

PFN_GLSEPARABLEFILTER2DEXT _glSeparableFilter2DEXT = &_get_glSeparableFilter2DEXT;

static void APIENTRY _fail_glTangent3bEXT(GLbyte tx, GLbyte ty, GLbyte tz) {
    const char *_name = "glTangent3bEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTangent3bEXT(GLbyte tx, GLbyte ty, GLbyte tz) {
    PFN_GLTANGENT3BEXT _ptr;
    _ptr = (PFN_GLTANGENT3BEXT)_getPrivateProcAddress("glTangent3bEXT");
    if (!_ptr) {
        _ptr = &_fail_glTangent3bEXT;
    }
    _glTangent3bEXT = _ptr;
    _glTangent3bEXT(tx, ty, tz);
}

PFN_GLTANGENT3BEXT _glTangent3bEXT = &_get_glTangent3bEXT;

static void APIENTRY _fail_glTangent3bvEXT(const GLbyte * v) {
    const char *_name = "glTangent3bvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTangent3bvEXT(const GLbyte * v) {
    PFN_GLTANGENT3BVEXT _ptr;
    _ptr = (PFN_GLTANGENT3BVEXT)_getPrivateProcAddress("glTangent3bvEXT");
    if (!_ptr) {
        _ptr = &_fail_glTangent3bvEXT;
    }
    _glTangent3bvEXT = _ptr;
    _glTangent3bvEXT(v);
}

PFN_GLTANGENT3BVEXT _glTangent3bvEXT = &_get_glTangent3bvEXT;

static void APIENTRY _fail_glTangent3dEXT(GLdouble tx, GLdouble ty, GLdouble tz) {
    const char *_name = "glTangent3dEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTangent3dEXT(GLdouble tx, GLdouble ty, GLdouble tz) {
    PFN_GLTANGENT3DEXT _ptr;
    _ptr = (PFN_GLTANGENT3DEXT)_getPrivateProcAddress("glTangent3dEXT");
    if (!_ptr) {
        _ptr = &_fail_glTangent3dEXT;
    }
    _glTangent3dEXT = _ptr;
    _glTangent3dEXT(tx, ty, tz);
}

PFN_GLTANGENT3DEXT _glTangent3dEXT = &_get_glTangent3dEXT;

static void APIENTRY _fail_glTangent3dvEXT(const GLdouble * v) {
    const char *_name = "glTangent3dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTangent3dvEXT(const GLdouble * v) {
    PFN_GLTANGENT3DVEXT _ptr;
    _ptr = (PFN_GLTANGENT3DVEXT)_getPrivateProcAddress("glTangent3dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glTangent3dvEXT;
    }
    _glTangent3dvEXT = _ptr;
    _glTangent3dvEXT(v);
}

PFN_GLTANGENT3DVEXT _glTangent3dvEXT = &_get_glTangent3dvEXT;

static void APIENTRY _fail_glTangent3fEXT(GLfloat tx, GLfloat ty, GLfloat tz) {
    const char *_name = "glTangent3fEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTangent3fEXT(GLfloat tx, GLfloat ty, GLfloat tz) {
    PFN_GLTANGENT3FEXT _ptr;
    _ptr = (PFN_GLTANGENT3FEXT)_getPrivateProcAddress("glTangent3fEXT");
    if (!_ptr) {
        _ptr = &_fail_glTangent3fEXT;
    }
    _glTangent3fEXT = _ptr;
    _glTangent3fEXT(tx, ty, tz);
}

PFN_GLTANGENT3FEXT _glTangent3fEXT = &_get_glTangent3fEXT;

static void APIENTRY _fail_glTangent3fvEXT(const GLfloat * v) {
    const char *_name = "glTangent3fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTangent3fvEXT(const GLfloat * v) {
    PFN_GLTANGENT3FVEXT _ptr;
    _ptr = (PFN_GLTANGENT3FVEXT)_getPrivateProcAddress("glTangent3fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glTangent3fvEXT;
    }
    _glTangent3fvEXT = _ptr;
    _glTangent3fvEXT(v);
}

PFN_GLTANGENT3FVEXT _glTangent3fvEXT = &_get_glTangent3fvEXT;

static void APIENTRY _fail_glTangent3iEXT(GLint tx, GLint ty, GLint tz) {
    const char *_name = "glTangent3iEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTangent3iEXT(GLint tx, GLint ty, GLint tz) {
    PFN_GLTANGENT3IEXT _ptr;
    _ptr = (PFN_GLTANGENT3IEXT)_getPrivateProcAddress("glTangent3iEXT");
    if (!_ptr) {
        _ptr = &_fail_glTangent3iEXT;
    }
    _glTangent3iEXT = _ptr;
    _glTangent3iEXT(tx, ty, tz);
}

PFN_GLTANGENT3IEXT _glTangent3iEXT = &_get_glTangent3iEXT;

static void APIENTRY _fail_glTangent3ivEXT(const GLint * v) {
    const char *_name = "glTangent3ivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTangent3ivEXT(const GLint * v) {
    PFN_GLTANGENT3IVEXT _ptr;
    _ptr = (PFN_GLTANGENT3IVEXT)_getPrivateProcAddress("glTangent3ivEXT");
    if (!_ptr) {
        _ptr = &_fail_glTangent3ivEXT;
    }
    _glTangent3ivEXT = _ptr;
    _glTangent3ivEXT(v);
}

PFN_GLTANGENT3IVEXT _glTangent3ivEXT = &_get_glTangent3ivEXT;

static void APIENTRY _fail_glTangent3sEXT(GLshort tx, GLshort ty, GLshort tz) {
    const char *_name = "glTangent3sEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTangent3sEXT(GLshort tx, GLshort ty, GLshort tz) {
    PFN_GLTANGENT3SEXT _ptr;
    _ptr = (PFN_GLTANGENT3SEXT)_getPrivateProcAddress("glTangent3sEXT");
    if (!_ptr) {
        _ptr = &_fail_glTangent3sEXT;
    }
    _glTangent3sEXT = _ptr;
    _glTangent3sEXT(tx, ty, tz);
}

PFN_GLTANGENT3SEXT _glTangent3sEXT = &_get_glTangent3sEXT;

static void APIENTRY _fail_glTangent3svEXT(const GLshort * v) {
    const char *_name = "glTangent3svEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTangent3svEXT(const GLshort * v) {
    PFN_GLTANGENT3SVEXT _ptr;
    _ptr = (PFN_GLTANGENT3SVEXT)_getPrivateProcAddress("glTangent3svEXT");
    if (!_ptr) {
        _ptr = &_fail_glTangent3svEXT;
    }
    _glTangent3svEXT = _ptr;
    _glTangent3svEXT(v);
}

PFN_GLTANGENT3SVEXT _glTangent3svEXT = &_get_glTangent3svEXT;

static void APIENTRY _fail_glBinormal3bEXT(GLbyte bx, GLbyte by, GLbyte bz) {
    const char *_name = "glBinormal3bEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBinormal3bEXT(GLbyte bx, GLbyte by, GLbyte bz) {
    PFN_GLBINORMAL3BEXT _ptr;
    _ptr = (PFN_GLBINORMAL3BEXT)_getPrivateProcAddress("glBinormal3bEXT");
    if (!_ptr) {
        _ptr = &_fail_glBinormal3bEXT;
    }
    _glBinormal3bEXT = _ptr;
    _glBinormal3bEXT(bx, by, bz);
}

PFN_GLBINORMAL3BEXT _glBinormal3bEXT = &_get_glBinormal3bEXT;

static void APIENTRY _fail_glBinormal3bvEXT(const GLbyte * v) {
    const char *_name = "glBinormal3bvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBinormal3bvEXT(const GLbyte * v) {
    PFN_GLBINORMAL3BVEXT _ptr;
    _ptr = (PFN_GLBINORMAL3BVEXT)_getPrivateProcAddress("glBinormal3bvEXT");
    if (!_ptr) {
        _ptr = &_fail_glBinormal3bvEXT;
    }
    _glBinormal3bvEXT = _ptr;
    _glBinormal3bvEXT(v);
}

PFN_GLBINORMAL3BVEXT _glBinormal3bvEXT = &_get_glBinormal3bvEXT;

static void APIENTRY _fail_glBinormal3dEXT(GLdouble bx, GLdouble by, GLdouble bz) {
    const char *_name = "glBinormal3dEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBinormal3dEXT(GLdouble bx, GLdouble by, GLdouble bz) {
    PFN_GLBINORMAL3DEXT _ptr;
    _ptr = (PFN_GLBINORMAL3DEXT)_getPrivateProcAddress("glBinormal3dEXT");
    if (!_ptr) {
        _ptr = &_fail_glBinormal3dEXT;
    }
    _glBinormal3dEXT = _ptr;
    _glBinormal3dEXT(bx, by, bz);
}

PFN_GLBINORMAL3DEXT _glBinormal3dEXT = &_get_glBinormal3dEXT;

static void APIENTRY _fail_glBinormal3dvEXT(const GLdouble * v) {
    const char *_name = "glBinormal3dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBinormal3dvEXT(const GLdouble * v) {
    PFN_GLBINORMAL3DVEXT _ptr;
    _ptr = (PFN_GLBINORMAL3DVEXT)_getPrivateProcAddress("glBinormal3dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glBinormal3dvEXT;
    }
    _glBinormal3dvEXT = _ptr;
    _glBinormal3dvEXT(v);
}

PFN_GLBINORMAL3DVEXT _glBinormal3dvEXT = &_get_glBinormal3dvEXT;

static void APIENTRY _fail_glBinormal3fEXT(GLfloat bx, GLfloat by, GLfloat bz) {
    const char *_name = "glBinormal3fEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBinormal3fEXT(GLfloat bx, GLfloat by, GLfloat bz) {
    PFN_GLBINORMAL3FEXT _ptr;
    _ptr = (PFN_GLBINORMAL3FEXT)_getPrivateProcAddress("glBinormal3fEXT");
    if (!_ptr) {
        _ptr = &_fail_glBinormal3fEXT;
    }
    _glBinormal3fEXT = _ptr;
    _glBinormal3fEXT(bx, by, bz);
}

PFN_GLBINORMAL3FEXT _glBinormal3fEXT = &_get_glBinormal3fEXT;

static void APIENTRY _fail_glBinormal3fvEXT(const GLfloat * v) {
    const char *_name = "glBinormal3fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBinormal3fvEXT(const GLfloat * v) {
    PFN_GLBINORMAL3FVEXT _ptr;
    _ptr = (PFN_GLBINORMAL3FVEXT)_getPrivateProcAddress("glBinormal3fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glBinormal3fvEXT;
    }
    _glBinormal3fvEXT = _ptr;
    _glBinormal3fvEXT(v);
}

PFN_GLBINORMAL3FVEXT _glBinormal3fvEXT = &_get_glBinormal3fvEXT;

static void APIENTRY _fail_glBinormal3iEXT(GLint bx, GLint by, GLint bz) {
    const char *_name = "glBinormal3iEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBinormal3iEXT(GLint bx, GLint by, GLint bz) {
    PFN_GLBINORMAL3IEXT _ptr;
    _ptr = (PFN_GLBINORMAL3IEXT)_getPrivateProcAddress("glBinormal3iEXT");
    if (!_ptr) {
        _ptr = &_fail_glBinormal3iEXT;
    }
    _glBinormal3iEXT = _ptr;
    _glBinormal3iEXT(bx, by, bz);
}

PFN_GLBINORMAL3IEXT _glBinormal3iEXT = &_get_glBinormal3iEXT;

static void APIENTRY _fail_glBinormal3ivEXT(const GLint * v) {
    const char *_name = "glBinormal3ivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBinormal3ivEXT(const GLint * v) {
    PFN_GLBINORMAL3IVEXT _ptr;
    _ptr = (PFN_GLBINORMAL3IVEXT)_getPrivateProcAddress("glBinormal3ivEXT");
    if (!_ptr) {
        _ptr = &_fail_glBinormal3ivEXT;
    }
    _glBinormal3ivEXT = _ptr;
    _glBinormal3ivEXT(v);
}

PFN_GLBINORMAL3IVEXT _glBinormal3ivEXT = &_get_glBinormal3ivEXT;

static void APIENTRY _fail_glBinormal3sEXT(GLshort bx, GLshort by, GLshort bz) {
    const char *_name = "glBinormal3sEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBinormal3sEXT(GLshort bx, GLshort by, GLshort bz) {
    PFN_GLBINORMAL3SEXT _ptr;
    _ptr = (PFN_GLBINORMAL3SEXT)_getPrivateProcAddress("glBinormal3sEXT");
    if (!_ptr) {
        _ptr = &_fail_glBinormal3sEXT;
    }
    _glBinormal3sEXT = _ptr;
    _glBinormal3sEXT(bx, by, bz);
}

PFN_GLBINORMAL3SEXT _glBinormal3sEXT = &_get_glBinormal3sEXT;

static void APIENTRY _fail_glBinormal3svEXT(const GLshort * v) {
    const char *_name = "glBinormal3svEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBinormal3svEXT(const GLshort * v) {
    PFN_GLBINORMAL3SVEXT _ptr;
    _ptr = (PFN_GLBINORMAL3SVEXT)_getPrivateProcAddress("glBinormal3svEXT");
    if (!_ptr) {
        _ptr = &_fail_glBinormal3svEXT;
    }
    _glBinormal3svEXT = _ptr;
    _glBinormal3svEXT(v);
}

PFN_GLBINORMAL3SVEXT _glBinormal3svEXT = &_get_glBinormal3svEXT;

static void APIENTRY _fail_glTangentPointerEXT(GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glTangentPointerEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTangentPointerEXT(GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLTANGENTPOINTEREXT _ptr;
    _ptr = (PFN_GLTANGENTPOINTEREXT)_getPrivateProcAddress("glTangentPointerEXT");
    if (!_ptr) {
        _ptr = &_fail_glTangentPointerEXT;
    }
    _glTangentPointerEXT = _ptr;
    _glTangentPointerEXT(type, stride, pointer);
}

PFN_GLTANGENTPOINTEREXT _glTangentPointerEXT = &_get_glTangentPointerEXT;

static void APIENTRY _fail_glBinormalPointerEXT(GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glBinormalPointerEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBinormalPointerEXT(GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLBINORMALPOINTEREXT _ptr;
    _ptr = (PFN_GLBINORMALPOINTEREXT)_getPrivateProcAddress("glBinormalPointerEXT");
    if (!_ptr) {
        _ptr = &_fail_glBinormalPointerEXT;
    }
    _glBinormalPointerEXT = _ptr;
    _glBinormalPointerEXT(type, stride, pointer);
}

PFN_GLBINORMALPOINTEREXT _glBinormalPointerEXT = &_get_glBinormalPointerEXT;

static void APIENTRY _fail_glCopyImageSubDataEXT(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) {
    const char *_name = "glCopyImageSubDataEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyImageSubDataEXT(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) {
    PFN_GLCOPYIMAGESUBDATAEXT _ptr;
    _ptr = (PFN_GLCOPYIMAGESUBDATAEXT)_getPrivateProcAddress("glCopyImageSubDataEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyImageSubDataEXT;
    }
    _glCopyImageSubDataEXT = _ptr;
    _glCopyImageSubDataEXT(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
}

PFN_GLCOPYIMAGESUBDATAEXT _glCopyImageSubDataEXT = &_get_glCopyImageSubDataEXT;

static void APIENTRY _fail_glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    const char *_name = "glCopyTexImage1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    PFN_GLCOPYTEXIMAGE1DEXT _ptr;
    _ptr = (PFN_GLCOPYTEXIMAGE1DEXT)_getPrivateProcAddress("glCopyTexImage1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyTexImage1DEXT;
    }
    _glCopyTexImage1DEXT = _ptr;
    _glCopyTexImage1DEXT(target, level, internalformat, x, y, width, border);
}

PFN_GLCOPYTEXIMAGE1DEXT _glCopyTexImage1DEXT = &_get_glCopyTexImage1DEXT;

static void APIENTRY _fail_glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    const char *_name = "glCopyTexImage2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    PFN_GLCOPYTEXIMAGE2DEXT _ptr;
    _ptr = (PFN_GLCOPYTEXIMAGE2DEXT)_getPrivateProcAddress("glCopyTexImage2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyTexImage2DEXT;
    }
    _glCopyTexImage2DEXT = _ptr;
    _glCopyTexImage2DEXT(target, level, internalformat, x, y, width, height, border);
}

PFN_GLCOPYTEXIMAGE2DEXT _glCopyTexImage2DEXT = &_get_glCopyTexImage2DEXT;

static void APIENTRY _fail_glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyTexSubImage1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    PFN_GLCOPYTEXSUBIMAGE1DEXT _ptr;
    _ptr = (PFN_GLCOPYTEXSUBIMAGE1DEXT)_getPrivateProcAddress("glCopyTexSubImage1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyTexSubImage1DEXT;
    }
    _glCopyTexSubImage1DEXT = _ptr;
    _glCopyTexSubImage1DEXT(target, level, xoffset, x, y, width);
}

PFN_GLCOPYTEXSUBIMAGE1DEXT _glCopyTexSubImage1DEXT = &_get_glCopyTexSubImage1DEXT;

static void APIENTRY _fail_glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyTexSubImage2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLCOPYTEXSUBIMAGE2DEXT _ptr;
    _ptr = (PFN_GLCOPYTEXSUBIMAGE2DEXT)_getPrivateProcAddress("glCopyTexSubImage2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyTexSubImage2DEXT;
    }
    _glCopyTexSubImage2DEXT = _ptr;
    _glCopyTexSubImage2DEXT(target, level, xoffset, yoffset, x, y, width, height);
}

PFN_GLCOPYTEXSUBIMAGE2DEXT _glCopyTexSubImage2DEXT = &_get_glCopyTexSubImage2DEXT;

static void APIENTRY _fail_glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyTexSubImage3DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLCOPYTEXSUBIMAGE3DEXT _ptr;
    _ptr = (PFN_GLCOPYTEXSUBIMAGE3DEXT)_getPrivateProcAddress("glCopyTexSubImage3DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyTexSubImage3DEXT;
    }
    _glCopyTexSubImage3DEXT = _ptr;
    _glCopyTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

PFN_GLCOPYTEXSUBIMAGE3DEXT _glCopyTexSubImage3DEXT = &_get_glCopyTexSubImage3DEXT;

static void APIENTRY _fail_glCullParameterdvEXT(GLenum pname, GLdouble * params) {
    const char *_name = "glCullParameterdvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCullParameterdvEXT(GLenum pname, GLdouble * params) {
    PFN_GLCULLPARAMETERDVEXT _ptr;
    _ptr = (PFN_GLCULLPARAMETERDVEXT)_getPrivateProcAddress("glCullParameterdvEXT");
    if (!_ptr) {
        _ptr = &_fail_glCullParameterdvEXT;
    }
    _glCullParameterdvEXT = _ptr;
    _glCullParameterdvEXT(pname, params);
}

PFN_GLCULLPARAMETERDVEXT _glCullParameterdvEXT = &_get_glCullParameterdvEXT;

static void APIENTRY _fail_glCullParameterfvEXT(GLenum pname, GLfloat * params) {
    const char *_name = "glCullParameterfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCullParameterfvEXT(GLenum pname, GLfloat * params) {
    PFN_GLCULLPARAMETERFVEXT _ptr;
    _ptr = (PFN_GLCULLPARAMETERFVEXT)_getPrivateProcAddress("glCullParameterfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glCullParameterfvEXT;
    }
    _glCullParameterfvEXT = _ptr;
    _glCullParameterfvEXT(pname, params);
}

PFN_GLCULLPARAMETERFVEXT _glCullParameterfvEXT = &_get_glCullParameterfvEXT;

static void APIENTRY _fail_glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar * label) {
}

static void APIENTRY _get_glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar * label) {
    PFN_GLLABELOBJECTEXT _ptr;
    _ptr = (PFN_GLLABELOBJECTEXT)_getPrivateProcAddress("glLabelObjectEXT");
    if (!_ptr) {
        _ptr = &_fail_glLabelObjectEXT;
    }
    _glLabelObjectEXT = _ptr;
    _glLabelObjectEXT(type, object, length, label);
}

PFN_GLLABELOBJECTEXT _glLabelObjectEXT = &_get_glLabelObjectEXT;

static void APIENTRY _fail_glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei * length, GLchar * label) {
    if (length != 0) *length = 0;
    if (label != 0 && bufSize > 0) *label = 0;
}

static void APIENTRY _get_glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei * length, GLchar * label) {
    PFN_GLGETOBJECTLABELEXT _ptr;
    _ptr = (PFN_GLGETOBJECTLABELEXT)_getPrivateProcAddress("glGetObjectLabelEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetObjectLabelEXT;
    }
    _glGetObjectLabelEXT = _ptr;
    _glGetObjectLabelEXT(type, object, bufSize, length, label);
}

PFN_GLGETOBJECTLABELEXT _glGetObjectLabelEXT = &_get_glGetObjectLabelEXT;

static void APIENTRY _fail_glInsertEventMarkerEXT(GLsizei length, const GLchar * marker) {
}

static void APIENTRY _get_glInsertEventMarkerEXT(GLsizei length, const GLchar * marker) {
    PFN_GLINSERTEVENTMARKEREXT _ptr;
    _ptr = (PFN_GLINSERTEVENTMARKEREXT)_getPrivateProcAddress("glInsertEventMarkerEXT");
    if (!_ptr) {
        _ptr = &_fail_glInsertEventMarkerEXT;
    }
    _glInsertEventMarkerEXT = _ptr;
    _glInsertEventMarkerEXT(length, marker);
}

PFN_GLINSERTEVENTMARKEREXT _glInsertEventMarkerEXT = &_get_glInsertEventMarkerEXT;

static void APIENTRY _fail_glPushGroupMarkerEXT(GLsizei length, const GLchar * marker) {
}

static void APIENTRY _get_glPushGroupMarkerEXT(GLsizei length, const GLchar * marker) {
    PFN_GLPUSHGROUPMARKEREXT _ptr;
    _ptr = (PFN_GLPUSHGROUPMARKEREXT)_getPrivateProcAddress("glPushGroupMarkerEXT");
    if (!_ptr) {
        _ptr = &_fail_glPushGroupMarkerEXT;
    }
    _glPushGroupMarkerEXT = _ptr;
    _glPushGroupMarkerEXT(length, marker);
}

PFN_GLPUSHGROUPMARKEREXT _glPushGroupMarkerEXT = &_get_glPushGroupMarkerEXT;

static void APIENTRY _fail_glPopGroupMarkerEXT(void) {
}

static void APIENTRY _get_glPopGroupMarkerEXT(void) {
    PFN_GLPOPGROUPMARKEREXT _ptr;
    _ptr = (PFN_GLPOPGROUPMARKEREXT)_getPrivateProcAddress("glPopGroupMarkerEXT");
    if (!_ptr) {
        _ptr = &_fail_glPopGroupMarkerEXT;
    }
    _glPopGroupMarkerEXT = _ptr;
    _glPopGroupMarkerEXT();
}

PFN_GLPOPGROUPMARKEREXT _glPopGroupMarkerEXT = &_get_glPopGroupMarkerEXT;

static void APIENTRY _fail_glDepthBoundsEXT(GLclampd zmin, GLclampd zmax) {
    const char *_name = "glDepthBoundsEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDepthBoundsEXT(GLclampd zmin, GLclampd zmax) {
    PFN_GLDEPTHBOUNDSEXT _ptr;
    _ptr = (PFN_GLDEPTHBOUNDSEXT)_getPrivateProcAddress("glDepthBoundsEXT");
    if (!_ptr) {
        _ptr = &_fail_glDepthBoundsEXT;
    }
    _glDepthBoundsEXT = _ptr;
    _glDepthBoundsEXT(zmin, zmax);
}

PFN_GLDEPTHBOUNDSEXT _glDepthBoundsEXT = &_get_glDepthBoundsEXT;

static void APIENTRY _fail_glBindMultiTextureEXT(GLenum texunit, GLenum target, GLuint texture) {
    const char *_name = "glBindMultiTextureEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindMultiTextureEXT(GLenum texunit, GLenum target, GLuint texture) {
    PFN_GLBINDMULTITEXTUREEXT _ptr;
    _ptr = (PFN_GLBINDMULTITEXTUREEXT)_getPrivateProcAddress("glBindMultiTextureEXT");
    if (!_ptr) {
        _ptr = &_fail_glBindMultiTextureEXT;
    }
    _glBindMultiTextureEXT = _ptr;
    _glBindMultiTextureEXT(texunit, target, texture);
}

PFN_GLBINDMULTITEXTUREEXT _glBindMultiTextureEXT = &_get_glBindMultiTextureEXT;

static GLenum APIENTRY _fail_glCheckNamedFramebufferStatusEXT(GLuint framebuffer, GLenum target) {
    const char *_name = "glCheckNamedFramebufferStatusEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLenum APIENTRY _get_glCheckNamedFramebufferStatusEXT(GLuint framebuffer, GLenum target) {
    PFN_GLCHECKNAMEDFRAMEBUFFERSTATUSEXT _ptr;
    _ptr = (PFN_GLCHECKNAMEDFRAMEBUFFERSTATUSEXT)_getPrivateProcAddress("glCheckNamedFramebufferStatusEXT");
    if (!_ptr) {
        _ptr = &_fail_glCheckNamedFramebufferStatusEXT;
    }
    _glCheckNamedFramebufferStatusEXT = _ptr;
    return _glCheckNamedFramebufferStatusEXT(framebuffer, target);
}

PFN_GLCHECKNAMEDFRAMEBUFFERSTATUSEXT _glCheckNamedFramebufferStatusEXT = &_get_glCheckNamedFramebufferStatusEXT;

static void APIENTRY _fail_glClearNamedBufferDataEXT(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data) {
    const char *_name = "glClearNamedBufferDataEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearNamedBufferDataEXT(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data) {
    PFN_GLCLEARNAMEDBUFFERDATAEXT _ptr;
    _ptr = (PFN_GLCLEARNAMEDBUFFERDATAEXT)_getPrivateProcAddress("glClearNamedBufferDataEXT");
    if (!_ptr) {
        _ptr = &_fail_glClearNamedBufferDataEXT;
    }
    _glClearNamedBufferDataEXT = _ptr;
    _glClearNamedBufferDataEXT(buffer, internalformat, format, type, data);
}

PFN_GLCLEARNAMEDBUFFERDATAEXT _glClearNamedBufferDataEXT = &_get_glClearNamedBufferDataEXT;

static void APIENTRY _fail_glClearNamedBufferSubDataEXT(GLuint buffer, GLenum internalformat, GLsizeiptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data) {
    const char *_name = "glClearNamedBufferSubDataEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearNamedBufferSubDataEXT(GLuint buffer, GLenum internalformat, GLsizeiptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data) {
    PFN_GLCLEARNAMEDBUFFERSUBDATAEXT _ptr;
    _ptr = (PFN_GLCLEARNAMEDBUFFERSUBDATAEXT)_getPrivateProcAddress("glClearNamedBufferSubDataEXT");
    if (!_ptr) {
        _ptr = &_fail_glClearNamedBufferSubDataEXT;
    }
    _glClearNamedBufferSubDataEXT = _ptr;
    _glClearNamedBufferSubDataEXT(buffer, internalformat, offset, size, format, type, data);
}

PFN_GLCLEARNAMEDBUFFERSUBDATAEXT _glClearNamedBufferSubDataEXT = &_get_glClearNamedBufferSubDataEXT;

static void APIENTRY _fail_glClientAttribDefaultEXT(GLbitfield mask) {
    const char *_name = "glClientAttribDefaultEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClientAttribDefaultEXT(GLbitfield mask) {
    PFN_GLCLIENTATTRIBDEFAULTEXT _ptr;
    _ptr = (PFN_GLCLIENTATTRIBDEFAULTEXT)_getPrivateProcAddress("glClientAttribDefaultEXT");
    if (!_ptr) {
        _ptr = &_fail_glClientAttribDefaultEXT;
    }
    _glClientAttribDefaultEXT = _ptr;
    _glClientAttribDefaultEXT(mask);
}

PFN_GLCLIENTATTRIBDEFAULTEXT _glClientAttribDefaultEXT = &_get_glClientAttribDefaultEXT;

static void APIENTRY _fail_glCompressedMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedMultiTexImage1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * bits) {
    PFN_GLCOMPRESSEDMULTITEXIMAGE1DEXT _ptr;
    _ptr = (PFN_GLCOMPRESSEDMULTITEXIMAGE1DEXT)_getPrivateProcAddress("glCompressedMultiTexImage1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCompressedMultiTexImage1DEXT;
    }
    _glCompressedMultiTexImage1DEXT = _ptr;
    _glCompressedMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, imageSize, bits);
}

PFN_GLCOMPRESSEDMULTITEXIMAGE1DEXT _glCompressedMultiTexImage1DEXT = &_get_glCompressedMultiTexImage1DEXT;

static void APIENTRY _fail_glCompressedMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedMultiTexImage2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * bits) {
    PFN_GLCOMPRESSEDMULTITEXIMAGE2DEXT _ptr;
    _ptr = (PFN_GLCOMPRESSEDMULTITEXIMAGE2DEXT)_getPrivateProcAddress("glCompressedMultiTexImage2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCompressedMultiTexImage2DEXT;
    }
    _glCompressedMultiTexImage2DEXT = _ptr;
    _glCompressedMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, imageSize, bits);
}

PFN_GLCOMPRESSEDMULTITEXIMAGE2DEXT _glCompressedMultiTexImage2DEXT = &_get_glCompressedMultiTexImage2DEXT;

static void APIENTRY _fail_glCompressedMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedMultiTexImage3DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * bits) {
    PFN_GLCOMPRESSEDMULTITEXIMAGE3DEXT _ptr;
    _ptr = (PFN_GLCOMPRESSEDMULTITEXIMAGE3DEXT)_getPrivateProcAddress("glCompressedMultiTexImage3DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCompressedMultiTexImage3DEXT;
    }
    _glCompressedMultiTexImage3DEXT = _ptr;
    _glCompressedMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
}

PFN_GLCOMPRESSEDMULTITEXIMAGE3DEXT _glCompressedMultiTexImage3DEXT = &_get_glCompressedMultiTexImage3DEXT;

static void APIENTRY _fail_glCompressedMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedMultiTexSubImage1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * bits) {
    PFN_GLCOMPRESSEDMULTITEXSUBIMAGE1DEXT _ptr;
    _ptr = (PFN_GLCOMPRESSEDMULTITEXSUBIMAGE1DEXT)_getPrivateProcAddress("glCompressedMultiTexSubImage1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCompressedMultiTexSubImage1DEXT;
    }
    _glCompressedMultiTexSubImage1DEXT = _ptr;
    _glCompressedMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, imageSize, bits);
}

PFN_GLCOMPRESSEDMULTITEXSUBIMAGE1DEXT _glCompressedMultiTexSubImage1DEXT = &_get_glCompressedMultiTexSubImage1DEXT;

static void APIENTRY _fail_glCompressedMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedMultiTexSubImage2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * bits) {
    PFN_GLCOMPRESSEDMULTITEXSUBIMAGE2DEXT _ptr;
    _ptr = (PFN_GLCOMPRESSEDMULTITEXSUBIMAGE2DEXT)_getPrivateProcAddress("glCompressedMultiTexSubImage2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCompressedMultiTexSubImage2DEXT;
    }
    _glCompressedMultiTexSubImage2DEXT = _ptr;
    _glCompressedMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
}

PFN_GLCOMPRESSEDMULTITEXSUBIMAGE2DEXT _glCompressedMultiTexSubImage2DEXT = &_get_glCompressedMultiTexSubImage2DEXT;

static void APIENTRY _fail_glCompressedMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedMultiTexSubImage3DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * bits) {
    PFN_GLCOMPRESSEDMULTITEXSUBIMAGE3DEXT _ptr;
    _ptr = (PFN_GLCOMPRESSEDMULTITEXSUBIMAGE3DEXT)_getPrivateProcAddress("glCompressedMultiTexSubImage3DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCompressedMultiTexSubImage3DEXT;
    }
    _glCompressedMultiTexSubImage3DEXT = _ptr;
    _glCompressedMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
}

PFN_GLCOMPRESSEDMULTITEXSUBIMAGE3DEXT _glCompressedMultiTexSubImage3DEXT = &_get_glCompressedMultiTexSubImage3DEXT;

static void APIENTRY _fail_glCompressedTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedTextureImage1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * bits) {
    PFN_GLCOMPRESSEDTEXTUREIMAGE1DEXT _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXTUREIMAGE1DEXT)_getPrivateProcAddress("glCompressedTextureImage1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTextureImage1DEXT;
    }
    _glCompressedTextureImage1DEXT = _ptr;
    _glCompressedTextureImage1DEXT(texture, target, level, internalformat, width, border, imageSize, bits);
}

PFN_GLCOMPRESSEDTEXTUREIMAGE1DEXT _glCompressedTextureImage1DEXT = &_get_glCompressedTextureImage1DEXT;

static void APIENTRY _fail_glCompressedTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedTextureImage2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * bits) {
    PFN_GLCOMPRESSEDTEXTUREIMAGE2DEXT _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXTUREIMAGE2DEXT)_getPrivateProcAddress("glCompressedTextureImage2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTextureImage2DEXT;
    }
    _glCompressedTextureImage2DEXT = _ptr;
    _glCompressedTextureImage2DEXT(texture, target, level, internalformat, width, height, border, imageSize, bits);
}

PFN_GLCOMPRESSEDTEXTUREIMAGE2DEXT _glCompressedTextureImage2DEXT = &_get_glCompressedTextureImage2DEXT;

static void APIENTRY _fail_glCompressedTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedTextureImage3DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * bits) {
    PFN_GLCOMPRESSEDTEXTUREIMAGE3DEXT _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXTUREIMAGE3DEXT)_getPrivateProcAddress("glCompressedTextureImage3DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTextureImage3DEXT;
    }
    _glCompressedTextureImage3DEXT = _ptr;
    _glCompressedTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
}

PFN_GLCOMPRESSEDTEXTUREIMAGE3DEXT _glCompressedTextureImage3DEXT = &_get_glCompressedTextureImage3DEXT;

static void APIENTRY _fail_glCompressedTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedTextureSubImage1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * bits) {
    PFN_GLCOMPRESSEDTEXTURESUBIMAGE1DEXT _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXTURESUBIMAGE1DEXT)_getPrivateProcAddress("glCompressedTextureSubImage1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTextureSubImage1DEXT;
    }
    _glCompressedTextureSubImage1DEXT = _ptr;
    _glCompressedTextureSubImage1DEXT(texture, target, level, xoffset, width, format, imageSize, bits);
}

PFN_GLCOMPRESSEDTEXTURESUBIMAGE1DEXT _glCompressedTextureSubImage1DEXT = &_get_glCompressedTextureSubImage1DEXT;

static void APIENTRY _fail_glCompressedTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedTextureSubImage2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * bits) {
    PFN_GLCOMPRESSEDTEXTURESUBIMAGE2DEXT _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXTURESUBIMAGE2DEXT)_getPrivateProcAddress("glCompressedTextureSubImage2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTextureSubImage2DEXT;
    }
    _glCompressedTextureSubImage2DEXT = _ptr;
    _glCompressedTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
}

PFN_GLCOMPRESSEDTEXTURESUBIMAGE2DEXT _glCompressedTextureSubImage2DEXT = &_get_glCompressedTextureSubImage2DEXT;

static void APIENTRY _fail_glCompressedTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * bits) {
    const char *_name = "glCompressedTextureSubImage3DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * bits) {
    PFN_GLCOMPRESSEDTEXTURESUBIMAGE3DEXT _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXTURESUBIMAGE3DEXT)_getPrivateProcAddress("glCompressedTextureSubImage3DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTextureSubImage3DEXT;
    }
    _glCompressedTextureSubImage3DEXT = _ptr;
    _glCompressedTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
}

PFN_GLCOMPRESSEDTEXTURESUBIMAGE3DEXT _glCompressedTextureSubImage3DEXT = &_get_glCompressedTextureSubImage3DEXT;

static void APIENTRY _fail_glCopyMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    const char *_name = "glCopyMultiTexImage1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    PFN_GLCOPYMULTITEXIMAGE1DEXT _ptr;
    _ptr = (PFN_GLCOPYMULTITEXIMAGE1DEXT)_getPrivateProcAddress("glCopyMultiTexImage1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyMultiTexImage1DEXT;
    }
    _glCopyMultiTexImage1DEXT = _ptr;
    _glCopyMultiTexImage1DEXT(texunit, target, level, internalformat, x, y, width, border);
}

PFN_GLCOPYMULTITEXIMAGE1DEXT _glCopyMultiTexImage1DEXT = &_get_glCopyMultiTexImage1DEXT;

static void APIENTRY _fail_glCopyMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    const char *_name = "glCopyMultiTexImage2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    PFN_GLCOPYMULTITEXIMAGE2DEXT _ptr;
    _ptr = (PFN_GLCOPYMULTITEXIMAGE2DEXT)_getPrivateProcAddress("glCopyMultiTexImage2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyMultiTexImage2DEXT;
    }
    _glCopyMultiTexImage2DEXT = _ptr;
    _glCopyMultiTexImage2DEXT(texunit, target, level, internalformat, x, y, width, height, border);
}

PFN_GLCOPYMULTITEXIMAGE2DEXT _glCopyMultiTexImage2DEXT = &_get_glCopyMultiTexImage2DEXT;

static void APIENTRY _fail_glCopyMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyMultiTexSubImage1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    PFN_GLCOPYMULTITEXSUBIMAGE1DEXT _ptr;
    _ptr = (PFN_GLCOPYMULTITEXSUBIMAGE1DEXT)_getPrivateProcAddress("glCopyMultiTexSubImage1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyMultiTexSubImage1DEXT;
    }
    _glCopyMultiTexSubImage1DEXT = _ptr;
    _glCopyMultiTexSubImage1DEXT(texunit, target, level, xoffset, x, y, width);
}

PFN_GLCOPYMULTITEXSUBIMAGE1DEXT _glCopyMultiTexSubImage1DEXT = &_get_glCopyMultiTexSubImage1DEXT;

static void APIENTRY _fail_glCopyMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyMultiTexSubImage2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLCOPYMULTITEXSUBIMAGE2DEXT _ptr;
    _ptr = (PFN_GLCOPYMULTITEXSUBIMAGE2DEXT)_getPrivateProcAddress("glCopyMultiTexSubImage2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyMultiTexSubImage2DEXT;
    }
    _glCopyMultiTexSubImage2DEXT = _ptr;
    _glCopyMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, x, y, width, height);
}

PFN_GLCOPYMULTITEXSUBIMAGE2DEXT _glCopyMultiTexSubImage2DEXT = &_get_glCopyMultiTexSubImage2DEXT;

static void APIENTRY _fail_glCopyMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyMultiTexSubImage3DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLCOPYMULTITEXSUBIMAGE3DEXT _ptr;
    _ptr = (PFN_GLCOPYMULTITEXSUBIMAGE3DEXT)_getPrivateProcAddress("glCopyMultiTexSubImage3DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyMultiTexSubImage3DEXT;
    }
    _glCopyMultiTexSubImage3DEXT = _ptr;
    _glCopyMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

PFN_GLCOPYMULTITEXSUBIMAGE3DEXT _glCopyMultiTexSubImage3DEXT = &_get_glCopyMultiTexSubImage3DEXT;

static void APIENTRY _fail_glCopyTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    const char *_name = "glCopyTextureImage1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    PFN_GLCOPYTEXTUREIMAGE1DEXT _ptr;
    _ptr = (PFN_GLCOPYTEXTUREIMAGE1DEXT)_getPrivateProcAddress("glCopyTextureImage1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyTextureImage1DEXT;
    }
    _glCopyTextureImage1DEXT = _ptr;
    _glCopyTextureImage1DEXT(texture, target, level, internalformat, x, y, width, border);
}

PFN_GLCOPYTEXTUREIMAGE1DEXT _glCopyTextureImage1DEXT = &_get_glCopyTextureImage1DEXT;

static void APIENTRY _fail_glCopyTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    const char *_name = "glCopyTextureImage2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    PFN_GLCOPYTEXTUREIMAGE2DEXT _ptr;
    _ptr = (PFN_GLCOPYTEXTUREIMAGE2DEXT)_getPrivateProcAddress("glCopyTextureImage2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyTextureImage2DEXT;
    }
    _glCopyTextureImage2DEXT = _ptr;
    _glCopyTextureImage2DEXT(texture, target, level, internalformat, x, y, width, height, border);
}

PFN_GLCOPYTEXTUREIMAGE2DEXT _glCopyTextureImage2DEXT = &_get_glCopyTextureImage2DEXT;

static void APIENTRY _fail_glCopyTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyTextureSubImage1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    PFN_GLCOPYTEXTURESUBIMAGE1DEXT _ptr;
    _ptr = (PFN_GLCOPYTEXTURESUBIMAGE1DEXT)_getPrivateProcAddress("glCopyTextureSubImage1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyTextureSubImage1DEXT;
    }
    _glCopyTextureSubImage1DEXT = _ptr;
    _glCopyTextureSubImage1DEXT(texture, target, level, xoffset, x, y, width);
}

PFN_GLCOPYTEXTURESUBIMAGE1DEXT _glCopyTextureSubImage1DEXT = &_get_glCopyTextureSubImage1DEXT;

static void APIENTRY _fail_glCopyTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyTextureSubImage2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLCOPYTEXTURESUBIMAGE2DEXT _ptr;
    _ptr = (PFN_GLCOPYTEXTURESUBIMAGE2DEXT)_getPrivateProcAddress("glCopyTextureSubImage2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyTextureSubImage2DEXT;
    }
    _glCopyTextureSubImage2DEXT = _ptr;
    _glCopyTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, x, y, width, height);
}

PFN_GLCOPYTEXTURESUBIMAGE2DEXT _glCopyTextureSubImage2DEXT = &_get_glCopyTextureSubImage2DEXT;

static void APIENTRY _fail_glCopyTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyTextureSubImage3DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLCOPYTEXTURESUBIMAGE3DEXT _ptr;
    _ptr = (PFN_GLCOPYTEXTURESUBIMAGE3DEXT)_getPrivateProcAddress("glCopyTextureSubImage3DEXT");
    if (!_ptr) {
        _ptr = &_fail_glCopyTextureSubImage3DEXT;
    }
    _glCopyTextureSubImage3DEXT = _ptr;
    _glCopyTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

PFN_GLCOPYTEXTURESUBIMAGE3DEXT _glCopyTextureSubImage3DEXT = &_get_glCopyTextureSubImage3DEXT;

static void APIENTRY _fail_glDisableClientStateIndexedEXT(GLenum array, GLuint index) {
    const char *_name = "glDisableClientStateIndexedEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDisableClientStateIndexedEXT(GLenum array, GLuint index) {
    PFN_GLDISABLECLIENTSTATEINDEXEDEXT _ptr;
    _ptr = (PFN_GLDISABLECLIENTSTATEINDEXEDEXT)_getPrivateProcAddress("glDisableClientStateIndexedEXT");
    if (!_ptr) {
        _ptr = &_fail_glDisableClientStateIndexedEXT;
    }
    _glDisableClientStateIndexedEXT = _ptr;
    _glDisableClientStateIndexedEXT(array, index);
}

PFN_GLDISABLECLIENTSTATEINDEXEDEXT _glDisableClientStateIndexedEXT = &_get_glDisableClientStateIndexedEXT;

static void APIENTRY _fail_glDisableClientStateiEXT(GLenum array, GLuint index) {
    const char *_name = "glDisableClientStateiEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDisableClientStateiEXT(GLenum array, GLuint index) {
    PFN_GLDISABLECLIENTSTATEIEXT _ptr;
    _ptr = (PFN_GLDISABLECLIENTSTATEIEXT)_getPrivateProcAddress("glDisableClientStateiEXT");
    if (!_ptr) {
        _ptr = &_fail_glDisableClientStateiEXT;
    }
    _glDisableClientStateiEXT = _ptr;
    _glDisableClientStateiEXT(array, index);
}

PFN_GLDISABLECLIENTSTATEIEXT _glDisableClientStateiEXT = &_get_glDisableClientStateiEXT;

static void APIENTRY _fail_glDisableVertexArrayAttribEXT(GLuint vaobj, GLuint index) {
    const char *_name = "glDisableVertexArrayAttribEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDisableVertexArrayAttribEXT(GLuint vaobj, GLuint index) {
    PFN_GLDISABLEVERTEXARRAYATTRIBEXT _ptr;
    _ptr = (PFN_GLDISABLEVERTEXARRAYATTRIBEXT)_getPrivateProcAddress("glDisableVertexArrayAttribEXT");
    if (!_ptr) {
        _ptr = &_fail_glDisableVertexArrayAttribEXT;
    }
    _glDisableVertexArrayAttribEXT = _ptr;
    _glDisableVertexArrayAttribEXT(vaobj, index);
}

PFN_GLDISABLEVERTEXARRAYATTRIBEXT _glDisableVertexArrayAttribEXT = &_get_glDisableVertexArrayAttribEXT;

static void APIENTRY _fail_glDisableVertexArrayEXT(GLuint vaobj, GLenum array) {
    const char *_name = "glDisableVertexArrayEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDisableVertexArrayEXT(GLuint vaobj, GLenum array) {
    PFN_GLDISABLEVERTEXARRAYEXT _ptr;
    _ptr = (PFN_GLDISABLEVERTEXARRAYEXT)_getPrivateProcAddress("glDisableVertexArrayEXT");
    if (!_ptr) {
        _ptr = &_fail_glDisableVertexArrayEXT;
    }
    _glDisableVertexArrayEXT = _ptr;
    _glDisableVertexArrayEXT(vaobj, array);
}

PFN_GLDISABLEVERTEXARRAYEXT _glDisableVertexArrayEXT = &_get_glDisableVertexArrayEXT;

static void APIENTRY _fail_glEnableClientStateIndexedEXT(GLenum array, GLuint index) {
    const char *_name = "glEnableClientStateIndexedEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEnableClientStateIndexedEXT(GLenum array, GLuint index) {
    PFN_GLENABLECLIENTSTATEINDEXEDEXT _ptr;
    _ptr = (PFN_GLENABLECLIENTSTATEINDEXEDEXT)_getPrivateProcAddress("glEnableClientStateIndexedEXT");
    if (!_ptr) {
        _ptr = &_fail_glEnableClientStateIndexedEXT;
    }
    _glEnableClientStateIndexedEXT = _ptr;
    _glEnableClientStateIndexedEXT(array, index);
}

PFN_GLENABLECLIENTSTATEINDEXEDEXT _glEnableClientStateIndexedEXT = &_get_glEnableClientStateIndexedEXT;

static void APIENTRY _fail_glEnableClientStateiEXT(GLenum array, GLuint index) {
    const char *_name = "glEnableClientStateiEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEnableClientStateiEXT(GLenum array, GLuint index) {
    PFN_GLENABLECLIENTSTATEIEXT _ptr;
    _ptr = (PFN_GLENABLECLIENTSTATEIEXT)_getPrivateProcAddress("glEnableClientStateiEXT");
    if (!_ptr) {
        _ptr = &_fail_glEnableClientStateiEXT;
    }
    _glEnableClientStateiEXT = _ptr;
    _glEnableClientStateiEXT(array, index);
}

PFN_GLENABLECLIENTSTATEIEXT _glEnableClientStateiEXT = &_get_glEnableClientStateiEXT;

static void APIENTRY _fail_glEnableVertexArrayAttribEXT(GLuint vaobj, GLuint index) {
    const char *_name = "glEnableVertexArrayAttribEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEnableVertexArrayAttribEXT(GLuint vaobj, GLuint index) {
    PFN_GLENABLEVERTEXARRAYATTRIBEXT _ptr;
    _ptr = (PFN_GLENABLEVERTEXARRAYATTRIBEXT)_getPrivateProcAddress("glEnableVertexArrayAttribEXT");
    if (!_ptr) {
        _ptr = &_fail_glEnableVertexArrayAttribEXT;
    }
    _glEnableVertexArrayAttribEXT = _ptr;
    _glEnableVertexArrayAttribEXT(vaobj, index);
}

PFN_GLENABLEVERTEXARRAYATTRIBEXT _glEnableVertexArrayAttribEXT = &_get_glEnableVertexArrayAttribEXT;

static void APIENTRY _fail_glEnableVertexArrayEXT(GLuint vaobj, GLenum array) {
    const char *_name = "glEnableVertexArrayEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEnableVertexArrayEXT(GLuint vaobj, GLenum array) {
    PFN_GLENABLEVERTEXARRAYEXT _ptr;
    _ptr = (PFN_GLENABLEVERTEXARRAYEXT)_getPrivateProcAddress("glEnableVertexArrayEXT");
    if (!_ptr) {
        _ptr = &_fail_glEnableVertexArrayEXT;
    }
    _glEnableVertexArrayEXT = _ptr;
    _glEnableVertexArrayEXT(vaobj, array);
}

PFN_GLENABLEVERTEXARRAYEXT _glEnableVertexArrayEXT = &_get_glEnableVertexArrayEXT;

static void APIENTRY _fail_glFlushMappedNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length) {
    const char *_name = "glFlushMappedNamedBufferRangeEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFlushMappedNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length) {
    PFN_GLFLUSHMAPPEDNAMEDBUFFERRANGEEXT _ptr;
    _ptr = (PFN_GLFLUSHMAPPEDNAMEDBUFFERRANGEEXT)_getPrivateProcAddress("glFlushMappedNamedBufferRangeEXT");
    if (!_ptr) {
        _ptr = &_fail_glFlushMappedNamedBufferRangeEXT;
    }
    _glFlushMappedNamedBufferRangeEXT = _ptr;
    _glFlushMappedNamedBufferRangeEXT(buffer, offset, length);
}

PFN_GLFLUSHMAPPEDNAMEDBUFFERRANGEEXT _glFlushMappedNamedBufferRangeEXT = &_get_glFlushMappedNamedBufferRangeEXT;

static void APIENTRY _fail_glFramebufferDrawBufferEXT(GLuint framebuffer, GLenum mode) {
    const char *_name = "glFramebufferDrawBufferEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferDrawBufferEXT(GLuint framebuffer, GLenum mode) {
    PFN_GLFRAMEBUFFERDRAWBUFFEREXT _ptr;
    _ptr = (PFN_GLFRAMEBUFFERDRAWBUFFEREXT)_getPrivateProcAddress("glFramebufferDrawBufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferDrawBufferEXT;
    }
    _glFramebufferDrawBufferEXT = _ptr;
    _glFramebufferDrawBufferEXT(framebuffer, mode);
}

PFN_GLFRAMEBUFFERDRAWBUFFEREXT _glFramebufferDrawBufferEXT = &_get_glFramebufferDrawBufferEXT;

static void APIENTRY _fail_glFramebufferDrawBuffersEXT(GLuint framebuffer, GLsizei n, const GLenum * bufs) {
    const char *_name = "glFramebufferDrawBuffersEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferDrawBuffersEXT(GLuint framebuffer, GLsizei n, const GLenum * bufs) {
    PFN_GLFRAMEBUFFERDRAWBUFFERSEXT _ptr;
    _ptr = (PFN_GLFRAMEBUFFERDRAWBUFFERSEXT)_getPrivateProcAddress("glFramebufferDrawBuffersEXT");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferDrawBuffersEXT;
    }
    _glFramebufferDrawBuffersEXT = _ptr;
    _glFramebufferDrawBuffersEXT(framebuffer, n, bufs);
}

PFN_GLFRAMEBUFFERDRAWBUFFERSEXT _glFramebufferDrawBuffersEXT = &_get_glFramebufferDrawBuffersEXT;

static void APIENTRY _fail_glFramebufferReadBufferEXT(GLuint framebuffer, GLenum mode) {
    const char *_name = "glFramebufferReadBufferEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferReadBufferEXT(GLuint framebuffer, GLenum mode) {
    PFN_GLFRAMEBUFFERREADBUFFEREXT _ptr;
    _ptr = (PFN_GLFRAMEBUFFERREADBUFFEREXT)_getPrivateProcAddress("glFramebufferReadBufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferReadBufferEXT;
    }
    _glFramebufferReadBufferEXT = _ptr;
    _glFramebufferReadBufferEXT(framebuffer, mode);
}

PFN_GLFRAMEBUFFERREADBUFFEREXT _glFramebufferReadBufferEXT = &_get_glFramebufferReadBufferEXT;

static void APIENTRY _fail_glGenerateMultiTexMipmapEXT(GLenum texunit, GLenum target) {
    const char *_name = "glGenerateMultiTexMipmapEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenerateMultiTexMipmapEXT(GLenum texunit, GLenum target) {
    PFN_GLGENERATEMULTITEXMIPMAPEXT _ptr;
    _ptr = (PFN_GLGENERATEMULTITEXMIPMAPEXT)_getPrivateProcAddress("glGenerateMultiTexMipmapEXT");
    if (!_ptr) {
        _ptr = &_fail_glGenerateMultiTexMipmapEXT;
    }
    _glGenerateMultiTexMipmapEXT = _ptr;
    _glGenerateMultiTexMipmapEXT(texunit, target);
}

PFN_GLGENERATEMULTITEXMIPMAPEXT _glGenerateMultiTexMipmapEXT = &_get_glGenerateMultiTexMipmapEXT;

static void APIENTRY _fail_glGenerateTextureMipmapEXT(GLuint texture, GLenum target) {
    const char *_name = "glGenerateTextureMipmapEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenerateTextureMipmapEXT(GLuint texture, GLenum target) {
    PFN_GLGENERATETEXTUREMIPMAPEXT _ptr;
    _ptr = (PFN_GLGENERATETEXTUREMIPMAPEXT)_getPrivateProcAddress("glGenerateTextureMipmapEXT");
    if (!_ptr) {
        _ptr = &_fail_glGenerateTextureMipmapEXT;
    }
    _glGenerateTextureMipmapEXT = _ptr;
    _glGenerateTextureMipmapEXT(texture, target);
}

PFN_GLGENERATETEXTUREMIPMAPEXT _glGenerateTextureMipmapEXT = &_get_glGenerateTextureMipmapEXT;

static void APIENTRY _fail_glGetCompressedMultiTexImageEXT(GLenum texunit, GLenum target, GLint lod, GLvoid * img) {
    const char *_name = "glGetCompressedMultiTexImageEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetCompressedMultiTexImageEXT(GLenum texunit, GLenum target, GLint lod, GLvoid * img) {
    PFN_GLGETCOMPRESSEDMULTITEXIMAGEEXT _ptr;
    _ptr = (PFN_GLGETCOMPRESSEDMULTITEXIMAGEEXT)_getPrivateProcAddress("glGetCompressedMultiTexImageEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetCompressedMultiTexImageEXT;
    }
    _glGetCompressedMultiTexImageEXT = _ptr;
    _glGetCompressedMultiTexImageEXT(texunit, target, lod, img);
}

PFN_GLGETCOMPRESSEDMULTITEXIMAGEEXT _glGetCompressedMultiTexImageEXT = &_get_glGetCompressedMultiTexImageEXT;

static void APIENTRY _fail_glGetCompressedTextureImageEXT(GLuint texture, GLenum target, GLint lod, GLvoid * img) {
    const char *_name = "glGetCompressedTextureImageEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetCompressedTextureImageEXT(GLuint texture, GLenum target, GLint lod, GLvoid * img) {
    PFN_GLGETCOMPRESSEDTEXTUREIMAGEEXT _ptr;
    _ptr = (PFN_GLGETCOMPRESSEDTEXTUREIMAGEEXT)_getPrivateProcAddress("glGetCompressedTextureImageEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetCompressedTextureImageEXT;
    }
    _glGetCompressedTextureImageEXT = _ptr;
    _glGetCompressedTextureImageEXT(texture, target, lod, img);
}

PFN_GLGETCOMPRESSEDTEXTUREIMAGEEXT _glGetCompressedTextureImageEXT = &_get_glGetCompressedTextureImageEXT;

static void APIENTRY _fail_glGetDoubleIndexedvEXT(GLenum target, GLuint index, GLdouble * data) {
    const char *_name = "glGetDoubleIndexedvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetDoubleIndexedvEXT(GLenum target, GLuint index, GLdouble * data) {
    PFN_GLGETDOUBLEINDEXEDVEXT _ptr;
    _ptr = (PFN_GLGETDOUBLEINDEXEDVEXT)_getPrivateProcAddress("glGetDoubleIndexedvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetDoubleIndexedvEXT;
    }
    _glGetDoubleIndexedvEXT = _ptr;
    _glGetDoubleIndexedvEXT(target, index, data);
}

PFN_GLGETDOUBLEINDEXEDVEXT _glGetDoubleIndexedvEXT = &_get_glGetDoubleIndexedvEXT;

static void APIENTRY _fail_glGetDoublei_vEXT(GLenum target, GLuint index, GLdouble * data) {
    const char *_name = "glGetDoublei_vEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetDoublei_vEXT(GLenum target, GLuint index, GLdouble * data) {
    PFN_GLGETDOUBLEI_VEXT _ptr;
    _ptr = (PFN_GLGETDOUBLEI_VEXT)_getPrivateProcAddress("glGetDoublei_vEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetDoublei_vEXT;
    }
    _glGetDoublei_vEXT = _ptr;
    _glGetDoublei_vEXT(target, index, data);
}

PFN_GLGETDOUBLEI_VEXT _glGetDoublei_vEXT = &_get_glGetDoublei_vEXT;

static void APIENTRY _fail_glGetFloatIndexedvEXT(GLenum target, GLuint index, GLfloat * data) {
    const char *_name = "glGetFloatIndexedvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFloatIndexedvEXT(GLenum target, GLuint index, GLfloat * data) {
    PFN_GLGETFLOATINDEXEDVEXT _ptr;
    _ptr = (PFN_GLGETFLOATINDEXEDVEXT)_getPrivateProcAddress("glGetFloatIndexedvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetFloatIndexedvEXT;
    }
    _glGetFloatIndexedvEXT = _ptr;
    _glGetFloatIndexedvEXT(target, index, data);
}

PFN_GLGETFLOATINDEXEDVEXT _glGetFloatIndexedvEXT = &_get_glGetFloatIndexedvEXT;

static void APIENTRY _fail_glGetFloati_vEXT(GLenum target, GLuint index, GLfloat * data) {
    const char *_name = "glGetFloati_vEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFloati_vEXT(GLenum target, GLuint index, GLfloat * data) {
    PFN_GLGETFLOATI_VEXT _ptr;
    _ptr = (PFN_GLGETFLOATI_VEXT)_getPrivateProcAddress("glGetFloati_vEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetFloati_vEXT;
    }
    _glGetFloati_vEXT = _ptr;
    _glGetFloati_vEXT(target, index, data);
}

PFN_GLGETFLOATI_VEXT _glGetFloati_vEXT = &_get_glGetFloati_vEXT;

static void APIENTRY _fail_glGetFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint * params) {
    const char *_name = "glGetFramebufferParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint * params) {
    PFN_GLGETFRAMEBUFFERPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLGETFRAMEBUFFERPARAMETERIVEXT)_getPrivateProcAddress("glGetFramebufferParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetFramebufferParameterivEXT;
    }
    _glGetFramebufferParameterivEXT = _ptr;
    _glGetFramebufferParameterivEXT(framebuffer, pname, params);
}

PFN_GLGETFRAMEBUFFERPARAMETERIVEXT _glGetFramebufferParameterivEXT = &_get_glGetFramebufferParameterivEXT;

static void APIENTRY _fail_glGetMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetMultiTexEnvfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat * params) {
    PFN_GLGETMULTITEXENVFVEXT _ptr;
    _ptr = (PFN_GLGETMULTITEXENVFVEXT)_getPrivateProcAddress("glGetMultiTexEnvfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetMultiTexEnvfvEXT;
    }
    _glGetMultiTexEnvfvEXT = _ptr;
    _glGetMultiTexEnvfvEXT(texunit, target, pname, params);
}

PFN_GLGETMULTITEXENVFVEXT _glGetMultiTexEnvfvEXT = &_get_glGetMultiTexEnvfvEXT;

static void APIENTRY _fail_glGetMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetMultiTexEnvivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETMULTITEXENVIVEXT _ptr;
    _ptr = (PFN_GLGETMULTITEXENVIVEXT)_getPrivateProcAddress("glGetMultiTexEnvivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetMultiTexEnvivEXT;
    }
    _glGetMultiTexEnvivEXT = _ptr;
    _glGetMultiTexEnvivEXT(texunit, target, pname, params);
}

PFN_GLGETMULTITEXENVIVEXT _glGetMultiTexEnvivEXT = &_get_glGetMultiTexEnvivEXT;

static void APIENTRY _fail_glGetMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble * params) {
    const char *_name = "glGetMultiTexGendvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble * params) {
    PFN_GLGETMULTITEXGENDVEXT _ptr;
    _ptr = (PFN_GLGETMULTITEXGENDVEXT)_getPrivateProcAddress("glGetMultiTexGendvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetMultiTexGendvEXT;
    }
    _glGetMultiTexGendvEXT = _ptr;
    _glGetMultiTexGendvEXT(texunit, coord, pname, params);
}

PFN_GLGETMULTITEXGENDVEXT _glGetMultiTexGendvEXT = &_get_glGetMultiTexGendvEXT;

static void APIENTRY _fail_glGetMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat * params) {
    const char *_name = "glGetMultiTexGenfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat * params) {
    PFN_GLGETMULTITEXGENFVEXT _ptr;
    _ptr = (PFN_GLGETMULTITEXGENFVEXT)_getPrivateProcAddress("glGetMultiTexGenfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetMultiTexGenfvEXT;
    }
    _glGetMultiTexGenfvEXT = _ptr;
    _glGetMultiTexGenfvEXT(texunit, coord, pname, params);
}

PFN_GLGETMULTITEXGENFVEXT _glGetMultiTexGenfvEXT = &_get_glGetMultiTexGenfvEXT;

static void APIENTRY _fail_glGetMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, GLint * params) {
    const char *_name = "glGetMultiTexGenivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, GLint * params) {
    PFN_GLGETMULTITEXGENIVEXT _ptr;
    _ptr = (PFN_GLGETMULTITEXGENIVEXT)_getPrivateProcAddress("glGetMultiTexGenivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetMultiTexGenivEXT;
    }
    _glGetMultiTexGenivEXT = _ptr;
    _glGetMultiTexGenivEXT(texunit, coord, pname, params);
}

PFN_GLGETMULTITEXGENIVEXT _glGetMultiTexGenivEXT = &_get_glGetMultiTexGenivEXT;

static void APIENTRY _fail_glGetMultiTexImageEXT(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels) {
    const char *_name = "glGetMultiTexImageEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMultiTexImageEXT(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels) {
    PFN_GLGETMULTITEXIMAGEEXT _ptr;
    _ptr = (PFN_GLGETMULTITEXIMAGEEXT)_getPrivateProcAddress("glGetMultiTexImageEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetMultiTexImageEXT;
    }
    _glGetMultiTexImageEXT = _ptr;
    _glGetMultiTexImageEXT(texunit, target, level, format, type, pixels);
}

PFN_GLGETMULTITEXIMAGEEXT _glGetMultiTexImageEXT = &_get_glGetMultiTexImageEXT;

static void APIENTRY _fail_glGetMultiTexLevelParameterfvEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat * params) {
    const char *_name = "glGetMultiTexLevelParameterfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMultiTexLevelParameterfvEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat * params) {
    PFN_GLGETMULTITEXLEVELPARAMETERFVEXT _ptr;
    _ptr = (PFN_GLGETMULTITEXLEVELPARAMETERFVEXT)_getPrivateProcAddress("glGetMultiTexLevelParameterfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetMultiTexLevelParameterfvEXT;
    }
    _glGetMultiTexLevelParameterfvEXT = _ptr;
    _glGetMultiTexLevelParameterfvEXT(texunit, target, level, pname, params);
}

PFN_GLGETMULTITEXLEVELPARAMETERFVEXT _glGetMultiTexLevelParameterfvEXT = &_get_glGetMultiTexLevelParameterfvEXT;

static void APIENTRY _fail_glGetMultiTexLevelParameterivEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint * params) {
    const char *_name = "glGetMultiTexLevelParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMultiTexLevelParameterivEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint * params) {
    PFN_GLGETMULTITEXLEVELPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLGETMULTITEXLEVELPARAMETERIVEXT)_getPrivateProcAddress("glGetMultiTexLevelParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetMultiTexLevelParameterivEXT;
    }
    _glGetMultiTexLevelParameterivEXT = _ptr;
    _glGetMultiTexLevelParameterivEXT(texunit, target, level, pname, params);
}

PFN_GLGETMULTITEXLEVELPARAMETERIVEXT _glGetMultiTexLevelParameterivEXT = &_get_glGetMultiTexLevelParameterivEXT;

static void APIENTRY _fail_glGetMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetMultiTexParameterIivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETMULTITEXPARAMETERIIVEXT _ptr;
    _ptr = (PFN_GLGETMULTITEXPARAMETERIIVEXT)_getPrivateProcAddress("glGetMultiTexParameterIivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetMultiTexParameterIivEXT;
    }
    _glGetMultiTexParameterIivEXT = _ptr;
    _glGetMultiTexParameterIivEXT(texunit, target, pname, params);
}

PFN_GLGETMULTITEXPARAMETERIIVEXT _glGetMultiTexParameterIivEXT = &_get_glGetMultiTexParameterIivEXT;

static void APIENTRY _fail_glGetMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, GLuint * params) {
    const char *_name = "glGetMultiTexParameterIuivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, GLuint * params) {
    PFN_GLGETMULTITEXPARAMETERIUIVEXT _ptr;
    _ptr = (PFN_GLGETMULTITEXPARAMETERIUIVEXT)_getPrivateProcAddress("glGetMultiTexParameterIuivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetMultiTexParameterIuivEXT;
    }
    _glGetMultiTexParameterIuivEXT = _ptr;
    _glGetMultiTexParameterIuivEXT(texunit, target, pname, params);
}

PFN_GLGETMULTITEXPARAMETERIUIVEXT _glGetMultiTexParameterIuivEXT = &_get_glGetMultiTexParameterIuivEXT;

static void APIENTRY _fail_glGetMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetMultiTexParameterfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat * params) {
    PFN_GLGETMULTITEXPARAMETERFVEXT _ptr;
    _ptr = (PFN_GLGETMULTITEXPARAMETERFVEXT)_getPrivateProcAddress("glGetMultiTexParameterfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetMultiTexParameterfvEXT;
    }
    _glGetMultiTexParameterfvEXT = _ptr;
    _glGetMultiTexParameterfvEXT(texunit, target, pname, params);
}

PFN_GLGETMULTITEXPARAMETERFVEXT _glGetMultiTexParameterfvEXT = &_get_glGetMultiTexParameterfvEXT;

static void APIENTRY _fail_glGetMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetMultiTexParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETMULTITEXPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLGETMULTITEXPARAMETERIVEXT)_getPrivateProcAddress("glGetMultiTexParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetMultiTexParameterivEXT;
    }
    _glGetMultiTexParameterivEXT = _ptr;
    _glGetMultiTexParameterivEXT(texunit, target, pname, params);
}

PFN_GLGETMULTITEXPARAMETERIVEXT _glGetMultiTexParameterivEXT = &_get_glGetMultiTexParameterivEXT;

static void APIENTRY _fail_glGetNamedBufferParameterivEXT(GLuint buffer, GLenum pname, GLint * params) {
    const char *_name = "glGetNamedBufferParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedBufferParameterivEXT(GLuint buffer, GLenum pname, GLint * params) {
    PFN_GLGETNAMEDBUFFERPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLGETNAMEDBUFFERPARAMETERIVEXT)_getPrivateProcAddress("glGetNamedBufferParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedBufferParameterivEXT;
    }
    _glGetNamedBufferParameterivEXT = _ptr;
    _glGetNamedBufferParameterivEXT(buffer, pname, params);
}

PFN_GLGETNAMEDBUFFERPARAMETERIVEXT _glGetNamedBufferParameterivEXT = &_get_glGetNamedBufferParameterivEXT;

static void APIENTRY _fail_glGetNamedBufferPointervEXT(GLuint buffer, GLenum pname, GLvoid * * params) {
    const char *_name = "glGetNamedBufferPointervEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedBufferPointervEXT(GLuint buffer, GLenum pname, GLvoid * * params) {
    PFN_GLGETNAMEDBUFFERPOINTERVEXT _ptr;
    _ptr = (PFN_GLGETNAMEDBUFFERPOINTERVEXT)_getPrivateProcAddress("glGetNamedBufferPointervEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedBufferPointervEXT;
    }
    _glGetNamedBufferPointervEXT = _ptr;
    _glGetNamedBufferPointervEXT(buffer, pname, params);
}

PFN_GLGETNAMEDBUFFERPOINTERVEXT _glGetNamedBufferPointervEXT = &_get_glGetNamedBufferPointervEXT;

static void APIENTRY _fail_glGetNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid * data) {
    const char *_name = "glGetNamedBufferSubDataEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid * data) {
    PFN_GLGETNAMEDBUFFERSUBDATAEXT _ptr;
    _ptr = (PFN_GLGETNAMEDBUFFERSUBDATAEXT)_getPrivateProcAddress("glGetNamedBufferSubDataEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedBufferSubDataEXT;
    }
    _glGetNamedBufferSubDataEXT = _ptr;
    _glGetNamedBufferSubDataEXT(buffer, offset, size, data);
}

PFN_GLGETNAMEDBUFFERSUBDATAEXT _glGetNamedBufferSubDataEXT = &_get_glGetNamedBufferSubDataEXT;

static void APIENTRY _fail_glGetNamedFramebufferAttachmentParameterivEXT(GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params) {
    const char *_name = "glGetNamedFramebufferAttachmentParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedFramebufferAttachmentParameterivEXT(GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params) {
    PFN_GLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXT)_getPrivateProcAddress("glGetNamedFramebufferAttachmentParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedFramebufferAttachmentParameterivEXT;
    }
    _glGetNamedFramebufferAttachmentParameterivEXT = _ptr;
    _glGetNamedFramebufferAttachmentParameterivEXT(framebuffer, attachment, pname, params);
}

PFN_GLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXT _glGetNamedFramebufferAttachmentParameterivEXT = &_get_glGetNamedFramebufferAttachmentParameterivEXT;

static void APIENTRY _fail_glGetNamedFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint * params) {
    const char *_name = "glGetNamedFramebufferParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint * params) {
    PFN_GLGETNAMEDFRAMEBUFFERPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLGETNAMEDFRAMEBUFFERPARAMETERIVEXT)_getPrivateProcAddress("glGetNamedFramebufferParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedFramebufferParameterivEXT;
    }
    _glGetNamedFramebufferParameterivEXT = _ptr;
    _glGetNamedFramebufferParameterivEXT(framebuffer, pname, params);
}

PFN_GLGETNAMEDFRAMEBUFFERPARAMETERIVEXT _glGetNamedFramebufferParameterivEXT = &_get_glGetNamedFramebufferParameterivEXT;

static void APIENTRY _fail_glGetNamedProgramLocalParameterIivEXT(GLuint program, GLenum target, GLuint index, GLint * params) {
    const char *_name = "glGetNamedProgramLocalParameterIivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedProgramLocalParameterIivEXT(GLuint program, GLenum target, GLuint index, GLint * params) {
    PFN_GLGETNAMEDPROGRAMLOCALPARAMETERIIVEXT _ptr;
    _ptr = (PFN_GLGETNAMEDPROGRAMLOCALPARAMETERIIVEXT)_getPrivateProcAddress("glGetNamedProgramLocalParameterIivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedProgramLocalParameterIivEXT;
    }
    _glGetNamedProgramLocalParameterIivEXT = _ptr;
    _glGetNamedProgramLocalParameterIivEXT(program, target, index, params);
}

PFN_GLGETNAMEDPROGRAMLOCALPARAMETERIIVEXT _glGetNamedProgramLocalParameterIivEXT = &_get_glGetNamedProgramLocalParameterIivEXT;

static void APIENTRY _fail_glGetNamedProgramLocalParameterIuivEXT(GLuint program, GLenum target, GLuint index, GLuint * params) {
    const char *_name = "glGetNamedProgramLocalParameterIuivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedProgramLocalParameterIuivEXT(GLuint program, GLenum target, GLuint index, GLuint * params) {
    PFN_GLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXT _ptr;
    _ptr = (PFN_GLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXT)_getPrivateProcAddress("glGetNamedProgramLocalParameterIuivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedProgramLocalParameterIuivEXT;
    }
    _glGetNamedProgramLocalParameterIuivEXT = _ptr;
    _glGetNamedProgramLocalParameterIuivEXT(program, target, index, params);
}

PFN_GLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXT _glGetNamedProgramLocalParameterIuivEXT = &_get_glGetNamedProgramLocalParameterIuivEXT;

static void APIENTRY _fail_glGetNamedProgramLocalParameterdvEXT(GLuint program, GLenum target, GLuint index, GLdouble * params) {
    const char *_name = "glGetNamedProgramLocalParameterdvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedProgramLocalParameterdvEXT(GLuint program, GLenum target, GLuint index, GLdouble * params) {
    PFN_GLGETNAMEDPROGRAMLOCALPARAMETERDVEXT _ptr;
    _ptr = (PFN_GLGETNAMEDPROGRAMLOCALPARAMETERDVEXT)_getPrivateProcAddress("glGetNamedProgramLocalParameterdvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedProgramLocalParameterdvEXT;
    }
    _glGetNamedProgramLocalParameterdvEXT = _ptr;
    _glGetNamedProgramLocalParameterdvEXT(program, target, index, params);
}

PFN_GLGETNAMEDPROGRAMLOCALPARAMETERDVEXT _glGetNamedProgramLocalParameterdvEXT = &_get_glGetNamedProgramLocalParameterdvEXT;

static void APIENTRY _fail_glGetNamedProgramLocalParameterfvEXT(GLuint program, GLenum target, GLuint index, GLfloat * params) {
    const char *_name = "glGetNamedProgramLocalParameterfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedProgramLocalParameterfvEXT(GLuint program, GLenum target, GLuint index, GLfloat * params) {
    PFN_GLGETNAMEDPROGRAMLOCALPARAMETERFVEXT _ptr;
    _ptr = (PFN_GLGETNAMEDPROGRAMLOCALPARAMETERFVEXT)_getPrivateProcAddress("glGetNamedProgramLocalParameterfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedProgramLocalParameterfvEXT;
    }
    _glGetNamedProgramLocalParameterfvEXT = _ptr;
    _glGetNamedProgramLocalParameterfvEXT(program, target, index, params);
}

PFN_GLGETNAMEDPROGRAMLOCALPARAMETERFVEXT _glGetNamedProgramLocalParameterfvEXT = &_get_glGetNamedProgramLocalParameterfvEXT;

static void APIENTRY _fail_glGetNamedProgramStringEXT(GLuint program, GLenum target, GLenum pname, GLvoid * string) {
    const char *_name = "glGetNamedProgramStringEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedProgramStringEXT(GLuint program, GLenum target, GLenum pname, GLvoid * string) {
    PFN_GLGETNAMEDPROGRAMSTRINGEXT _ptr;
    _ptr = (PFN_GLGETNAMEDPROGRAMSTRINGEXT)_getPrivateProcAddress("glGetNamedProgramStringEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedProgramStringEXT;
    }
    _glGetNamedProgramStringEXT = _ptr;
    _glGetNamedProgramStringEXT(program, target, pname, string);
}

PFN_GLGETNAMEDPROGRAMSTRINGEXT _glGetNamedProgramStringEXT = &_get_glGetNamedProgramStringEXT;

static void APIENTRY _fail_glGetNamedProgramivEXT(GLuint program, GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetNamedProgramivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedProgramivEXT(GLuint program, GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETNAMEDPROGRAMIVEXT _ptr;
    _ptr = (PFN_GLGETNAMEDPROGRAMIVEXT)_getPrivateProcAddress("glGetNamedProgramivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedProgramivEXT;
    }
    _glGetNamedProgramivEXT = _ptr;
    _glGetNamedProgramivEXT(program, target, pname, params);
}

PFN_GLGETNAMEDPROGRAMIVEXT _glGetNamedProgramivEXT = &_get_glGetNamedProgramivEXT;

static void APIENTRY _fail_glGetNamedRenderbufferParameterivEXT(GLuint renderbuffer, GLenum pname, GLint * params) {
    const char *_name = "glGetNamedRenderbufferParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedRenderbufferParameterivEXT(GLuint renderbuffer, GLenum pname, GLint * params) {
    PFN_GLGETNAMEDRENDERBUFFERPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLGETNAMEDRENDERBUFFERPARAMETERIVEXT)_getPrivateProcAddress("glGetNamedRenderbufferParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedRenderbufferParameterivEXT;
    }
    _glGetNamedRenderbufferParameterivEXT = _ptr;
    _glGetNamedRenderbufferParameterivEXT(renderbuffer, pname, params);
}

PFN_GLGETNAMEDRENDERBUFFERPARAMETERIVEXT _glGetNamedRenderbufferParameterivEXT = &_get_glGetNamedRenderbufferParameterivEXT;

static void APIENTRY _fail_glGetPointerIndexedvEXT(GLenum target, GLuint index, GLvoid * * data) {
    const char *_name = "glGetPointerIndexedvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPointerIndexedvEXT(GLenum target, GLuint index, GLvoid * * data) {
    PFN_GLGETPOINTERINDEXEDVEXT _ptr;
    _ptr = (PFN_GLGETPOINTERINDEXEDVEXT)_getPrivateProcAddress("glGetPointerIndexedvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetPointerIndexedvEXT;
    }
    _glGetPointerIndexedvEXT = _ptr;
    _glGetPointerIndexedvEXT(target, index, data);
}

PFN_GLGETPOINTERINDEXEDVEXT _glGetPointerIndexedvEXT = &_get_glGetPointerIndexedvEXT;

static void APIENTRY _fail_glGetPointeri_vEXT(GLenum target, GLuint index, GLvoid * * data) {
    const char *_name = "glGetPointeri_vEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPointeri_vEXT(GLenum target, GLuint index, GLvoid * * data) {
    PFN_GLGETPOINTERI_VEXT _ptr;
    _ptr = (PFN_GLGETPOINTERI_VEXT)_getPrivateProcAddress("glGetPointeri_vEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetPointeri_vEXT;
    }
    _glGetPointeri_vEXT = _ptr;
    _glGetPointeri_vEXT(target, index, data);
}

PFN_GLGETPOINTERI_VEXT _glGetPointeri_vEXT = &_get_glGetPointeri_vEXT;

static void APIENTRY _fail_glGetTextureImageEXT(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels) {
    const char *_name = "glGetTextureImageEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTextureImageEXT(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels) {
    PFN_GLGETTEXTUREIMAGEEXT _ptr;
    _ptr = (PFN_GLGETTEXTUREIMAGEEXT)_getPrivateProcAddress("glGetTextureImageEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureImageEXT;
    }
    _glGetTextureImageEXT = _ptr;
    _glGetTextureImageEXT(texture, target, level, format, type, pixels);
}

PFN_GLGETTEXTUREIMAGEEXT _glGetTextureImageEXT = &_get_glGetTextureImageEXT;

static void APIENTRY _fail_glGetTextureLevelParameterfvEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat * params) {
    const char *_name = "glGetTextureLevelParameterfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTextureLevelParameterfvEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat * params) {
    PFN_GLGETTEXTURELEVELPARAMETERFVEXT _ptr;
    _ptr = (PFN_GLGETTEXTURELEVELPARAMETERFVEXT)_getPrivateProcAddress("glGetTextureLevelParameterfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureLevelParameterfvEXT;
    }
    _glGetTextureLevelParameterfvEXT = _ptr;
    _glGetTextureLevelParameterfvEXT(texture, target, level, pname, params);
}

PFN_GLGETTEXTURELEVELPARAMETERFVEXT _glGetTextureLevelParameterfvEXT = &_get_glGetTextureLevelParameterfvEXT;

static void APIENTRY _fail_glGetTextureLevelParameterivEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLint * params) {
    const char *_name = "glGetTextureLevelParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTextureLevelParameterivEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLint * params) {
    PFN_GLGETTEXTURELEVELPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLGETTEXTURELEVELPARAMETERIVEXT)_getPrivateProcAddress("glGetTextureLevelParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureLevelParameterivEXT;
    }
    _glGetTextureLevelParameterivEXT = _ptr;
    _glGetTextureLevelParameterivEXT(texture, target, level, pname, params);
}

PFN_GLGETTEXTURELEVELPARAMETERIVEXT _glGetTextureLevelParameterivEXT = &_get_glGetTextureLevelParameterivEXT;

static void APIENTRY _fail_glGetTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetTextureParameterIivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETTEXTUREPARAMETERIIVEXT _ptr;
    _ptr = (PFN_GLGETTEXTUREPARAMETERIIVEXT)_getPrivateProcAddress("glGetTextureParameterIivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureParameterIivEXT;
    }
    _glGetTextureParameterIivEXT = _ptr;
    _glGetTextureParameterIivEXT(texture, target, pname, params);
}

PFN_GLGETTEXTUREPARAMETERIIVEXT _glGetTextureParameterIivEXT = &_get_glGetTextureParameterIivEXT;

static void APIENTRY _fail_glGetTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, GLuint * params) {
    const char *_name = "glGetTextureParameterIuivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, GLuint * params) {
    PFN_GLGETTEXTUREPARAMETERIUIVEXT _ptr;
    _ptr = (PFN_GLGETTEXTUREPARAMETERIUIVEXT)_getPrivateProcAddress("glGetTextureParameterIuivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureParameterIuivEXT;
    }
    _glGetTextureParameterIuivEXT = _ptr;
    _glGetTextureParameterIuivEXT(texture, target, pname, params);
}

PFN_GLGETTEXTUREPARAMETERIUIVEXT _glGetTextureParameterIuivEXT = &_get_glGetTextureParameterIuivEXT;

static void APIENTRY _fail_glGetTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetTextureParameterfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, GLfloat * params) {
    PFN_GLGETTEXTUREPARAMETERFVEXT _ptr;
    _ptr = (PFN_GLGETTEXTUREPARAMETERFVEXT)_getPrivateProcAddress("glGetTextureParameterfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureParameterfvEXT;
    }
    _glGetTextureParameterfvEXT = _ptr;
    _glGetTextureParameterfvEXT(texture, target, pname, params);
}

PFN_GLGETTEXTUREPARAMETERFVEXT _glGetTextureParameterfvEXT = &_get_glGetTextureParameterfvEXT;

static void APIENTRY _fail_glGetTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetTextureParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETTEXTUREPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLGETTEXTUREPARAMETERIVEXT)_getPrivateProcAddress("glGetTextureParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureParameterivEXT;
    }
    _glGetTextureParameterivEXT = _ptr;
    _glGetTextureParameterivEXT(texture, target, pname, params);
}

PFN_GLGETTEXTUREPARAMETERIVEXT _glGetTextureParameterivEXT = &_get_glGetTextureParameterivEXT;

static void APIENTRY _fail_glGetVertexArrayIntegeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLint * param) {
    const char *_name = "glGetVertexArrayIntegeri_vEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexArrayIntegeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLint * param) {
    PFN_GLGETVERTEXARRAYINTEGERI_VEXT _ptr;
    _ptr = (PFN_GLGETVERTEXARRAYINTEGERI_VEXT)_getPrivateProcAddress("glGetVertexArrayIntegeri_vEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexArrayIntegeri_vEXT;
    }
    _glGetVertexArrayIntegeri_vEXT = _ptr;
    _glGetVertexArrayIntegeri_vEXT(vaobj, index, pname, param);
}

PFN_GLGETVERTEXARRAYINTEGERI_VEXT _glGetVertexArrayIntegeri_vEXT = &_get_glGetVertexArrayIntegeri_vEXT;

static void APIENTRY _fail_glGetVertexArrayIntegervEXT(GLuint vaobj, GLenum pname, GLint * param) {
    const char *_name = "glGetVertexArrayIntegervEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexArrayIntegervEXT(GLuint vaobj, GLenum pname, GLint * param) {
    PFN_GLGETVERTEXARRAYINTEGERVEXT _ptr;
    _ptr = (PFN_GLGETVERTEXARRAYINTEGERVEXT)_getPrivateProcAddress("glGetVertexArrayIntegervEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexArrayIntegervEXT;
    }
    _glGetVertexArrayIntegervEXT = _ptr;
    _glGetVertexArrayIntegervEXT(vaobj, pname, param);
}

PFN_GLGETVERTEXARRAYINTEGERVEXT _glGetVertexArrayIntegervEXT = &_get_glGetVertexArrayIntegervEXT;

static void APIENTRY _fail_glGetVertexArrayPointeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLvoid * * param) {
    const char *_name = "glGetVertexArrayPointeri_vEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexArrayPointeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLvoid * * param) {
    PFN_GLGETVERTEXARRAYPOINTERI_VEXT _ptr;
    _ptr = (PFN_GLGETVERTEXARRAYPOINTERI_VEXT)_getPrivateProcAddress("glGetVertexArrayPointeri_vEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexArrayPointeri_vEXT;
    }
    _glGetVertexArrayPointeri_vEXT = _ptr;
    _glGetVertexArrayPointeri_vEXT(vaobj, index, pname, param);
}

PFN_GLGETVERTEXARRAYPOINTERI_VEXT _glGetVertexArrayPointeri_vEXT = &_get_glGetVertexArrayPointeri_vEXT;

static void APIENTRY _fail_glGetVertexArrayPointervEXT(GLuint vaobj, GLenum pname, GLvoid * * param) {
    const char *_name = "glGetVertexArrayPointervEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexArrayPointervEXT(GLuint vaobj, GLenum pname, GLvoid * * param) {
    PFN_GLGETVERTEXARRAYPOINTERVEXT _ptr;
    _ptr = (PFN_GLGETVERTEXARRAYPOINTERVEXT)_getPrivateProcAddress("glGetVertexArrayPointervEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexArrayPointervEXT;
    }
    _glGetVertexArrayPointervEXT = _ptr;
    _glGetVertexArrayPointervEXT(vaobj, pname, param);
}

PFN_GLGETVERTEXARRAYPOINTERVEXT _glGetVertexArrayPointervEXT = &_get_glGetVertexArrayPointervEXT;

static GLvoid * APIENTRY _fail_glMapNamedBufferEXT(GLuint buffer, GLenum access) {
    const char *_name = "glMapNamedBufferEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLvoid * APIENTRY _get_glMapNamedBufferEXT(GLuint buffer, GLenum access) {
    PFN_GLMAPNAMEDBUFFEREXT _ptr;
    _ptr = (PFN_GLMAPNAMEDBUFFEREXT)_getPrivateProcAddress("glMapNamedBufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glMapNamedBufferEXT;
    }
    _glMapNamedBufferEXT = _ptr;
    return _glMapNamedBufferEXT(buffer, access);
}

PFN_GLMAPNAMEDBUFFEREXT _glMapNamedBufferEXT = &_get_glMapNamedBufferEXT;

static GLvoid * APIENTRY _fail_glMapNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access) {
    const char *_name = "glMapNamedBufferRangeEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLvoid * APIENTRY _get_glMapNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access) {
    PFN_GLMAPNAMEDBUFFERRANGEEXT _ptr;
    _ptr = (PFN_GLMAPNAMEDBUFFERRANGEEXT)_getPrivateProcAddress("glMapNamedBufferRangeEXT");
    if (!_ptr) {
        _ptr = &_fail_glMapNamedBufferRangeEXT;
    }
    _glMapNamedBufferRangeEXT = _ptr;
    return _glMapNamedBufferRangeEXT(buffer, offset, length, access);
}

PFN_GLMAPNAMEDBUFFERRANGEEXT _glMapNamedBufferRangeEXT = &_get_glMapNamedBufferRangeEXT;

static void APIENTRY _fail_glMatrixFrustumEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    const char *_name = "glMatrixFrustumEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixFrustumEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    PFN_GLMATRIXFRUSTUMEXT _ptr;
    _ptr = (PFN_GLMATRIXFRUSTUMEXT)_getPrivateProcAddress("glMatrixFrustumEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixFrustumEXT;
    }
    _glMatrixFrustumEXT = _ptr;
    _glMatrixFrustumEXT(mode, left, right, bottom, top, zNear, zFar);
}

PFN_GLMATRIXFRUSTUMEXT _glMatrixFrustumEXT = &_get_glMatrixFrustumEXT;

static void APIENTRY _fail_glMatrixLoadIdentityEXT(GLenum mode) {
    const char *_name = "glMatrixLoadIdentityEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixLoadIdentityEXT(GLenum mode) {
    PFN_GLMATRIXLOADIDENTITYEXT _ptr;
    _ptr = (PFN_GLMATRIXLOADIDENTITYEXT)_getPrivateProcAddress("glMatrixLoadIdentityEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixLoadIdentityEXT;
    }
    _glMatrixLoadIdentityEXT = _ptr;
    _glMatrixLoadIdentityEXT(mode);
}

PFN_GLMATRIXLOADIDENTITYEXT _glMatrixLoadIdentityEXT = &_get_glMatrixLoadIdentityEXT;

static void APIENTRY _fail_glMatrixLoadTransposedEXT(GLenum mode, const GLdouble * m) {
    const char *_name = "glMatrixLoadTransposedEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixLoadTransposedEXT(GLenum mode, const GLdouble * m) {
    PFN_GLMATRIXLOADTRANSPOSEDEXT _ptr;
    _ptr = (PFN_GLMATRIXLOADTRANSPOSEDEXT)_getPrivateProcAddress("glMatrixLoadTransposedEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixLoadTransposedEXT;
    }
    _glMatrixLoadTransposedEXT = _ptr;
    _glMatrixLoadTransposedEXT(mode, m);
}

PFN_GLMATRIXLOADTRANSPOSEDEXT _glMatrixLoadTransposedEXT = &_get_glMatrixLoadTransposedEXT;

static void APIENTRY _fail_glMatrixLoadTransposefEXT(GLenum mode, const GLfloat * m) {
    const char *_name = "glMatrixLoadTransposefEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixLoadTransposefEXT(GLenum mode, const GLfloat * m) {
    PFN_GLMATRIXLOADTRANSPOSEFEXT _ptr;
    _ptr = (PFN_GLMATRIXLOADTRANSPOSEFEXT)_getPrivateProcAddress("glMatrixLoadTransposefEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixLoadTransposefEXT;
    }
    _glMatrixLoadTransposefEXT = _ptr;
    _glMatrixLoadTransposefEXT(mode, m);
}

PFN_GLMATRIXLOADTRANSPOSEFEXT _glMatrixLoadTransposefEXT = &_get_glMatrixLoadTransposefEXT;

static void APIENTRY _fail_glMatrixLoaddEXT(GLenum mode, const GLdouble * m) {
    const char *_name = "glMatrixLoaddEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixLoaddEXT(GLenum mode, const GLdouble * m) {
    PFN_GLMATRIXLOADDEXT _ptr;
    _ptr = (PFN_GLMATRIXLOADDEXT)_getPrivateProcAddress("glMatrixLoaddEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixLoaddEXT;
    }
    _glMatrixLoaddEXT = _ptr;
    _glMatrixLoaddEXT(mode, m);
}

PFN_GLMATRIXLOADDEXT _glMatrixLoaddEXT = &_get_glMatrixLoaddEXT;

static void APIENTRY _fail_glMatrixLoadfEXT(GLenum mode, const GLfloat * m) {
    const char *_name = "glMatrixLoadfEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixLoadfEXT(GLenum mode, const GLfloat * m) {
    PFN_GLMATRIXLOADFEXT _ptr;
    _ptr = (PFN_GLMATRIXLOADFEXT)_getPrivateProcAddress("glMatrixLoadfEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixLoadfEXT;
    }
    _glMatrixLoadfEXT = _ptr;
    _glMatrixLoadfEXT(mode, m);
}

PFN_GLMATRIXLOADFEXT _glMatrixLoadfEXT = &_get_glMatrixLoadfEXT;

static void APIENTRY _fail_glMatrixMultTransposedEXT(GLenum mode, const GLdouble * m) {
    const char *_name = "glMatrixMultTransposedEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixMultTransposedEXT(GLenum mode, const GLdouble * m) {
    PFN_GLMATRIXMULTTRANSPOSEDEXT _ptr;
    _ptr = (PFN_GLMATRIXMULTTRANSPOSEDEXT)_getPrivateProcAddress("glMatrixMultTransposedEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixMultTransposedEXT;
    }
    _glMatrixMultTransposedEXT = _ptr;
    _glMatrixMultTransposedEXT(mode, m);
}

PFN_GLMATRIXMULTTRANSPOSEDEXT _glMatrixMultTransposedEXT = &_get_glMatrixMultTransposedEXT;

static void APIENTRY _fail_glMatrixMultTransposefEXT(GLenum mode, const GLfloat * m) {
    const char *_name = "glMatrixMultTransposefEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixMultTransposefEXT(GLenum mode, const GLfloat * m) {
    PFN_GLMATRIXMULTTRANSPOSEFEXT _ptr;
    _ptr = (PFN_GLMATRIXMULTTRANSPOSEFEXT)_getPrivateProcAddress("glMatrixMultTransposefEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixMultTransposefEXT;
    }
    _glMatrixMultTransposefEXT = _ptr;
    _glMatrixMultTransposefEXT(mode, m);
}

PFN_GLMATRIXMULTTRANSPOSEFEXT _glMatrixMultTransposefEXT = &_get_glMatrixMultTransposefEXT;

static void APIENTRY _fail_glMatrixMultdEXT(GLenum mode, const GLdouble * m) {
    const char *_name = "glMatrixMultdEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixMultdEXT(GLenum mode, const GLdouble * m) {
    PFN_GLMATRIXMULTDEXT _ptr;
    _ptr = (PFN_GLMATRIXMULTDEXT)_getPrivateProcAddress("glMatrixMultdEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixMultdEXT;
    }
    _glMatrixMultdEXT = _ptr;
    _glMatrixMultdEXT(mode, m);
}

PFN_GLMATRIXMULTDEXT _glMatrixMultdEXT = &_get_glMatrixMultdEXT;

static void APIENTRY _fail_glMatrixMultfEXT(GLenum mode, const GLfloat * m) {
    const char *_name = "glMatrixMultfEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixMultfEXT(GLenum mode, const GLfloat * m) {
    PFN_GLMATRIXMULTFEXT _ptr;
    _ptr = (PFN_GLMATRIXMULTFEXT)_getPrivateProcAddress("glMatrixMultfEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixMultfEXT;
    }
    _glMatrixMultfEXT = _ptr;
    _glMatrixMultfEXT(mode, m);
}

PFN_GLMATRIXMULTFEXT _glMatrixMultfEXT = &_get_glMatrixMultfEXT;

static void APIENTRY _fail_glMatrixOrthoEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    const char *_name = "glMatrixOrthoEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixOrthoEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    PFN_GLMATRIXORTHOEXT _ptr;
    _ptr = (PFN_GLMATRIXORTHOEXT)_getPrivateProcAddress("glMatrixOrthoEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixOrthoEXT;
    }
    _glMatrixOrthoEXT = _ptr;
    _glMatrixOrthoEXT(mode, left, right, bottom, top, zNear, zFar);
}

PFN_GLMATRIXORTHOEXT _glMatrixOrthoEXT = &_get_glMatrixOrthoEXT;

static void APIENTRY _fail_glMatrixPopEXT(GLenum mode) {
    const char *_name = "glMatrixPopEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixPopEXT(GLenum mode) {
    PFN_GLMATRIXPOPEXT _ptr;
    _ptr = (PFN_GLMATRIXPOPEXT)_getPrivateProcAddress("glMatrixPopEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixPopEXT;
    }
    _glMatrixPopEXT = _ptr;
    _glMatrixPopEXT(mode);
}

PFN_GLMATRIXPOPEXT _glMatrixPopEXT = &_get_glMatrixPopEXT;

static void APIENTRY _fail_glMatrixPushEXT(GLenum mode) {
    const char *_name = "glMatrixPushEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixPushEXT(GLenum mode) {
    PFN_GLMATRIXPUSHEXT _ptr;
    _ptr = (PFN_GLMATRIXPUSHEXT)_getPrivateProcAddress("glMatrixPushEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixPushEXT;
    }
    _glMatrixPushEXT = _ptr;
    _glMatrixPushEXT(mode);
}

PFN_GLMATRIXPUSHEXT _glMatrixPushEXT = &_get_glMatrixPushEXT;

static void APIENTRY _fail_glMatrixRotatedEXT(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glMatrixRotatedEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixRotatedEXT(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLMATRIXROTATEDEXT _ptr;
    _ptr = (PFN_GLMATRIXROTATEDEXT)_getPrivateProcAddress("glMatrixRotatedEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixRotatedEXT;
    }
    _glMatrixRotatedEXT = _ptr;
    _glMatrixRotatedEXT(mode, angle, x, y, z);
}

PFN_GLMATRIXROTATEDEXT _glMatrixRotatedEXT = &_get_glMatrixRotatedEXT;

static void APIENTRY _fail_glMatrixRotatefEXT(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glMatrixRotatefEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixRotatefEXT(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLMATRIXROTATEFEXT _ptr;
    _ptr = (PFN_GLMATRIXROTATEFEXT)_getPrivateProcAddress("glMatrixRotatefEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixRotatefEXT;
    }
    _glMatrixRotatefEXT = _ptr;
    _glMatrixRotatefEXT(mode, angle, x, y, z);
}

PFN_GLMATRIXROTATEFEXT _glMatrixRotatefEXT = &_get_glMatrixRotatefEXT;

static void APIENTRY _fail_glMatrixScaledEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glMatrixScaledEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixScaledEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLMATRIXSCALEDEXT _ptr;
    _ptr = (PFN_GLMATRIXSCALEDEXT)_getPrivateProcAddress("glMatrixScaledEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixScaledEXT;
    }
    _glMatrixScaledEXT = _ptr;
    _glMatrixScaledEXT(mode, x, y, z);
}

PFN_GLMATRIXSCALEDEXT _glMatrixScaledEXT = &_get_glMatrixScaledEXT;

static void APIENTRY _fail_glMatrixScalefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glMatrixScalefEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixScalefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLMATRIXSCALEFEXT _ptr;
    _ptr = (PFN_GLMATRIXSCALEFEXT)_getPrivateProcAddress("glMatrixScalefEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixScalefEXT;
    }
    _glMatrixScalefEXT = _ptr;
    _glMatrixScalefEXT(mode, x, y, z);
}

PFN_GLMATRIXSCALEFEXT _glMatrixScalefEXT = &_get_glMatrixScalefEXT;

static void APIENTRY _fail_glMatrixTranslatedEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glMatrixTranslatedEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixTranslatedEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLMATRIXTRANSLATEDEXT _ptr;
    _ptr = (PFN_GLMATRIXTRANSLATEDEXT)_getPrivateProcAddress("glMatrixTranslatedEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixTranslatedEXT;
    }
    _glMatrixTranslatedEXT = _ptr;
    _glMatrixTranslatedEXT(mode, x, y, z);
}

PFN_GLMATRIXTRANSLATEDEXT _glMatrixTranslatedEXT = &_get_glMatrixTranslatedEXT;

static void APIENTRY _fail_glMatrixTranslatefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glMatrixTranslatefEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixTranslatefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLMATRIXTRANSLATEFEXT _ptr;
    _ptr = (PFN_GLMATRIXTRANSLATEFEXT)_getPrivateProcAddress("glMatrixTranslatefEXT");
    if (!_ptr) {
        _ptr = &_fail_glMatrixTranslatefEXT;
    }
    _glMatrixTranslatefEXT = _ptr;
    _glMatrixTranslatefEXT(mode, x, y, z);
}

PFN_GLMATRIXTRANSLATEFEXT _glMatrixTranslatefEXT = &_get_glMatrixTranslatefEXT;

static void APIENTRY _fail_glMultiTexBufferEXT(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer) {
    const char *_name = "glMultiTexBufferEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexBufferEXT(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer) {
    PFN_GLMULTITEXBUFFEREXT _ptr;
    _ptr = (PFN_GLMULTITEXBUFFEREXT)_getPrivateProcAddress("glMultiTexBufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexBufferEXT;
    }
    _glMultiTexBufferEXT = _ptr;
    _glMultiTexBufferEXT(texunit, target, internalformat, buffer);
}

PFN_GLMULTITEXBUFFEREXT _glMultiTexBufferEXT = &_get_glMultiTexBufferEXT;

static void APIENTRY _fail_glMultiTexCoordPointerEXT(GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glMultiTexCoordPointerEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoordPointerEXT(GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLMULTITEXCOORDPOINTEREXT _ptr;
    _ptr = (PFN_GLMULTITEXCOORDPOINTEREXT)_getPrivateProcAddress("glMultiTexCoordPointerEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoordPointerEXT;
    }
    _glMultiTexCoordPointerEXT = _ptr;
    _glMultiTexCoordPointerEXT(texunit, size, type, stride, pointer);
}

PFN_GLMULTITEXCOORDPOINTEREXT _glMultiTexCoordPointerEXT = &_get_glMultiTexCoordPointerEXT;

static void APIENTRY _fail_glMultiTexEnvfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param) {
    const char *_name = "glMultiTexEnvfEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexEnvfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param) {
    PFN_GLMULTITEXENVFEXT _ptr;
    _ptr = (PFN_GLMULTITEXENVFEXT)_getPrivateProcAddress("glMultiTexEnvfEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexEnvfEXT;
    }
    _glMultiTexEnvfEXT = _ptr;
    _glMultiTexEnvfEXT(texunit, target, pname, param);
}

PFN_GLMULTITEXENVFEXT _glMultiTexEnvfEXT = &_get_glMultiTexEnvfEXT;

static void APIENTRY _fail_glMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glMultiTexEnvfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat * params) {
    PFN_GLMULTITEXENVFVEXT _ptr;
    _ptr = (PFN_GLMULTITEXENVFVEXT)_getPrivateProcAddress("glMultiTexEnvfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexEnvfvEXT;
    }
    _glMultiTexEnvfvEXT = _ptr;
    _glMultiTexEnvfvEXT(texunit, target, pname, params);
}

PFN_GLMULTITEXENVFVEXT _glMultiTexEnvfvEXT = &_get_glMultiTexEnvfvEXT;

static void APIENTRY _fail_glMultiTexEnviEXT(GLenum texunit, GLenum target, GLenum pname, GLint param) {
    const char *_name = "glMultiTexEnviEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexEnviEXT(GLenum texunit, GLenum target, GLenum pname, GLint param) {
    PFN_GLMULTITEXENVIEXT _ptr;
    _ptr = (PFN_GLMULTITEXENVIEXT)_getPrivateProcAddress("glMultiTexEnviEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexEnviEXT;
    }
    _glMultiTexEnviEXT = _ptr;
    _glMultiTexEnviEXT(texunit, target, pname, param);
}

PFN_GLMULTITEXENVIEXT _glMultiTexEnviEXT = &_get_glMultiTexEnviEXT;

static void APIENTRY _fail_glMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glMultiTexEnvivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint * params) {
    PFN_GLMULTITEXENVIVEXT _ptr;
    _ptr = (PFN_GLMULTITEXENVIVEXT)_getPrivateProcAddress("glMultiTexEnvivEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexEnvivEXT;
    }
    _glMultiTexEnvivEXT = _ptr;
    _glMultiTexEnvivEXT(texunit, target, pname, params);
}

PFN_GLMULTITEXENVIVEXT _glMultiTexEnvivEXT = &_get_glMultiTexEnvivEXT;

static void APIENTRY _fail_glMultiTexGendEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble param) {
    const char *_name = "glMultiTexGendEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexGendEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble param) {
    PFN_GLMULTITEXGENDEXT _ptr;
    _ptr = (PFN_GLMULTITEXGENDEXT)_getPrivateProcAddress("glMultiTexGendEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexGendEXT;
    }
    _glMultiTexGendEXT = _ptr;
    _glMultiTexGendEXT(texunit, coord, pname, param);
}

PFN_GLMULTITEXGENDEXT _glMultiTexGendEXT = &_get_glMultiTexGendEXT;

static void APIENTRY _fail_glMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLdouble * params) {
    const char *_name = "glMultiTexGendvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLdouble * params) {
    PFN_GLMULTITEXGENDVEXT _ptr;
    _ptr = (PFN_GLMULTITEXGENDVEXT)_getPrivateProcAddress("glMultiTexGendvEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexGendvEXT;
    }
    _glMultiTexGendvEXT = _ptr;
    _glMultiTexGendvEXT(texunit, coord, pname, params);
}

PFN_GLMULTITEXGENDVEXT _glMultiTexGendvEXT = &_get_glMultiTexGendvEXT;

static void APIENTRY _fail_glMultiTexGenfEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat param) {
    const char *_name = "glMultiTexGenfEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexGenfEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat param) {
    PFN_GLMULTITEXGENFEXT _ptr;
    _ptr = (PFN_GLMULTITEXGENFEXT)_getPrivateProcAddress("glMultiTexGenfEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexGenfEXT;
    }
    _glMultiTexGenfEXT = _ptr;
    _glMultiTexGenfEXT(texunit, coord, pname, param);
}

PFN_GLMULTITEXGENFEXT _glMultiTexGenfEXT = &_get_glMultiTexGenfEXT;

static void APIENTRY _fail_glMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLfloat * params) {
    const char *_name = "glMultiTexGenfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLfloat * params) {
    PFN_GLMULTITEXGENFVEXT _ptr;
    _ptr = (PFN_GLMULTITEXGENFVEXT)_getPrivateProcAddress("glMultiTexGenfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexGenfvEXT;
    }
    _glMultiTexGenfvEXT = _ptr;
    _glMultiTexGenfvEXT(texunit, coord, pname, params);
}

PFN_GLMULTITEXGENFVEXT _glMultiTexGenfvEXT = &_get_glMultiTexGenfvEXT;

static void APIENTRY _fail_glMultiTexGeniEXT(GLenum texunit, GLenum coord, GLenum pname, GLint param) {
    const char *_name = "glMultiTexGeniEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexGeniEXT(GLenum texunit, GLenum coord, GLenum pname, GLint param) {
    PFN_GLMULTITEXGENIEXT _ptr;
    _ptr = (PFN_GLMULTITEXGENIEXT)_getPrivateProcAddress("glMultiTexGeniEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexGeniEXT;
    }
    _glMultiTexGeniEXT = _ptr;
    _glMultiTexGeniEXT(texunit, coord, pname, param);
}

PFN_GLMULTITEXGENIEXT _glMultiTexGeniEXT = &_get_glMultiTexGeniEXT;

static void APIENTRY _fail_glMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, const GLint * params) {
    const char *_name = "glMultiTexGenivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, const GLint * params) {
    PFN_GLMULTITEXGENIVEXT _ptr;
    _ptr = (PFN_GLMULTITEXGENIVEXT)_getPrivateProcAddress("glMultiTexGenivEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexGenivEXT;
    }
    _glMultiTexGenivEXT = _ptr;
    _glMultiTexGenivEXT(texunit, coord, pname, params);
}

PFN_GLMULTITEXGENIVEXT _glMultiTexGenivEXT = &_get_glMultiTexGenivEXT;

static void APIENTRY _fail_glMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glMultiTexImage1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLMULTITEXIMAGE1DEXT _ptr;
    _ptr = (PFN_GLMULTITEXIMAGE1DEXT)_getPrivateProcAddress("glMultiTexImage1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexImage1DEXT;
    }
    _glMultiTexImage1DEXT = _ptr;
    _glMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, format, type, pixels);
}

PFN_GLMULTITEXIMAGE1DEXT _glMultiTexImage1DEXT = &_get_glMultiTexImage1DEXT;

static void APIENTRY _fail_glMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glMultiTexImage2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLMULTITEXIMAGE2DEXT _ptr;
    _ptr = (PFN_GLMULTITEXIMAGE2DEXT)_getPrivateProcAddress("glMultiTexImage2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexImage2DEXT;
    }
    _glMultiTexImage2DEXT = _ptr;
    _glMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, format, type, pixels);
}

PFN_GLMULTITEXIMAGE2DEXT _glMultiTexImage2DEXT = &_get_glMultiTexImage2DEXT;

static void APIENTRY _fail_glMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glMultiTexImage3DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLMULTITEXIMAGE3DEXT _ptr;
    _ptr = (PFN_GLMULTITEXIMAGE3DEXT)_getPrivateProcAddress("glMultiTexImage3DEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexImage3DEXT;
    }
    _glMultiTexImage3DEXT = _ptr;
    _glMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
}

PFN_GLMULTITEXIMAGE3DEXT _glMultiTexImage3DEXT = &_get_glMultiTexImage3DEXT;

static void APIENTRY _fail_glMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glMultiTexParameterIivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint * params) {
    PFN_GLMULTITEXPARAMETERIIVEXT _ptr;
    _ptr = (PFN_GLMULTITEXPARAMETERIIVEXT)_getPrivateProcAddress("glMultiTexParameterIivEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexParameterIivEXT;
    }
    _glMultiTexParameterIivEXT = _ptr;
    _glMultiTexParameterIivEXT(texunit, target, pname, params);
}

PFN_GLMULTITEXPARAMETERIIVEXT _glMultiTexParameterIivEXT = &_get_glMultiTexParameterIivEXT;

static void APIENTRY _fail_glMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, const GLuint * params) {
    const char *_name = "glMultiTexParameterIuivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, const GLuint * params) {
    PFN_GLMULTITEXPARAMETERIUIVEXT _ptr;
    _ptr = (PFN_GLMULTITEXPARAMETERIUIVEXT)_getPrivateProcAddress("glMultiTexParameterIuivEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexParameterIuivEXT;
    }
    _glMultiTexParameterIuivEXT = _ptr;
    _glMultiTexParameterIuivEXT(texunit, target, pname, params);
}

PFN_GLMULTITEXPARAMETERIUIVEXT _glMultiTexParameterIuivEXT = &_get_glMultiTexParameterIuivEXT;

static void APIENTRY _fail_glMultiTexParameterfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param) {
    const char *_name = "glMultiTexParameterfEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexParameterfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param) {
    PFN_GLMULTITEXPARAMETERFEXT _ptr;
    _ptr = (PFN_GLMULTITEXPARAMETERFEXT)_getPrivateProcAddress("glMultiTexParameterfEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexParameterfEXT;
    }
    _glMultiTexParameterfEXT = _ptr;
    _glMultiTexParameterfEXT(texunit, target, pname, param);
}

PFN_GLMULTITEXPARAMETERFEXT _glMultiTexParameterfEXT = &_get_glMultiTexParameterfEXT;

static void APIENTRY _fail_glMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glMultiTexParameterfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat * params) {
    PFN_GLMULTITEXPARAMETERFVEXT _ptr;
    _ptr = (PFN_GLMULTITEXPARAMETERFVEXT)_getPrivateProcAddress("glMultiTexParameterfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexParameterfvEXT;
    }
    _glMultiTexParameterfvEXT = _ptr;
    _glMultiTexParameterfvEXT(texunit, target, pname, params);
}

PFN_GLMULTITEXPARAMETERFVEXT _glMultiTexParameterfvEXT = &_get_glMultiTexParameterfvEXT;

static void APIENTRY _fail_glMultiTexParameteriEXT(GLenum texunit, GLenum target, GLenum pname, GLint param) {
    const char *_name = "glMultiTexParameteriEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexParameteriEXT(GLenum texunit, GLenum target, GLenum pname, GLint param) {
    PFN_GLMULTITEXPARAMETERIEXT _ptr;
    _ptr = (PFN_GLMULTITEXPARAMETERIEXT)_getPrivateProcAddress("glMultiTexParameteriEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexParameteriEXT;
    }
    _glMultiTexParameteriEXT = _ptr;
    _glMultiTexParameteriEXT(texunit, target, pname, param);
}

PFN_GLMULTITEXPARAMETERIEXT _glMultiTexParameteriEXT = &_get_glMultiTexParameteriEXT;

static void APIENTRY _fail_glMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glMultiTexParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint * params) {
    PFN_GLMULTITEXPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLMULTITEXPARAMETERIVEXT)_getPrivateProcAddress("glMultiTexParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexParameterivEXT;
    }
    _glMultiTexParameterivEXT = _ptr;
    _glMultiTexParameterivEXT(texunit, target, pname, params);
}

PFN_GLMULTITEXPARAMETERIVEXT _glMultiTexParameterivEXT = &_get_glMultiTexParameterivEXT;

static void APIENTRY _fail_glMultiTexRenderbufferEXT(GLenum texunit, GLenum target, GLuint renderbuffer) {
    const char *_name = "glMultiTexRenderbufferEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexRenderbufferEXT(GLenum texunit, GLenum target, GLuint renderbuffer) {
    PFN_GLMULTITEXRENDERBUFFEREXT _ptr;
    _ptr = (PFN_GLMULTITEXRENDERBUFFEREXT)_getPrivateProcAddress("glMultiTexRenderbufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexRenderbufferEXT;
    }
    _glMultiTexRenderbufferEXT = _ptr;
    _glMultiTexRenderbufferEXT(texunit, target, renderbuffer);
}

PFN_GLMULTITEXRENDERBUFFEREXT _glMultiTexRenderbufferEXT = &_get_glMultiTexRenderbufferEXT;

static void APIENTRY _fail_glMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glMultiTexSubImage1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLMULTITEXSUBIMAGE1DEXT _ptr;
    _ptr = (PFN_GLMULTITEXSUBIMAGE1DEXT)_getPrivateProcAddress("glMultiTexSubImage1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexSubImage1DEXT;
    }
    _glMultiTexSubImage1DEXT = _ptr;
    _glMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, type, pixels);
}

PFN_GLMULTITEXSUBIMAGE1DEXT _glMultiTexSubImage1DEXT = &_get_glMultiTexSubImage1DEXT;

static void APIENTRY _fail_glMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glMultiTexSubImage2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLMULTITEXSUBIMAGE2DEXT _ptr;
    _ptr = (PFN_GLMULTITEXSUBIMAGE2DEXT)_getPrivateProcAddress("glMultiTexSubImage2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexSubImage2DEXT;
    }
    _glMultiTexSubImage2DEXT = _ptr;
    _glMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
}

PFN_GLMULTITEXSUBIMAGE2DEXT _glMultiTexSubImage2DEXT = &_get_glMultiTexSubImage2DEXT;

static void APIENTRY _fail_glMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glMultiTexSubImage3DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLMULTITEXSUBIMAGE3DEXT _ptr;
    _ptr = (PFN_GLMULTITEXSUBIMAGE3DEXT)_getPrivateProcAddress("glMultiTexSubImage3DEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexSubImage3DEXT;
    }
    _glMultiTexSubImage3DEXT = _ptr;
    _glMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

PFN_GLMULTITEXSUBIMAGE3DEXT _glMultiTexSubImage3DEXT = &_get_glMultiTexSubImage3DEXT;

static void APIENTRY _fail_glNamedBufferDataEXT(GLuint buffer, GLsizeiptr size, const GLvoid * data, GLenum usage) {
    const char *_name = "glNamedBufferDataEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedBufferDataEXT(GLuint buffer, GLsizeiptr size, const GLvoid * data, GLenum usage) {
    PFN_GLNAMEDBUFFERDATAEXT _ptr;
    _ptr = (PFN_GLNAMEDBUFFERDATAEXT)_getPrivateProcAddress("glNamedBufferDataEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedBufferDataEXT;
    }
    _glNamedBufferDataEXT = _ptr;
    _glNamedBufferDataEXT(buffer, size, data, usage);
}

PFN_GLNAMEDBUFFERDATAEXT _glNamedBufferDataEXT = &_get_glNamedBufferDataEXT;

static void APIENTRY _fail_glNamedBufferStorageEXT(GLuint buffer, GLsizeiptr size, const GLvoid * data, GLbitfield flags) {
    const char *_name = "glNamedBufferStorageEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedBufferStorageEXT(GLuint buffer, GLsizeiptr size, const GLvoid * data, GLbitfield flags) {
    PFN_GLNAMEDBUFFERSTORAGEEXT _ptr;
    _ptr = (PFN_GLNAMEDBUFFERSTORAGEEXT)_getPrivateProcAddress("glNamedBufferStorageEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedBufferStorageEXT;
    }
    _glNamedBufferStorageEXT = _ptr;
    _glNamedBufferStorageEXT(buffer, size, data, flags);
}

PFN_GLNAMEDBUFFERSTORAGEEXT _glNamedBufferStorageEXT = &_get_glNamedBufferStorageEXT;

static void APIENTRY _fail_glNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid * data) {
    const char *_name = "glNamedBufferSubDataEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid * data) {
    PFN_GLNAMEDBUFFERSUBDATAEXT _ptr;
    _ptr = (PFN_GLNAMEDBUFFERSUBDATAEXT)_getPrivateProcAddress("glNamedBufferSubDataEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedBufferSubDataEXT;
    }
    _glNamedBufferSubDataEXT = _ptr;
    _glNamedBufferSubDataEXT(buffer, offset, size, data);
}

PFN_GLNAMEDBUFFERSUBDATAEXT _glNamedBufferSubDataEXT = &_get_glNamedBufferSubDataEXT;

static void APIENTRY _fail_glNamedCopyBufferSubDataEXT(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) {
    const char *_name = "glNamedCopyBufferSubDataEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedCopyBufferSubDataEXT(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) {
    PFN_GLNAMEDCOPYBUFFERSUBDATAEXT _ptr;
    _ptr = (PFN_GLNAMEDCOPYBUFFERSUBDATAEXT)_getPrivateProcAddress("glNamedCopyBufferSubDataEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedCopyBufferSubDataEXT;
    }
    _glNamedCopyBufferSubDataEXT = _ptr;
    _glNamedCopyBufferSubDataEXT(readBuffer, writeBuffer, readOffset, writeOffset, size);
}

PFN_GLNAMEDCOPYBUFFERSUBDATAEXT _glNamedCopyBufferSubDataEXT = &_get_glNamedCopyBufferSubDataEXT;

static void APIENTRY _fail_glNamedFramebufferParameteriEXT(GLuint framebuffer, GLenum pname, GLint param) {
    const char *_name = "glNamedFramebufferParameteriEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedFramebufferParameteriEXT(GLuint framebuffer, GLenum pname, GLint param) {
    PFN_GLNAMEDFRAMEBUFFERPARAMETERIEXT _ptr;
    _ptr = (PFN_GLNAMEDFRAMEBUFFERPARAMETERIEXT)_getPrivateProcAddress("glNamedFramebufferParameteriEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedFramebufferParameteriEXT;
    }
    _glNamedFramebufferParameteriEXT = _ptr;
    _glNamedFramebufferParameteriEXT(framebuffer, pname, param);
}

PFN_GLNAMEDFRAMEBUFFERPARAMETERIEXT _glNamedFramebufferParameteriEXT = &_get_glNamedFramebufferParameteriEXT;

static void APIENTRY _fail_glNamedFramebufferRenderbufferEXT(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) {
    const char *_name = "glNamedFramebufferRenderbufferEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedFramebufferRenderbufferEXT(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) {
    PFN_GLNAMEDFRAMEBUFFERRENDERBUFFEREXT _ptr;
    _ptr = (PFN_GLNAMEDFRAMEBUFFERRENDERBUFFEREXT)_getPrivateProcAddress("glNamedFramebufferRenderbufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedFramebufferRenderbufferEXT;
    }
    _glNamedFramebufferRenderbufferEXT = _ptr;
    _glNamedFramebufferRenderbufferEXT(framebuffer, attachment, renderbuffertarget, renderbuffer);
}

PFN_GLNAMEDFRAMEBUFFERRENDERBUFFEREXT _glNamedFramebufferRenderbufferEXT = &_get_glNamedFramebufferRenderbufferEXT;

static void APIENTRY _fail_glNamedFramebufferTexture1DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    const char *_name = "glNamedFramebufferTexture1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedFramebufferTexture1DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    PFN_GLNAMEDFRAMEBUFFERTEXTURE1DEXT _ptr;
    _ptr = (PFN_GLNAMEDFRAMEBUFFERTEXTURE1DEXT)_getPrivateProcAddress("glNamedFramebufferTexture1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedFramebufferTexture1DEXT;
    }
    _glNamedFramebufferTexture1DEXT = _ptr;
    _glNamedFramebufferTexture1DEXT(framebuffer, attachment, textarget, texture, level);
}

PFN_GLNAMEDFRAMEBUFFERTEXTURE1DEXT _glNamedFramebufferTexture1DEXT = &_get_glNamedFramebufferTexture1DEXT;

static void APIENTRY _fail_glNamedFramebufferTexture2DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    const char *_name = "glNamedFramebufferTexture2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedFramebufferTexture2DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    PFN_GLNAMEDFRAMEBUFFERTEXTURE2DEXT _ptr;
    _ptr = (PFN_GLNAMEDFRAMEBUFFERTEXTURE2DEXT)_getPrivateProcAddress("glNamedFramebufferTexture2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedFramebufferTexture2DEXT;
    }
    _glNamedFramebufferTexture2DEXT = _ptr;
    _glNamedFramebufferTexture2DEXT(framebuffer, attachment, textarget, texture, level);
}

PFN_GLNAMEDFRAMEBUFFERTEXTURE2DEXT _glNamedFramebufferTexture2DEXT = &_get_glNamedFramebufferTexture2DEXT;

static void APIENTRY _fail_glNamedFramebufferTexture3DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) {
    const char *_name = "glNamedFramebufferTexture3DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedFramebufferTexture3DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) {
    PFN_GLNAMEDFRAMEBUFFERTEXTURE3DEXT _ptr;
    _ptr = (PFN_GLNAMEDFRAMEBUFFERTEXTURE3DEXT)_getPrivateProcAddress("glNamedFramebufferTexture3DEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedFramebufferTexture3DEXT;
    }
    _glNamedFramebufferTexture3DEXT = _ptr;
    _glNamedFramebufferTexture3DEXT(framebuffer, attachment, textarget, texture, level, zoffset);
}

PFN_GLNAMEDFRAMEBUFFERTEXTURE3DEXT _glNamedFramebufferTexture3DEXT = &_get_glNamedFramebufferTexture3DEXT;

static void APIENTRY _fail_glNamedFramebufferTextureEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level) {
    const char *_name = "glNamedFramebufferTextureEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedFramebufferTextureEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level) {
    PFN_GLNAMEDFRAMEBUFFERTEXTUREEXT _ptr;
    _ptr = (PFN_GLNAMEDFRAMEBUFFERTEXTUREEXT)_getPrivateProcAddress("glNamedFramebufferTextureEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedFramebufferTextureEXT;
    }
    _glNamedFramebufferTextureEXT = _ptr;
    _glNamedFramebufferTextureEXT(framebuffer, attachment, texture, level);
}

PFN_GLNAMEDFRAMEBUFFERTEXTUREEXT _glNamedFramebufferTextureEXT = &_get_glNamedFramebufferTextureEXT;

static void APIENTRY _fail_glNamedFramebufferTextureFaceEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face) {
    const char *_name = "glNamedFramebufferTextureFaceEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedFramebufferTextureFaceEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face) {
    PFN_GLNAMEDFRAMEBUFFERTEXTUREFACEEXT _ptr;
    _ptr = (PFN_GLNAMEDFRAMEBUFFERTEXTUREFACEEXT)_getPrivateProcAddress("glNamedFramebufferTextureFaceEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedFramebufferTextureFaceEXT;
    }
    _glNamedFramebufferTextureFaceEXT = _ptr;
    _glNamedFramebufferTextureFaceEXT(framebuffer, attachment, texture, level, face);
}

PFN_GLNAMEDFRAMEBUFFERTEXTUREFACEEXT _glNamedFramebufferTextureFaceEXT = &_get_glNamedFramebufferTextureFaceEXT;

static void APIENTRY _fail_glNamedFramebufferTextureLayerEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer) {
    const char *_name = "glNamedFramebufferTextureLayerEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedFramebufferTextureLayerEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer) {
    PFN_GLNAMEDFRAMEBUFFERTEXTURELAYEREXT _ptr;
    _ptr = (PFN_GLNAMEDFRAMEBUFFERTEXTURELAYEREXT)_getPrivateProcAddress("glNamedFramebufferTextureLayerEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedFramebufferTextureLayerEXT;
    }
    _glNamedFramebufferTextureLayerEXT = _ptr;
    _glNamedFramebufferTextureLayerEXT(framebuffer, attachment, texture, level, layer);
}

PFN_GLNAMEDFRAMEBUFFERTEXTURELAYEREXT _glNamedFramebufferTextureLayerEXT = &_get_glNamedFramebufferTextureLayerEXT;

static void APIENTRY _fail_glNamedProgramLocalParameter4dEXT(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glNamedProgramLocalParameter4dEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedProgramLocalParameter4dEXT(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    PFN_GLNAMEDPROGRAMLOCALPARAMETER4DEXT _ptr;
    _ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETER4DEXT)_getPrivateProcAddress("glNamedProgramLocalParameter4dEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedProgramLocalParameter4dEXT;
    }
    _glNamedProgramLocalParameter4dEXT = _ptr;
    _glNamedProgramLocalParameter4dEXT(program, target, index, x, y, z, w);
}

PFN_GLNAMEDPROGRAMLOCALPARAMETER4DEXT _glNamedProgramLocalParameter4dEXT = &_get_glNamedProgramLocalParameter4dEXT;

static void APIENTRY _fail_glNamedProgramLocalParameter4dvEXT(GLuint program, GLenum target, GLuint index, const GLdouble * params) {
    const char *_name = "glNamedProgramLocalParameter4dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedProgramLocalParameter4dvEXT(GLuint program, GLenum target, GLuint index, const GLdouble * params) {
    PFN_GLNAMEDPROGRAMLOCALPARAMETER4DVEXT _ptr;
    _ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETER4DVEXT)_getPrivateProcAddress("glNamedProgramLocalParameter4dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedProgramLocalParameter4dvEXT;
    }
    _glNamedProgramLocalParameter4dvEXT = _ptr;
    _glNamedProgramLocalParameter4dvEXT(program, target, index, params);
}

PFN_GLNAMEDPROGRAMLOCALPARAMETER4DVEXT _glNamedProgramLocalParameter4dvEXT = &_get_glNamedProgramLocalParameter4dvEXT;

static void APIENTRY _fail_glNamedProgramLocalParameter4fEXT(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glNamedProgramLocalParameter4fEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedProgramLocalParameter4fEXT(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    PFN_GLNAMEDPROGRAMLOCALPARAMETER4FEXT _ptr;
    _ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETER4FEXT)_getPrivateProcAddress("glNamedProgramLocalParameter4fEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedProgramLocalParameter4fEXT;
    }
    _glNamedProgramLocalParameter4fEXT = _ptr;
    _glNamedProgramLocalParameter4fEXT(program, target, index, x, y, z, w);
}

PFN_GLNAMEDPROGRAMLOCALPARAMETER4FEXT _glNamedProgramLocalParameter4fEXT = &_get_glNamedProgramLocalParameter4fEXT;

static void APIENTRY _fail_glNamedProgramLocalParameter4fvEXT(GLuint program, GLenum target, GLuint index, const GLfloat * params) {
    const char *_name = "glNamedProgramLocalParameter4fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedProgramLocalParameter4fvEXT(GLuint program, GLenum target, GLuint index, const GLfloat * params) {
    PFN_GLNAMEDPROGRAMLOCALPARAMETER4FVEXT _ptr;
    _ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETER4FVEXT)_getPrivateProcAddress("glNamedProgramLocalParameter4fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedProgramLocalParameter4fvEXT;
    }
    _glNamedProgramLocalParameter4fvEXT = _ptr;
    _glNamedProgramLocalParameter4fvEXT(program, target, index, params);
}

PFN_GLNAMEDPROGRAMLOCALPARAMETER4FVEXT _glNamedProgramLocalParameter4fvEXT = &_get_glNamedProgramLocalParameter4fvEXT;

static void APIENTRY _fail_glNamedProgramLocalParameterI4iEXT(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) {
    const char *_name = "glNamedProgramLocalParameterI4iEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedProgramLocalParameterI4iEXT(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) {
    PFN_GLNAMEDPROGRAMLOCALPARAMETERI4IEXT _ptr;
    _ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETERI4IEXT)_getPrivateProcAddress("glNamedProgramLocalParameterI4iEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedProgramLocalParameterI4iEXT;
    }
    _glNamedProgramLocalParameterI4iEXT = _ptr;
    _glNamedProgramLocalParameterI4iEXT(program, target, index, x, y, z, w);
}

PFN_GLNAMEDPROGRAMLOCALPARAMETERI4IEXT _glNamedProgramLocalParameterI4iEXT = &_get_glNamedProgramLocalParameterI4iEXT;

static void APIENTRY _fail_glNamedProgramLocalParameterI4ivEXT(GLuint program, GLenum target, GLuint index, const GLint * params) {
    const char *_name = "glNamedProgramLocalParameterI4ivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedProgramLocalParameterI4ivEXT(GLuint program, GLenum target, GLuint index, const GLint * params) {
    PFN_GLNAMEDPROGRAMLOCALPARAMETERI4IVEXT _ptr;
    _ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETERI4IVEXT)_getPrivateProcAddress("glNamedProgramLocalParameterI4ivEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedProgramLocalParameterI4ivEXT;
    }
    _glNamedProgramLocalParameterI4ivEXT = _ptr;
    _glNamedProgramLocalParameterI4ivEXT(program, target, index, params);
}

PFN_GLNAMEDPROGRAMLOCALPARAMETERI4IVEXT _glNamedProgramLocalParameterI4ivEXT = &_get_glNamedProgramLocalParameterI4ivEXT;

static void APIENTRY _fail_glNamedProgramLocalParameterI4uiEXT(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
    const char *_name = "glNamedProgramLocalParameterI4uiEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedProgramLocalParameterI4uiEXT(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
    PFN_GLNAMEDPROGRAMLOCALPARAMETERI4UIEXT _ptr;
    _ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETERI4UIEXT)_getPrivateProcAddress("glNamedProgramLocalParameterI4uiEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedProgramLocalParameterI4uiEXT;
    }
    _glNamedProgramLocalParameterI4uiEXT = _ptr;
    _glNamedProgramLocalParameterI4uiEXT(program, target, index, x, y, z, w);
}

PFN_GLNAMEDPROGRAMLOCALPARAMETERI4UIEXT _glNamedProgramLocalParameterI4uiEXT = &_get_glNamedProgramLocalParameterI4uiEXT;

static void APIENTRY _fail_glNamedProgramLocalParameterI4uivEXT(GLuint program, GLenum target, GLuint index, const GLuint * params) {
    const char *_name = "glNamedProgramLocalParameterI4uivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedProgramLocalParameterI4uivEXT(GLuint program, GLenum target, GLuint index, const GLuint * params) {
    PFN_GLNAMEDPROGRAMLOCALPARAMETERI4UIVEXT _ptr;
    _ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETERI4UIVEXT)_getPrivateProcAddress("glNamedProgramLocalParameterI4uivEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedProgramLocalParameterI4uivEXT;
    }
    _glNamedProgramLocalParameterI4uivEXT = _ptr;
    _glNamedProgramLocalParameterI4uivEXT(program, target, index, params);
}

PFN_GLNAMEDPROGRAMLOCALPARAMETERI4UIVEXT _glNamedProgramLocalParameterI4uivEXT = &_get_glNamedProgramLocalParameterI4uivEXT;

static void APIENTRY _fail_glNamedProgramLocalParameters4fvEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat * params) {
    const char *_name = "glNamedProgramLocalParameters4fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedProgramLocalParameters4fvEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat * params) {
    PFN_GLNAMEDPROGRAMLOCALPARAMETERS4FVEXT _ptr;
    _ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETERS4FVEXT)_getPrivateProcAddress("glNamedProgramLocalParameters4fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedProgramLocalParameters4fvEXT;
    }
    _glNamedProgramLocalParameters4fvEXT = _ptr;
    _glNamedProgramLocalParameters4fvEXT(program, target, index, count, params);
}

PFN_GLNAMEDPROGRAMLOCALPARAMETERS4FVEXT _glNamedProgramLocalParameters4fvEXT = &_get_glNamedProgramLocalParameters4fvEXT;

static void APIENTRY _fail_glNamedProgramLocalParametersI4ivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint * params) {
    const char *_name = "glNamedProgramLocalParametersI4ivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedProgramLocalParametersI4ivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint * params) {
    PFN_GLNAMEDPROGRAMLOCALPARAMETERSI4IVEXT _ptr;
    _ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETERSI4IVEXT)_getPrivateProcAddress("glNamedProgramLocalParametersI4ivEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedProgramLocalParametersI4ivEXT;
    }
    _glNamedProgramLocalParametersI4ivEXT = _ptr;
    _glNamedProgramLocalParametersI4ivEXT(program, target, index, count, params);
}

PFN_GLNAMEDPROGRAMLOCALPARAMETERSI4IVEXT _glNamedProgramLocalParametersI4ivEXT = &_get_glNamedProgramLocalParametersI4ivEXT;

static void APIENTRY _fail_glNamedProgramLocalParametersI4uivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint * params) {
    const char *_name = "glNamedProgramLocalParametersI4uivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedProgramLocalParametersI4uivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint * params) {
    PFN_GLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXT _ptr;
    _ptr = (PFN_GLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXT)_getPrivateProcAddress("glNamedProgramLocalParametersI4uivEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedProgramLocalParametersI4uivEXT;
    }
    _glNamedProgramLocalParametersI4uivEXT = _ptr;
    _glNamedProgramLocalParametersI4uivEXT(program, target, index, count, params);
}

PFN_GLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXT _glNamedProgramLocalParametersI4uivEXT = &_get_glNamedProgramLocalParametersI4uivEXT;

static void APIENTRY _fail_glNamedProgramStringEXT(GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid * string) {
    const char *_name = "glNamedProgramStringEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedProgramStringEXT(GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid * string) {
    PFN_GLNAMEDPROGRAMSTRINGEXT _ptr;
    _ptr = (PFN_GLNAMEDPROGRAMSTRINGEXT)_getPrivateProcAddress("glNamedProgramStringEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedProgramStringEXT;
    }
    _glNamedProgramStringEXT = _ptr;
    _glNamedProgramStringEXT(program, target, format, len, string);
}

PFN_GLNAMEDPROGRAMSTRINGEXT _glNamedProgramStringEXT = &_get_glNamedProgramStringEXT;

static void APIENTRY _fail_glNamedRenderbufferStorageEXT(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glNamedRenderbufferStorageEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedRenderbufferStorageEXT(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height) {
    PFN_GLNAMEDRENDERBUFFERSTORAGEEXT _ptr;
    _ptr = (PFN_GLNAMEDRENDERBUFFERSTORAGEEXT)_getPrivateProcAddress("glNamedRenderbufferStorageEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedRenderbufferStorageEXT;
    }
    _glNamedRenderbufferStorageEXT = _ptr;
    _glNamedRenderbufferStorageEXT(renderbuffer, internalformat, width, height);
}

PFN_GLNAMEDRENDERBUFFERSTORAGEEXT _glNamedRenderbufferStorageEXT = &_get_glNamedRenderbufferStorageEXT;

static void APIENTRY _fail_glNamedRenderbufferStorageMultisampleCoverageEXT(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glNamedRenderbufferStorageMultisampleCoverageEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedRenderbufferStorageMultisampleCoverageEXT(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height) {
    PFN_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXT _ptr;
    _ptr = (PFN_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXT)_getPrivateProcAddress("glNamedRenderbufferStorageMultisampleCoverageEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedRenderbufferStorageMultisampleCoverageEXT;
    }
    _glNamedRenderbufferStorageMultisampleCoverageEXT = _ptr;
    _glNamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
}

PFN_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXT _glNamedRenderbufferStorageMultisampleCoverageEXT = &_get_glNamedRenderbufferStorageMultisampleCoverageEXT;

static void APIENTRY _fail_glNamedRenderbufferStorageMultisampleEXT(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glNamedRenderbufferStorageMultisampleEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNamedRenderbufferStorageMultisampleEXT(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    PFN_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXT _ptr;
    _ptr = (PFN_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXT)_getPrivateProcAddress("glNamedRenderbufferStorageMultisampleEXT");
    if (!_ptr) {
        _ptr = &_fail_glNamedRenderbufferStorageMultisampleEXT;
    }
    _glNamedRenderbufferStorageMultisampleEXT = _ptr;
    _glNamedRenderbufferStorageMultisampleEXT(renderbuffer, samples, internalformat, width, height);
}

PFN_GLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXT _glNamedRenderbufferStorageMultisampleEXT = &_get_glNamedRenderbufferStorageMultisampleEXT;

static void APIENTRY _fail_glProgramUniform1dEXT(GLuint program, GLint location, GLdouble x) {
    const char *_name = "glProgramUniform1dEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1dEXT(GLuint program, GLint location, GLdouble x) {
    PFN_GLPROGRAMUNIFORM1DEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1DEXT)_getPrivateProcAddress("glProgramUniform1dEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1dEXT;
    }
    _glProgramUniform1dEXT = _ptr;
    _glProgramUniform1dEXT(program, location, x);
}

PFN_GLPROGRAMUNIFORM1DEXT _glProgramUniform1dEXT = &_get_glProgramUniform1dEXT;

static void APIENTRY _fail_glProgramUniform1dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glProgramUniform1dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORM1DVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1DVEXT)_getPrivateProcAddress("glProgramUniform1dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1dvEXT;
    }
    _glProgramUniform1dvEXT = _ptr;
    _glProgramUniform1dvEXT(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM1DVEXT _glProgramUniform1dvEXT = &_get_glProgramUniform1dvEXT;

static void APIENTRY _fail_glProgramUniform1fEXT(GLuint program, GLint location, GLfloat v0) {
    const char *_name = "glProgramUniform1fEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1fEXT(GLuint program, GLint location, GLfloat v0) {
    PFN_GLPROGRAMUNIFORM1FEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1FEXT)_getPrivateProcAddress("glProgramUniform1fEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1fEXT;
    }
    _glProgramUniform1fEXT = _ptr;
    _glProgramUniform1fEXT(program, location, v0);
}

PFN_GLPROGRAMUNIFORM1FEXT _glProgramUniform1fEXT = &_get_glProgramUniform1fEXT;

static void APIENTRY _fail_glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glProgramUniform1fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORM1FVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1FVEXT)_getPrivateProcAddress("glProgramUniform1fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1fvEXT;
    }
    _glProgramUniform1fvEXT = _ptr;
    _glProgramUniform1fvEXT(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM1FVEXT _glProgramUniform1fvEXT = &_get_glProgramUniform1fvEXT;

static void APIENTRY _fail_glProgramUniform1iEXT(GLuint program, GLint location, GLint v0) {
    const char *_name = "glProgramUniform1iEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1iEXT(GLuint program, GLint location, GLint v0) {
    PFN_GLPROGRAMUNIFORM1IEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1IEXT)_getPrivateProcAddress("glProgramUniform1iEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1iEXT;
    }
    _glProgramUniform1iEXT = _ptr;
    _glProgramUniform1iEXT(program, location, v0);
}

PFN_GLPROGRAMUNIFORM1IEXT _glProgramUniform1iEXT = &_get_glProgramUniform1iEXT;

static void APIENTRY _fail_glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glProgramUniform1ivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value) {
    PFN_GLPROGRAMUNIFORM1IVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1IVEXT)_getPrivateProcAddress("glProgramUniform1ivEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1ivEXT;
    }
    _glProgramUniform1ivEXT = _ptr;
    _glProgramUniform1ivEXT(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM1IVEXT _glProgramUniform1ivEXT = &_get_glProgramUniform1ivEXT;

static void APIENTRY _fail_glProgramUniform1uiEXT(GLuint program, GLint location, GLuint v0) {
    const char *_name = "glProgramUniform1uiEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1uiEXT(GLuint program, GLint location, GLuint v0) {
    PFN_GLPROGRAMUNIFORM1UIEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1UIEXT)_getPrivateProcAddress("glProgramUniform1uiEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1uiEXT;
    }
    _glProgramUniform1uiEXT = _ptr;
    _glProgramUniform1uiEXT(program, location, v0);
}

PFN_GLPROGRAMUNIFORM1UIEXT _glProgramUniform1uiEXT = &_get_glProgramUniform1uiEXT;

static void APIENTRY _fail_glProgramUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glProgramUniform1uivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    PFN_GLPROGRAMUNIFORM1UIVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1UIVEXT)_getPrivateProcAddress("glProgramUniform1uivEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1uivEXT;
    }
    _glProgramUniform1uivEXT = _ptr;
    _glProgramUniform1uivEXT(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM1UIVEXT _glProgramUniform1uivEXT = &_get_glProgramUniform1uivEXT;

static void APIENTRY _fail_glProgramUniform2dEXT(GLuint program, GLint location, GLdouble x, GLdouble y) {
    const char *_name = "glProgramUniform2dEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2dEXT(GLuint program, GLint location, GLdouble x, GLdouble y) {
    PFN_GLPROGRAMUNIFORM2DEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2DEXT)_getPrivateProcAddress("glProgramUniform2dEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2dEXT;
    }
    _glProgramUniform2dEXT = _ptr;
    _glProgramUniform2dEXT(program, location, x, y);
}

PFN_GLPROGRAMUNIFORM2DEXT _glProgramUniform2dEXT = &_get_glProgramUniform2dEXT;

static void APIENTRY _fail_glProgramUniform2dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glProgramUniform2dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORM2DVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2DVEXT)_getPrivateProcAddress("glProgramUniform2dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2dvEXT;
    }
    _glProgramUniform2dvEXT = _ptr;
    _glProgramUniform2dvEXT(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM2DVEXT _glProgramUniform2dvEXT = &_get_glProgramUniform2dvEXT;

static void APIENTRY _fail_glProgramUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1) {
    const char *_name = "glProgramUniform2fEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1) {
    PFN_GLPROGRAMUNIFORM2FEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2FEXT)_getPrivateProcAddress("glProgramUniform2fEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2fEXT;
    }
    _glProgramUniform2fEXT = _ptr;
    _glProgramUniform2fEXT(program, location, v0, v1);
}

PFN_GLPROGRAMUNIFORM2FEXT _glProgramUniform2fEXT = &_get_glProgramUniform2fEXT;

static void APIENTRY _fail_glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glProgramUniform2fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORM2FVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2FVEXT)_getPrivateProcAddress("glProgramUniform2fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2fvEXT;
    }
    _glProgramUniform2fvEXT = _ptr;
    _glProgramUniform2fvEXT(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM2FVEXT _glProgramUniform2fvEXT = &_get_glProgramUniform2fvEXT;

static void APIENTRY _fail_glProgramUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1) {
    const char *_name = "glProgramUniform2iEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1) {
    PFN_GLPROGRAMUNIFORM2IEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2IEXT)_getPrivateProcAddress("glProgramUniform2iEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2iEXT;
    }
    _glProgramUniform2iEXT = _ptr;
    _glProgramUniform2iEXT(program, location, v0, v1);
}

PFN_GLPROGRAMUNIFORM2IEXT _glProgramUniform2iEXT = &_get_glProgramUniform2iEXT;

static void APIENTRY _fail_glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glProgramUniform2ivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value) {
    PFN_GLPROGRAMUNIFORM2IVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2IVEXT)_getPrivateProcAddress("glProgramUniform2ivEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2ivEXT;
    }
    _glProgramUniform2ivEXT = _ptr;
    _glProgramUniform2ivEXT(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM2IVEXT _glProgramUniform2ivEXT = &_get_glProgramUniform2ivEXT;

static void APIENTRY _fail_glProgramUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1) {
    const char *_name = "glProgramUniform2uiEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1) {
    PFN_GLPROGRAMUNIFORM2UIEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2UIEXT)_getPrivateProcAddress("glProgramUniform2uiEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2uiEXT;
    }
    _glProgramUniform2uiEXT = _ptr;
    _glProgramUniform2uiEXT(program, location, v0, v1);
}

PFN_GLPROGRAMUNIFORM2UIEXT _glProgramUniform2uiEXT = &_get_glProgramUniform2uiEXT;

static void APIENTRY _fail_glProgramUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glProgramUniform2uivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    PFN_GLPROGRAMUNIFORM2UIVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2UIVEXT)_getPrivateProcAddress("glProgramUniform2uivEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2uivEXT;
    }
    _glProgramUniform2uivEXT = _ptr;
    _glProgramUniform2uivEXT(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM2UIVEXT _glProgramUniform2uivEXT = &_get_glProgramUniform2uivEXT;

static void APIENTRY _fail_glProgramUniform3dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glProgramUniform3dEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLPROGRAMUNIFORM3DEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3DEXT)_getPrivateProcAddress("glProgramUniform3dEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3dEXT;
    }
    _glProgramUniform3dEXT = _ptr;
    _glProgramUniform3dEXT(program, location, x, y, z);
}

PFN_GLPROGRAMUNIFORM3DEXT _glProgramUniform3dEXT = &_get_glProgramUniform3dEXT;

static void APIENTRY _fail_glProgramUniform3dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glProgramUniform3dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORM3DVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3DVEXT)_getPrivateProcAddress("glProgramUniform3dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3dvEXT;
    }
    _glProgramUniform3dvEXT = _ptr;
    _glProgramUniform3dvEXT(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM3DVEXT _glProgramUniform3dvEXT = &_get_glProgramUniform3dvEXT;

static void APIENTRY _fail_glProgramUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
    const char *_name = "glProgramUniform3fEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
    PFN_GLPROGRAMUNIFORM3FEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3FEXT)_getPrivateProcAddress("glProgramUniform3fEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3fEXT;
    }
    _glProgramUniform3fEXT = _ptr;
    _glProgramUniform3fEXT(program, location, v0, v1, v2);
}

PFN_GLPROGRAMUNIFORM3FEXT _glProgramUniform3fEXT = &_get_glProgramUniform3fEXT;

static void APIENTRY _fail_glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glProgramUniform3fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORM3FVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3FVEXT)_getPrivateProcAddress("glProgramUniform3fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3fvEXT;
    }
    _glProgramUniform3fvEXT = _ptr;
    _glProgramUniform3fvEXT(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM3FVEXT _glProgramUniform3fvEXT = &_get_glProgramUniform3fvEXT;

static void APIENTRY _fail_glProgramUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) {
    const char *_name = "glProgramUniform3iEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) {
    PFN_GLPROGRAMUNIFORM3IEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3IEXT)_getPrivateProcAddress("glProgramUniform3iEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3iEXT;
    }
    _glProgramUniform3iEXT = _ptr;
    _glProgramUniform3iEXT(program, location, v0, v1, v2);
}

PFN_GLPROGRAMUNIFORM3IEXT _glProgramUniform3iEXT = &_get_glProgramUniform3iEXT;

static void APIENTRY _fail_glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glProgramUniform3ivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value) {
    PFN_GLPROGRAMUNIFORM3IVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3IVEXT)_getPrivateProcAddress("glProgramUniform3ivEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3ivEXT;
    }
    _glProgramUniform3ivEXT = _ptr;
    _glProgramUniform3ivEXT(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM3IVEXT _glProgramUniform3ivEXT = &_get_glProgramUniform3ivEXT;

static void APIENTRY _fail_glProgramUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2) {
    const char *_name = "glProgramUniform3uiEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2) {
    PFN_GLPROGRAMUNIFORM3UIEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3UIEXT)_getPrivateProcAddress("glProgramUniform3uiEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3uiEXT;
    }
    _glProgramUniform3uiEXT = _ptr;
    _glProgramUniform3uiEXT(program, location, v0, v1, v2);
}

PFN_GLPROGRAMUNIFORM3UIEXT _glProgramUniform3uiEXT = &_get_glProgramUniform3uiEXT;

static void APIENTRY _fail_glProgramUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glProgramUniform3uivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    PFN_GLPROGRAMUNIFORM3UIVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3UIVEXT)_getPrivateProcAddress("glProgramUniform3uivEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3uivEXT;
    }
    _glProgramUniform3uivEXT = _ptr;
    _glProgramUniform3uivEXT(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM3UIVEXT _glProgramUniform3uivEXT = &_get_glProgramUniform3uivEXT;

static void APIENTRY _fail_glProgramUniform4dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glProgramUniform4dEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    PFN_GLPROGRAMUNIFORM4DEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4DEXT)_getPrivateProcAddress("glProgramUniform4dEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4dEXT;
    }
    _glProgramUniform4dEXT = _ptr;
    _glProgramUniform4dEXT(program, location, x, y, z, w);
}

PFN_GLPROGRAMUNIFORM4DEXT _glProgramUniform4dEXT = &_get_glProgramUniform4dEXT;

static void APIENTRY _fail_glProgramUniform4dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    const char *_name = "glProgramUniform4dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORM4DVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4DVEXT)_getPrivateProcAddress("glProgramUniform4dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4dvEXT;
    }
    _glProgramUniform4dvEXT = _ptr;
    _glProgramUniform4dvEXT(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM4DVEXT _glProgramUniform4dvEXT = &_get_glProgramUniform4dvEXT;

static void APIENTRY _fail_glProgramUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
    const char *_name = "glProgramUniform4fEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
    PFN_GLPROGRAMUNIFORM4FEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4FEXT)_getPrivateProcAddress("glProgramUniform4fEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4fEXT;
    }
    _glProgramUniform4fEXT = _ptr;
    _glProgramUniform4fEXT(program, location, v0, v1, v2, v3);
}

PFN_GLPROGRAMUNIFORM4FEXT _glProgramUniform4fEXT = &_get_glProgramUniform4fEXT;

static void APIENTRY _fail_glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    const char *_name = "glProgramUniform4fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORM4FVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4FVEXT)_getPrivateProcAddress("glProgramUniform4fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4fvEXT;
    }
    _glProgramUniform4fvEXT = _ptr;
    _glProgramUniform4fvEXT(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM4FVEXT _glProgramUniform4fvEXT = &_get_glProgramUniform4fvEXT;

static void APIENTRY _fail_glProgramUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
    const char *_name = "glProgramUniform4iEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
    PFN_GLPROGRAMUNIFORM4IEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4IEXT)_getPrivateProcAddress("glProgramUniform4iEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4iEXT;
    }
    _glProgramUniform4iEXT = _ptr;
    _glProgramUniform4iEXT(program, location, v0, v1, v2, v3);
}

PFN_GLPROGRAMUNIFORM4IEXT _glProgramUniform4iEXT = &_get_glProgramUniform4iEXT;

static void APIENTRY _fail_glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value) {
    const char *_name = "glProgramUniform4ivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint * value) {
    PFN_GLPROGRAMUNIFORM4IVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4IVEXT)_getPrivateProcAddress("glProgramUniform4ivEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4ivEXT;
    }
    _glProgramUniform4ivEXT = _ptr;
    _glProgramUniform4ivEXT(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM4IVEXT _glProgramUniform4ivEXT = &_get_glProgramUniform4ivEXT;

static void APIENTRY _fail_glProgramUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
    const char *_name = "glProgramUniform4uiEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
    PFN_GLPROGRAMUNIFORM4UIEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4UIEXT)_getPrivateProcAddress("glProgramUniform4uiEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4uiEXT;
    }
    _glProgramUniform4uiEXT = _ptr;
    _glProgramUniform4uiEXT(program, location, v0, v1, v2, v3);
}

PFN_GLPROGRAMUNIFORM4UIEXT _glProgramUniform4uiEXT = &_get_glProgramUniform4uiEXT;

static void APIENTRY _fail_glProgramUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glProgramUniform4uivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint * value) {
    PFN_GLPROGRAMUNIFORM4UIVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4UIVEXT)_getPrivateProcAddress("glProgramUniform4uivEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4uivEXT;
    }
    _glProgramUniform4uivEXT = _ptr;
    _glProgramUniform4uivEXT(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM4UIVEXT _glProgramUniform4uivEXT = &_get_glProgramUniform4uivEXT;

static void APIENTRY _fail_glProgramUniformMatrix2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix2dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORMMATRIX2DVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX2DVEXT)_getPrivateProcAddress("glProgramUniformMatrix2dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix2dvEXT;
    }
    _glProgramUniformMatrix2dvEXT = _ptr;
    _glProgramUniformMatrix2dvEXT(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX2DVEXT _glProgramUniformMatrix2dvEXT = &_get_glProgramUniformMatrix2dvEXT;

static void APIENTRY _fail_glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix2fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORMMATRIX2FVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX2FVEXT)_getPrivateProcAddress("glProgramUniformMatrix2fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix2fvEXT;
    }
    _glProgramUniformMatrix2fvEXT = _ptr;
    _glProgramUniformMatrix2fvEXT(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX2FVEXT _glProgramUniformMatrix2fvEXT = &_get_glProgramUniformMatrix2fvEXT;

static void APIENTRY _fail_glProgramUniformMatrix2x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix2x3dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix2x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORMMATRIX2X3DVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX2X3DVEXT)_getPrivateProcAddress("glProgramUniformMatrix2x3dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix2x3dvEXT;
    }
    _glProgramUniformMatrix2x3dvEXT = _ptr;
    _glProgramUniformMatrix2x3dvEXT(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX2X3DVEXT _glProgramUniformMatrix2x3dvEXT = &_get_glProgramUniformMatrix2x3dvEXT;

static void APIENTRY _fail_glProgramUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix2x3fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORMMATRIX2X3FVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX2X3FVEXT)_getPrivateProcAddress("glProgramUniformMatrix2x3fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix2x3fvEXT;
    }
    _glProgramUniformMatrix2x3fvEXT = _ptr;
    _glProgramUniformMatrix2x3fvEXT(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX2X3FVEXT _glProgramUniformMatrix2x3fvEXT = &_get_glProgramUniformMatrix2x3fvEXT;

static void APIENTRY _fail_glProgramUniformMatrix2x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix2x4dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix2x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORMMATRIX2X4DVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX2X4DVEXT)_getPrivateProcAddress("glProgramUniformMatrix2x4dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix2x4dvEXT;
    }
    _glProgramUniformMatrix2x4dvEXT = _ptr;
    _glProgramUniformMatrix2x4dvEXT(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX2X4DVEXT _glProgramUniformMatrix2x4dvEXT = &_get_glProgramUniformMatrix2x4dvEXT;

static void APIENTRY _fail_glProgramUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix2x4fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORMMATRIX2X4FVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX2X4FVEXT)_getPrivateProcAddress("glProgramUniformMatrix2x4fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix2x4fvEXT;
    }
    _glProgramUniformMatrix2x4fvEXT = _ptr;
    _glProgramUniformMatrix2x4fvEXT(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX2X4FVEXT _glProgramUniformMatrix2x4fvEXT = &_get_glProgramUniformMatrix2x4fvEXT;

static void APIENTRY _fail_glProgramUniformMatrix3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix3dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORMMATRIX3DVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX3DVEXT)_getPrivateProcAddress("glProgramUniformMatrix3dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix3dvEXT;
    }
    _glProgramUniformMatrix3dvEXT = _ptr;
    _glProgramUniformMatrix3dvEXT(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX3DVEXT _glProgramUniformMatrix3dvEXT = &_get_glProgramUniformMatrix3dvEXT;

static void APIENTRY _fail_glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix3fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORMMATRIX3FVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX3FVEXT)_getPrivateProcAddress("glProgramUniformMatrix3fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix3fvEXT;
    }
    _glProgramUniformMatrix3fvEXT = _ptr;
    _glProgramUniformMatrix3fvEXT(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX3FVEXT _glProgramUniformMatrix3fvEXT = &_get_glProgramUniformMatrix3fvEXT;

static void APIENTRY _fail_glProgramUniformMatrix3x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix3x2dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix3x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORMMATRIX3X2DVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX3X2DVEXT)_getPrivateProcAddress("glProgramUniformMatrix3x2dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix3x2dvEXT;
    }
    _glProgramUniformMatrix3x2dvEXT = _ptr;
    _glProgramUniformMatrix3x2dvEXT(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX3X2DVEXT _glProgramUniformMatrix3x2dvEXT = &_get_glProgramUniformMatrix3x2dvEXT;

static void APIENTRY _fail_glProgramUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix3x2fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORMMATRIX3X2FVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX3X2FVEXT)_getPrivateProcAddress("glProgramUniformMatrix3x2fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix3x2fvEXT;
    }
    _glProgramUniformMatrix3x2fvEXT = _ptr;
    _glProgramUniformMatrix3x2fvEXT(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX3X2FVEXT _glProgramUniformMatrix3x2fvEXT = &_get_glProgramUniformMatrix3x2fvEXT;

static void APIENTRY _fail_glProgramUniformMatrix3x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix3x4dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix3x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORMMATRIX3X4DVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX3X4DVEXT)_getPrivateProcAddress("glProgramUniformMatrix3x4dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix3x4dvEXT;
    }
    _glProgramUniformMatrix3x4dvEXT = _ptr;
    _glProgramUniformMatrix3x4dvEXT(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX3X4DVEXT _glProgramUniformMatrix3x4dvEXT = &_get_glProgramUniformMatrix3x4dvEXT;

static void APIENTRY _fail_glProgramUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix3x4fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORMMATRIX3X4FVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX3X4FVEXT)_getPrivateProcAddress("glProgramUniformMatrix3x4fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix3x4fvEXT;
    }
    _glProgramUniformMatrix3x4fvEXT = _ptr;
    _glProgramUniformMatrix3x4fvEXT(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX3X4FVEXT _glProgramUniformMatrix3x4fvEXT = &_get_glProgramUniformMatrix3x4fvEXT;

static void APIENTRY _fail_glProgramUniformMatrix4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix4dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORMMATRIX4DVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX4DVEXT)_getPrivateProcAddress("glProgramUniformMatrix4dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix4dvEXT;
    }
    _glProgramUniformMatrix4dvEXT = _ptr;
    _glProgramUniformMatrix4dvEXT(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX4DVEXT _glProgramUniformMatrix4dvEXT = &_get_glProgramUniformMatrix4dvEXT;

static void APIENTRY _fail_glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix4fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORMMATRIX4FVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX4FVEXT)_getPrivateProcAddress("glProgramUniformMatrix4fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix4fvEXT;
    }
    _glProgramUniformMatrix4fvEXT = _ptr;
    _glProgramUniformMatrix4fvEXT(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX4FVEXT _glProgramUniformMatrix4fvEXT = &_get_glProgramUniformMatrix4fvEXT;

static void APIENTRY _fail_glProgramUniformMatrix4x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix4x2dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix4x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORMMATRIX4X2DVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX4X2DVEXT)_getPrivateProcAddress("glProgramUniformMatrix4x2dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix4x2dvEXT;
    }
    _glProgramUniformMatrix4x2dvEXT = _ptr;
    _glProgramUniformMatrix4x2dvEXT(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX4X2DVEXT _glProgramUniformMatrix4x2dvEXT = &_get_glProgramUniformMatrix4x2dvEXT;

static void APIENTRY _fail_glProgramUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix4x2fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORMMATRIX4X2FVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX4X2FVEXT)_getPrivateProcAddress("glProgramUniformMatrix4x2fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix4x2fvEXT;
    }
    _glProgramUniformMatrix4x2fvEXT = _ptr;
    _glProgramUniformMatrix4x2fvEXT(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX4X2FVEXT _glProgramUniformMatrix4x2fvEXT = &_get_glProgramUniformMatrix4x2fvEXT;

static void APIENTRY _fail_glProgramUniformMatrix4x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    const char *_name = "glProgramUniformMatrix4x3dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix4x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value) {
    PFN_GLPROGRAMUNIFORMMATRIX4X3DVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX4X3DVEXT)_getPrivateProcAddress("glProgramUniformMatrix4x3dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix4x3dvEXT;
    }
    _glProgramUniformMatrix4x3dvEXT = _ptr;
    _glProgramUniformMatrix4x3dvEXT(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX4X3DVEXT _glProgramUniformMatrix4x3dvEXT = &_get_glProgramUniformMatrix4x3dvEXT;

static void APIENTRY _fail_glProgramUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    const char *_name = "glProgramUniformMatrix4x3fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value) {
    PFN_GLPROGRAMUNIFORMMATRIX4X3FVEXT _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMMATRIX4X3FVEXT)_getPrivateProcAddress("glProgramUniformMatrix4x3fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformMatrix4x3fvEXT;
    }
    _glProgramUniformMatrix4x3fvEXT = _ptr;
    _glProgramUniformMatrix4x3fvEXT(program, location, count, transpose, value);
}

PFN_GLPROGRAMUNIFORMMATRIX4X3FVEXT _glProgramUniformMatrix4x3fvEXT = &_get_glProgramUniformMatrix4x3fvEXT;

static void APIENTRY _fail_glPushClientAttribDefaultEXT(GLbitfield mask) {
    const char *_name = "glPushClientAttribDefaultEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPushClientAttribDefaultEXT(GLbitfield mask) {
    PFN_GLPUSHCLIENTATTRIBDEFAULTEXT _ptr;
    _ptr = (PFN_GLPUSHCLIENTATTRIBDEFAULTEXT)_getPrivateProcAddress("glPushClientAttribDefaultEXT");
    if (!_ptr) {
        _ptr = &_fail_glPushClientAttribDefaultEXT;
    }
    _glPushClientAttribDefaultEXT = _ptr;
    _glPushClientAttribDefaultEXT(mask);
}

PFN_GLPUSHCLIENTATTRIBDEFAULTEXT _glPushClientAttribDefaultEXT = &_get_glPushClientAttribDefaultEXT;

static void APIENTRY _fail_glTextureBufferEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer) {
    const char *_name = "glTextureBufferEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureBufferEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer) {
    PFN_GLTEXTUREBUFFEREXT _ptr;
    _ptr = (PFN_GLTEXTUREBUFFEREXT)_getPrivateProcAddress("glTextureBufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureBufferEXT;
    }
    _glTextureBufferEXT = _ptr;
    _glTextureBufferEXT(texture, target, internalformat, buffer);
}

PFN_GLTEXTUREBUFFEREXT _glTextureBufferEXT = &_get_glTextureBufferEXT;

static void APIENTRY _fail_glTextureBufferRangeEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    const char *_name = "glTextureBufferRangeEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureBufferRangeEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    PFN_GLTEXTUREBUFFERRANGEEXT _ptr;
    _ptr = (PFN_GLTEXTUREBUFFERRANGEEXT)_getPrivateProcAddress("glTextureBufferRangeEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureBufferRangeEXT;
    }
    _glTextureBufferRangeEXT = _ptr;
    _glTextureBufferRangeEXT(texture, target, internalformat, buffer, offset, size);
}

PFN_GLTEXTUREBUFFERRANGEEXT _glTextureBufferRangeEXT = &_get_glTextureBufferRangeEXT;

static void APIENTRY _fail_glTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTextureImage1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXTUREIMAGE1DEXT _ptr;
    _ptr = (PFN_GLTEXTUREIMAGE1DEXT)_getPrivateProcAddress("glTextureImage1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureImage1DEXT;
    }
    _glTextureImage1DEXT = _ptr;
    _glTextureImage1DEXT(texture, target, level, internalformat, width, border, format, type, pixels);
}

PFN_GLTEXTUREIMAGE1DEXT _glTextureImage1DEXT = &_get_glTextureImage1DEXT;

static void APIENTRY _fail_glTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTextureImage2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXTUREIMAGE2DEXT _ptr;
    _ptr = (PFN_GLTEXTUREIMAGE2DEXT)_getPrivateProcAddress("glTextureImage2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureImage2DEXT;
    }
    _glTextureImage2DEXT = _ptr;
    _glTextureImage2DEXT(texture, target, level, internalformat, width, height, border, format, type, pixels);
}

PFN_GLTEXTUREIMAGE2DEXT _glTextureImage2DEXT = &_get_glTextureImage2DEXT;

static void APIENTRY _fail_glTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTextureImage3DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXTUREIMAGE3DEXT _ptr;
    _ptr = (PFN_GLTEXTUREIMAGE3DEXT)_getPrivateProcAddress("glTextureImage3DEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureImage3DEXT;
    }
    _glTextureImage3DEXT = _ptr;
    _glTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
}

PFN_GLTEXTUREIMAGE3DEXT _glTextureImage3DEXT = &_get_glTextureImage3DEXT;

static void APIENTRY _fail_glTexturePageCommitmentEXT(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) {
    const char *_name = "glTexturePageCommitmentEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexturePageCommitmentEXT(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) {
    PFN_GLTEXTUREPAGECOMMITMENTEXT _ptr;
    _ptr = (PFN_GLTEXTUREPAGECOMMITMENTEXT)_getPrivateProcAddress("glTexturePageCommitmentEXT");
    if (!_ptr) {
        _ptr = &_fail_glTexturePageCommitmentEXT;
    }
    _glTexturePageCommitmentEXT = _ptr;
    _glTexturePageCommitmentEXT(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);
}

PFN_GLTEXTUREPAGECOMMITMENTEXT _glTexturePageCommitmentEXT = &_get_glTexturePageCommitmentEXT;

static void APIENTRY _fail_glTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glTextureParameterIivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, const GLint * params) {
    PFN_GLTEXTUREPARAMETERIIVEXT _ptr;
    _ptr = (PFN_GLTEXTUREPARAMETERIIVEXT)_getPrivateProcAddress("glTextureParameterIivEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureParameterIivEXT;
    }
    _glTextureParameterIivEXT = _ptr;
    _glTextureParameterIivEXT(texture, target, pname, params);
}

PFN_GLTEXTUREPARAMETERIIVEXT _glTextureParameterIivEXT = &_get_glTextureParameterIivEXT;

static void APIENTRY _fail_glTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, const GLuint * params) {
    const char *_name = "glTextureParameterIuivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, const GLuint * params) {
    PFN_GLTEXTUREPARAMETERIUIVEXT _ptr;
    _ptr = (PFN_GLTEXTUREPARAMETERIUIVEXT)_getPrivateProcAddress("glTextureParameterIuivEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureParameterIuivEXT;
    }
    _glTextureParameterIuivEXT = _ptr;
    _glTextureParameterIuivEXT(texture, target, pname, params);
}

PFN_GLTEXTUREPARAMETERIUIVEXT _glTextureParameterIuivEXT = &_get_glTextureParameterIuivEXT;

static void APIENTRY _fail_glTextureParameterfEXT(GLuint texture, GLenum target, GLenum pname, GLfloat param) {
    const char *_name = "glTextureParameterfEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureParameterfEXT(GLuint texture, GLenum target, GLenum pname, GLfloat param) {
    PFN_GLTEXTUREPARAMETERFEXT _ptr;
    _ptr = (PFN_GLTEXTUREPARAMETERFEXT)_getPrivateProcAddress("glTextureParameterfEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureParameterfEXT;
    }
    _glTextureParameterfEXT = _ptr;
    _glTextureParameterfEXT(texture, target, pname, param);
}

PFN_GLTEXTUREPARAMETERFEXT _glTextureParameterfEXT = &_get_glTextureParameterfEXT;

static void APIENTRY _fail_glTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glTextureParameterfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, const GLfloat * params) {
    PFN_GLTEXTUREPARAMETERFVEXT _ptr;
    _ptr = (PFN_GLTEXTUREPARAMETERFVEXT)_getPrivateProcAddress("glTextureParameterfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureParameterfvEXT;
    }
    _glTextureParameterfvEXT = _ptr;
    _glTextureParameterfvEXT(texture, target, pname, params);
}

PFN_GLTEXTUREPARAMETERFVEXT _glTextureParameterfvEXT = &_get_glTextureParameterfvEXT;

static void APIENTRY _fail_glTextureParameteriEXT(GLuint texture, GLenum target, GLenum pname, GLint param) {
    const char *_name = "glTextureParameteriEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureParameteriEXT(GLuint texture, GLenum target, GLenum pname, GLint param) {
    PFN_GLTEXTUREPARAMETERIEXT _ptr;
    _ptr = (PFN_GLTEXTUREPARAMETERIEXT)_getPrivateProcAddress("glTextureParameteriEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureParameteriEXT;
    }
    _glTextureParameteriEXT = _ptr;
    _glTextureParameteriEXT(texture, target, pname, param);
}

PFN_GLTEXTUREPARAMETERIEXT _glTextureParameteriEXT = &_get_glTextureParameteriEXT;

static void APIENTRY _fail_glTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glTextureParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, const GLint * params) {
    PFN_GLTEXTUREPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLTEXTUREPARAMETERIVEXT)_getPrivateProcAddress("glTextureParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureParameterivEXT;
    }
    _glTextureParameterivEXT = _ptr;
    _glTextureParameterivEXT(texture, target, pname, params);
}

PFN_GLTEXTUREPARAMETERIVEXT _glTextureParameterivEXT = &_get_glTextureParameterivEXT;

static void APIENTRY _fail_glTextureRenderbufferEXT(GLuint texture, GLenum target, GLuint renderbuffer) {
    const char *_name = "glTextureRenderbufferEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureRenderbufferEXT(GLuint texture, GLenum target, GLuint renderbuffer) {
    PFN_GLTEXTURERENDERBUFFEREXT _ptr;
    _ptr = (PFN_GLTEXTURERENDERBUFFEREXT)_getPrivateProcAddress("glTextureRenderbufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureRenderbufferEXT;
    }
    _glTextureRenderbufferEXT = _ptr;
    _glTextureRenderbufferEXT(texture, target, renderbuffer);
}

PFN_GLTEXTURERENDERBUFFEREXT _glTextureRenderbufferEXT = &_get_glTextureRenderbufferEXT;

static void APIENTRY _fail_glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) {
    const char *_name = "glTextureStorage1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) {
    PFN_GLTEXTURESTORAGE1DEXT _ptr;
    _ptr = (PFN_GLTEXTURESTORAGE1DEXT)_getPrivateProcAddress("glTextureStorage1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureStorage1DEXT;
    }
    _glTextureStorage1DEXT = _ptr;
    _glTextureStorage1DEXT(texture, target, levels, internalformat, width);
}

PFN_GLTEXTURESTORAGE1DEXT _glTextureStorage1DEXT = &_get_glTextureStorage1DEXT;

static void APIENTRY _fail_glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glTextureStorage2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) {
    PFN_GLTEXTURESTORAGE2DEXT _ptr;
    _ptr = (PFN_GLTEXTURESTORAGE2DEXT)_getPrivateProcAddress("glTextureStorage2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureStorage2DEXT;
    }
    _glTextureStorage2DEXT = _ptr;
    _glTextureStorage2DEXT(texture, target, levels, internalformat, width, height);
}

PFN_GLTEXTURESTORAGE2DEXT _glTextureStorage2DEXT = &_get_glTextureStorage2DEXT;

static void APIENTRY _fail_glTextureStorage2DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
    const char *_name = "glTextureStorage2DMultisampleEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureStorage2DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
    PFN_GLTEXTURESTORAGE2DMULTISAMPLEEXT _ptr;
    _ptr = (PFN_GLTEXTURESTORAGE2DMULTISAMPLEEXT)_getPrivateProcAddress("glTextureStorage2DMultisampleEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureStorage2DMultisampleEXT;
    }
    _glTextureStorage2DMultisampleEXT = _ptr;
    _glTextureStorage2DMultisampleEXT(texture, target, samples, internalformat, width, height, fixedsamplelocations);
}

PFN_GLTEXTURESTORAGE2DMULTISAMPLEEXT _glTextureStorage2DMultisampleEXT = &_get_glTextureStorage2DMultisampleEXT;

static void APIENTRY _fail_glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) {
    const char *_name = "glTextureStorage3DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) {
    PFN_GLTEXTURESTORAGE3DEXT _ptr;
    _ptr = (PFN_GLTEXTURESTORAGE3DEXT)_getPrivateProcAddress("glTextureStorage3DEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureStorage3DEXT;
    }
    _glTextureStorage3DEXT = _ptr;
    _glTextureStorage3DEXT(texture, target, levels, internalformat, width, height, depth);
}

PFN_GLTEXTURESTORAGE3DEXT _glTextureStorage3DEXT = &_get_glTextureStorage3DEXT;

static void APIENTRY _fail_glTextureStorage3DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
    const char *_name = "glTextureStorage3DMultisampleEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureStorage3DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
    PFN_GLTEXTURESTORAGE3DMULTISAMPLEEXT _ptr;
    _ptr = (PFN_GLTEXTURESTORAGE3DMULTISAMPLEEXT)_getPrivateProcAddress("glTextureStorage3DMultisampleEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureStorage3DMultisampleEXT;
    }
    _glTextureStorage3DMultisampleEXT = _ptr;
    _glTextureStorage3DMultisampleEXT(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
}

PFN_GLTEXTURESTORAGE3DMULTISAMPLEEXT _glTextureStorage3DMultisampleEXT = &_get_glTextureStorage3DMultisampleEXT;

static void APIENTRY _fail_glTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTextureSubImage1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXTURESUBIMAGE1DEXT _ptr;
    _ptr = (PFN_GLTEXTURESUBIMAGE1DEXT)_getPrivateProcAddress("glTextureSubImage1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureSubImage1DEXT;
    }
    _glTextureSubImage1DEXT = _ptr;
    _glTextureSubImage1DEXT(texture, target, level, xoffset, width, format, type, pixels);
}

PFN_GLTEXTURESUBIMAGE1DEXT _glTextureSubImage1DEXT = &_get_glTextureSubImage1DEXT;

static void APIENTRY _fail_glTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTextureSubImage2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXTURESUBIMAGE2DEXT _ptr;
    _ptr = (PFN_GLTEXTURESUBIMAGE2DEXT)_getPrivateProcAddress("glTextureSubImage2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureSubImage2DEXT;
    }
    _glTextureSubImage2DEXT = _ptr;
    _glTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
}

PFN_GLTEXTURESUBIMAGE2DEXT _glTextureSubImage2DEXT = &_get_glTextureSubImage2DEXT;

static void APIENTRY _fail_glTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTextureSubImage3DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXTURESUBIMAGE3DEXT _ptr;
    _ptr = (PFN_GLTEXTURESUBIMAGE3DEXT)_getPrivateProcAddress("glTextureSubImage3DEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureSubImage3DEXT;
    }
    _glTextureSubImage3DEXT = _ptr;
    _glTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

PFN_GLTEXTURESUBIMAGE3DEXT _glTextureSubImage3DEXT = &_get_glTextureSubImage3DEXT;

static GLboolean APIENTRY _fail_glUnmapNamedBufferEXT(GLuint buffer) {
    const char *_name = "glUnmapNamedBufferEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glUnmapNamedBufferEXT(GLuint buffer) {
    PFN_GLUNMAPNAMEDBUFFEREXT _ptr;
    _ptr = (PFN_GLUNMAPNAMEDBUFFEREXT)_getPrivateProcAddress("glUnmapNamedBufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glUnmapNamedBufferEXT;
    }
    _glUnmapNamedBufferEXT = _ptr;
    return _glUnmapNamedBufferEXT(buffer);
}

PFN_GLUNMAPNAMEDBUFFEREXT _glUnmapNamedBufferEXT = &_get_glUnmapNamedBufferEXT;

static void APIENTRY _fail_glVertexArrayBindVertexBufferEXT(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) {
    const char *_name = "glVertexArrayBindVertexBufferEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayBindVertexBufferEXT(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) {
    PFN_GLVERTEXARRAYBINDVERTEXBUFFEREXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYBINDVERTEXBUFFEREXT)_getPrivateProcAddress("glVertexArrayBindVertexBufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayBindVertexBufferEXT;
    }
    _glVertexArrayBindVertexBufferEXT = _ptr;
    _glVertexArrayBindVertexBufferEXT(vaobj, bindingindex, buffer, offset, stride);
}

PFN_GLVERTEXARRAYBINDVERTEXBUFFEREXT _glVertexArrayBindVertexBufferEXT = &_get_glVertexArrayBindVertexBufferEXT;

static void APIENTRY _fail_glVertexArrayColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayColorOffsetEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    PFN_GLVERTEXARRAYCOLOROFFSETEXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYCOLOROFFSETEXT)_getPrivateProcAddress("glVertexArrayColorOffsetEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayColorOffsetEXT;
    }
    _glVertexArrayColorOffsetEXT = _ptr;
    _glVertexArrayColorOffsetEXT(vaobj, buffer, size, type, stride, offset);
}

PFN_GLVERTEXARRAYCOLOROFFSETEXT _glVertexArrayColorOffsetEXT = &_get_glVertexArrayColorOffsetEXT;

static void APIENTRY _fail_glVertexArrayEdgeFlagOffsetEXT(GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayEdgeFlagOffsetEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayEdgeFlagOffsetEXT(GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset) {
    PFN_GLVERTEXARRAYEDGEFLAGOFFSETEXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYEDGEFLAGOFFSETEXT)_getPrivateProcAddress("glVertexArrayEdgeFlagOffsetEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayEdgeFlagOffsetEXT;
    }
    _glVertexArrayEdgeFlagOffsetEXT = _ptr;
    _glVertexArrayEdgeFlagOffsetEXT(vaobj, buffer, stride, offset);
}

PFN_GLVERTEXARRAYEDGEFLAGOFFSETEXT _glVertexArrayEdgeFlagOffsetEXT = &_get_glVertexArrayEdgeFlagOffsetEXT;

static void APIENTRY _fail_glVertexArrayFogCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayFogCoordOffsetEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayFogCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) {
    PFN_GLVERTEXARRAYFOGCOORDOFFSETEXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYFOGCOORDOFFSETEXT)_getPrivateProcAddress("glVertexArrayFogCoordOffsetEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayFogCoordOffsetEXT;
    }
    _glVertexArrayFogCoordOffsetEXT = _ptr;
    _glVertexArrayFogCoordOffsetEXT(vaobj, buffer, type, stride, offset);
}

PFN_GLVERTEXARRAYFOGCOORDOFFSETEXT _glVertexArrayFogCoordOffsetEXT = &_get_glVertexArrayFogCoordOffsetEXT;

static void APIENTRY _fail_glVertexArrayIndexOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayIndexOffsetEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayIndexOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) {
    PFN_GLVERTEXARRAYINDEXOFFSETEXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYINDEXOFFSETEXT)_getPrivateProcAddress("glVertexArrayIndexOffsetEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayIndexOffsetEXT;
    }
    _glVertexArrayIndexOffsetEXT = _ptr;
    _glVertexArrayIndexOffsetEXT(vaobj, buffer, type, stride, offset);
}

PFN_GLVERTEXARRAYINDEXOFFSETEXT _glVertexArrayIndexOffsetEXT = &_get_glVertexArrayIndexOffsetEXT;

static void APIENTRY _fail_glVertexArrayMultiTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayMultiTexCoordOffsetEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayMultiTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    PFN_GLVERTEXARRAYMULTITEXCOORDOFFSETEXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYMULTITEXCOORDOFFSETEXT)_getPrivateProcAddress("glVertexArrayMultiTexCoordOffsetEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayMultiTexCoordOffsetEXT;
    }
    _glVertexArrayMultiTexCoordOffsetEXT = _ptr;
    _glVertexArrayMultiTexCoordOffsetEXT(vaobj, buffer, texunit, size, type, stride, offset);
}

PFN_GLVERTEXARRAYMULTITEXCOORDOFFSETEXT _glVertexArrayMultiTexCoordOffsetEXT = &_get_glVertexArrayMultiTexCoordOffsetEXT;

static void APIENTRY _fail_glVertexArrayNormalOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayNormalOffsetEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayNormalOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset) {
    PFN_GLVERTEXARRAYNORMALOFFSETEXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYNORMALOFFSETEXT)_getPrivateProcAddress("glVertexArrayNormalOffsetEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayNormalOffsetEXT;
    }
    _glVertexArrayNormalOffsetEXT = _ptr;
    _glVertexArrayNormalOffsetEXT(vaobj, buffer, type, stride, offset);
}

PFN_GLVERTEXARRAYNORMALOFFSETEXT _glVertexArrayNormalOffsetEXT = &_get_glVertexArrayNormalOffsetEXT;

static void APIENTRY _fail_glVertexArraySecondaryColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArraySecondaryColorOffsetEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArraySecondaryColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    PFN_GLVERTEXARRAYSECONDARYCOLOROFFSETEXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYSECONDARYCOLOROFFSETEXT)_getPrivateProcAddress("glVertexArraySecondaryColorOffsetEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArraySecondaryColorOffsetEXT;
    }
    _glVertexArraySecondaryColorOffsetEXT = _ptr;
    _glVertexArraySecondaryColorOffsetEXT(vaobj, buffer, size, type, stride, offset);
}

PFN_GLVERTEXARRAYSECONDARYCOLOROFFSETEXT _glVertexArraySecondaryColorOffsetEXT = &_get_glVertexArraySecondaryColorOffsetEXT;

static void APIENTRY _fail_glVertexArrayTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayTexCoordOffsetEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    PFN_GLVERTEXARRAYTEXCOORDOFFSETEXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYTEXCOORDOFFSETEXT)_getPrivateProcAddress("glVertexArrayTexCoordOffsetEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayTexCoordOffsetEXT;
    }
    _glVertexArrayTexCoordOffsetEXT = _ptr;
    _glVertexArrayTexCoordOffsetEXT(vaobj, buffer, size, type, stride, offset);
}

PFN_GLVERTEXARRAYTEXCOORDOFFSETEXT _glVertexArrayTexCoordOffsetEXT = &_get_glVertexArrayTexCoordOffsetEXT;

static void APIENTRY _fail_glVertexArrayVertexAttribBindingEXT(GLuint vaobj, GLuint attribindex, GLuint bindingindex) {
    const char *_name = "glVertexArrayVertexAttribBindingEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayVertexAttribBindingEXT(GLuint vaobj, GLuint attribindex, GLuint bindingindex) {
    PFN_GLVERTEXARRAYVERTEXATTRIBBINDINGEXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYVERTEXATTRIBBINDINGEXT)_getPrivateProcAddress("glVertexArrayVertexAttribBindingEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayVertexAttribBindingEXT;
    }
    _glVertexArrayVertexAttribBindingEXT = _ptr;
    _glVertexArrayVertexAttribBindingEXT(vaobj, attribindex, bindingindex);
}

PFN_GLVERTEXARRAYVERTEXATTRIBBINDINGEXT _glVertexArrayVertexAttribBindingEXT = &_get_glVertexArrayVertexAttribBindingEXT;

static void APIENTRY _fail_glVertexArrayVertexAttribDivisorEXT(GLuint vaobj, GLuint index, GLuint divisor) {
    const char *_name = "glVertexArrayVertexAttribDivisorEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayVertexAttribDivisorEXT(GLuint vaobj, GLuint index, GLuint divisor) {
    PFN_GLVERTEXARRAYVERTEXATTRIBDIVISOREXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYVERTEXATTRIBDIVISOREXT)_getPrivateProcAddress("glVertexArrayVertexAttribDivisorEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayVertexAttribDivisorEXT;
    }
    _glVertexArrayVertexAttribDivisorEXT = _ptr;
    _glVertexArrayVertexAttribDivisorEXT(vaobj, index, divisor);
}

PFN_GLVERTEXARRAYVERTEXATTRIBDIVISOREXT _glVertexArrayVertexAttribDivisorEXT = &_get_glVertexArrayVertexAttribDivisorEXT;

static void APIENTRY _fail_glVertexArrayVertexAttribFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) {
    const char *_name = "glVertexArrayVertexAttribFormatEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayVertexAttribFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) {
    PFN_GLVERTEXARRAYVERTEXATTRIBFORMATEXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYVERTEXATTRIBFORMATEXT)_getPrivateProcAddress("glVertexArrayVertexAttribFormatEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayVertexAttribFormatEXT;
    }
    _glVertexArrayVertexAttribFormatEXT = _ptr;
    _glVertexArrayVertexAttribFormatEXT(vaobj, attribindex, size, type, normalized, relativeoffset);
}

PFN_GLVERTEXARRAYVERTEXATTRIBFORMATEXT _glVertexArrayVertexAttribFormatEXT = &_get_glVertexArrayVertexAttribFormatEXT;

static void APIENTRY _fail_glVertexArrayVertexAttribIFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
    const char *_name = "glVertexArrayVertexAttribIFormatEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayVertexAttribIFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
    PFN_GLVERTEXARRAYVERTEXATTRIBIFORMATEXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYVERTEXATTRIBIFORMATEXT)_getPrivateProcAddress("glVertexArrayVertexAttribIFormatEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayVertexAttribIFormatEXT;
    }
    _glVertexArrayVertexAttribIFormatEXT = _ptr;
    _glVertexArrayVertexAttribIFormatEXT(vaobj, attribindex, size, type, relativeoffset);
}

PFN_GLVERTEXARRAYVERTEXATTRIBIFORMATEXT _glVertexArrayVertexAttribIFormatEXT = &_get_glVertexArrayVertexAttribIFormatEXT;

static void APIENTRY _fail_glVertexArrayVertexAttribIOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayVertexAttribIOffsetEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayVertexAttribIOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    PFN_GLVERTEXARRAYVERTEXATTRIBIOFFSETEXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYVERTEXATTRIBIOFFSETEXT)_getPrivateProcAddress("glVertexArrayVertexAttribIOffsetEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayVertexAttribIOffsetEXT;
    }
    _glVertexArrayVertexAttribIOffsetEXT = _ptr;
    _glVertexArrayVertexAttribIOffsetEXT(vaobj, buffer, index, size, type, stride, offset);
}

PFN_GLVERTEXARRAYVERTEXATTRIBIOFFSETEXT _glVertexArrayVertexAttribIOffsetEXT = &_get_glVertexArrayVertexAttribIOffsetEXT;

static void APIENTRY _fail_glVertexArrayVertexAttribLFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
    const char *_name = "glVertexArrayVertexAttribLFormatEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayVertexAttribLFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
    PFN_GLVERTEXARRAYVERTEXATTRIBLFORMATEXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYVERTEXATTRIBLFORMATEXT)_getPrivateProcAddress("glVertexArrayVertexAttribLFormatEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayVertexAttribLFormatEXT;
    }
    _glVertexArrayVertexAttribLFormatEXT = _ptr;
    _glVertexArrayVertexAttribLFormatEXT(vaobj, attribindex, size, type, relativeoffset);
}

PFN_GLVERTEXARRAYVERTEXATTRIBLFORMATEXT _glVertexArrayVertexAttribLFormatEXT = &_get_glVertexArrayVertexAttribLFormatEXT;

static void APIENTRY _fail_glVertexArrayVertexAttribLOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayVertexAttribLOffsetEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayVertexAttribLOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    PFN_GLVERTEXARRAYVERTEXATTRIBLOFFSETEXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYVERTEXATTRIBLOFFSETEXT)_getPrivateProcAddress("glVertexArrayVertexAttribLOffsetEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayVertexAttribLOffsetEXT;
    }
    _glVertexArrayVertexAttribLOffsetEXT = _ptr;
    _glVertexArrayVertexAttribLOffsetEXT(vaobj, buffer, index, size, type, stride, offset);
}

PFN_GLVERTEXARRAYVERTEXATTRIBLOFFSETEXT _glVertexArrayVertexAttribLOffsetEXT = &_get_glVertexArrayVertexAttribLOffsetEXT;

static void APIENTRY _fail_glVertexArrayVertexAttribOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayVertexAttribOffsetEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayVertexAttribOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset) {
    PFN_GLVERTEXARRAYVERTEXATTRIBOFFSETEXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYVERTEXATTRIBOFFSETEXT)_getPrivateProcAddress("glVertexArrayVertexAttribOffsetEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayVertexAttribOffsetEXT;
    }
    _glVertexArrayVertexAttribOffsetEXT = _ptr;
    _glVertexArrayVertexAttribOffsetEXT(vaobj, buffer, index, size, type, normalized, stride, offset);
}

PFN_GLVERTEXARRAYVERTEXATTRIBOFFSETEXT _glVertexArrayVertexAttribOffsetEXT = &_get_glVertexArrayVertexAttribOffsetEXT;

static void APIENTRY _fail_glVertexArrayVertexBindingDivisorEXT(GLuint vaobj, GLuint bindingindex, GLuint divisor) {
    const char *_name = "glVertexArrayVertexBindingDivisorEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayVertexBindingDivisorEXT(GLuint vaobj, GLuint bindingindex, GLuint divisor) {
    PFN_GLVERTEXARRAYVERTEXBINDINGDIVISOREXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYVERTEXBINDINGDIVISOREXT)_getPrivateProcAddress("glVertexArrayVertexBindingDivisorEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayVertexBindingDivisorEXT;
    }
    _glVertexArrayVertexBindingDivisorEXT = _ptr;
    _glVertexArrayVertexBindingDivisorEXT(vaobj, bindingindex, divisor);
}

PFN_GLVERTEXARRAYVERTEXBINDINGDIVISOREXT _glVertexArrayVertexBindingDivisorEXT = &_get_glVertexArrayVertexBindingDivisorEXT;

static void APIENTRY _fail_glVertexArrayVertexOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    const char *_name = "glVertexArrayVertexOffsetEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayVertexOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset) {
    PFN_GLVERTEXARRAYVERTEXOFFSETEXT _ptr;
    _ptr = (PFN_GLVERTEXARRAYVERTEXOFFSETEXT)_getPrivateProcAddress("glVertexArrayVertexOffsetEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayVertexOffsetEXT;
    }
    _glVertexArrayVertexOffsetEXT = _ptr;
    _glVertexArrayVertexOffsetEXT(vaobj, buffer, size, type, stride, offset);
}

PFN_GLVERTEXARRAYVERTEXOFFSETEXT _glVertexArrayVertexOffsetEXT = &_get_glVertexArrayVertexOffsetEXT;

static void APIENTRY _fail_glDiscardFramebufferEXT(GLenum target, GLsizei numAttachments, const GLenum * attachments) {
    const char *_name = "glDiscardFramebufferEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDiscardFramebufferEXT(GLenum target, GLsizei numAttachments, const GLenum * attachments) {
    PFN_GLDISCARDFRAMEBUFFEREXT _ptr;
    _ptr = (PFN_GLDISCARDFRAMEBUFFEREXT)_getPrivateProcAddress("glDiscardFramebufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glDiscardFramebufferEXT;
    }
    _glDiscardFramebufferEXT = _ptr;
    _glDiscardFramebufferEXT(target, numAttachments, attachments);
}

PFN_GLDISCARDFRAMEBUFFEREXT _glDiscardFramebufferEXT = &_get_glDiscardFramebufferEXT;

static void APIENTRY _fail_glDrawBuffersEXT(GLsizei n, const GLenum * bufs) {
    const char *_name = "glDrawBuffersEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawBuffersEXT(GLsizei n, const GLenum * bufs) {
    PFN_GLDRAWBUFFERSEXT _ptr;
    _ptr = (PFN_GLDRAWBUFFERSEXT)_getPrivateProcAddress("glDrawBuffersEXT");
    if (!_ptr) {
        _ptr = &_fail_glDrawBuffersEXT;
    }
    _glDrawBuffersEXT = _ptr;
    _glDrawBuffersEXT(n, bufs);
}

PFN_GLDRAWBUFFERSEXT _glDrawBuffersEXT = &_get_glDrawBuffersEXT;

static void APIENTRY _fail_glColorMaskIndexedEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) {
    const char *_name = "glColorMaskIndexedEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorMaskIndexedEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) {
    PFN_GLCOLORMASKINDEXEDEXT _ptr;
    _ptr = (PFN_GLCOLORMASKINDEXEDEXT)_getPrivateProcAddress("glColorMaskIndexedEXT");
    if (!_ptr) {
        _ptr = &_fail_glColorMaskIndexedEXT;
    }
    _glColorMaskIndexedEXT = _ptr;
    _glColorMaskIndexedEXT(index, r, g, b, a);
}

PFN_GLCOLORMASKINDEXEDEXT _glColorMaskIndexedEXT = &_get_glColorMaskIndexedEXT;

static void APIENTRY _fail_glGetBooleanIndexedvEXT(GLenum target, GLuint index, GLboolean * data) {
    const char *_name = "glGetBooleanIndexedvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetBooleanIndexedvEXT(GLenum target, GLuint index, GLboolean * data) {
    PFN_GLGETBOOLEANINDEXEDVEXT _ptr;
    _ptr = (PFN_GLGETBOOLEANINDEXEDVEXT)_getPrivateProcAddress("glGetBooleanIndexedvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetBooleanIndexedvEXT;
    }
    _glGetBooleanIndexedvEXT = _ptr;
    _glGetBooleanIndexedvEXT(target, index, data);
}

PFN_GLGETBOOLEANINDEXEDVEXT _glGetBooleanIndexedvEXT = &_get_glGetBooleanIndexedvEXT;

static void APIENTRY _fail_glGetIntegerIndexedvEXT(GLenum target, GLuint index, GLint * data) {
    const char *_name = "glGetIntegerIndexedvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetIntegerIndexedvEXT(GLenum target, GLuint index, GLint * data) {
    PFN_GLGETINTEGERINDEXEDVEXT _ptr;
    _ptr = (PFN_GLGETINTEGERINDEXEDVEXT)_getPrivateProcAddress("glGetIntegerIndexedvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetIntegerIndexedvEXT;
    }
    _glGetIntegerIndexedvEXT = _ptr;
    _glGetIntegerIndexedvEXT(target, index, data);
}

PFN_GLGETINTEGERINDEXEDVEXT _glGetIntegerIndexedvEXT = &_get_glGetIntegerIndexedvEXT;

static void APIENTRY _fail_glEnableIndexedEXT(GLenum target, GLuint index) {
    const char *_name = "glEnableIndexedEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEnableIndexedEXT(GLenum target, GLuint index) {
    PFN_GLENABLEINDEXEDEXT _ptr;
    _ptr = (PFN_GLENABLEINDEXEDEXT)_getPrivateProcAddress("glEnableIndexedEXT");
    if (!_ptr) {
        _ptr = &_fail_glEnableIndexedEXT;
    }
    _glEnableIndexedEXT = _ptr;
    _glEnableIndexedEXT(target, index);
}

PFN_GLENABLEINDEXEDEXT _glEnableIndexedEXT = &_get_glEnableIndexedEXT;

static void APIENTRY _fail_glDisableIndexedEXT(GLenum target, GLuint index) {
    const char *_name = "glDisableIndexedEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDisableIndexedEXT(GLenum target, GLuint index) {
    PFN_GLDISABLEINDEXEDEXT _ptr;
    _ptr = (PFN_GLDISABLEINDEXEDEXT)_getPrivateProcAddress("glDisableIndexedEXT");
    if (!_ptr) {
        _ptr = &_fail_glDisableIndexedEXT;
    }
    _glDisableIndexedEXT = _ptr;
    _glDisableIndexedEXT(target, index);
}

PFN_GLDISABLEINDEXEDEXT _glDisableIndexedEXT = &_get_glDisableIndexedEXT;

static GLboolean APIENTRY _fail_glIsEnabledIndexedEXT(GLenum target, GLuint index) {
    const char *_name = "glIsEnabledIndexedEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsEnabledIndexedEXT(GLenum target, GLuint index) {
    PFN_GLISENABLEDINDEXEDEXT _ptr;
    _ptr = (PFN_GLISENABLEDINDEXEDEXT)_getPrivateProcAddress("glIsEnabledIndexedEXT");
    if (!_ptr) {
        _ptr = &_fail_glIsEnabledIndexedEXT;
    }
    _glIsEnabledIndexedEXT = _ptr;
    return _glIsEnabledIndexedEXT(target, index);
}

PFN_GLISENABLEDINDEXEDEXT _glIsEnabledIndexedEXT = &_get_glIsEnabledIndexedEXT;

static void APIENTRY _fail_glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount) {
    const char *_name = "glDrawArraysInstancedEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount) {
    PFN_GLDRAWARRAYSINSTANCEDEXT _ptr;
    _ptr = (PFN_GLDRAWARRAYSINSTANCEDEXT)_getPrivateProcAddress("glDrawArraysInstancedEXT");
    if (!_ptr) {
        _ptr = &_fail_glDrawArraysInstancedEXT;
    }
    _glDrawArraysInstancedEXT = _ptr;
    _glDrawArraysInstancedEXT(mode, start, count, primcount);
}

PFN_GLDRAWARRAYSINSTANCEDEXT _glDrawArraysInstancedEXT = &_get_glDrawArraysInstancedEXT;

static void APIENTRY _fail_glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount) {
    const char *_name = "glDrawElementsInstancedEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount) {
    PFN_GLDRAWELEMENTSINSTANCEDEXT _ptr;
    _ptr = (PFN_GLDRAWELEMENTSINSTANCEDEXT)_getPrivateProcAddress("glDrawElementsInstancedEXT");
    if (!_ptr) {
        _ptr = &_fail_glDrawElementsInstancedEXT;
    }
    _glDrawElementsInstancedEXT = _ptr;
    _glDrawElementsInstancedEXT(mode, count, type, indices, primcount);
}

PFN_GLDRAWELEMENTSINSTANCEDEXT _glDrawElementsInstancedEXT = &_get_glDrawElementsInstancedEXT;

static void APIENTRY _fail_glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices) {
    const char *_name = "glDrawRangeElementsEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices) {
    PFN_GLDRAWRANGEELEMENTSEXT _ptr;
    _ptr = (PFN_GLDRAWRANGEELEMENTSEXT)_getPrivateProcAddress("glDrawRangeElementsEXT");
    if (!_ptr) {
        _ptr = &_fail_glDrawRangeElementsEXT;
    }
    _glDrawRangeElementsEXT = _ptr;
    _glDrawRangeElementsEXT(mode, start, end, count, type, indices);
}

PFN_GLDRAWRANGEELEMENTSEXT _glDrawRangeElementsEXT = &_get_glDrawRangeElementsEXT;

static void APIENTRY _fail_glFogCoordfEXT(GLfloat coord) {
    const char *_name = "glFogCoordfEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogCoordfEXT(GLfloat coord) {
    PFN_GLFOGCOORDFEXT _ptr;
    _ptr = (PFN_GLFOGCOORDFEXT)_getPrivateProcAddress("glFogCoordfEXT");
    if (!_ptr) {
        _ptr = &_fail_glFogCoordfEXT;
    }
    _glFogCoordfEXT = _ptr;
    _glFogCoordfEXT(coord);
}

PFN_GLFOGCOORDFEXT _glFogCoordfEXT = &_get_glFogCoordfEXT;

static void APIENTRY _fail_glFogCoordfvEXT(const GLfloat * coord) {
    const char *_name = "glFogCoordfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogCoordfvEXT(const GLfloat * coord) {
    PFN_GLFOGCOORDFVEXT _ptr;
    _ptr = (PFN_GLFOGCOORDFVEXT)_getPrivateProcAddress("glFogCoordfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glFogCoordfvEXT;
    }
    _glFogCoordfvEXT = _ptr;
    _glFogCoordfvEXT(coord);
}

PFN_GLFOGCOORDFVEXT _glFogCoordfvEXT = &_get_glFogCoordfvEXT;

static void APIENTRY _fail_glFogCoorddEXT(GLdouble coord) {
    const char *_name = "glFogCoorddEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogCoorddEXT(GLdouble coord) {
    PFN_GLFOGCOORDDEXT _ptr;
    _ptr = (PFN_GLFOGCOORDDEXT)_getPrivateProcAddress("glFogCoorddEXT");
    if (!_ptr) {
        _ptr = &_fail_glFogCoorddEXT;
    }
    _glFogCoorddEXT = _ptr;
    _glFogCoorddEXT(coord);
}

PFN_GLFOGCOORDDEXT _glFogCoorddEXT = &_get_glFogCoorddEXT;

static void APIENTRY _fail_glFogCoorddvEXT(const GLdouble * coord) {
    const char *_name = "glFogCoorddvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogCoorddvEXT(const GLdouble * coord) {
    PFN_GLFOGCOORDDVEXT _ptr;
    _ptr = (PFN_GLFOGCOORDDVEXT)_getPrivateProcAddress("glFogCoorddvEXT");
    if (!_ptr) {
        _ptr = &_fail_glFogCoorddvEXT;
    }
    _glFogCoorddvEXT = _ptr;
    _glFogCoorddvEXT(coord);
}

PFN_GLFOGCOORDDVEXT _glFogCoorddvEXT = &_get_glFogCoorddvEXT;

static void APIENTRY _fail_glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glFogCoordPointerEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLFOGCOORDPOINTEREXT _ptr;
    _ptr = (PFN_GLFOGCOORDPOINTEREXT)_getPrivateProcAddress("glFogCoordPointerEXT");
    if (!_ptr) {
        _ptr = &_fail_glFogCoordPointerEXT;
    }
    _glFogCoordPointerEXT = _ptr;
    _glFogCoordPointerEXT(type, stride, pointer);
}

PFN_GLFOGCOORDPOINTEREXT _glFogCoordPointerEXT = &_get_glFogCoordPointerEXT;

static void APIENTRY _fail_glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
    const char *_name = "glBlitFramebufferEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
    PFN_GLBLITFRAMEBUFFEREXT _ptr;
    _ptr = (PFN_GLBLITFRAMEBUFFEREXT)_getPrivateProcAddress("glBlitFramebufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glBlitFramebufferEXT;
    }
    _glBlitFramebufferEXT = _ptr;
    _glBlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

PFN_GLBLITFRAMEBUFFEREXT _glBlitFramebufferEXT = &_get_glBlitFramebufferEXT;

static void APIENTRY _fail_glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glRenderbufferStorageMultisampleEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEEXT _ptr;
    _ptr = (PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEEXT)_getPrivateProcAddress("glRenderbufferStorageMultisampleEXT");
    if (!_ptr) {
        _ptr = &_fail_glRenderbufferStorageMultisampleEXT;
    }
    _glRenderbufferStorageMultisampleEXT = _ptr;
    _glRenderbufferStorageMultisampleEXT(target, samples, internalformat, width, height);
}

PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEEXT _glRenderbufferStorageMultisampleEXT = &_get_glRenderbufferStorageMultisampleEXT;

static GLboolean APIENTRY _fail_glIsRenderbufferEXT(GLuint renderbuffer) {
    const char *_name = "glIsRenderbufferEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsRenderbufferEXT(GLuint renderbuffer) {
    PFN_GLISRENDERBUFFEREXT _ptr;
    _ptr = (PFN_GLISRENDERBUFFEREXT)_getPrivateProcAddress("glIsRenderbufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glIsRenderbufferEXT;
    }
    _glIsRenderbufferEXT = _ptr;
    return _glIsRenderbufferEXT(renderbuffer);
}

PFN_GLISRENDERBUFFEREXT _glIsRenderbufferEXT = &_get_glIsRenderbufferEXT;

static void APIENTRY _fail_glBindRenderbufferEXT(GLenum target, GLuint renderbuffer) {
    const char *_name = "glBindRenderbufferEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindRenderbufferEXT(GLenum target, GLuint renderbuffer) {
    PFN_GLBINDRENDERBUFFEREXT _ptr;
    _ptr = (PFN_GLBINDRENDERBUFFEREXT)_getPrivateProcAddress("glBindRenderbufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glBindRenderbufferEXT;
    }
    _glBindRenderbufferEXT = _ptr;
    _glBindRenderbufferEXT(target, renderbuffer);
}

PFN_GLBINDRENDERBUFFEREXT _glBindRenderbufferEXT = &_get_glBindRenderbufferEXT;

static void APIENTRY _fail_glDeleteRenderbuffersEXT(GLsizei n, const GLuint * renderbuffers) {
    const char *_name = "glDeleteRenderbuffersEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteRenderbuffersEXT(GLsizei n, const GLuint * renderbuffers) {
    PFN_GLDELETERENDERBUFFERSEXT _ptr;
    _ptr = (PFN_GLDELETERENDERBUFFERSEXT)_getPrivateProcAddress("glDeleteRenderbuffersEXT");
    if (!_ptr) {
        _ptr = &_fail_glDeleteRenderbuffersEXT;
    }
    _glDeleteRenderbuffersEXT = _ptr;
    _glDeleteRenderbuffersEXT(n, renderbuffers);
}

PFN_GLDELETERENDERBUFFERSEXT _glDeleteRenderbuffersEXT = &_get_glDeleteRenderbuffersEXT;

static void APIENTRY _fail_glGenRenderbuffersEXT(GLsizei n, GLuint * renderbuffers) {
    const char *_name = "glGenRenderbuffersEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenRenderbuffersEXT(GLsizei n, GLuint * renderbuffers) {
    PFN_GLGENRENDERBUFFERSEXT _ptr;
    _ptr = (PFN_GLGENRENDERBUFFERSEXT)_getPrivateProcAddress("glGenRenderbuffersEXT");
    if (!_ptr) {
        _ptr = &_fail_glGenRenderbuffersEXT;
    }
    _glGenRenderbuffersEXT = _ptr;
    _glGenRenderbuffersEXT(n, renderbuffers);
}

PFN_GLGENRENDERBUFFERSEXT _glGenRenderbuffersEXT = &_get_glGenRenderbuffersEXT;

static void APIENTRY _fail_glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glRenderbufferStorageEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) {
    PFN_GLRENDERBUFFERSTORAGEEXT _ptr;
    _ptr = (PFN_GLRENDERBUFFERSTORAGEEXT)_getPrivateProcAddress("glRenderbufferStorageEXT");
    if (!_ptr) {
        _ptr = &_fail_glRenderbufferStorageEXT;
    }
    _glRenderbufferStorageEXT = _ptr;
    _glRenderbufferStorageEXT(target, internalformat, width, height);
}

PFN_GLRENDERBUFFERSTORAGEEXT _glRenderbufferStorageEXT = &_get_glRenderbufferStorageEXT;

static void APIENTRY _fail_glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetRenderbufferParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETRENDERBUFFERPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLGETRENDERBUFFERPARAMETERIVEXT)_getPrivateProcAddress("glGetRenderbufferParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetRenderbufferParameterivEXT;
    }
    _glGetRenderbufferParameterivEXT = _ptr;
    _glGetRenderbufferParameterivEXT(target, pname, params);
}

PFN_GLGETRENDERBUFFERPARAMETERIVEXT _glGetRenderbufferParameterivEXT = &_get_glGetRenderbufferParameterivEXT;

static GLboolean APIENTRY _fail_glIsFramebufferEXT(GLuint framebuffer) {
    const char *_name = "glIsFramebufferEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsFramebufferEXT(GLuint framebuffer) {
    PFN_GLISFRAMEBUFFEREXT _ptr;
    _ptr = (PFN_GLISFRAMEBUFFEREXT)_getPrivateProcAddress("glIsFramebufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glIsFramebufferEXT;
    }
    _glIsFramebufferEXT = _ptr;
    return _glIsFramebufferEXT(framebuffer);
}

PFN_GLISFRAMEBUFFEREXT _glIsFramebufferEXT = &_get_glIsFramebufferEXT;

static void APIENTRY _fail_glBindFramebufferEXT(GLenum target, GLuint framebuffer) {
    const char *_name = "glBindFramebufferEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindFramebufferEXT(GLenum target, GLuint framebuffer) {
    PFN_GLBINDFRAMEBUFFEREXT _ptr;
    _ptr = (PFN_GLBINDFRAMEBUFFEREXT)_getPrivateProcAddress("glBindFramebufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glBindFramebufferEXT;
    }
    _glBindFramebufferEXT = _ptr;
    _glBindFramebufferEXT(target, framebuffer);
}

PFN_GLBINDFRAMEBUFFEREXT _glBindFramebufferEXT = &_get_glBindFramebufferEXT;

static void APIENTRY _fail_glDeleteFramebuffersEXT(GLsizei n, const GLuint * framebuffers) {
    const char *_name = "glDeleteFramebuffersEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteFramebuffersEXT(GLsizei n, const GLuint * framebuffers) {
    PFN_GLDELETEFRAMEBUFFERSEXT _ptr;
    _ptr = (PFN_GLDELETEFRAMEBUFFERSEXT)_getPrivateProcAddress("glDeleteFramebuffersEXT");
    if (!_ptr) {
        _ptr = &_fail_glDeleteFramebuffersEXT;
    }
    _glDeleteFramebuffersEXT = _ptr;
    _glDeleteFramebuffersEXT(n, framebuffers);
}

PFN_GLDELETEFRAMEBUFFERSEXT _glDeleteFramebuffersEXT = &_get_glDeleteFramebuffersEXT;

static void APIENTRY _fail_glGenFramebuffersEXT(GLsizei n, GLuint * framebuffers) {
    const char *_name = "glGenFramebuffersEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenFramebuffersEXT(GLsizei n, GLuint * framebuffers) {
    PFN_GLGENFRAMEBUFFERSEXT _ptr;
    _ptr = (PFN_GLGENFRAMEBUFFERSEXT)_getPrivateProcAddress("glGenFramebuffersEXT");
    if (!_ptr) {
        _ptr = &_fail_glGenFramebuffersEXT;
    }
    _glGenFramebuffersEXT = _ptr;
    _glGenFramebuffersEXT(n, framebuffers);
}

PFN_GLGENFRAMEBUFFERSEXT _glGenFramebuffersEXT = &_get_glGenFramebuffersEXT;

static GLenum APIENTRY _fail_glCheckFramebufferStatusEXT(GLenum target) {
    const char *_name = "glCheckFramebufferStatusEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLenum APIENTRY _get_glCheckFramebufferStatusEXT(GLenum target) {
    PFN_GLCHECKFRAMEBUFFERSTATUSEXT _ptr;
    _ptr = (PFN_GLCHECKFRAMEBUFFERSTATUSEXT)_getPrivateProcAddress("glCheckFramebufferStatusEXT");
    if (!_ptr) {
        _ptr = &_fail_glCheckFramebufferStatusEXT;
    }
    _glCheckFramebufferStatusEXT = _ptr;
    return _glCheckFramebufferStatusEXT(target);
}

PFN_GLCHECKFRAMEBUFFERSTATUSEXT _glCheckFramebufferStatusEXT = &_get_glCheckFramebufferStatusEXT;

static void APIENTRY _fail_glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    const char *_name = "glFramebufferTexture1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    PFN_GLFRAMEBUFFERTEXTURE1DEXT _ptr;
    _ptr = (PFN_GLFRAMEBUFFERTEXTURE1DEXT)_getPrivateProcAddress("glFramebufferTexture1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferTexture1DEXT;
    }
    _glFramebufferTexture1DEXT = _ptr;
    _glFramebufferTexture1DEXT(target, attachment, textarget, texture, level);
}

PFN_GLFRAMEBUFFERTEXTURE1DEXT _glFramebufferTexture1DEXT = &_get_glFramebufferTexture1DEXT;

static void APIENTRY _fail_glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    const char *_name = "glFramebufferTexture2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    PFN_GLFRAMEBUFFERTEXTURE2DEXT _ptr;
    _ptr = (PFN_GLFRAMEBUFFERTEXTURE2DEXT)_getPrivateProcAddress("glFramebufferTexture2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferTexture2DEXT;
    }
    _glFramebufferTexture2DEXT = _ptr;
    _glFramebufferTexture2DEXT(target, attachment, textarget, texture, level);
}

PFN_GLFRAMEBUFFERTEXTURE2DEXT _glFramebufferTexture2DEXT = &_get_glFramebufferTexture2DEXT;

static void APIENTRY _fail_glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) {
    const char *_name = "glFramebufferTexture3DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) {
    PFN_GLFRAMEBUFFERTEXTURE3DEXT _ptr;
    _ptr = (PFN_GLFRAMEBUFFERTEXTURE3DEXT)_getPrivateProcAddress("glFramebufferTexture3DEXT");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferTexture3DEXT;
    }
    _glFramebufferTexture3DEXT = _ptr;
    _glFramebufferTexture3DEXT(target, attachment, textarget, texture, level, zoffset);
}

PFN_GLFRAMEBUFFERTEXTURE3DEXT _glFramebufferTexture3DEXT = &_get_glFramebufferTexture3DEXT;

static void APIENTRY _fail_glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) {
    const char *_name = "glFramebufferRenderbufferEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) {
    PFN_GLFRAMEBUFFERRENDERBUFFEREXT _ptr;
    _ptr = (PFN_GLFRAMEBUFFERRENDERBUFFEREXT)_getPrivateProcAddress("glFramebufferRenderbufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferRenderbufferEXT;
    }
    _glFramebufferRenderbufferEXT = _ptr;
    _glFramebufferRenderbufferEXT(target, attachment, renderbuffertarget, renderbuffer);
}

PFN_GLFRAMEBUFFERRENDERBUFFEREXT _glFramebufferRenderbufferEXT = &_get_glFramebufferRenderbufferEXT;

static void APIENTRY _fail_glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint * params) {
    const char *_name = "glGetFramebufferAttachmentParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint * params) {
    PFN_GLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXT)_getPrivateProcAddress("glGetFramebufferAttachmentParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetFramebufferAttachmentParameterivEXT;
    }
    _glGetFramebufferAttachmentParameterivEXT = _ptr;
    _glGetFramebufferAttachmentParameterivEXT(target, attachment, pname, params);
}

PFN_GLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXT _glGetFramebufferAttachmentParameterivEXT = &_get_glGetFramebufferAttachmentParameterivEXT;

static void APIENTRY _fail_glGenerateMipmapEXT(GLenum target) {
    const char *_name = "glGenerateMipmapEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenerateMipmapEXT(GLenum target) {
    PFN_GLGENERATEMIPMAPEXT _ptr;
    _ptr = (PFN_GLGENERATEMIPMAPEXT)_getPrivateProcAddress("glGenerateMipmapEXT");
    if (!_ptr) {
        _ptr = &_fail_glGenerateMipmapEXT;
    }
    _glGenerateMipmapEXT = _ptr;
    _glGenerateMipmapEXT(target);
}

PFN_GLGENERATEMIPMAPEXT _glGenerateMipmapEXT = &_get_glGenerateMipmapEXT;

static void APIENTRY _fail_glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level) {
    const char *_name = "glFramebufferTextureEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level) {
    PFN_GLFRAMEBUFFERTEXTUREEXT _ptr;
    _ptr = (PFN_GLFRAMEBUFFERTEXTUREEXT)_getPrivateProcAddress("glFramebufferTextureEXT");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferTextureEXT;
    }
    _glFramebufferTextureEXT = _ptr;
    _glFramebufferTextureEXT(target, attachment, texture, level);
}

PFN_GLFRAMEBUFFERTEXTUREEXT _glFramebufferTextureEXT = &_get_glFramebufferTextureEXT;

static void APIENTRY _fail_glProgramParameteriEXT(GLuint program, GLenum pname, GLint value) {
    const char *_name = "glProgramParameteriEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramParameteriEXT(GLuint program, GLenum pname, GLint value) {
    PFN_GLPROGRAMPARAMETERIEXT _ptr;
    _ptr = (PFN_GLPROGRAMPARAMETERIEXT)_getPrivateProcAddress("glProgramParameteriEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramParameteriEXT;
    }
    _glProgramParameteriEXT = _ptr;
    _glProgramParameteriEXT(program, pname, value);
}

PFN_GLPROGRAMPARAMETERIEXT _glProgramParameteriEXT = &_get_glProgramParameteriEXT;

static void APIENTRY _fail_glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat * params) {
    const char *_name = "glProgramEnvParameters4fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat * params) {
    PFN_GLPROGRAMENVPARAMETERS4FVEXT _ptr;
    _ptr = (PFN_GLPROGRAMENVPARAMETERS4FVEXT)_getPrivateProcAddress("glProgramEnvParameters4fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramEnvParameters4fvEXT;
    }
    _glProgramEnvParameters4fvEXT = _ptr;
    _glProgramEnvParameters4fvEXT(target, index, count, params);
}

PFN_GLPROGRAMENVPARAMETERS4FVEXT _glProgramEnvParameters4fvEXT = &_get_glProgramEnvParameters4fvEXT;

static void APIENTRY _fail_glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat * params) {
    const char *_name = "glProgramLocalParameters4fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat * params) {
    PFN_GLPROGRAMLOCALPARAMETERS4FVEXT _ptr;
    _ptr = (PFN_GLPROGRAMLOCALPARAMETERS4FVEXT)_getPrivateProcAddress("glProgramLocalParameters4fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glProgramLocalParameters4fvEXT;
    }
    _glProgramLocalParameters4fvEXT = _ptr;
    _glProgramLocalParameters4fvEXT(target, index, count, params);
}

PFN_GLPROGRAMLOCALPARAMETERS4FVEXT _glProgramLocalParameters4fvEXT = &_get_glProgramLocalParameters4fvEXT;

static void APIENTRY _fail_glGetUniformuivEXT(GLuint program, GLint location, GLuint * params) {
    const char *_name = "glGetUniformuivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetUniformuivEXT(GLuint program, GLint location, GLuint * params) {
    PFN_GLGETUNIFORMUIVEXT _ptr;
    _ptr = (PFN_GLGETUNIFORMUIVEXT)_getPrivateProcAddress("glGetUniformuivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetUniformuivEXT;
    }
    _glGetUniformuivEXT = _ptr;
    _glGetUniformuivEXT(program, location, params);
}

PFN_GLGETUNIFORMUIVEXT _glGetUniformuivEXT = &_get_glGetUniformuivEXT;

static void APIENTRY _fail_glBindFragDataLocationEXT(GLuint program, GLuint color, const GLchar * name) {
    const char *_name = "glBindFragDataLocationEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindFragDataLocationEXT(GLuint program, GLuint color, const GLchar * name) {
    PFN_GLBINDFRAGDATALOCATIONEXT _ptr;
    _ptr = (PFN_GLBINDFRAGDATALOCATIONEXT)_getPrivateProcAddress("glBindFragDataLocationEXT");
    if (!_ptr) {
        _ptr = &_fail_glBindFragDataLocationEXT;
    }
    _glBindFragDataLocationEXT = _ptr;
    _glBindFragDataLocationEXT(program, color, name);
}

PFN_GLBINDFRAGDATALOCATIONEXT _glBindFragDataLocationEXT = &_get_glBindFragDataLocationEXT;

static GLint APIENTRY _fail_glGetFragDataLocationEXT(GLuint program, const GLchar * name) {
    const char *_name = "glGetFragDataLocationEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLint APIENTRY _get_glGetFragDataLocationEXT(GLuint program, const GLchar * name) {
    PFN_GLGETFRAGDATALOCATIONEXT _ptr;
    _ptr = (PFN_GLGETFRAGDATALOCATIONEXT)_getPrivateProcAddress("glGetFragDataLocationEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetFragDataLocationEXT;
    }
    _glGetFragDataLocationEXT = _ptr;
    return _glGetFragDataLocationEXT(program, name);
}

PFN_GLGETFRAGDATALOCATIONEXT _glGetFragDataLocationEXT = &_get_glGetFragDataLocationEXT;

static void APIENTRY _fail_glUniform1uiEXT(GLint location, GLuint v0) {
    const char *_name = "glUniform1uiEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1uiEXT(GLint location, GLuint v0) {
    PFN_GLUNIFORM1UIEXT _ptr;
    _ptr = (PFN_GLUNIFORM1UIEXT)_getPrivateProcAddress("glUniform1uiEXT");
    if (!_ptr) {
        _ptr = &_fail_glUniform1uiEXT;
    }
    _glUniform1uiEXT = _ptr;
    _glUniform1uiEXT(location, v0);
}

PFN_GLUNIFORM1UIEXT _glUniform1uiEXT = &_get_glUniform1uiEXT;

static void APIENTRY _fail_glUniform2uiEXT(GLint location, GLuint v0, GLuint v1) {
    const char *_name = "glUniform2uiEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2uiEXT(GLint location, GLuint v0, GLuint v1) {
    PFN_GLUNIFORM2UIEXT _ptr;
    _ptr = (PFN_GLUNIFORM2UIEXT)_getPrivateProcAddress("glUniform2uiEXT");
    if (!_ptr) {
        _ptr = &_fail_glUniform2uiEXT;
    }
    _glUniform2uiEXT = _ptr;
    _glUniform2uiEXT(location, v0, v1);
}

PFN_GLUNIFORM2UIEXT _glUniform2uiEXT = &_get_glUniform2uiEXT;

static void APIENTRY _fail_glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2) {
    const char *_name = "glUniform3uiEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2) {
    PFN_GLUNIFORM3UIEXT _ptr;
    _ptr = (PFN_GLUNIFORM3UIEXT)_getPrivateProcAddress("glUniform3uiEXT");
    if (!_ptr) {
        _ptr = &_fail_glUniform3uiEXT;
    }
    _glUniform3uiEXT = _ptr;
    _glUniform3uiEXT(location, v0, v1, v2);
}

PFN_GLUNIFORM3UIEXT _glUniform3uiEXT = &_get_glUniform3uiEXT;

static void APIENTRY _fail_glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
    const char *_name = "glUniform4uiEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
    PFN_GLUNIFORM4UIEXT _ptr;
    _ptr = (PFN_GLUNIFORM4UIEXT)_getPrivateProcAddress("glUniform4uiEXT");
    if (!_ptr) {
        _ptr = &_fail_glUniform4uiEXT;
    }
    _glUniform4uiEXT = _ptr;
    _glUniform4uiEXT(location, v0, v1, v2, v3);
}

PFN_GLUNIFORM4UIEXT _glUniform4uiEXT = &_get_glUniform4uiEXT;

static void APIENTRY _fail_glUniform1uivEXT(GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glUniform1uivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1uivEXT(GLint location, GLsizei count, const GLuint * value) {
    PFN_GLUNIFORM1UIVEXT _ptr;
    _ptr = (PFN_GLUNIFORM1UIVEXT)_getPrivateProcAddress("glUniform1uivEXT");
    if (!_ptr) {
        _ptr = &_fail_glUniform1uivEXT;
    }
    _glUniform1uivEXT = _ptr;
    _glUniform1uivEXT(location, count, value);
}

PFN_GLUNIFORM1UIVEXT _glUniform1uivEXT = &_get_glUniform1uivEXT;

static void APIENTRY _fail_glUniform2uivEXT(GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glUniform2uivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2uivEXT(GLint location, GLsizei count, const GLuint * value) {
    PFN_GLUNIFORM2UIVEXT _ptr;
    _ptr = (PFN_GLUNIFORM2UIVEXT)_getPrivateProcAddress("glUniform2uivEXT");
    if (!_ptr) {
        _ptr = &_fail_glUniform2uivEXT;
    }
    _glUniform2uivEXT = _ptr;
    _glUniform2uivEXT(location, count, value);
}

PFN_GLUNIFORM2UIVEXT _glUniform2uivEXT = &_get_glUniform2uivEXT;

static void APIENTRY _fail_glUniform3uivEXT(GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glUniform3uivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3uivEXT(GLint location, GLsizei count, const GLuint * value) {
    PFN_GLUNIFORM3UIVEXT _ptr;
    _ptr = (PFN_GLUNIFORM3UIVEXT)_getPrivateProcAddress("glUniform3uivEXT");
    if (!_ptr) {
        _ptr = &_fail_glUniform3uivEXT;
    }
    _glUniform3uivEXT = _ptr;
    _glUniform3uivEXT(location, count, value);
}

PFN_GLUNIFORM3UIVEXT _glUniform3uivEXT = &_get_glUniform3uivEXT;

static void APIENTRY _fail_glUniform4uivEXT(GLint location, GLsizei count, const GLuint * value) {
    const char *_name = "glUniform4uivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4uivEXT(GLint location, GLsizei count, const GLuint * value) {
    PFN_GLUNIFORM4UIVEXT _ptr;
    _ptr = (PFN_GLUNIFORM4UIVEXT)_getPrivateProcAddress("glUniform4uivEXT");
    if (!_ptr) {
        _ptr = &_fail_glUniform4uivEXT;
    }
    _glUniform4uivEXT = _ptr;
    _glUniform4uivEXT(location, count, value);
}

PFN_GLUNIFORM4UIVEXT _glUniform4uivEXT = &_get_glUniform4uivEXT;

static void APIENTRY _fail_glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values) {
    const char *_name = "glGetHistogramEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values) {
    PFN_GLGETHISTOGRAMEXT _ptr;
    _ptr = (PFN_GLGETHISTOGRAMEXT)_getPrivateProcAddress("glGetHistogramEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetHistogramEXT;
    }
    _glGetHistogramEXT = _ptr;
    _glGetHistogramEXT(target, reset, format, type, values);
}

PFN_GLGETHISTOGRAMEXT _glGetHistogramEXT = &_get_glGetHistogramEXT;

static void APIENTRY _fail_glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetHistogramParameterfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat * params) {
    PFN_GLGETHISTOGRAMPARAMETERFVEXT _ptr;
    _ptr = (PFN_GLGETHISTOGRAMPARAMETERFVEXT)_getPrivateProcAddress("glGetHistogramParameterfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetHistogramParameterfvEXT;
    }
    _glGetHistogramParameterfvEXT = _ptr;
    _glGetHistogramParameterfvEXT(target, pname, params);
}

PFN_GLGETHISTOGRAMPARAMETERFVEXT _glGetHistogramParameterfvEXT = &_get_glGetHistogramParameterfvEXT;

static void APIENTRY _fail_glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetHistogramParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETHISTOGRAMPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLGETHISTOGRAMPARAMETERIVEXT)_getPrivateProcAddress("glGetHistogramParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetHistogramParameterivEXT;
    }
    _glGetHistogramParameterivEXT = _ptr;
    _glGetHistogramParameterivEXT(target, pname, params);
}

PFN_GLGETHISTOGRAMPARAMETERIVEXT _glGetHistogramParameterivEXT = &_get_glGetHistogramParameterivEXT;

static void APIENTRY _fail_glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values) {
    const char *_name = "glGetMinmaxEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values) {
    PFN_GLGETMINMAXEXT _ptr;
    _ptr = (PFN_GLGETMINMAXEXT)_getPrivateProcAddress("glGetMinmaxEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetMinmaxEXT;
    }
    _glGetMinmaxEXT = _ptr;
    _glGetMinmaxEXT(target, reset, format, type, values);
}

PFN_GLGETMINMAXEXT _glGetMinmaxEXT = &_get_glGetMinmaxEXT;

static void APIENTRY _fail_glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetMinmaxParameterfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat * params) {
    PFN_GLGETMINMAXPARAMETERFVEXT _ptr;
    _ptr = (PFN_GLGETMINMAXPARAMETERFVEXT)_getPrivateProcAddress("glGetMinmaxParameterfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetMinmaxParameterfvEXT;
    }
    _glGetMinmaxParameterfvEXT = _ptr;
    _glGetMinmaxParameterfvEXT(target, pname, params);
}

PFN_GLGETMINMAXPARAMETERFVEXT _glGetMinmaxParameterfvEXT = &_get_glGetMinmaxParameterfvEXT;

static void APIENTRY _fail_glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetMinmaxParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETMINMAXPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLGETMINMAXPARAMETERIVEXT)_getPrivateProcAddress("glGetMinmaxParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetMinmaxParameterivEXT;
    }
    _glGetMinmaxParameterivEXT = _ptr;
    _glGetMinmaxParameterivEXT(target, pname, params);
}

PFN_GLGETMINMAXPARAMETERIVEXT _glGetMinmaxParameterivEXT = &_get_glGetMinmaxParameterivEXT;

static void APIENTRY _fail_glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) {
    const char *_name = "glHistogramEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) {
    PFN_GLHISTOGRAMEXT _ptr;
    _ptr = (PFN_GLHISTOGRAMEXT)_getPrivateProcAddress("glHistogramEXT");
    if (!_ptr) {
        _ptr = &_fail_glHistogramEXT;
    }
    _glHistogramEXT = _ptr;
    _glHistogramEXT(target, width, internalformat, sink);
}

PFN_GLHISTOGRAMEXT _glHistogramEXT = &_get_glHistogramEXT;

static void APIENTRY _fail_glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink) {
    const char *_name = "glMinmaxEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink) {
    PFN_GLMINMAXEXT _ptr;
    _ptr = (PFN_GLMINMAXEXT)_getPrivateProcAddress("glMinmaxEXT");
    if (!_ptr) {
        _ptr = &_fail_glMinmaxEXT;
    }
    _glMinmaxEXT = _ptr;
    _glMinmaxEXT(target, internalformat, sink);
}

PFN_GLMINMAXEXT _glMinmaxEXT = &_get_glMinmaxEXT;

static void APIENTRY _fail_glResetHistogramEXT(GLenum target) {
    const char *_name = "glResetHistogramEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glResetHistogramEXT(GLenum target) {
    PFN_GLRESETHISTOGRAMEXT _ptr;
    _ptr = (PFN_GLRESETHISTOGRAMEXT)_getPrivateProcAddress("glResetHistogramEXT");
    if (!_ptr) {
        _ptr = &_fail_glResetHistogramEXT;
    }
    _glResetHistogramEXT = _ptr;
    _glResetHistogramEXT(target);
}

PFN_GLRESETHISTOGRAMEXT _glResetHistogramEXT = &_get_glResetHistogramEXT;

static void APIENTRY _fail_glResetMinmaxEXT(GLenum target) {
    const char *_name = "glResetMinmaxEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glResetMinmaxEXT(GLenum target) {
    PFN_GLRESETMINMAXEXT _ptr;
    _ptr = (PFN_GLRESETMINMAXEXT)_getPrivateProcAddress("glResetMinmaxEXT");
    if (!_ptr) {
        _ptr = &_fail_glResetMinmaxEXT;
    }
    _glResetMinmaxEXT = _ptr;
    _glResetMinmaxEXT(target);
}

PFN_GLRESETMINMAXEXT _glResetMinmaxEXT = &_get_glResetMinmaxEXT;

static void APIENTRY _fail_glIndexFuncEXT(GLenum func, GLclampf ref) {
    const char *_name = "glIndexFuncEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glIndexFuncEXT(GLenum func, GLclampf ref) {
    PFN_GLINDEXFUNCEXT _ptr;
    _ptr = (PFN_GLINDEXFUNCEXT)_getPrivateProcAddress("glIndexFuncEXT");
    if (!_ptr) {
        _ptr = &_fail_glIndexFuncEXT;
    }
    _glIndexFuncEXT = _ptr;
    _glIndexFuncEXT(func, ref);
}

PFN_GLINDEXFUNCEXT _glIndexFuncEXT = &_get_glIndexFuncEXT;

static void APIENTRY _fail_glIndexMaterialEXT(GLenum face, GLenum mode) {
    const char *_name = "glIndexMaterialEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glIndexMaterialEXT(GLenum face, GLenum mode) {
    PFN_GLINDEXMATERIALEXT _ptr;
    _ptr = (PFN_GLINDEXMATERIALEXT)_getPrivateProcAddress("glIndexMaterialEXT");
    if (!_ptr) {
        _ptr = &_fail_glIndexMaterialEXT;
    }
    _glIndexMaterialEXT = _ptr;
    _glIndexMaterialEXT(face, mode);
}

PFN_GLINDEXMATERIALEXT _glIndexMaterialEXT = &_get_glIndexMaterialEXT;

static void APIENTRY _fail_glVertexAttribDivisorEXT(GLuint index, GLuint divisor) {
    const char *_name = "glVertexAttribDivisorEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribDivisorEXT(GLuint index, GLuint divisor) {
    PFN_GLVERTEXATTRIBDIVISOREXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBDIVISOREXT)_getPrivateProcAddress("glVertexAttribDivisorEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribDivisorEXT;
    }
    _glVertexAttribDivisorEXT = _ptr;
    _glVertexAttribDivisorEXT(index, divisor);
}

PFN_GLVERTEXATTRIBDIVISOREXT _glVertexAttribDivisorEXT = &_get_glVertexAttribDivisorEXT;

static void APIENTRY _fail_glApplyTextureEXT(GLenum mode) {
    const char *_name = "glApplyTextureEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glApplyTextureEXT(GLenum mode) {
    PFN_GLAPPLYTEXTUREEXT _ptr;
    _ptr = (PFN_GLAPPLYTEXTUREEXT)_getPrivateProcAddress("glApplyTextureEXT");
    if (!_ptr) {
        _ptr = &_fail_glApplyTextureEXT;
    }
    _glApplyTextureEXT = _ptr;
    _glApplyTextureEXT(mode);
}

PFN_GLAPPLYTEXTUREEXT _glApplyTextureEXT = &_get_glApplyTextureEXT;

static void APIENTRY _fail_glTextureLightEXT(GLenum pname) {
    const char *_name = "glTextureLightEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureLightEXT(GLenum pname) {
    PFN_GLTEXTURELIGHTEXT _ptr;
    _ptr = (PFN_GLTEXTURELIGHTEXT)_getPrivateProcAddress("glTextureLightEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureLightEXT;
    }
    _glTextureLightEXT = _ptr;
    _glTextureLightEXT(pname);
}

PFN_GLTEXTURELIGHTEXT _glTextureLightEXT = &_get_glTextureLightEXT;

static void APIENTRY _fail_glTextureMaterialEXT(GLenum face, GLenum mode) {
    const char *_name = "glTextureMaterialEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureMaterialEXT(GLenum face, GLenum mode) {
    PFN_GLTEXTUREMATERIALEXT _ptr;
    _ptr = (PFN_GLTEXTUREMATERIALEXT)_getPrivateProcAddress("glTextureMaterialEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureMaterialEXT;
    }
    _glTextureMaterialEXT = _ptr;
    _glTextureMaterialEXT(face, mode);
}

PFN_GLTEXTUREMATERIALEXT _glTextureMaterialEXT = &_get_glTextureMaterialEXT;

static GLvoid * APIENTRY _fail_glMapBufferRangeEXT(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) {
    const char *_name = "glMapBufferRangeEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLvoid * APIENTRY _get_glMapBufferRangeEXT(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) {
    PFN_GLMAPBUFFERRANGEEXT _ptr;
    _ptr = (PFN_GLMAPBUFFERRANGEEXT)_getPrivateProcAddress("glMapBufferRangeEXT");
    if (!_ptr) {
        _ptr = &_fail_glMapBufferRangeEXT;
    }
    _glMapBufferRangeEXT = _ptr;
    return _glMapBufferRangeEXT(target, offset, length, access);
}

PFN_GLMAPBUFFERRANGEEXT _glMapBufferRangeEXT = &_get_glMapBufferRangeEXT;

static void APIENTRY _fail_glFlushMappedBufferRangeEXT(GLenum target, GLintptr offset, GLsizeiptr length) {
    const char *_name = "glFlushMappedBufferRangeEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFlushMappedBufferRangeEXT(GLenum target, GLintptr offset, GLsizeiptr length) {
    PFN_GLFLUSHMAPPEDBUFFERRANGEEXT _ptr;
    _ptr = (PFN_GLFLUSHMAPPEDBUFFERRANGEEXT)_getPrivateProcAddress("glFlushMappedBufferRangeEXT");
    if (!_ptr) {
        _ptr = &_fail_glFlushMappedBufferRangeEXT;
    }
    _glFlushMappedBufferRangeEXT = _ptr;
    _glFlushMappedBufferRangeEXT(target, offset, length);
}

PFN_GLFLUSHMAPPEDBUFFERRANGEEXT _glFlushMappedBufferRangeEXT = &_get_glFlushMappedBufferRangeEXT;

static void APIENTRY _fail_glMultiDrawArraysEXT(GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount) {
    const char *_name = "glMultiDrawArraysEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiDrawArraysEXT(GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount) {
    PFN_GLMULTIDRAWARRAYSEXT _ptr;
    _ptr = (PFN_GLMULTIDRAWARRAYSEXT)_getPrivateProcAddress("glMultiDrawArraysEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiDrawArraysEXT;
    }
    _glMultiDrawArraysEXT = _ptr;
    _glMultiDrawArraysEXT(mode, first, count, primcount);
}

PFN_GLMULTIDRAWARRAYSEXT _glMultiDrawArraysEXT = &_get_glMultiDrawArraysEXT;

static void APIENTRY _fail_glMultiDrawElementsEXT(GLenum mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei primcount) {
    const char *_name = "glMultiDrawElementsEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiDrawElementsEXT(GLenum mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei primcount) {
    PFN_GLMULTIDRAWELEMENTSEXT _ptr;
    _ptr = (PFN_GLMULTIDRAWELEMENTSEXT)_getPrivateProcAddress("glMultiDrawElementsEXT");
    if (!_ptr) {
        _ptr = &_fail_glMultiDrawElementsEXT;
    }
    _glMultiDrawElementsEXT = _ptr;
    _glMultiDrawElementsEXT(mode, count, type, indices, primcount);
}

PFN_GLMULTIDRAWELEMENTSEXT _glMultiDrawElementsEXT = &_get_glMultiDrawElementsEXT;

static void APIENTRY _fail_glSampleMaskEXT(GLclampf value, GLboolean invert) {
    const char *_name = "glSampleMaskEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSampleMaskEXT(GLclampf value, GLboolean invert) {
    PFN_GLSAMPLEMASKEXT _ptr;
    _ptr = (PFN_GLSAMPLEMASKEXT)_getPrivateProcAddress("glSampleMaskEXT");
    if (!_ptr) {
        _ptr = &_fail_glSampleMaskEXT;
    }
    _glSampleMaskEXT = _ptr;
    _glSampleMaskEXT(value, invert);
}

PFN_GLSAMPLEMASKEXT _glSampleMaskEXT = &_get_glSampleMaskEXT;

static void APIENTRY _fail_glSamplePatternEXT(GLenum pattern) {
    const char *_name = "glSamplePatternEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSamplePatternEXT(GLenum pattern) {
    PFN_GLSAMPLEPATTERNEXT _ptr;
    _ptr = (PFN_GLSAMPLEPATTERNEXT)_getPrivateProcAddress("glSamplePatternEXT");
    if (!_ptr) {
        _ptr = &_fail_glSamplePatternEXT;
    }
    _glSamplePatternEXT = _ptr;
    _glSamplePatternEXT(pattern);
}

PFN_GLSAMPLEPATTERNEXT _glSamplePatternEXT = &_get_glSamplePatternEXT;

static void APIENTRY _fail_glFramebufferTexture2DMultisampleEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples) {
    const char *_name = "glFramebufferTexture2DMultisampleEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferTexture2DMultisampleEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples) {
    PFN_GLFRAMEBUFFERTEXTURE2DMULTISAMPLEEXT _ptr;
    _ptr = (PFN_GLFRAMEBUFFERTEXTURE2DMULTISAMPLEEXT)_getPrivateProcAddress("glFramebufferTexture2DMultisampleEXT");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferTexture2DMultisampleEXT;
    }
    _glFramebufferTexture2DMultisampleEXT = _ptr;
    _glFramebufferTexture2DMultisampleEXT(target, attachment, textarget, texture, level, samples);
}

PFN_GLFRAMEBUFFERTEXTURE2DMULTISAMPLEEXT _glFramebufferTexture2DMultisampleEXT = &_get_glFramebufferTexture2DMultisampleEXT;

static void APIENTRY _fail_glGenQueriesEXT(GLsizei n, GLuint * ids) {
    const char *_name = "glGenQueriesEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenQueriesEXT(GLsizei n, GLuint * ids) {
    PFN_GLGENQUERIESEXT _ptr;
    _ptr = (PFN_GLGENQUERIESEXT)_getPrivateProcAddress("glGenQueriesEXT");
    if (!_ptr) {
        _ptr = &_fail_glGenQueriesEXT;
    }
    _glGenQueriesEXT = _ptr;
    _glGenQueriesEXT(n, ids);
}

PFN_GLGENQUERIESEXT _glGenQueriesEXT = &_get_glGenQueriesEXT;

static void APIENTRY _fail_glDeleteQueriesEXT(GLsizei n, const GLuint * ids) {
    const char *_name = "glDeleteQueriesEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteQueriesEXT(GLsizei n, const GLuint * ids) {
    PFN_GLDELETEQUERIESEXT _ptr;
    _ptr = (PFN_GLDELETEQUERIESEXT)_getPrivateProcAddress("glDeleteQueriesEXT");
    if (!_ptr) {
        _ptr = &_fail_glDeleteQueriesEXT;
    }
    _glDeleteQueriesEXT = _ptr;
    _glDeleteQueriesEXT(n, ids);
}

PFN_GLDELETEQUERIESEXT _glDeleteQueriesEXT = &_get_glDeleteQueriesEXT;

static GLboolean APIENTRY _fail_glIsQueryEXT(GLuint id) {
    const char *_name = "glIsQueryEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsQueryEXT(GLuint id) {
    PFN_GLISQUERYEXT _ptr;
    _ptr = (PFN_GLISQUERYEXT)_getPrivateProcAddress("glIsQueryEXT");
    if (!_ptr) {
        _ptr = &_fail_glIsQueryEXT;
    }
    _glIsQueryEXT = _ptr;
    return _glIsQueryEXT(id);
}

PFN_GLISQUERYEXT _glIsQueryEXT = &_get_glIsQueryEXT;

static void APIENTRY _fail_glBeginQueryEXT(GLenum target, GLuint id) {
    const char *_name = "glBeginQueryEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBeginQueryEXT(GLenum target, GLuint id) {
    PFN_GLBEGINQUERYEXT _ptr;
    _ptr = (PFN_GLBEGINQUERYEXT)_getPrivateProcAddress("glBeginQueryEXT");
    if (!_ptr) {
        _ptr = &_fail_glBeginQueryEXT;
    }
    _glBeginQueryEXT = _ptr;
    _glBeginQueryEXT(target, id);
}

PFN_GLBEGINQUERYEXT _glBeginQueryEXT = &_get_glBeginQueryEXT;

static void APIENTRY _fail_glEndQueryEXT(GLenum target) {
    const char *_name = "glEndQueryEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEndQueryEXT(GLenum target) {
    PFN_GLENDQUERYEXT _ptr;
    _ptr = (PFN_GLENDQUERYEXT)_getPrivateProcAddress("glEndQueryEXT");
    if (!_ptr) {
        _ptr = &_fail_glEndQueryEXT;
    }
    _glEndQueryEXT = _ptr;
    _glEndQueryEXT(target);
}

PFN_GLENDQUERYEXT _glEndQueryEXT = &_get_glEndQueryEXT;

static void APIENTRY _fail_glGetQueryivEXT(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetQueryivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryivEXT(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETQUERYIVEXT _ptr;
    _ptr = (PFN_GLGETQUERYIVEXT)_getPrivateProcAddress("glGetQueryivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryivEXT;
    }
    _glGetQueryivEXT = _ptr;
    _glGetQueryivEXT(target, pname, params);
}

PFN_GLGETQUERYIVEXT _glGetQueryivEXT = &_get_glGetQueryivEXT;

static void APIENTRY _fail_glGetQueryObjectuivEXT(GLuint id, GLenum pname, GLuint * params) {
    const char *_name = "glGetQueryObjectuivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryObjectuivEXT(GLuint id, GLenum pname, GLuint * params) {
    PFN_GLGETQUERYOBJECTUIVEXT _ptr;
    _ptr = (PFN_GLGETQUERYOBJECTUIVEXT)_getPrivateProcAddress("glGetQueryObjectuivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryObjectuivEXT;
    }
    _glGetQueryObjectuivEXT = _ptr;
    _glGetQueryObjectuivEXT(id, pname, params);
}

PFN_GLGETQUERYOBJECTUIVEXT _glGetQueryObjectuivEXT = &_get_glGetQueryObjectuivEXT;

static void APIENTRY _fail_glColorTableEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table) {
    const char *_name = "glColorTableEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorTableEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table) {
    PFN_GLCOLORTABLEEXT _ptr;
    _ptr = (PFN_GLCOLORTABLEEXT)_getPrivateProcAddress("glColorTableEXT");
    if (!_ptr) {
        _ptr = &_fail_glColorTableEXT;
    }
    _glColorTableEXT = _ptr;
    _glColorTableEXT(target, internalformat, width, format, type, table);
}

PFN_GLCOLORTABLEEXT _glColorTableEXT = &_get_glColorTableEXT;

static void APIENTRY _fail_glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid * data) {
    const char *_name = "glGetColorTableEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid * data) {
    PFN_GLGETCOLORTABLEEXT _ptr;
    _ptr = (PFN_GLGETCOLORTABLEEXT)_getPrivateProcAddress("glGetColorTableEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetColorTableEXT;
    }
    _glGetColorTableEXT = _ptr;
    _glGetColorTableEXT(target, format, type, data);
}

PFN_GLGETCOLORTABLEEXT _glGetColorTableEXT = &_get_glGetColorTableEXT;

static void APIENTRY _fail_glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetColorTableParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETCOLORTABLEPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLGETCOLORTABLEPARAMETERIVEXT)_getPrivateProcAddress("glGetColorTableParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetColorTableParameterivEXT;
    }
    _glGetColorTableParameterivEXT = _ptr;
    _glGetColorTableParameterivEXT(target, pname, params);
}

PFN_GLGETCOLORTABLEPARAMETERIVEXT _glGetColorTableParameterivEXT = &_get_glGetColorTableParameterivEXT;

static void APIENTRY _fail_glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetColorTableParameterfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat * params) {
    PFN_GLGETCOLORTABLEPARAMETERFVEXT _ptr;
    _ptr = (PFN_GLGETCOLORTABLEPARAMETERFVEXT)_getPrivateProcAddress("glGetColorTableParameterfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetColorTableParameterfvEXT;
    }
    _glGetColorTableParameterfvEXT = _ptr;
    _glGetColorTableParameterfvEXT(target, pname, params);
}

PFN_GLGETCOLORTABLEPARAMETERFVEXT _glGetColorTableParameterfvEXT = &_get_glGetColorTableParameterfvEXT;

static void APIENTRY _fail_glPixelTransformParameteriEXT(GLenum target, GLenum pname, GLint param) {
    const char *_name = "glPixelTransformParameteriEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPixelTransformParameteriEXT(GLenum target, GLenum pname, GLint param) {
    PFN_GLPIXELTRANSFORMPARAMETERIEXT _ptr;
    _ptr = (PFN_GLPIXELTRANSFORMPARAMETERIEXT)_getPrivateProcAddress("glPixelTransformParameteriEXT");
    if (!_ptr) {
        _ptr = &_fail_glPixelTransformParameteriEXT;
    }
    _glPixelTransformParameteriEXT = _ptr;
    _glPixelTransformParameteriEXT(target, pname, param);
}

PFN_GLPIXELTRANSFORMPARAMETERIEXT _glPixelTransformParameteriEXT = &_get_glPixelTransformParameteriEXT;

static void APIENTRY _fail_glPixelTransformParameterfEXT(GLenum target, GLenum pname, GLfloat param) {
    const char *_name = "glPixelTransformParameterfEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPixelTransformParameterfEXT(GLenum target, GLenum pname, GLfloat param) {
    PFN_GLPIXELTRANSFORMPARAMETERFEXT _ptr;
    _ptr = (PFN_GLPIXELTRANSFORMPARAMETERFEXT)_getPrivateProcAddress("glPixelTransformParameterfEXT");
    if (!_ptr) {
        _ptr = &_fail_glPixelTransformParameterfEXT;
    }
    _glPixelTransformParameterfEXT = _ptr;
    _glPixelTransformParameterfEXT(target, pname, param);
}

PFN_GLPIXELTRANSFORMPARAMETERFEXT _glPixelTransformParameterfEXT = &_get_glPixelTransformParameterfEXT;

static void APIENTRY _fail_glPixelTransformParameterivEXT(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glPixelTransformParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPixelTransformParameterivEXT(GLenum target, GLenum pname, const GLint * params) {
    PFN_GLPIXELTRANSFORMPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLPIXELTRANSFORMPARAMETERIVEXT)_getPrivateProcAddress("glPixelTransformParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glPixelTransformParameterivEXT;
    }
    _glPixelTransformParameterivEXT = _ptr;
    _glPixelTransformParameterivEXT(target, pname, params);
}

PFN_GLPIXELTRANSFORMPARAMETERIVEXT _glPixelTransformParameterivEXT = &_get_glPixelTransformParameterivEXT;

static void APIENTRY _fail_glPixelTransformParameterfvEXT(GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glPixelTransformParameterfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPixelTransformParameterfvEXT(GLenum target, GLenum pname, const GLfloat * params) {
    PFN_GLPIXELTRANSFORMPARAMETERFVEXT _ptr;
    _ptr = (PFN_GLPIXELTRANSFORMPARAMETERFVEXT)_getPrivateProcAddress("glPixelTransformParameterfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glPixelTransformParameterfvEXT;
    }
    _glPixelTransformParameterfvEXT = _ptr;
    _glPixelTransformParameterfvEXT(target, pname, params);
}

PFN_GLPIXELTRANSFORMPARAMETERFVEXT _glPixelTransformParameterfvEXT = &_get_glPixelTransformParameterfvEXT;

static void APIENTRY _fail_glGetPixelTransformParameterivEXT(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetPixelTransformParameterivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPixelTransformParameterivEXT(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETPIXELTRANSFORMPARAMETERIVEXT _ptr;
    _ptr = (PFN_GLGETPIXELTRANSFORMPARAMETERIVEXT)_getPrivateProcAddress("glGetPixelTransformParameterivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetPixelTransformParameterivEXT;
    }
    _glGetPixelTransformParameterivEXT = _ptr;
    _glGetPixelTransformParameterivEXT(target, pname, params);
}

PFN_GLGETPIXELTRANSFORMPARAMETERIVEXT _glGetPixelTransformParameterivEXT = &_get_glGetPixelTransformParameterivEXT;

static void APIENTRY _fail_glGetPixelTransformParameterfvEXT(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetPixelTransformParameterfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPixelTransformParameterfvEXT(GLenum target, GLenum pname, GLfloat * params) {
    PFN_GLGETPIXELTRANSFORMPARAMETERFVEXT _ptr;
    _ptr = (PFN_GLGETPIXELTRANSFORMPARAMETERFVEXT)_getPrivateProcAddress("glGetPixelTransformParameterfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetPixelTransformParameterfvEXT;
    }
    _glGetPixelTransformParameterfvEXT = _ptr;
    _glGetPixelTransformParameterfvEXT(target, pname, params);
}

PFN_GLGETPIXELTRANSFORMPARAMETERFVEXT _glGetPixelTransformParameterfvEXT = &_get_glGetPixelTransformParameterfvEXT;

static void APIENTRY _fail_glPointParameterfEXT(GLenum pname, GLfloat param) {
    const char *_name = "glPointParameterfEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPointParameterfEXT(GLenum pname, GLfloat param) {
    PFN_GLPOINTPARAMETERFEXT _ptr;
    _ptr = (PFN_GLPOINTPARAMETERFEXT)_getPrivateProcAddress("glPointParameterfEXT");
    if (!_ptr) {
        _ptr = &_fail_glPointParameterfEXT;
    }
    _glPointParameterfEXT = _ptr;
    _glPointParameterfEXT(pname, param);
}

PFN_GLPOINTPARAMETERFEXT _glPointParameterfEXT = &_get_glPointParameterfEXT;

static void APIENTRY _fail_glPointParameterfvEXT(GLenum pname, const GLfloat * params) {
    const char *_name = "glPointParameterfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPointParameterfvEXT(GLenum pname, const GLfloat * params) {
    PFN_GLPOINTPARAMETERFVEXT _ptr;
    _ptr = (PFN_GLPOINTPARAMETERFVEXT)_getPrivateProcAddress("glPointParameterfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glPointParameterfvEXT;
    }
    _glPointParameterfvEXT = _ptr;
    _glPointParameterfvEXT(pname, params);
}

PFN_GLPOINTPARAMETERFVEXT _glPointParameterfvEXT = &_get_glPointParameterfvEXT;

static void APIENTRY _fail_glPolygonOffsetEXT(GLfloat factor, GLfloat bias) {
    const char *_name = "glPolygonOffsetEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPolygonOffsetEXT(GLfloat factor, GLfloat bias) {
    PFN_GLPOLYGONOFFSETEXT _ptr;
    _ptr = (PFN_GLPOLYGONOFFSETEXT)_getPrivateProcAddress("glPolygonOffsetEXT");
    if (!_ptr) {
        _ptr = &_fail_glPolygonOffsetEXT;
    }
    _glPolygonOffsetEXT = _ptr;
    _glPolygonOffsetEXT(factor, bias);
}

PFN_GLPOLYGONOFFSETEXT _glPolygonOffsetEXT = &_get_glPolygonOffsetEXT;

static void APIENTRY _fail_glPolygonOffsetClampEXT(GLfloat factor, GLfloat units, GLfloat clamp) {
    const char *_name = "glPolygonOffsetClampEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPolygonOffsetClampEXT(GLfloat factor, GLfloat units, GLfloat clamp) {
    PFN_GLPOLYGONOFFSETCLAMPEXT _ptr;
    _ptr = (PFN_GLPOLYGONOFFSETCLAMPEXT)_getPrivateProcAddress("glPolygonOffsetClampEXT");
    if (!_ptr) {
        _ptr = &_fail_glPolygonOffsetClampEXT;
    }
    _glPolygonOffsetClampEXT = _ptr;
    _glPolygonOffsetClampEXT(factor, units, clamp);
}

PFN_GLPOLYGONOFFSETCLAMPEXT _glPolygonOffsetClampEXT = &_get_glPolygonOffsetClampEXT;

static void APIENTRY _fail_glPrimitiveBoundingBoxEXT(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) {
    const char *_name = "glPrimitiveBoundingBoxEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPrimitiveBoundingBoxEXT(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) {
    PFN_GLPRIMITIVEBOUNDINGBOXEXT _ptr;
    _ptr = (PFN_GLPRIMITIVEBOUNDINGBOXEXT)_getPrivateProcAddress("glPrimitiveBoundingBoxEXT");
    if (!_ptr) {
        _ptr = &_fail_glPrimitiveBoundingBoxEXT;
    }
    _glPrimitiveBoundingBoxEXT = _ptr;
    _glPrimitiveBoundingBoxEXT(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
}

PFN_GLPRIMITIVEBOUNDINGBOXEXT _glPrimitiveBoundingBoxEXT = &_get_glPrimitiveBoundingBoxEXT;

static void APIENTRY _fail_glProvokingVertexEXT(GLenum mode) {
    const char *_name = "glProvokingVertexEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProvokingVertexEXT(GLenum mode) {
    PFN_GLPROVOKINGVERTEXEXT _ptr;
    _ptr = (PFN_GLPROVOKINGVERTEXEXT)_getPrivateProcAddress("glProvokingVertexEXT");
    if (!_ptr) {
        _ptr = &_fail_glProvokingVertexEXT;
    }
    _glProvokingVertexEXT = _ptr;
    _glProvokingVertexEXT(mode);
}

PFN_GLPROVOKINGVERTEXEXT _glProvokingVertexEXT = &_get_glProvokingVertexEXT;

static void APIENTRY _fail_glRasterSamplesEXT(GLuint samples, GLboolean fixedsamplelocations) {
    const char *_name = "glRasterSamplesEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRasterSamplesEXT(GLuint samples, GLboolean fixedsamplelocations) {
    PFN_GLRASTERSAMPLESEXT _ptr;
    _ptr = (PFN_GLRASTERSAMPLESEXT)_getPrivateProcAddress("glRasterSamplesEXT");
    if (!_ptr) {
        _ptr = &_fail_glRasterSamplesEXT;
    }
    _glRasterSamplesEXT = _ptr;
    _glRasterSamplesEXT(samples, fixedsamplelocations);
}

PFN_GLRASTERSAMPLESEXT _glRasterSamplesEXT = &_get_glRasterSamplesEXT;

static void APIENTRY _fail_glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue) {
    const char *_name = "glSecondaryColor3bEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue) {
    PFN_GLSECONDARYCOLOR3BEXT _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3BEXT)_getPrivateProcAddress("glSecondaryColor3bEXT");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3bEXT;
    }
    _glSecondaryColor3bEXT = _ptr;
    _glSecondaryColor3bEXT(red, green, blue);
}

PFN_GLSECONDARYCOLOR3BEXT _glSecondaryColor3bEXT = &_get_glSecondaryColor3bEXT;

static void APIENTRY _fail_glSecondaryColor3bvEXT(const GLbyte * v) {
    const char *_name = "glSecondaryColor3bvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3bvEXT(const GLbyte * v) {
    PFN_GLSECONDARYCOLOR3BVEXT _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3BVEXT)_getPrivateProcAddress("glSecondaryColor3bvEXT");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3bvEXT;
    }
    _glSecondaryColor3bvEXT = _ptr;
    _glSecondaryColor3bvEXT(v);
}

PFN_GLSECONDARYCOLOR3BVEXT _glSecondaryColor3bvEXT = &_get_glSecondaryColor3bvEXT;

static void APIENTRY _fail_glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue) {
    const char *_name = "glSecondaryColor3dEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue) {
    PFN_GLSECONDARYCOLOR3DEXT _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3DEXT)_getPrivateProcAddress("glSecondaryColor3dEXT");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3dEXT;
    }
    _glSecondaryColor3dEXT = _ptr;
    _glSecondaryColor3dEXT(red, green, blue);
}

PFN_GLSECONDARYCOLOR3DEXT _glSecondaryColor3dEXT = &_get_glSecondaryColor3dEXT;

static void APIENTRY _fail_glSecondaryColor3dvEXT(const GLdouble * v) {
    const char *_name = "glSecondaryColor3dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3dvEXT(const GLdouble * v) {
    PFN_GLSECONDARYCOLOR3DVEXT _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3DVEXT)_getPrivateProcAddress("glSecondaryColor3dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3dvEXT;
    }
    _glSecondaryColor3dvEXT = _ptr;
    _glSecondaryColor3dvEXT(v);
}

PFN_GLSECONDARYCOLOR3DVEXT _glSecondaryColor3dvEXT = &_get_glSecondaryColor3dvEXT;

static void APIENTRY _fail_glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue) {
    const char *_name = "glSecondaryColor3fEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue) {
    PFN_GLSECONDARYCOLOR3FEXT _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3FEXT)_getPrivateProcAddress("glSecondaryColor3fEXT");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3fEXT;
    }
    _glSecondaryColor3fEXT = _ptr;
    _glSecondaryColor3fEXT(red, green, blue);
}

PFN_GLSECONDARYCOLOR3FEXT _glSecondaryColor3fEXT = &_get_glSecondaryColor3fEXT;

static void APIENTRY _fail_glSecondaryColor3fvEXT(const GLfloat * v) {
    const char *_name = "glSecondaryColor3fvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3fvEXT(const GLfloat * v) {
    PFN_GLSECONDARYCOLOR3FVEXT _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3FVEXT)_getPrivateProcAddress("glSecondaryColor3fvEXT");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3fvEXT;
    }
    _glSecondaryColor3fvEXT = _ptr;
    _glSecondaryColor3fvEXT(v);
}

PFN_GLSECONDARYCOLOR3FVEXT _glSecondaryColor3fvEXT = &_get_glSecondaryColor3fvEXT;

static void APIENTRY _fail_glSecondaryColor3iEXT(GLint red, GLint green, GLint blue) {
    const char *_name = "glSecondaryColor3iEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3iEXT(GLint red, GLint green, GLint blue) {
    PFN_GLSECONDARYCOLOR3IEXT _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3IEXT)_getPrivateProcAddress("glSecondaryColor3iEXT");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3iEXT;
    }
    _glSecondaryColor3iEXT = _ptr;
    _glSecondaryColor3iEXT(red, green, blue);
}

PFN_GLSECONDARYCOLOR3IEXT _glSecondaryColor3iEXT = &_get_glSecondaryColor3iEXT;

static void APIENTRY _fail_glSecondaryColor3ivEXT(const GLint * v) {
    const char *_name = "glSecondaryColor3ivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3ivEXT(const GLint * v) {
    PFN_GLSECONDARYCOLOR3IVEXT _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3IVEXT)_getPrivateProcAddress("glSecondaryColor3ivEXT");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3ivEXT;
    }
    _glSecondaryColor3ivEXT = _ptr;
    _glSecondaryColor3ivEXT(v);
}

PFN_GLSECONDARYCOLOR3IVEXT _glSecondaryColor3ivEXT = &_get_glSecondaryColor3ivEXT;

static void APIENTRY _fail_glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue) {
    const char *_name = "glSecondaryColor3sEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue) {
    PFN_GLSECONDARYCOLOR3SEXT _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3SEXT)_getPrivateProcAddress("glSecondaryColor3sEXT");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3sEXT;
    }
    _glSecondaryColor3sEXT = _ptr;
    _glSecondaryColor3sEXT(red, green, blue);
}

PFN_GLSECONDARYCOLOR3SEXT _glSecondaryColor3sEXT = &_get_glSecondaryColor3sEXT;

static void APIENTRY _fail_glSecondaryColor3svEXT(const GLshort * v) {
    const char *_name = "glSecondaryColor3svEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3svEXT(const GLshort * v) {
    PFN_GLSECONDARYCOLOR3SVEXT _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3SVEXT)_getPrivateProcAddress("glSecondaryColor3svEXT");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3svEXT;
    }
    _glSecondaryColor3svEXT = _ptr;
    _glSecondaryColor3svEXT(v);
}

PFN_GLSECONDARYCOLOR3SVEXT _glSecondaryColor3svEXT = &_get_glSecondaryColor3svEXT;

static void APIENTRY _fail_glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue) {
    const char *_name = "glSecondaryColor3ubEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue) {
    PFN_GLSECONDARYCOLOR3UBEXT _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3UBEXT)_getPrivateProcAddress("glSecondaryColor3ubEXT");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3ubEXT;
    }
    _glSecondaryColor3ubEXT = _ptr;
    _glSecondaryColor3ubEXT(red, green, blue);
}

PFN_GLSECONDARYCOLOR3UBEXT _glSecondaryColor3ubEXT = &_get_glSecondaryColor3ubEXT;

static void APIENTRY _fail_glSecondaryColor3ubvEXT(const GLubyte * v) {
    const char *_name = "glSecondaryColor3ubvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3ubvEXT(const GLubyte * v) {
    PFN_GLSECONDARYCOLOR3UBVEXT _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3UBVEXT)_getPrivateProcAddress("glSecondaryColor3ubvEXT");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3ubvEXT;
    }
    _glSecondaryColor3ubvEXT = _ptr;
    _glSecondaryColor3ubvEXT(v);
}

PFN_GLSECONDARYCOLOR3UBVEXT _glSecondaryColor3ubvEXT = &_get_glSecondaryColor3ubvEXT;

static void APIENTRY _fail_glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue) {
    const char *_name = "glSecondaryColor3uiEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue) {
    PFN_GLSECONDARYCOLOR3UIEXT _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3UIEXT)_getPrivateProcAddress("glSecondaryColor3uiEXT");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3uiEXT;
    }
    _glSecondaryColor3uiEXT = _ptr;
    _glSecondaryColor3uiEXT(red, green, blue);
}

PFN_GLSECONDARYCOLOR3UIEXT _glSecondaryColor3uiEXT = &_get_glSecondaryColor3uiEXT;

static void APIENTRY _fail_glSecondaryColor3uivEXT(const GLuint * v) {
    const char *_name = "glSecondaryColor3uivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3uivEXT(const GLuint * v) {
    PFN_GLSECONDARYCOLOR3UIVEXT _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3UIVEXT)_getPrivateProcAddress("glSecondaryColor3uivEXT");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3uivEXT;
    }
    _glSecondaryColor3uivEXT = _ptr;
    _glSecondaryColor3uivEXT(v);
}

PFN_GLSECONDARYCOLOR3UIVEXT _glSecondaryColor3uivEXT = &_get_glSecondaryColor3uivEXT;

static void APIENTRY _fail_glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue) {
    const char *_name = "glSecondaryColor3usEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue) {
    PFN_GLSECONDARYCOLOR3USEXT _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3USEXT)_getPrivateProcAddress("glSecondaryColor3usEXT");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3usEXT;
    }
    _glSecondaryColor3usEXT = _ptr;
    _glSecondaryColor3usEXT(red, green, blue);
}

PFN_GLSECONDARYCOLOR3USEXT _glSecondaryColor3usEXT = &_get_glSecondaryColor3usEXT;

static void APIENTRY _fail_glSecondaryColor3usvEXT(const GLushort * v) {
    const char *_name = "glSecondaryColor3usvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3usvEXT(const GLushort * v) {
    PFN_GLSECONDARYCOLOR3USVEXT _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3USVEXT)_getPrivateProcAddress("glSecondaryColor3usvEXT");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3usvEXT;
    }
    _glSecondaryColor3usvEXT = _ptr;
    _glSecondaryColor3usvEXT(v);
}

PFN_GLSECONDARYCOLOR3USVEXT _glSecondaryColor3usvEXT = &_get_glSecondaryColor3usvEXT;

static void APIENTRY _fail_glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glSecondaryColorPointerEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLSECONDARYCOLORPOINTEREXT _ptr;
    _ptr = (PFN_GLSECONDARYCOLORPOINTEREXT)_getPrivateProcAddress("glSecondaryColorPointerEXT");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColorPointerEXT;
    }
    _glSecondaryColorPointerEXT = _ptr;
    _glSecondaryColorPointerEXT(size, type, stride, pointer);
}

PFN_GLSECONDARYCOLORPOINTEREXT _glSecondaryColorPointerEXT = &_get_glSecondaryColorPointerEXT;

static void APIENTRY _fail_glUseShaderProgramEXT(GLenum type, GLuint program) {
    const char *_name = "glUseShaderProgramEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUseShaderProgramEXT(GLenum type, GLuint program) {
    PFN_GLUSESHADERPROGRAMEXT _ptr;
    _ptr = (PFN_GLUSESHADERPROGRAMEXT)_getPrivateProcAddress("glUseShaderProgramEXT");
    if (!_ptr) {
        _ptr = &_fail_glUseShaderProgramEXT;
    }
    _glUseShaderProgramEXT = _ptr;
    _glUseShaderProgramEXT(type, program);
}

PFN_GLUSESHADERPROGRAMEXT _glUseShaderProgramEXT = &_get_glUseShaderProgramEXT;

static void APIENTRY _fail_glActiveProgramEXT(GLuint program) {
    const char *_name = "glActiveProgramEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glActiveProgramEXT(GLuint program) {
    PFN_GLACTIVEPROGRAMEXT _ptr;
    _ptr = (PFN_GLACTIVEPROGRAMEXT)_getPrivateProcAddress("glActiveProgramEXT");
    if (!_ptr) {
        _ptr = &_fail_glActiveProgramEXT;
    }
    _glActiveProgramEXT = _ptr;
    _glActiveProgramEXT(program);
}

PFN_GLACTIVEPROGRAMEXT _glActiveProgramEXT = &_get_glActiveProgramEXT;

static GLuint APIENTRY _fail_glCreateShaderProgramEXT(GLenum type, const GLchar * string) {
    const char *_name = "glCreateShaderProgramEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glCreateShaderProgramEXT(GLenum type, const GLchar * string) {
    PFN_GLCREATESHADERPROGRAMEXT _ptr;
    _ptr = (PFN_GLCREATESHADERPROGRAMEXT)_getPrivateProcAddress("glCreateShaderProgramEXT");
    if (!_ptr) {
        _ptr = &_fail_glCreateShaderProgramEXT;
    }
    _glCreateShaderProgramEXT = _ptr;
    return _glCreateShaderProgramEXT(type, string);
}

PFN_GLCREATESHADERPROGRAMEXT _glCreateShaderProgramEXT = &_get_glCreateShaderProgramEXT;

static void APIENTRY _fail_glActiveShaderProgramEXT(GLuint pipeline, GLuint program) {
    const char *_name = "glActiveShaderProgramEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glActiveShaderProgramEXT(GLuint pipeline, GLuint program) {
    PFN_GLACTIVESHADERPROGRAMEXT _ptr;
    _ptr = (PFN_GLACTIVESHADERPROGRAMEXT)_getPrivateProcAddress("glActiveShaderProgramEXT");
    if (!_ptr) {
        _ptr = &_fail_glActiveShaderProgramEXT;
    }
    _glActiveShaderProgramEXT = _ptr;
    _glActiveShaderProgramEXT(pipeline, program);
}

PFN_GLACTIVESHADERPROGRAMEXT _glActiveShaderProgramEXT = &_get_glActiveShaderProgramEXT;

static void APIENTRY _fail_glBindProgramPipelineEXT(GLuint pipeline) {
    const char *_name = "glBindProgramPipelineEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindProgramPipelineEXT(GLuint pipeline) {
    PFN_GLBINDPROGRAMPIPELINEEXT _ptr;
    _ptr = (PFN_GLBINDPROGRAMPIPELINEEXT)_getPrivateProcAddress("glBindProgramPipelineEXT");
    if (!_ptr) {
        _ptr = &_fail_glBindProgramPipelineEXT;
    }
    _glBindProgramPipelineEXT = _ptr;
    _glBindProgramPipelineEXT(pipeline);
}

PFN_GLBINDPROGRAMPIPELINEEXT _glBindProgramPipelineEXT = &_get_glBindProgramPipelineEXT;

static GLuint APIENTRY _fail_glCreateShaderProgramvEXT(GLenum type, GLsizei count, const GLchar * * const strings) {
    const char *_name = "glCreateShaderProgramvEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glCreateShaderProgramvEXT(GLenum type, GLsizei count, const GLchar * * const strings) {
    PFN_GLCREATESHADERPROGRAMVEXT _ptr;
    _ptr = (PFN_GLCREATESHADERPROGRAMVEXT)_getPrivateProcAddress("glCreateShaderProgramvEXT");
    if (!_ptr) {
        _ptr = &_fail_glCreateShaderProgramvEXT;
    }
    _glCreateShaderProgramvEXT = _ptr;
    return _glCreateShaderProgramvEXT(type, count, strings);
}

PFN_GLCREATESHADERPROGRAMVEXT _glCreateShaderProgramvEXT = &_get_glCreateShaderProgramvEXT;

static void APIENTRY _fail_glDeleteProgramPipelinesEXT(GLsizei n, const GLuint * pipelines) {
    const char *_name = "glDeleteProgramPipelinesEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteProgramPipelinesEXT(GLsizei n, const GLuint * pipelines) {
    PFN_GLDELETEPROGRAMPIPELINESEXT _ptr;
    _ptr = (PFN_GLDELETEPROGRAMPIPELINESEXT)_getPrivateProcAddress("glDeleteProgramPipelinesEXT");
    if (!_ptr) {
        _ptr = &_fail_glDeleteProgramPipelinesEXT;
    }
    _glDeleteProgramPipelinesEXT = _ptr;
    _glDeleteProgramPipelinesEXT(n, pipelines);
}

PFN_GLDELETEPROGRAMPIPELINESEXT _glDeleteProgramPipelinesEXT = &_get_glDeleteProgramPipelinesEXT;

static void APIENTRY _fail_glGenProgramPipelinesEXT(GLsizei n, GLuint * pipelines) {
    const char *_name = "glGenProgramPipelinesEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenProgramPipelinesEXT(GLsizei n, GLuint * pipelines) {
    PFN_GLGENPROGRAMPIPELINESEXT _ptr;
    _ptr = (PFN_GLGENPROGRAMPIPELINESEXT)_getPrivateProcAddress("glGenProgramPipelinesEXT");
    if (!_ptr) {
        _ptr = &_fail_glGenProgramPipelinesEXT;
    }
    _glGenProgramPipelinesEXT = _ptr;
    _glGenProgramPipelinesEXT(n, pipelines);
}

PFN_GLGENPROGRAMPIPELINESEXT _glGenProgramPipelinesEXT = &_get_glGenProgramPipelinesEXT;

static void APIENTRY _fail_glGetProgramPipelineInfoLogEXT(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog) {
    const char *_name = "glGetProgramPipelineInfoLogEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramPipelineInfoLogEXT(GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog) {
    PFN_GLGETPROGRAMPIPELINEINFOLOGEXT _ptr;
    _ptr = (PFN_GLGETPROGRAMPIPELINEINFOLOGEXT)_getPrivateProcAddress("glGetProgramPipelineInfoLogEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramPipelineInfoLogEXT;
    }
    _glGetProgramPipelineInfoLogEXT = _ptr;
    _glGetProgramPipelineInfoLogEXT(pipeline, bufSize, length, infoLog);
}

PFN_GLGETPROGRAMPIPELINEINFOLOGEXT _glGetProgramPipelineInfoLogEXT = &_get_glGetProgramPipelineInfoLogEXT;

static void APIENTRY _fail_glGetProgramPipelineivEXT(GLuint pipeline, GLenum pname, GLint * params) {
    const char *_name = "glGetProgramPipelineivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramPipelineivEXT(GLuint pipeline, GLenum pname, GLint * params) {
    PFN_GLGETPROGRAMPIPELINEIVEXT _ptr;
    _ptr = (PFN_GLGETPROGRAMPIPELINEIVEXT)_getPrivateProcAddress("glGetProgramPipelineivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramPipelineivEXT;
    }
    _glGetProgramPipelineivEXT = _ptr;
    _glGetProgramPipelineivEXT(pipeline, pname, params);
}

PFN_GLGETPROGRAMPIPELINEIVEXT _glGetProgramPipelineivEXT = &_get_glGetProgramPipelineivEXT;

static GLboolean APIENTRY _fail_glIsProgramPipelineEXT(GLuint pipeline) {
    const char *_name = "glIsProgramPipelineEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsProgramPipelineEXT(GLuint pipeline) {
    PFN_GLISPROGRAMPIPELINEEXT _ptr;
    _ptr = (PFN_GLISPROGRAMPIPELINEEXT)_getPrivateProcAddress("glIsProgramPipelineEXT");
    if (!_ptr) {
        _ptr = &_fail_glIsProgramPipelineEXT;
    }
    _glIsProgramPipelineEXT = _ptr;
    return _glIsProgramPipelineEXT(pipeline);
}

PFN_GLISPROGRAMPIPELINEEXT _glIsProgramPipelineEXT = &_get_glIsProgramPipelineEXT;

static void APIENTRY _fail_glUseProgramStagesEXT(GLuint pipeline, GLbitfield stages, GLuint program) {
    const char *_name = "glUseProgramStagesEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUseProgramStagesEXT(GLuint pipeline, GLbitfield stages, GLuint program) {
    PFN_GLUSEPROGRAMSTAGESEXT _ptr;
    _ptr = (PFN_GLUSEPROGRAMSTAGESEXT)_getPrivateProcAddress("glUseProgramStagesEXT");
    if (!_ptr) {
        _ptr = &_fail_glUseProgramStagesEXT;
    }
    _glUseProgramStagesEXT = _ptr;
    _glUseProgramStagesEXT(pipeline, stages, program);
}

PFN_GLUSEPROGRAMSTAGESEXT _glUseProgramStagesEXT = &_get_glUseProgramStagesEXT;

static void APIENTRY _fail_glValidateProgramPipelineEXT(GLuint pipeline) {
    const char *_name = "glValidateProgramPipelineEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glValidateProgramPipelineEXT(GLuint pipeline) {
    PFN_GLVALIDATEPROGRAMPIPELINEEXT _ptr;
    _ptr = (PFN_GLVALIDATEPROGRAMPIPELINEEXT)_getPrivateProcAddress("glValidateProgramPipelineEXT");
    if (!_ptr) {
        _ptr = &_fail_glValidateProgramPipelineEXT;
    }
    _glValidateProgramPipelineEXT = _ptr;
    _glValidateProgramPipelineEXT(pipeline);
}

PFN_GLVALIDATEPROGRAMPIPELINEEXT _glValidateProgramPipelineEXT = &_get_glValidateProgramPipelineEXT;

static void APIENTRY _fail_glBindImageTextureEXT(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format) {
    const char *_name = "glBindImageTextureEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindImageTextureEXT(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format) {
    PFN_GLBINDIMAGETEXTUREEXT _ptr;
    _ptr = (PFN_GLBINDIMAGETEXTUREEXT)_getPrivateProcAddress("glBindImageTextureEXT");
    if (!_ptr) {
        _ptr = &_fail_glBindImageTextureEXT;
    }
    _glBindImageTextureEXT = _ptr;
    _glBindImageTextureEXT(index, texture, level, layered, layer, access, format);
}

PFN_GLBINDIMAGETEXTUREEXT _glBindImageTextureEXT = &_get_glBindImageTextureEXT;

static void APIENTRY _fail_glMemoryBarrierEXT(GLbitfield barriers) {
    const char *_name = "glMemoryBarrierEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMemoryBarrierEXT(GLbitfield barriers) {
    PFN_GLMEMORYBARRIEREXT _ptr;
    _ptr = (PFN_GLMEMORYBARRIEREXT)_getPrivateProcAddress("glMemoryBarrierEXT");
    if (!_ptr) {
        _ptr = &_fail_glMemoryBarrierEXT;
    }
    _glMemoryBarrierEXT = _ptr;
    _glMemoryBarrierEXT(barriers);
}

PFN_GLMEMORYBARRIEREXT _glMemoryBarrierEXT = &_get_glMemoryBarrierEXT;

static void APIENTRY _fail_glStencilClearTagEXT(GLsizei stencilTagBits, GLuint stencilClearTag) {
    const char *_name = "glStencilClearTagEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStencilClearTagEXT(GLsizei stencilTagBits, GLuint stencilClearTag) {
    PFN_GLSTENCILCLEARTAGEXT _ptr;
    _ptr = (PFN_GLSTENCILCLEARTAGEXT)_getPrivateProcAddress("glStencilClearTagEXT");
    if (!_ptr) {
        _ptr = &_fail_glStencilClearTagEXT;
    }
    _glStencilClearTagEXT = _ptr;
    _glStencilClearTagEXT(stencilTagBits, stencilClearTag);
}

PFN_GLSTENCILCLEARTAGEXT _glStencilClearTagEXT = &_get_glStencilClearTagEXT;

static void APIENTRY _fail_glActiveStencilFaceEXT(GLenum face) {
    const char *_name = "glActiveStencilFaceEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glActiveStencilFaceEXT(GLenum face) {
    PFN_GLACTIVESTENCILFACEEXT _ptr;
    _ptr = (PFN_GLACTIVESTENCILFACEEXT)_getPrivateProcAddress("glActiveStencilFaceEXT");
    if (!_ptr) {
        _ptr = &_fail_glActiveStencilFaceEXT;
    }
    _glActiveStencilFaceEXT = _ptr;
    _glActiveStencilFaceEXT(face);
}

PFN_GLACTIVESTENCILFACEEXT _glActiveStencilFaceEXT = &_get_glActiveStencilFaceEXT;

static void APIENTRY _fail_glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexSubImage1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXSUBIMAGE1DEXT _ptr;
    _ptr = (PFN_GLTEXSUBIMAGE1DEXT)_getPrivateProcAddress("glTexSubImage1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glTexSubImage1DEXT;
    }
    _glTexSubImage1DEXT = _ptr;
    _glTexSubImage1DEXT(target, level, xoffset, width, format, type, pixels);
}

PFN_GLTEXSUBIMAGE1DEXT _glTexSubImage1DEXT = &_get_glTexSubImage1DEXT;

static void APIENTRY _fail_glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexSubImage2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXSUBIMAGE2DEXT _ptr;
    _ptr = (PFN_GLTEXSUBIMAGE2DEXT)_getPrivateProcAddress("glTexSubImage2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glTexSubImage2DEXT;
    }
    _glTexSubImage2DEXT = _ptr;
    _glTexSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

PFN_GLTEXSUBIMAGE2DEXT _glTexSubImage2DEXT = &_get_glTexSubImage2DEXT;

static void APIENTRY _fail_glPatchParameteriEXT(GLenum pname, GLint value) {
    const char *_name = "glPatchParameteriEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPatchParameteriEXT(GLenum pname, GLint value) {
    PFN_GLPATCHPARAMETERIEXT _ptr;
    _ptr = (PFN_GLPATCHPARAMETERIEXT)_getPrivateProcAddress("glPatchParameteriEXT");
    if (!_ptr) {
        _ptr = &_fail_glPatchParameteriEXT;
    }
    _glPatchParameteriEXT = _ptr;
    _glPatchParameteriEXT(pname, value);
}

PFN_GLPATCHPARAMETERIEXT _glPatchParameteriEXT = &_get_glPatchParameteriEXT;

static void APIENTRY _fail_glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexImage3DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXIMAGE3DEXT _ptr;
    _ptr = (PFN_GLTEXIMAGE3DEXT)_getPrivateProcAddress("glTexImage3DEXT");
    if (!_ptr) {
        _ptr = &_fail_glTexImage3DEXT;
    }
    _glTexImage3DEXT = _ptr;
    _glTexImage3DEXT(target, level, internalformat, width, height, depth, border, format, type, pixels);
}

PFN_GLTEXIMAGE3DEXT _glTexImage3DEXT = &_get_glTexImage3DEXT;

static void APIENTRY _fail_glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexSubImage3DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXSUBIMAGE3DEXT _ptr;
    _ptr = (PFN_GLTEXSUBIMAGE3DEXT)_getPrivateProcAddress("glTexSubImage3DEXT");
    if (!_ptr) {
        _ptr = &_fail_glTexSubImage3DEXT;
    }
    _glTexSubImage3DEXT = _ptr;
    _glTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

PFN_GLTEXSUBIMAGE3DEXT _glTexSubImage3DEXT = &_get_glTexSubImage3DEXT;

static void APIENTRY _fail_glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) {
    const char *_name = "glFramebufferTextureLayerEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) {
    PFN_GLFRAMEBUFFERTEXTURELAYEREXT _ptr;
    _ptr = (PFN_GLFRAMEBUFFERTEXTURELAYEREXT)_getPrivateProcAddress("glFramebufferTextureLayerEXT");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferTextureLayerEXT;
    }
    _glFramebufferTextureLayerEXT = _ptr;
    _glFramebufferTextureLayerEXT(target, attachment, texture, level, layer);
}

PFN_GLFRAMEBUFFERTEXTURELAYEREXT _glFramebufferTextureLayerEXT = &_get_glFramebufferTextureLayerEXT;

static void APIENTRY _fail_glTexBufferEXT(GLenum target, GLenum internalformat, GLuint buffer) {
    const char *_name = "glTexBufferEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexBufferEXT(GLenum target, GLenum internalformat, GLuint buffer) {
    PFN_GLTEXBUFFEREXT _ptr;
    _ptr = (PFN_GLTEXBUFFEREXT)_getPrivateProcAddress("glTexBufferEXT");
    if (!_ptr) {
        _ptr = &_fail_glTexBufferEXT;
    }
    _glTexBufferEXT = _ptr;
    _glTexBufferEXT(target, internalformat, buffer);
}

PFN_GLTEXBUFFEREXT _glTexBufferEXT = &_get_glTexBufferEXT;

static void APIENTRY _fail_glTexBufferRangeEXT(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    const char *_name = "glTexBufferRangeEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexBufferRangeEXT(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    PFN_GLTEXBUFFERRANGEEXT _ptr;
    _ptr = (PFN_GLTEXBUFFERRANGEEXT)_getPrivateProcAddress("glTexBufferRangeEXT");
    if (!_ptr) {
        _ptr = &_fail_glTexBufferRangeEXT;
    }
    _glTexBufferRangeEXT = _ptr;
    _glTexBufferRangeEXT(target, internalformat, buffer, offset, size);
}

PFN_GLTEXBUFFERRANGEEXT _glTexBufferRangeEXT = &_get_glTexBufferRangeEXT;

static void APIENTRY _fail_glTexParameterIivEXT(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glTexParameterIivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexParameterIivEXT(GLenum target, GLenum pname, const GLint * params) {
    PFN_GLTEXPARAMETERIIVEXT _ptr;
    _ptr = (PFN_GLTEXPARAMETERIIVEXT)_getPrivateProcAddress("glTexParameterIivEXT");
    if (!_ptr) {
        _ptr = &_fail_glTexParameterIivEXT;
    }
    _glTexParameterIivEXT = _ptr;
    _glTexParameterIivEXT(target, pname, params);
}

PFN_GLTEXPARAMETERIIVEXT _glTexParameterIivEXT = &_get_glTexParameterIivEXT;

static void APIENTRY _fail_glTexParameterIuivEXT(GLenum target, GLenum pname, const GLuint * params) {
    const char *_name = "glTexParameterIuivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexParameterIuivEXT(GLenum target, GLenum pname, const GLuint * params) {
    PFN_GLTEXPARAMETERIUIVEXT _ptr;
    _ptr = (PFN_GLTEXPARAMETERIUIVEXT)_getPrivateProcAddress("glTexParameterIuivEXT");
    if (!_ptr) {
        _ptr = &_fail_glTexParameterIuivEXT;
    }
    _glTexParameterIuivEXT = _ptr;
    _glTexParameterIuivEXT(target, pname, params);
}

PFN_GLTEXPARAMETERIUIVEXT _glTexParameterIuivEXT = &_get_glTexParameterIuivEXT;

static void APIENTRY _fail_glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetTexParameterIivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETTEXPARAMETERIIVEXT _ptr;
    _ptr = (PFN_GLGETTEXPARAMETERIIVEXT)_getPrivateProcAddress("glGetTexParameterIivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetTexParameterIivEXT;
    }
    _glGetTexParameterIivEXT = _ptr;
    _glGetTexParameterIivEXT(target, pname, params);
}

PFN_GLGETTEXPARAMETERIIVEXT _glGetTexParameterIivEXT = &_get_glGetTexParameterIivEXT;

static void APIENTRY _fail_glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint * params) {
    const char *_name = "glGetTexParameterIuivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint * params) {
    PFN_GLGETTEXPARAMETERIUIVEXT _ptr;
    _ptr = (PFN_GLGETTEXPARAMETERIUIVEXT)_getPrivateProcAddress("glGetTexParameterIuivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetTexParameterIuivEXT;
    }
    _glGetTexParameterIuivEXT = _ptr;
    _glGetTexParameterIuivEXT(target, pname, params);
}

PFN_GLGETTEXPARAMETERIUIVEXT _glGetTexParameterIuivEXT = &_get_glGetTexParameterIuivEXT;

static void APIENTRY _fail_glClearColorIiEXT(GLint red, GLint green, GLint blue, GLint alpha) {
    const char *_name = "glClearColorIiEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearColorIiEXT(GLint red, GLint green, GLint blue, GLint alpha) {
    PFN_GLCLEARCOLORIIEXT _ptr;
    _ptr = (PFN_GLCLEARCOLORIIEXT)_getPrivateProcAddress("glClearColorIiEXT");
    if (!_ptr) {
        _ptr = &_fail_glClearColorIiEXT;
    }
    _glClearColorIiEXT = _ptr;
    _glClearColorIiEXT(red, green, blue, alpha);
}

PFN_GLCLEARCOLORIIEXT _glClearColorIiEXT = &_get_glClearColorIiEXT;

static void APIENTRY _fail_glClearColorIuiEXT(GLuint red, GLuint green, GLuint blue, GLuint alpha) {
    const char *_name = "glClearColorIuiEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearColorIuiEXT(GLuint red, GLuint green, GLuint blue, GLuint alpha) {
    PFN_GLCLEARCOLORIUIEXT _ptr;
    _ptr = (PFN_GLCLEARCOLORIUIEXT)_getPrivateProcAddress("glClearColorIuiEXT");
    if (!_ptr) {
        _ptr = &_fail_glClearColorIuiEXT;
    }
    _glClearColorIuiEXT = _ptr;
    _glClearColorIuiEXT(red, green, blue, alpha);
}

PFN_GLCLEARCOLORIUIEXT _glClearColorIuiEXT = &_get_glClearColorIuiEXT;

static GLboolean APIENTRY _fail_glAreTexturesResidentEXT(GLsizei n, const GLuint * textures, GLboolean * residences) {
    const char *_name = "glAreTexturesResidentEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glAreTexturesResidentEXT(GLsizei n, const GLuint * textures, GLboolean * residences) {
    PFN_GLARETEXTURESRESIDENTEXT _ptr;
    _ptr = (PFN_GLARETEXTURESRESIDENTEXT)_getPrivateProcAddress("glAreTexturesResidentEXT");
    if (!_ptr) {
        _ptr = &_fail_glAreTexturesResidentEXT;
    }
    _glAreTexturesResidentEXT = _ptr;
    return _glAreTexturesResidentEXT(n, textures, residences);
}

PFN_GLARETEXTURESRESIDENTEXT _glAreTexturesResidentEXT = &_get_glAreTexturesResidentEXT;

static void APIENTRY _fail_glBindTextureEXT(GLenum target, GLuint texture) {
    const char *_name = "glBindTextureEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindTextureEXT(GLenum target, GLuint texture) {
    PFN_GLBINDTEXTUREEXT _ptr;
    _ptr = (PFN_GLBINDTEXTUREEXT)_getPrivateProcAddress("glBindTextureEXT");
    if (!_ptr) {
        _ptr = &_fail_glBindTextureEXT;
    }
    _glBindTextureEXT = _ptr;
    _glBindTextureEXT(target, texture);
}

PFN_GLBINDTEXTUREEXT _glBindTextureEXT = &_get_glBindTextureEXT;

static void APIENTRY _fail_glDeleteTexturesEXT(GLsizei n, const GLuint * textures) {
    const char *_name = "glDeleteTexturesEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteTexturesEXT(GLsizei n, const GLuint * textures) {
    PFN_GLDELETETEXTURESEXT _ptr;
    _ptr = (PFN_GLDELETETEXTURESEXT)_getPrivateProcAddress("glDeleteTexturesEXT");
    if (!_ptr) {
        _ptr = &_fail_glDeleteTexturesEXT;
    }
    _glDeleteTexturesEXT = _ptr;
    _glDeleteTexturesEXT(n, textures);
}

PFN_GLDELETETEXTURESEXT _glDeleteTexturesEXT = &_get_glDeleteTexturesEXT;

static void APIENTRY _fail_glGenTexturesEXT(GLsizei n, GLuint * textures) {
    const char *_name = "glGenTexturesEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenTexturesEXT(GLsizei n, GLuint * textures) {
    PFN_GLGENTEXTURESEXT _ptr;
    _ptr = (PFN_GLGENTEXTURESEXT)_getPrivateProcAddress("glGenTexturesEXT");
    if (!_ptr) {
        _ptr = &_fail_glGenTexturesEXT;
    }
    _glGenTexturesEXT = _ptr;
    _glGenTexturesEXT(n, textures);
}

PFN_GLGENTEXTURESEXT _glGenTexturesEXT = &_get_glGenTexturesEXT;

static GLboolean APIENTRY _fail_glIsTextureEXT(GLuint texture) {
    const char *_name = "glIsTextureEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsTextureEXT(GLuint texture) {
    PFN_GLISTEXTUREEXT _ptr;
    _ptr = (PFN_GLISTEXTUREEXT)_getPrivateProcAddress("glIsTextureEXT");
    if (!_ptr) {
        _ptr = &_fail_glIsTextureEXT;
    }
    _glIsTextureEXT = _ptr;
    return _glIsTextureEXT(texture);
}

PFN_GLISTEXTUREEXT _glIsTextureEXT = &_get_glIsTextureEXT;

static void APIENTRY _fail_glPrioritizeTexturesEXT(GLsizei n, const GLuint * textures, const GLclampf * priorities) {
    const char *_name = "glPrioritizeTexturesEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPrioritizeTexturesEXT(GLsizei n, const GLuint * textures, const GLclampf * priorities) {
    PFN_GLPRIORITIZETEXTURESEXT _ptr;
    _ptr = (PFN_GLPRIORITIZETEXTURESEXT)_getPrivateProcAddress("glPrioritizeTexturesEXT");
    if (!_ptr) {
        _ptr = &_fail_glPrioritizeTexturesEXT;
    }
    _glPrioritizeTexturesEXT = _ptr;
    _glPrioritizeTexturesEXT(n, textures, priorities);
}

PFN_GLPRIORITIZETEXTURESEXT _glPrioritizeTexturesEXT = &_get_glPrioritizeTexturesEXT;

static void APIENTRY _fail_glTextureNormalEXT(GLenum mode) {
    const char *_name = "glTextureNormalEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureNormalEXT(GLenum mode) {
    PFN_GLTEXTURENORMALEXT _ptr;
    _ptr = (PFN_GLTEXTURENORMALEXT)_getPrivateProcAddress("glTextureNormalEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureNormalEXT;
    }
    _glTextureNormalEXT = _ptr;
    _glTextureNormalEXT(mode);
}

PFN_GLTEXTURENORMALEXT _glTextureNormalEXT = &_get_glTextureNormalEXT;

static void APIENTRY _fail_glTexStorage1DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) {
    const char *_name = "glTexStorage1DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexStorage1DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) {
    PFN_GLTEXSTORAGE1DEXT _ptr;
    _ptr = (PFN_GLTEXSTORAGE1DEXT)_getPrivateProcAddress("glTexStorage1DEXT");
    if (!_ptr) {
        _ptr = &_fail_glTexStorage1DEXT;
    }
    _glTexStorage1DEXT = _ptr;
    _glTexStorage1DEXT(target, levels, internalformat, width);
}

PFN_GLTEXSTORAGE1DEXT _glTexStorage1DEXT = &_get_glTexStorage1DEXT;

static void APIENTRY _fail_glTexStorage2DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glTexStorage2DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexStorage2DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) {
    PFN_GLTEXSTORAGE2DEXT _ptr;
    _ptr = (PFN_GLTEXSTORAGE2DEXT)_getPrivateProcAddress("glTexStorage2DEXT");
    if (!_ptr) {
        _ptr = &_fail_glTexStorage2DEXT;
    }
    _glTexStorage2DEXT = _ptr;
    _glTexStorage2DEXT(target, levels, internalformat, width, height);
}

PFN_GLTEXSTORAGE2DEXT _glTexStorage2DEXT = &_get_glTexStorage2DEXT;

static void APIENTRY _fail_glTexStorage3DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) {
    const char *_name = "glTexStorage3DEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexStorage3DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) {
    PFN_GLTEXSTORAGE3DEXT _ptr;
    _ptr = (PFN_GLTEXSTORAGE3DEXT)_getPrivateProcAddress("glTexStorage3DEXT");
    if (!_ptr) {
        _ptr = &_fail_glTexStorage3DEXT;
    }
    _glTexStorage3DEXT = _ptr;
    _glTexStorage3DEXT(target, levels, internalformat, width, height, depth);
}

PFN_GLTEXSTORAGE3DEXT _glTexStorage3DEXT = &_get_glTexStorage3DEXT;

static void APIENTRY _fail_glTextureViewEXT(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) {
    const char *_name = "glTextureViewEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureViewEXT(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) {
    PFN_GLTEXTUREVIEWEXT _ptr;
    _ptr = (PFN_GLTEXTUREVIEWEXT)_getPrivateProcAddress("glTextureViewEXT");
    if (!_ptr) {
        _ptr = &_fail_glTextureViewEXT;
    }
    _glTextureViewEXT = _ptr;
    _glTextureViewEXT(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
}

PFN_GLTEXTUREVIEWEXT _glTextureViewEXT = &_get_glTextureViewEXT;

static void APIENTRY _fail_glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT * params) {
    const char *_name = "glGetQueryObjecti64vEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT * params) {
    PFN_GLGETQUERYOBJECTI64VEXT _ptr;
    _ptr = (PFN_GLGETQUERYOBJECTI64VEXT)_getPrivateProcAddress("glGetQueryObjecti64vEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryObjecti64vEXT;
    }
    _glGetQueryObjecti64vEXT = _ptr;
    _glGetQueryObjecti64vEXT(id, pname, params);
}

PFN_GLGETQUERYOBJECTI64VEXT _glGetQueryObjecti64vEXT = &_get_glGetQueryObjecti64vEXT;

static void APIENTRY _fail_glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT * params) {
    const char *_name = "glGetQueryObjectui64vEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT * params) {
    PFN_GLGETQUERYOBJECTUI64VEXT _ptr;
    _ptr = (PFN_GLGETQUERYOBJECTUI64VEXT)_getPrivateProcAddress("glGetQueryObjectui64vEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetQueryObjectui64vEXT;
    }
    _glGetQueryObjectui64vEXT = _ptr;
    _glGetQueryObjectui64vEXT(id, pname, params);
}

PFN_GLGETQUERYOBJECTUI64VEXT _glGetQueryObjectui64vEXT = &_get_glGetQueryObjectui64vEXT;

static void APIENTRY _fail_glBeginTransformFeedbackEXT(GLenum primitiveMode) {
    const char *_name = "glBeginTransformFeedbackEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBeginTransformFeedbackEXT(GLenum primitiveMode) {
    PFN_GLBEGINTRANSFORMFEEDBACKEXT _ptr;
    _ptr = (PFN_GLBEGINTRANSFORMFEEDBACKEXT)_getPrivateProcAddress("glBeginTransformFeedbackEXT");
    if (!_ptr) {
        _ptr = &_fail_glBeginTransformFeedbackEXT;
    }
    _glBeginTransformFeedbackEXT = _ptr;
    _glBeginTransformFeedbackEXT(primitiveMode);
}

PFN_GLBEGINTRANSFORMFEEDBACKEXT _glBeginTransformFeedbackEXT = &_get_glBeginTransformFeedbackEXT;

static void APIENTRY _fail_glEndTransformFeedbackEXT(void) {
    const char *_name = "glEndTransformFeedbackEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEndTransformFeedbackEXT(void) {
    PFN_GLENDTRANSFORMFEEDBACKEXT _ptr;
    _ptr = (PFN_GLENDTRANSFORMFEEDBACKEXT)_getPrivateProcAddress("glEndTransformFeedbackEXT");
    if (!_ptr) {
        _ptr = &_fail_glEndTransformFeedbackEXT;
    }
    _glEndTransformFeedbackEXT = _ptr;
    _glEndTransformFeedbackEXT();
}

PFN_GLENDTRANSFORMFEEDBACKEXT _glEndTransformFeedbackEXT = &_get_glEndTransformFeedbackEXT;

static void APIENTRY _fail_glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    const char *_name = "glBindBufferRangeEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    PFN_GLBINDBUFFERRANGEEXT _ptr;
    _ptr = (PFN_GLBINDBUFFERRANGEEXT)_getPrivateProcAddress("glBindBufferRangeEXT");
    if (!_ptr) {
        _ptr = &_fail_glBindBufferRangeEXT;
    }
    _glBindBufferRangeEXT = _ptr;
    _glBindBufferRangeEXT(target, index, buffer, offset, size);
}

PFN_GLBINDBUFFERRANGEEXT _glBindBufferRangeEXT = &_get_glBindBufferRangeEXT;

static void APIENTRY _fail_glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset) {
    const char *_name = "glBindBufferOffsetEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset) {
    PFN_GLBINDBUFFEROFFSETEXT _ptr;
    _ptr = (PFN_GLBINDBUFFEROFFSETEXT)_getPrivateProcAddress("glBindBufferOffsetEXT");
    if (!_ptr) {
        _ptr = &_fail_glBindBufferOffsetEXT;
    }
    _glBindBufferOffsetEXT = _ptr;
    _glBindBufferOffsetEXT(target, index, buffer, offset);
}

PFN_GLBINDBUFFEROFFSETEXT _glBindBufferOffsetEXT = &_get_glBindBufferOffsetEXT;

static void APIENTRY _fail_glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer) {
    const char *_name = "glBindBufferBaseEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer) {
    PFN_GLBINDBUFFERBASEEXT _ptr;
    _ptr = (PFN_GLBINDBUFFERBASEEXT)_getPrivateProcAddress("glBindBufferBaseEXT");
    if (!_ptr) {
        _ptr = &_fail_glBindBufferBaseEXT;
    }
    _glBindBufferBaseEXT = _ptr;
    _glBindBufferBaseEXT(target, index, buffer);
}

PFN_GLBINDBUFFERBASEEXT _glBindBufferBaseEXT = &_get_glBindBufferBaseEXT;

static void APIENTRY _fail_glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar * const * varyings, GLenum bufferMode) {
    const char *_name = "glTransformFeedbackVaryingsEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar * const * varyings, GLenum bufferMode) {
    PFN_GLTRANSFORMFEEDBACKVARYINGSEXT _ptr;
    _ptr = (PFN_GLTRANSFORMFEEDBACKVARYINGSEXT)_getPrivateProcAddress("glTransformFeedbackVaryingsEXT");
    if (!_ptr) {
        _ptr = &_fail_glTransformFeedbackVaryingsEXT;
    }
    _glTransformFeedbackVaryingsEXT = _ptr;
    _glTransformFeedbackVaryingsEXT(program, count, varyings, bufferMode);
}

PFN_GLTRANSFORMFEEDBACKVARYINGSEXT _glTransformFeedbackVaryingsEXT = &_get_glTransformFeedbackVaryingsEXT;

static void APIENTRY _fail_glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name) {
    const char *_name = "glGetTransformFeedbackVaryingEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name) {
    PFN_GLGETTRANSFORMFEEDBACKVARYINGEXT _ptr;
    _ptr = (PFN_GLGETTRANSFORMFEEDBACKVARYINGEXT)_getPrivateProcAddress("glGetTransformFeedbackVaryingEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetTransformFeedbackVaryingEXT;
    }
    _glGetTransformFeedbackVaryingEXT = _ptr;
    _glGetTransformFeedbackVaryingEXT(program, index, bufSize, length, size, type, name);
}

PFN_GLGETTRANSFORMFEEDBACKVARYINGEXT _glGetTransformFeedbackVaryingEXT = &_get_glGetTransformFeedbackVaryingEXT;

static void APIENTRY _fail_glArrayElementEXT(GLint i) {
    const char *_name = "glArrayElementEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glArrayElementEXT(GLint i) {
    PFN_GLARRAYELEMENTEXT _ptr;
    _ptr = (PFN_GLARRAYELEMENTEXT)_getPrivateProcAddress("glArrayElementEXT");
    if (!_ptr) {
        _ptr = &_fail_glArrayElementEXT;
    }
    _glArrayElementEXT = _ptr;
    _glArrayElementEXT(i);
}

PFN_GLARRAYELEMENTEXT _glArrayElementEXT = &_get_glArrayElementEXT;

static void APIENTRY _fail_glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer) {
    const char *_name = "glColorPointerEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer) {
    PFN_GLCOLORPOINTEREXT _ptr;
    _ptr = (PFN_GLCOLORPOINTEREXT)_getPrivateProcAddress("glColorPointerEXT");
    if (!_ptr) {
        _ptr = &_fail_glColorPointerEXT;
    }
    _glColorPointerEXT = _ptr;
    _glColorPointerEXT(size, type, stride, count, pointer);
}

PFN_GLCOLORPOINTEREXT _glColorPointerEXT = &_get_glColorPointerEXT;

static void APIENTRY _fail_glDrawArraysEXT(GLenum mode, GLint first, GLsizei count) {
    const char *_name = "glDrawArraysEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawArraysEXT(GLenum mode, GLint first, GLsizei count) {
    PFN_GLDRAWARRAYSEXT _ptr;
    _ptr = (PFN_GLDRAWARRAYSEXT)_getPrivateProcAddress("glDrawArraysEXT");
    if (!_ptr) {
        _ptr = &_fail_glDrawArraysEXT;
    }
    _glDrawArraysEXT = _ptr;
    _glDrawArraysEXT(mode, first, count);
}

PFN_GLDRAWARRAYSEXT _glDrawArraysEXT = &_get_glDrawArraysEXT;

static void APIENTRY _fail_glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean * pointer) {
    const char *_name = "glEdgeFlagPointerEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean * pointer) {
    PFN_GLEDGEFLAGPOINTEREXT _ptr;
    _ptr = (PFN_GLEDGEFLAGPOINTEREXT)_getPrivateProcAddress("glEdgeFlagPointerEXT");
    if (!_ptr) {
        _ptr = &_fail_glEdgeFlagPointerEXT;
    }
    _glEdgeFlagPointerEXT = _ptr;
    _glEdgeFlagPointerEXT(stride, count, pointer);
}

PFN_GLEDGEFLAGPOINTEREXT _glEdgeFlagPointerEXT = &_get_glEdgeFlagPointerEXT;

static void APIENTRY _fail_glGetPointervEXT(GLenum pname, GLvoid * * params) {
    const char *_name = "glGetPointervEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPointervEXT(GLenum pname, GLvoid * * params) {
    PFN_GLGETPOINTERVEXT _ptr;
    _ptr = (PFN_GLGETPOINTERVEXT)_getPrivateProcAddress("glGetPointervEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetPointervEXT;
    }
    _glGetPointervEXT = _ptr;
    _glGetPointervEXT(pname, params);
}

PFN_GLGETPOINTERVEXT _glGetPointervEXT = &_get_glGetPointervEXT;

static void APIENTRY _fail_glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer) {
    const char *_name = "glIndexPointerEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer) {
    PFN_GLINDEXPOINTEREXT _ptr;
    _ptr = (PFN_GLINDEXPOINTEREXT)_getPrivateProcAddress("glIndexPointerEXT");
    if (!_ptr) {
        _ptr = &_fail_glIndexPointerEXT;
    }
    _glIndexPointerEXT = _ptr;
    _glIndexPointerEXT(type, stride, count, pointer);
}

PFN_GLINDEXPOINTEREXT _glIndexPointerEXT = &_get_glIndexPointerEXT;

static void APIENTRY _fail_glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer) {
    const char *_name = "glNormalPointerEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer) {
    PFN_GLNORMALPOINTEREXT _ptr;
    _ptr = (PFN_GLNORMALPOINTEREXT)_getPrivateProcAddress("glNormalPointerEXT");
    if (!_ptr) {
        _ptr = &_fail_glNormalPointerEXT;
    }
    _glNormalPointerEXT = _ptr;
    _glNormalPointerEXT(type, stride, count, pointer);
}

PFN_GLNORMALPOINTEREXT _glNormalPointerEXT = &_get_glNormalPointerEXT;

static void APIENTRY _fail_glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer) {
    const char *_name = "glTexCoordPointerEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer) {
    PFN_GLTEXCOORDPOINTEREXT _ptr;
    _ptr = (PFN_GLTEXCOORDPOINTEREXT)_getPrivateProcAddress("glTexCoordPointerEXT");
    if (!_ptr) {
        _ptr = &_fail_glTexCoordPointerEXT;
    }
    _glTexCoordPointerEXT = _ptr;
    _glTexCoordPointerEXT(size, type, stride, count, pointer);
}

PFN_GLTEXCOORDPOINTEREXT _glTexCoordPointerEXT = &_get_glTexCoordPointerEXT;

static void APIENTRY _fail_glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer) {
    const char *_name = "glVertexPointerEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer) {
    PFN_GLVERTEXPOINTEREXT _ptr;
    _ptr = (PFN_GLVERTEXPOINTEREXT)_getPrivateProcAddress("glVertexPointerEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexPointerEXT;
    }
    _glVertexPointerEXT = _ptr;
    _glVertexPointerEXT(size, type, stride, count, pointer);
}

PFN_GLVERTEXPOINTEREXT _glVertexPointerEXT = &_get_glVertexPointerEXT;

static void APIENTRY _fail_glVertexAttribL1dEXT(GLuint index, GLdouble x) {
    const char *_name = "glVertexAttribL1dEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL1dEXT(GLuint index, GLdouble x) {
    PFN_GLVERTEXATTRIBL1DEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL1DEXT)_getPrivateProcAddress("glVertexAttribL1dEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL1dEXT;
    }
    _glVertexAttribL1dEXT = _ptr;
    _glVertexAttribL1dEXT(index, x);
}

PFN_GLVERTEXATTRIBL1DEXT _glVertexAttribL1dEXT = &_get_glVertexAttribL1dEXT;

static void APIENTRY _fail_glVertexAttribL2dEXT(GLuint index, GLdouble x, GLdouble y) {
    const char *_name = "glVertexAttribL2dEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL2dEXT(GLuint index, GLdouble x, GLdouble y) {
    PFN_GLVERTEXATTRIBL2DEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL2DEXT)_getPrivateProcAddress("glVertexAttribL2dEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL2dEXT;
    }
    _glVertexAttribL2dEXT = _ptr;
    _glVertexAttribL2dEXT(index, x, y);
}

PFN_GLVERTEXATTRIBL2DEXT _glVertexAttribL2dEXT = &_get_glVertexAttribL2dEXT;

static void APIENTRY _fail_glVertexAttribL3dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glVertexAttribL3dEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL3dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLVERTEXATTRIBL3DEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL3DEXT)_getPrivateProcAddress("glVertexAttribL3dEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL3dEXT;
    }
    _glVertexAttribL3dEXT = _ptr;
    _glVertexAttribL3dEXT(index, x, y, z);
}

PFN_GLVERTEXATTRIBL3DEXT _glVertexAttribL3dEXT = &_get_glVertexAttribL3dEXT;

static void APIENTRY _fail_glVertexAttribL4dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glVertexAttribL4dEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL4dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    PFN_GLVERTEXATTRIBL4DEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL4DEXT)_getPrivateProcAddress("glVertexAttribL4dEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL4dEXT;
    }
    _glVertexAttribL4dEXT = _ptr;
    _glVertexAttribL4dEXT(index, x, y, z, w);
}

PFN_GLVERTEXATTRIBL4DEXT _glVertexAttribL4dEXT = &_get_glVertexAttribL4dEXT;

static void APIENTRY _fail_glVertexAttribL1dvEXT(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttribL1dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL1dvEXT(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIBL1DVEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL1DVEXT)_getPrivateProcAddress("glVertexAttribL1dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL1dvEXT;
    }
    _glVertexAttribL1dvEXT = _ptr;
    _glVertexAttribL1dvEXT(index, v);
}

PFN_GLVERTEXATTRIBL1DVEXT _glVertexAttribL1dvEXT = &_get_glVertexAttribL1dvEXT;

static void APIENTRY _fail_glVertexAttribL2dvEXT(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttribL2dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL2dvEXT(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIBL2DVEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL2DVEXT)_getPrivateProcAddress("glVertexAttribL2dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL2dvEXT;
    }
    _glVertexAttribL2dvEXT = _ptr;
    _glVertexAttribL2dvEXT(index, v);
}

PFN_GLVERTEXATTRIBL2DVEXT _glVertexAttribL2dvEXT = &_get_glVertexAttribL2dvEXT;

static void APIENTRY _fail_glVertexAttribL3dvEXT(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttribL3dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL3dvEXT(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIBL3DVEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL3DVEXT)_getPrivateProcAddress("glVertexAttribL3dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL3dvEXT;
    }
    _glVertexAttribL3dvEXT = _ptr;
    _glVertexAttribL3dvEXT(index, v);
}

PFN_GLVERTEXATTRIBL3DVEXT _glVertexAttribL3dvEXT = &_get_glVertexAttribL3dvEXT;

static void APIENTRY _fail_glVertexAttribL4dvEXT(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttribL4dvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL4dvEXT(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIBL4DVEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL4DVEXT)_getPrivateProcAddress("glVertexAttribL4dvEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL4dvEXT;
    }
    _glVertexAttribL4dvEXT = _ptr;
    _glVertexAttribL4dvEXT(index, v);
}

PFN_GLVERTEXATTRIBL4DVEXT _glVertexAttribL4dvEXT = &_get_glVertexAttribL4dvEXT;

static void APIENTRY _fail_glVertexAttribLPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glVertexAttribLPointerEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribLPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLVERTEXATTRIBLPOINTEREXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBLPOINTEREXT)_getPrivateProcAddress("glVertexAttribLPointerEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribLPointerEXT;
    }
    _glVertexAttribLPointerEXT = _ptr;
    _glVertexAttribLPointerEXT(index, size, type, stride, pointer);
}

PFN_GLVERTEXATTRIBLPOINTEREXT _glVertexAttribLPointerEXT = &_get_glVertexAttribLPointerEXT;

static void APIENTRY _fail_glGetVertexAttribLdvEXT(GLuint index, GLenum pname, GLdouble * params) {
    const char *_name = "glGetVertexAttribLdvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribLdvEXT(GLuint index, GLenum pname, GLdouble * params) {
    PFN_GLGETVERTEXATTRIBLDVEXT _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBLDVEXT)_getPrivateProcAddress("glGetVertexAttribLdvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribLdvEXT;
    }
    _glGetVertexAttribLdvEXT = _ptr;
    _glGetVertexAttribLdvEXT(index, pname, params);
}

PFN_GLGETVERTEXATTRIBLDVEXT _glGetVertexAttribLdvEXT = &_get_glGetVertexAttribLdvEXT;

static void APIENTRY _fail_glBeginVertexShaderEXT(void) {
    const char *_name = "glBeginVertexShaderEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBeginVertexShaderEXT(void) {
    PFN_GLBEGINVERTEXSHADEREXT _ptr;
    _ptr = (PFN_GLBEGINVERTEXSHADEREXT)_getPrivateProcAddress("glBeginVertexShaderEXT");
    if (!_ptr) {
        _ptr = &_fail_glBeginVertexShaderEXT;
    }
    _glBeginVertexShaderEXT = _ptr;
    _glBeginVertexShaderEXT();
}

PFN_GLBEGINVERTEXSHADEREXT _glBeginVertexShaderEXT = &_get_glBeginVertexShaderEXT;

static void APIENTRY _fail_glEndVertexShaderEXT(void) {
    const char *_name = "glEndVertexShaderEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEndVertexShaderEXT(void) {
    PFN_GLENDVERTEXSHADEREXT _ptr;
    _ptr = (PFN_GLENDVERTEXSHADEREXT)_getPrivateProcAddress("glEndVertexShaderEXT");
    if (!_ptr) {
        _ptr = &_fail_glEndVertexShaderEXT;
    }
    _glEndVertexShaderEXT = _ptr;
    _glEndVertexShaderEXT();
}

PFN_GLENDVERTEXSHADEREXT _glEndVertexShaderEXT = &_get_glEndVertexShaderEXT;

static void APIENTRY _fail_glBindVertexShaderEXT(GLuint id) {
    const char *_name = "glBindVertexShaderEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindVertexShaderEXT(GLuint id) {
    PFN_GLBINDVERTEXSHADEREXT _ptr;
    _ptr = (PFN_GLBINDVERTEXSHADEREXT)_getPrivateProcAddress("glBindVertexShaderEXT");
    if (!_ptr) {
        _ptr = &_fail_glBindVertexShaderEXT;
    }
    _glBindVertexShaderEXT = _ptr;
    _glBindVertexShaderEXT(id);
}

PFN_GLBINDVERTEXSHADEREXT _glBindVertexShaderEXT = &_get_glBindVertexShaderEXT;

static GLuint APIENTRY _fail_glGenVertexShadersEXT(GLuint range) {
    const char *_name = "glGenVertexShadersEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glGenVertexShadersEXT(GLuint range) {
    PFN_GLGENVERTEXSHADERSEXT _ptr;
    _ptr = (PFN_GLGENVERTEXSHADERSEXT)_getPrivateProcAddress("glGenVertexShadersEXT");
    if (!_ptr) {
        _ptr = &_fail_glGenVertexShadersEXT;
    }
    _glGenVertexShadersEXT = _ptr;
    return _glGenVertexShadersEXT(range);
}

PFN_GLGENVERTEXSHADERSEXT _glGenVertexShadersEXT = &_get_glGenVertexShadersEXT;

static void APIENTRY _fail_glDeleteVertexShaderEXT(GLuint id) {
    const char *_name = "glDeleteVertexShaderEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteVertexShaderEXT(GLuint id) {
    PFN_GLDELETEVERTEXSHADEREXT _ptr;
    _ptr = (PFN_GLDELETEVERTEXSHADEREXT)_getPrivateProcAddress("glDeleteVertexShaderEXT");
    if (!_ptr) {
        _ptr = &_fail_glDeleteVertexShaderEXT;
    }
    _glDeleteVertexShaderEXT = _ptr;
    _glDeleteVertexShaderEXT(id);
}

PFN_GLDELETEVERTEXSHADEREXT _glDeleteVertexShaderEXT = &_get_glDeleteVertexShaderEXT;

static void APIENTRY _fail_glShaderOp1EXT(GLenum op, GLuint res, GLuint arg1) {
    const char *_name = "glShaderOp1EXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glShaderOp1EXT(GLenum op, GLuint res, GLuint arg1) {
    PFN_GLSHADEROP1EXT _ptr;
    _ptr = (PFN_GLSHADEROP1EXT)_getPrivateProcAddress("glShaderOp1EXT");
    if (!_ptr) {
        _ptr = &_fail_glShaderOp1EXT;
    }
    _glShaderOp1EXT = _ptr;
    _glShaderOp1EXT(op, res, arg1);
}

PFN_GLSHADEROP1EXT _glShaderOp1EXT = &_get_glShaderOp1EXT;

static void APIENTRY _fail_glShaderOp2EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2) {
    const char *_name = "glShaderOp2EXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glShaderOp2EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2) {
    PFN_GLSHADEROP2EXT _ptr;
    _ptr = (PFN_GLSHADEROP2EXT)_getPrivateProcAddress("glShaderOp2EXT");
    if (!_ptr) {
        _ptr = &_fail_glShaderOp2EXT;
    }
    _glShaderOp2EXT = _ptr;
    _glShaderOp2EXT(op, res, arg1, arg2);
}

PFN_GLSHADEROP2EXT _glShaderOp2EXT = &_get_glShaderOp2EXT;

static void APIENTRY _fail_glShaderOp3EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3) {
    const char *_name = "glShaderOp3EXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glShaderOp3EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3) {
    PFN_GLSHADEROP3EXT _ptr;
    _ptr = (PFN_GLSHADEROP3EXT)_getPrivateProcAddress("glShaderOp3EXT");
    if (!_ptr) {
        _ptr = &_fail_glShaderOp3EXT;
    }
    _glShaderOp3EXT = _ptr;
    _glShaderOp3EXT(op, res, arg1, arg2, arg3);
}

PFN_GLSHADEROP3EXT _glShaderOp3EXT = &_get_glShaderOp3EXT;

static void APIENTRY _fail_glSwizzleEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW) {
    const char *_name = "glSwizzleEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSwizzleEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW) {
    PFN_GLSWIZZLEEXT _ptr;
    _ptr = (PFN_GLSWIZZLEEXT)_getPrivateProcAddress("glSwizzleEXT");
    if (!_ptr) {
        _ptr = &_fail_glSwizzleEXT;
    }
    _glSwizzleEXT = _ptr;
    _glSwizzleEXT(res, in, outX, outY, outZ, outW);
}

PFN_GLSWIZZLEEXT _glSwizzleEXT = &_get_glSwizzleEXT;

static void APIENTRY _fail_glWriteMaskEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW) {
    const char *_name = "glWriteMaskEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWriteMaskEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW) {
    PFN_GLWRITEMASKEXT _ptr;
    _ptr = (PFN_GLWRITEMASKEXT)_getPrivateProcAddress("glWriteMaskEXT");
    if (!_ptr) {
        _ptr = &_fail_glWriteMaskEXT;
    }
    _glWriteMaskEXT = _ptr;
    _glWriteMaskEXT(res, in, outX, outY, outZ, outW);
}

PFN_GLWRITEMASKEXT _glWriteMaskEXT = &_get_glWriteMaskEXT;

static void APIENTRY _fail_glInsertComponentEXT(GLuint res, GLuint src, GLuint num) {
    const char *_name = "glInsertComponentEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glInsertComponentEXT(GLuint res, GLuint src, GLuint num) {
    PFN_GLINSERTCOMPONENTEXT _ptr;
    _ptr = (PFN_GLINSERTCOMPONENTEXT)_getPrivateProcAddress("glInsertComponentEXT");
    if (!_ptr) {
        _ptr = &_fail_glInsertComponentEXT;
    }
    _glInsertComponentEXT = _ptr;
    _glInsertComponentEXT(res, src, num);
}

PFN_GLINSERTCOMPONENTEXT _glInsertComponentEXT = &_get_glInsertComponentEXT;

static void APIENTRY _fail_glExtractComponentEXT(GLuint res, GLuint src, GLuint num) {
    const char *_name = "glExtractComponentEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glExtractComponentEXT(GLuint res, GLuint src, GLuint num) {
    PFN_GLEXTRACTCOMPONENTEXT _ptr;
    _ptr = (PFN_GLEXTRACTCOMPONENTEXT)_getPrivateProcAddress("glExtractComponentEXT");
    if (!_ptr) {
        _ptr = &_fail_glExtractComponentEXT;
    }
    _glExtractComponentEXT = _ptr;
    _glExtractComponentEXT(res, src, num);
}

PFN_GLEXTRACTCOMPONENTEXT _glExtractComponentEXT = &_get_glExtractComponentEXT;

static GLuint APIENTRY _fail_glGenSymbolsEXT(GLenum datatype, GLenum storagetype, GLenum range, GLuint components) {
    const char *_name = "glGenSymbolsEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glGenSymbolsEXT(GLenum datatype, GLenum storagetype, GLenum range, GLuint components) {
    PFN_GLGENSYMBOLSEXT _ptr;
    _ptr = (PFN_GLGENSYMBOLSEXT)_getPrivateProcAddress("glGenSymbolsEXT");
    if (!_ptr) {
        _ptr = &_fail_glGenSymbolsEXT;
    }
    _glGenSymbolsEXT = _ptr;
    return _glGenSymbolsEXT(datatype, storagetype, range, components);
}

PFN_GLGENSYMBOLSEXT _glGenSymbolsEXT = &_get_glGenSymbolsEXT;

static void APIENTRY _fail_glSetInvariantEXT(GLuint id, GLenum type, const GLvoid * addr) {
    const char *_name = "glSetInvariantEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSetInvariantEXT(GLuint id, GLenum type, const GLvoid * addr) {
    PFN_GLSETINVARIANTEXT _ptr;
    _ptr = (PFN_GLSETINVARIANTEXT)_getPrivateProcAddress("glSetInvariantEXT");
    if (!_ptr) {
        _ptr = &_fail_glSetInvariantEXT;
    }
    _glSetInvariantEXT = _ptr;
    _glSetInvariantEXT(id, type, addr);
}

PFN_GLSETINVARIANTEXT _glSetInvariantEXT = &_get_glSetInvariantEXT;

static void APIENTRY _fail_glSetLocalConstantEXT(GLuint id, GLenum type, const GLvoid * addr) {
    const char *_name = "glSetLocalConstantEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSetLocalConstantEXT(GLuint id, GLenum type, const GLvoid * addr) {
    PFN_GLSETLOCALCONSTANTEXT _ptr;
    _ptr = (PFN_GLSETLOCALCONSTANTEXT)_getPrivateProcAddress("glSetLocalConstantEXT");
    if (!_ptr) {
        _ptr = &_fail_glSetLocalConstantEXT;
    }
    _glSetLocalConstantEXT = _ptr;
    _glSetLocalConstantEXT(id, type, addr);
}

PFN_GLSETLOCALCONSTANTEXT _glSetLocalConstantEXT = &_get_glSetLocalConstantEXT;

static void APIENTRY _fail_glVariantbvEXT(GLuint id, const GLbyte * addr) {
    const char *_name = "glVariantbvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVariantbvEXT(GLuint id, const GLbyte * addr) {
    PFN_GLVARIANTBVEXT _ptr;
    _ptr = (PFN_GLVARIANTBVEXT)_getPrivateProcAddress("glVariantbvEXT");
    if (!_ptr) {
        _ptr = &_fail_glVariantbvEXT;
    }
    _glVariantbvEXT = _ptr;
    _glVariantbvEXT(id, addr);
}

PFN_GLVARIANTBVEXT _glVariantbvEXT = &_get_glVariantbvEXT;

static void APIENTRY _fail_glVariantsvEXT(GLuint id, const GLshort * addr) {
    const char *_name = "glVariantsvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVariantsvEXT(GLuint id, const GLshort * addr) {
    PFN_GLVARIANTSVEXT _ptr;
    _ptr = (PFN_GLVARIANTSVEXT)_getPrivateProcAddress("glVariantsvEXT");
    if (!_ptr) {
        _ptr = &_fail_glVariantsvEXT;
    }
    _glVariantsvEXT = _ptr;
    _glVariantsvEXT(id, addr);
}

PFN_GLVARIANTSVEXT _glVariantsvEXT = &_get_glVariantsvEXT;

static void APIENTRY _fail_glVariantivEXT(GLuint id, const GLint * addr) {
    const char *_name = "glVariantivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVariantivEXT(GLuint id, const GLint * addr) {
    PFN_GLVARIANTIVEXT _ptr;
    _ptr = (PFN_GLVARIANTIVEXT)_getPrivateProcAddress("glVariantivEXT");
    if (!_ptr) {
        _ptr = &_fail_glVariantivEXT;
    }
    _glVariantivEXT = _ptr;
    _glVariantivEXT(id, addr);
}

PFN_GLVARIANTIVEXT _glVariantivEXT = &_get_glVariantivEXT;

static void APIENTRY _fail_glVariantfvEXT(GLuint id, const GLfloat * addr) {
    const char *_name = "glVariantfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVariantfvEXT(GLuint id, const GLfloat * addr) {
    PFN_GLVARIANTFVEXT _ptr;
    _ptr = (PFN_GLVARIANTFVEXT)_getPrivateProcAddress("glVariantfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glVariantfvEXT;
    }
    _glVariantfvEXT = _ptr;
    _glVariantfvEXT(id, addr);
}

PFN_GLVARIANTFVEXT _glVariantfvEXT = &_get_glVariantfvEXT;

static void APIENTRY _fail_glVariantdvEXT(GLuint id, const GLdouble * addr) {
    const char *_name = "glVariantdvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVariantdvEXT(GLuint id, const GLdouble * addr) {
    PFN_GLVARIANTDVEXT _ptr;
    _ptr = (PFN_GLVARIANTDVEXT)_getPrivateProcAddress("glVariantdvEXT");
    if (!_ptr) {
        _ptr = &_fail_glVariantdvEXT;
    }
    _glVariantdvEXT = _ptr;
    _glVariantdvEXT(id, addr);
}

PFN_GLVARIANTDVEXT _glVariantdvEXT = &_get_glVariantdvEXT;

static void APIENTRY _fail_glVariantubvEXT(GLuint id, const GLubyte * addr) {
    const char *_name = "glVariantubvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVariantubvEXT(GLuint id, const GLubyte * addr) {
    PFN_GLVARIANTUBVEXT _ptr;
    _ptr = (PFN_GLVARIANTUBVEXT)_getPrivateProcAddress("glVariantubvEXT");
    if (!_ptr) {
        _ptr = &_fail_glVariantubvEXT;
    }
    _glVariantubvEXT = _ptr;
    _glVariantubvEXT(id, addr);
}

PFN_GLVARIANTUBVEXT _glVariantubvEXT = &_get_glVariantubvEXT;

static void APIENTRY _fail_glVariantusvEXT(GLuint id, const GLushort * addr) {
    const char *_name = "glVariantusvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVariantusvEXT(GLuint id, const GLushort * addr) {
    PFN_GLVARIANTUSVEXT _ptr;
    _ptr = (PFN_GLVARIANTUSVEXT)_getPrivateProcAddress("glVariantusvEXT");
    if (!_ptr) {
        _ptr = &_fail_glVariantusvEXT;
    }
    _glVariantusvEXT = _ptr;
    _glVariantusvEXT(id, addr);
}

PFN_GLVARIANTUSVEXT _glVariantusvEXT = &_get_glVariantusvEXT;

static void APIENTRY _fail_glVariantuivEXT(GLuint id, const GLuint * addr) {
    const char *_name = "glVariantuivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVariantuivEXT(GLuint id, const GLuint * addr) {
    PFN_GLVARIANTUIVEXT _ptr;
    _ptr = (PFN_GLVARIANTUIVEXT)_getPrivateProcAddress("glVariantuivEXT");
    if (!_ptr) {
        _ptr = &_fail_glVariantuivEXT;
    }
    _glVariantuivEXT = _ptr;
    _glVariantuivEXT(id, addr);
}

PFN_GLVARIANTUIVEXT _glVariantuivEXT = &_get_glVariantuivEXT;

static void APIENTRY _fail_glVariantPointerEXT(GLuint id, GLenum type, GLuint stride, const GLvoid * addr) {
    const char *_name = "glVariantPointerEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVariantPointerEXT(GLuint id, GLenum type, GLuint stride, const GLvoid * addr) {
    PFN_GLVARIANTPOINTEREXT _ptr;
    _ptr = (PFN_GLVARIANTPOINTEREXT)_getPrivateProcAddress("glVariantPointerEXT");
    if (!_ptr) {
        _ptr = &_fail_glVariantPointerEXT;
    }
    _glVariantPointerEXT = _ptr;
    _glVariantPointerEXT(id, type, stride, addr);
}

PFN_GLVARIANTPOINTEREXT _glVariantPointerEXT = &_get_glVariantPointerEXT;

static void APIENTRY _fail_glEnableVariantClientStateEXT(GLuint id) {
    const char *_name = "glEnableVariantClientStateEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEnableVariantClientStateEXT(GLuint id) {
    PFN_GLENABLEVARIANTCLIENTSTATEEXT _ptr;
    _ptr = (PFN_GLENABLEVARIANTCLIENTSTATEEXT)_getPrivateProcAddress("glEnableVariantClientStateEXT");
    if (!_ptr) {
        _ptr = &_fail_glEnableVariantClientStateEXT;
    }
    _glEnableVariantClientStateEXT = _ptr;
    _glEnableVariantClientStateEXT(id);
}

PFN_GLENABLEVARIANTCLIENTSTATEEXT _glEnableVariantClientStateEXT = &_get_glEnableVariantClientStateEXT;

static void APIENTRY _fail_glDisableVariantClientStateEXT(GLuint id) {
    const char *_name = "glDisableVariantClientStateEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDisableVariantClientStateEXT(GLuint id) {
    PFN_GLDISABLEVARIANTCLIENTSTATEEXT _ptr;
    _ptr = (PFN_GLDISABLEVARIANTCLIENTSTATEEXT)_getPrivateProcAddress("glDisableVariantClientStateEXT");
    if (!_ptr) {
        _ptr = &_fail_glDisableVariantClientStateEXT;
    }
    _glDisableVariantClientStateEXT = _ptr;
    _glDisableVariantClientStateEXT(id);
}

PFN_GLDISABLEVARIANTCLIENTSTATEEXT _glDisableVariantClientStateEXT = &_get_glDisableVariantClientStateEXT;

static GLuint APIENTRY _fail_glBindLightParameterEXT(GLenum light, GLenum value) {
    const char *_name = "glBindLightParameterEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glBindLightParameterEXT(GLenum light, GLenum value) {
    PFN_GLBINDLIGHTPARAMETEREXT _ptr;
    _ptr = (PFN_GLBINDLIGHTPARAMETEREXT)_getPrivateProcAddress("glBindLightParameterEXT");
    if (!_ptr) {
        _ptr = &_fail_glBindLightParameterEXT;
    }
    _glBindLightParameterEXT = _ptr;
    return _glBindLightParameterEXT(light, value);
}

PFN_GLBINDLIGHTPARAMETEREXT _glBindLightParameterEXT = &_get_glBindLightParameterEXT;

static GLuint APIENTRY _fail_glBindMaterialParameterEXT(GLenum face, GLenum value) {
    const char *_name = "glBindMaterialParameterEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glBindMaterialParameterEXT(GLenum face, GLenum value) {
    PFN_GLBINDMATERIALPARAMETEREXT _ptr;
    _ptr = (PFN_GLBINDMATERIALPARAMETEREXT)_getPrivateProcAddress("glBindMaterialParameterEXT");
    if (!_ptr) {
        _ptr = &_fail_glBindMaterialParameterEXT;
    }
    _glBindMaterialParameterEXT = _ptr;
    return _glBindMaterialParameterEXT(face, value);
}

PFN_GLBINDMATERIALPARAMETEREXT _glBindMaterialParameterEXT = &_get_glBindMaterialParameterEXT;

static GLuint APIENTRY _fail_glBindTexGenParameterEXT(GLenum unit, GLenum coord, GLenum value) {
    const char *_name = "glBindTexGenParameterEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glBindTexGenParameterEXT(GLenum unit, GLenum coord, GLenum value) {
    PFN_GLBINDTEXGENPARAMETEREXT _ptr;
    _ptr = (PFN_GLBINDTEXGENPARAMETEREXT)_getPrivateProcAddress("glBindTexGenParameterEXT");
    if (!_ptr) {
        _ptr = &_fail_glBindTexGenParameterEXT;
    }
    _glBindTexGenParameterEXT = _ptr;
    return _glBindTexGenParameterEXT(unit, coord, value);
}

PFN_GLBINDTEXGENPARAMETEREXT _glBindTexGenParameterEXT = &_get_glBindTexGenParameterEXT;

static GLuint APIENTRY _fail_glBindTextureUnitParameterEXT(GLenum unit, GLenum value) {
    const char *_name = "glBindTextureUnitParameterEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glBindTextureUnitParameterEXT(GLenum unit, GLenum value) {
    PFN_GLBINDTEXTUREUNITPARAMETEREXT _ptr;
    _ptr = (PFN_GLBINDTEXTUREUNITPARAMETEREXT)_getPrivateProcAddress("glBindTextureUnitParameterEXT");
    if (!_ptr) {
        _ptr = &_fail_glBindTextureUnitParameterEXT;
    }
    _glBindTextureUnitParameterEXT = _ptr;
    return _glBindTextureUnitParameterEXT(unit, value);
}

PFN_GLBINDTEXTUREUNITPARAMETEREXT _glBindTextureUnitParameterEXT = &_get_glBindTextureUnitParameterEXT;

static GLuint APIENTRY _fail_glBindParameterEXT(GLenum value) {
    const char *_name = "glBindParameterEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glBindParameterEXT(GLenum value) {
    PFN_GLBINDPARAMETEREXT _ptr;
    _ptr = (PFN_GLBINDPARAMETEREXT)_getPrivateProcAddress("glBindParameterEXT");
    if (!_ptr) {
        _ptr = &_fail_glBindParameterEXT;
    }
    _glBindParameterEXT = _ptr;
    return _glBindParameterEXT(value);
}

PFN_GLBINDPARAMETEREXT _glBindParameterEXT = &_get_glBindParameterEXT;

static GLboolean APIENTRY _fail_glIsVariantEnabledEXT(GLuint id, GLenum cap) {
    const char *_name = "glIsVariantEnabledEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsVariantEnabledEXT(GLuint id, GLenum cap) {
    PFN_GLISVARIANTENABLEDEXT _ptr;
    _ptr = (PFN_GLISVARIANTENABLEDEXT)_getPrivateProcAddress("glIsVariantEnabledEXT");
    if (!_ptr) {
        _ptr = &_fail_glIsVariantEnabledEXT;
    }
    _glIsVariantEnabledEXT = _ptr;
    return _glIsVariantEnabledEXT(id, cap);
}

PFN_GLISVARIANTENABLEDEXT _glIsVariantEnabledEXT = &_get_glIsVariantEnabledEXT;

static void APIENTRY _fail_glGetVariantBooleanvEXT(GLuint id, GLenum value, GLboolean * data) {
    const char *_name = "glGetVariantBooleanvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVariantBooleanvEXT(GLuint id, GLenum value, GLboolean * data) {
    PFN_GLGETVARIANTBOOLEANVEXT _ptr;
    _ptr = (PFN_GLGETVARIANTBOOLEANVEXT)_getPrivateProcAddress("glGetVariantBooleanvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetVariantBooleanvEXT;
    }
    _glGetVariantBooleanvEXT = _ptr;
    _glGetVariantBooleanvEXT(id, value, data);
}

PFN_GLGETVARIANTBOOLEANVEXT _glGetVariantBooleanvEXT = &_get_glGetVariantBooleanvEXT;

static void APIENTRY _fail_glGetVariantIntegervEXT(GLuint id, GLenum value, GLint * data) {
    const char *_name = "glGetVariantIntegervEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVariantIntegervEXT(GLuint id, GLenum value, GLint * data) {
    PFN_GLGETVARIANTINTEGERVEXT _ptr;
    _ptr = (PFN_GLGETVARIANTINTEGERVEXT)_getPrivateProcAddress("glGetVariantIntegervEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetVariantIntegervEXT;
    }
    _glGetVariantIntegervEXT = _ptr;
    _glGetVariantIntegervEXT(id, value, data);
}

PFN_GLGETVARIANTINTEGERVEXT _glGetVariantIntegervEXT = &_get_glGetVariantIntegervEXT;

static void APIENTRY _fail_glGetVariantFloatvEXT(GLuint id, GLenum value, GLfloat * data) {
    const char *_name = "glGetVariantFloatvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVariantFloatvEXT(GLuint id, GLenum value, GLfloat * data) {
    PFN_GLGETVARIANTFLOATVEXT _ptr;
    _ptr = (PFN_GLGETVARIANTFLOATVEXT)_getPrivateProcAddress("glGetVariantFloatvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetVariantFloatvEXT;
    }
    _glGetVariantFloatvEXT = _ptr;
    _glGetVariantFloatvEXT(id, value, data);
}

PFN_GLGETVARIANTFLOATVEXT _glGetVariantFloatvEXT = &_get_glGetVariantFloatvEXT;

static void APIENTRY _fail_glGetVariantPointervEXT(GLuint id, GLenum value, GLvoid * * data) {
    const char *_name = "glGetVariantPointervEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVariantPointervEXT(GLuint id, GLenum value, GLvoid * * data) {
    PFN_GLGETVARIANTPOINTERVEXT _ptr;
    _ptr = (PFN_GLGETVARIANTPOINTERVEXT)_getPrivateProcAddress("glGetVariantPointervEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetVariantPointervEXT;
    }
    _glGetVariantPointervEXT = _ptr;
    _glGetVariantPointervEXT(id, value, data);
}

PFN_GLGETVARIANTPOINTERVEXT _glGetVariantPointervEXT = &_get_glGetVariantPointervEXT;

static void APIENTRY _fail_glGetInvariantBooleanvEXT(GLuint id, GLenum value, GLboolean * data) {
    const char *_name = "glGetInvariantBooleanvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetInvariantBooleanvEXT(GLuint id, GLenum value, GLboolean * data) {
    PFN_GLGETINVARIANTBOOLEANVEXT _ptr;
    _ptr = (PFN_GLGETINVARIANTBOOLEANVEXT)_getPrivateProcAddress("glGetInvariantBooleanvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetInvariantBooleanvEXT;
    }
    _glGetInvariantBooleanvEXT = _ptr;
    _glGetInvariantBooleanvEXT(id, value, data);
}

PFN_GLGETINVARIANTBOOLEANVEXT _glGetInvariantBooleanvEXT = &_get_glGetInvariantBooleanvEXT;

static void APIENTRY _fail_glGetInvariantIntegervEXT(GLuint id, GLenum value, GLint * data) {
    const char *_name = "glGetInvariantIntegervEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetInvariantIntegervEXT(GLuint id, GLenum value, GLint * data) {
    PFN_GLGETINVARIANTINTEGERVEXT _ptr;
    _ptr = (PFN_GLGETINVARIANTINTEGERVEXT)_getPrivateProcAddress("glGetInvariantIntegervEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetInvariantIntegervEXT;
    }
    _glGetInvariantIntegervEXT = _ptr;
    _glGetInvariantIntegervEXT(id, value, data);
}

PFN_GLGETINVARIANTINTEGERVEXT _glGetInvariantIntegervEXT = &_get_glGetInvariantIntegervEXT;

static void APIENTRY _fail_glGetInvariantFloatvEXT(GLuint id, GLenum value, GLfloat * data) {
    const char *_name = "glGetInvariantFloatvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetInvariantFloatvEXT(GLuint id, GLenum value, GLfloat * data) {
    PFN_GLGETINVARIANTFLOATVEXT _ptr;
    _ptr = (PFN_GLGETINVARIANTFLOATVEXT)_getPrivateProcAddress("glGetInvariantFloatvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetInvariantFloatvEXT;
    }
    _glGetInvariantFloatvEXT = _ptr;
    _glGetInvariantFloatvEXT(id, value, data);
}

PFN_GLGETINVARIANTFLOATVEXT _glGetInvariantFloatvEXT = &_get_glGetInvariantFloatvEXT;

static void APIENTRY _fail_glGetLocalConstantBooleanvEXT(GLuint id, GLenum value, GLboolean * data) {
    const char *_name = "glGetLocalConstantBooleanvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetLocalConstantBooleanvEXT(GLuint id, GLenum value, GLboolean * data) {
    PFN_GLGETLOCALCONSTANTBOOLEANVEXT _ptr;
    _ptr = (PFN_GLGETLOCALCONSTANTBOOLEANVEXT)_getPrivateProcAddress("glGetLocalConstantBooleanvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetLocalConstantBooleanvEXT;
    }
    _glGetLocalConstantBooleanvEXT = _ptr;
    _glGetLocalConstantBooleanvEXT(id, value, data);
}

PFN_GLGETLOCALCONSTANTBOOLEANVEXT _glGetLocalConstantBooleanvEXT = &_get_glGetLocalConstantBooleanvEXT;

static void APIENTRY _fail_glGetLocalConstantIntegervEXT(GLuint id, GLenum value, GLint * data) {
    const char *_name = "glGetLocalConstantIntegervEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetLocalConstantIntegervEXT(GLuint id, GLenum value, GLint * data) {
    PFN_GLGETLOCALCONSTANTINTEGERVEXT _ptr;
    _ptr = (PFN_GLGETLOCALCONSTANTINTEGERVEXT)_getPrivateProcAddress("glGetLocalConstantIntegervEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetLocalConstantIntegervEXT;
    }
    _glGetLocalConstantIntegervEXT = _ptr;
    _glGetLocalConstantIntegervEXT(id, value, data);
}

PFN_GLGETLOCALCONSTANTINTEGERVEXT _glGetLocalConstantIntegervEXT = &_get_glGetLocalConstantIntegervEXT;

static void APIENTRY _fail_glGetLocalConstantFloatvEXT(GLuint id, GLenum value, GLfloat * data) {
    const char *_name = "glGetLocalConstantFloatvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetLocalConstantFloatvEXT(GLuint id, GLenum value, GLfloat * data) {
    PFN_GLGETLOCALCONSTANTFLOATVEXT _ptr;
    _ptr = (PFN_GLGETLOCALCONSTANTFLOATVEXT)_getPrivateProcAddress("glGetLocalConstantFloatvEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetLocalConstantFloatvEXT;
    }
    _glGetLocalConstantFloatvEXT = _ptr;
    _glGetLocalConstantFloatvEXT(id, value, data);
}

PFN_GLGETLOCALCONSTANTFLOATVEXT _glGetLocalConstantFloatvEXT = &_get_glGetLocalConstantFloatvEXT;

static void APIENTRY _fail_glVertexWeightfEXT(GLfloat weight) {
    const char *_name = "glVertexWeightfEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexWeightfEXT(GLfloat weight) {
    PFN_GLVERTEXWEIGHTFEXT _ptr;
    _ptr = (PFN_GLVERTEXWEIGHTFEXT)_getPrivateProcAddress("glVertexWeightfEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexWeightfEXT;
    }
    _glVertexWeightfEXT = _ptr;
    _glVertexWeightfEXT(weight);
}

PFN_GLVERTEXWEIGHTFEXT _glVertexWeightfEXT = &_get_glVertexWeightfEXT;

static void APIENTRY _fail_glVertexWeightfvEXT(const GLfloat * weight) {
    const char *_name = "glVertexWeightfvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexWeightfvEXT(const GLfloat * weight) {
    PFN_GLVERTEXWEIGHTFVEXT _ptr;
    _ptr = (PFN_GLVERTEXWEIGHTFVEXT)_getPrivateProcAddress("glVertexWeightfvEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexWeightfvEXT;
    }
    _glVertexWeightfvEXT = _ptr;
    _glVertexWeightfvEXT(weight);
}

PFN_GLVERTEXWEIGHTFVEXT _glVertexWeightfvEXT = &_get_glVertexWeightfvEXT;

static void APIENTRY _fail_glVertexWeightPointerEXT(GLsizei size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glVertexWeightPointerEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexWeightPointerEXT(GLsizei size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLVERTEXWEIGHTPOINTEREXT _ptr;
    _ptr = (PFN_GLVERTEXWEIGHTPOINTEREXT)_getPrivateProcAddress("glVertexWeightPointerEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexWeightPointerEXT;
    }
    _glVertexWeightPointerEXT = _ptr;
    _glVertexWeightPointerEXT(size, type, stride, pointer);
}

PFN_GLVERTEXWEIGHTPOINTEREXT _glVertexWeightPointerEXT = &_get_glVertexWeightPointerEXT;

static GLsync APIENTRY _fail_glImportSyncEXT(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags) {
    const char *_name = "glImportSyncEXT";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLsync APIENTRY _get_glImportSyncEXT(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags) {
    PFN_GLIMPORTSYNCEXT _ptr;
    _ptr = (PFN_GLIMPORTSYNCEXT)_getPrivateProcAddress("glImportSyncEXT");
    if (!_ptr) {
        _ptr = &_fail_glImportSyncEXT;
    }
    _glImportSyncEXT = _ptr;
    return _glImportSyncEXT(external_sync_type, external_sync, flags);
}

PFN_GLIMPORTSYNCEXT _glImportSyncEXT = &_get_glImportSyncEXT;

static void APIENTRY _fail_glFrameTerminatorGREMEDY(void) {
    const char *_name = "glFrameTerminatorGREMEDY";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFrameTerminatorGREMEDY(void) {
    PFN_GLFRAMETERMINATORGREMEDY _ptr;
    _ptr = (PFN_GLFRAMETERMINATORGREMEDY)_getPrivateProcAddress("glFrameTerminatorGREMEDY");
    if (!_ptr) {
        _ptr = &_fail_glFrameTerminatorGREMEDY;
    }
    _glFrameTerminatorGREMEDY = _ptr;
    _glFrameTerminatorGREMEDY();
}

PFN_GLFRAMETERMINATORGREMEDY _glFrameTerminatorGREMEDY = &_get_glFrameTerminatorGREMEDY;

static void APIENTRY _fail_glStringMarkerGREMEDY(GLsizei len, const GLvoid * string) {
    const char *_name = "glStringMarkerGREMEDY";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStringMarkerGREMEDY(GLsizei len, const GLvoid * string) {
    PFN_GLSTRINGMARKERGREMEDY _ptr;
    _ptr = (PFN_GLSTRINGMARKERGREMEDY)_getPrivateProcAddress("glStringMarkerGREMEDY");
    if (!_ptr) {
        _ptr = &_fail_glStringMarkerGREMEDY;
    }
    _glStringMarkerGREMEDY = _ptr;
    _glStringMarkerGREMEDY(len, string);
}

PFN_GLSTRINGMARKERGREMEDY _glStringMarkerGREMEDY = &_get_glStringMarkerGREMEDY;

static void APIENTRY _fail_glImageTransformParameteriHP(GLenum target, GLenum pname, GLint param) {
    const char *_name = "glImageTransformParameteriHP";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glImageTransformParameteriHP(GLenum target, GLenum pname, GLint param) {
    PFN_GLIMAGETRANSFORMPARAMETERIHP _ptr;
    _ptr = (PFN_GLIMAGETRANSFORMPARAMETERIHP)_getPrivateProcAddress("glImageTransformParameteriHP");
    if (!_ptr) {
        _ptr = &_fail_glImageTransformParameteriHP;
    }
    _glImageTransformParameteriHP = _ptr;
    _glImageTransformParameteriHP(target, pname, param);
}

PFN_GLIMAGETRANSFORMPARAMETERIHP _glImageTransformParameteriHP = &_get_glImageTransformParameteriHP;

static void APIENTRY _fail_glImageTransformParameterfHP(GLenum target, GLenum pname, GLfloat param) {
    const char *_name = "glImageTransformParameterfHP";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glImageTransformParameterfHP(GLenum target, GLenum pname, GLfloat param) {
    PFN_GLIMAGETRANSFORMPARAMETERFHP _ptr;
    _ptr = (PFN_GLIMAGETRANSFORMPARAMETERFHP)_getPrivateProcAddress("glImageTransformParameterfHP");
    if (!_ptr) {
        _ptr = &_fail_glImageTransformParameterfHP;
    }
    _glImageTransformParameterfHP = _ptr;
    _glImageTransformParameterfHP(target, pname, param);
}

PFN_GLIMAGETRANSFORMPARAMETERFHP _glImageTransformParameterfHP = &_get_glImageTransformParameterfHP;

static void APIENTRY _fail_glImageTransformParameterivHP(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glImageTransformParameterivHP";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glImageTransformParameterivHP(GLenum target, GLenum pname, const GLint * params) {
    PFN_GLIMAGETRANSFORMPARAMETERIVHP _ptr;
    _ptr = (PFN_GLIMAGETRANSFORMPARAMETERIVHP)_getPrivateProcAddress("glImageTransformParameterivHP");
    if (!_ptr) {
        _ptr = &_fail_glImageTransformParameterivHP;
    }
    _glImageTransformParameterivHP = _ptr;
    _glImageTransformParameterivHP(target, pname, params);
}

PFN_GLIMAGETRANSFORMPARAMETERIVHP _glImageTransformParameterivHP = &_get_glImageTransformParameterivHP;

static void APIENTRY _fail_glImageTransformParameterfvHP(GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glImageTransformParameterfvHP";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glImageTransformParameterfvHP(GLenum target, GLenum pname, const GLfloat * params) {
    PFN_GLIMAGETRANSFORMPARAMETERFVHP _ptr;
    _ptr = (PFN_GLIMAGETRANSFORMPARAMETERFVHP)_getPrivateProcAddress("glImageTransformParameterfvHP");
    if (!_ptr) {
        _ptr = &_fail_glImageTransformParameterfvHP;
    }
    _glImageTransformParameterfvHP = _ptr;
    _glImageTransformParameterfvHP(target, pname, params);
}

PFN_GLIMAGETRANSFORMPARAMETERFVHP _glImageTransformParameterfvHP = &_get_glImageTransformParameterfvHP;

static void APIENTRY _fail_glGetImageTransformParameterivHP(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetImageTransformParameterivHP";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetImageTransformParameterivHP(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETIMAGETRANSFORMPARAMETERIVHP _ptr;
    _ptr = (PFN_GLGETIMAGETRANSFORMPARAMETERIVHP)_getPrivateProcAddress("glGetImageTransformParameterivHP");
    if (!_ptr) {
        _ptr = &_fail_glGetImageTransformParameterivHP;
    }
    _glGetImageTransformParameterivHP = _ptr;
    _glGetImageTransformParameterivHP(target, pname, params);
}

PFN_GLGETIMAGETRANSFORMPARAMETERIVHP _glGetImageTransformParameterivHP = &_get_glGetImageTransformParameterivHP;

static void APIENTRY _fail_glGetImageTransformParameterfvHP(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetImageTransformParameterfvHP";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetImageTransformParameterfvHP(GLenum target, GLenum pname, GLfloat * params) {
    PFN_GLGETIMAGETRANSFORMPARAMETERFVHP _ptr;
    _ptr = (PFN_GLGETIMAGETRANSFORMPARAMETERFVHP)_getPrivateProcAddress("glGetImageTransformParameterfvHP");
    if (!_ptr) {
        _ptr = &_fail_glGetImageTransformParameterfvHP;
    }
    _glGetImageTransformParameterfvHP = _ptr;
    _glGetImageTransformParameterfvHP(target, pname, params);
}

PFN_GLGETIMAGETRANSFORMPARAMETERFVHP _glGetImageTransformParameterfvHP = &_get_glGetImageTransformParameterfvHP;

static void APIENTRY _fail_glMultiModeDrawArraysIBM(const GLenum * mode, const GLint * first, const GLsizei * count, GLsizei primcount, GLint modestride) {
    const char *_name = "glMultiModeDrawArraysIBM";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiModeDrawArraysIBM(const GLenum * mode, const GLint * first, const GLsizei * count, GLsizei primcount, GLint modestride) {
    PFN_GLMULTIMODEDRAWARRAYSIBM _ptr;
    _ptr = (PFN_GLMULTIMODEDRAWARRAYSIBM)_getPrivateProcAddress("glMultiModeDrawArraysIBM");
    if (!_ptr) {
        _ptr = &_fail_glMultiModeDrawArraysIBM;
    }
    _glMultiModeDrawArraysIBM = _ptr;
    _glMultiModeDrawArraysIBM(mode, first, count, primcount, modestride);
}

PFN_GLMULTIMODEDRAWARRAYSIBM _glMultiModeDrawArraysIBM = &_get_glMultiModeDrawArraysIBM;

static void APIENTRY _fail_glMultiModeDrawElementsIBM(const GLenum * mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei primcount, GLint modestride) {
    const char *_name = "glMultiModeDrawElementsIBM";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiModeDrawElementsIBM(const GLenum * mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei primcount, GLint modestride) {
    PFN_GLMULTIMODEDRAWELEMENTSIBM _ptr;
    _ptr = (PFN_GLMULTIMODEDRAWELEMENTSIBM)_getPrivateProcAddress("glMultiModeDrawElementsIBM");
    if (!_ptr) {
        _ptr = &_fail_glMultiModeDrawElementsIBM;
    }
    _glMultiModeDrawElementsIBM = _ptr;
    _glMultiModeDrawElementsIBM(mode, count, type, indices, primcount, modestride);
}

PFN_GLMULTIMODEDRAWELEMENTSIBM _glMultiModeDrawElementsIBM = &_get_glMultiModeDrawElementsIBM;

static void APIENTRY _fail_glColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    const char *_name = "glColorPointerListIBM";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    PFN_GLCOLORPOINTERLISTIBM _ptr;
    _ptr = (PFN_GLCOLORPOINTERLISTIBM)_getPrivateProcAddress("glColorPointerListIBM");
    if (!_ptr) {
        _ptr = &_fail_glColorPointerListIBM;
    }
    _glColorPointerListIBM = _ptr;
    _glColorPointerListIBM(size, type, stride, pointer, ptrstride);
}

PFN_GLCOLORPOINTERLISTIBM _glColorPointerListIBM = &_get_glColorPointerListIBM;

static void APIENTRY _fail_glSecondaryColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    const char *_name = "glSecondaryColorPointerListIBM";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    PFN_GLSECONDARYCOLORPOINTERLISTIBM _ptr;
    _ptr = (PFN_GLSECONDARYCOLORPOINTERLISTIBM)_getPrivateProcAddress("glSecondaryColorPointerListIBM");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColorPointerListIBM;
    }
    _glSecondaryColorPointerListIBM = _ptr;
    _glSecondaryColorPointerListIBM(size, type, stride, pointer, ptrstride);
}

PFN_GLSECONDARYCOLORPOINTERLISTIBM _glSecondaryColorPointerListIBM = &_get_glSecondaryColorPointerListIBM;

static void APIENTRY _fail_glEdgeFlagPointerListIBM(GLint stride, const GLboolean * * pointer, GLint ptrstride) {
    const char *_name = "glEdgeFlagPointerListIBM";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEdgeFlagPointerListIBM(GLint stride, const GLboolean * * pointer, GLint ptrstride) {
    PFN_GLEDGEFLAGPOINTERLISTIBM _ptr;
    _ptr = (PFN_GLEDGEFLAGPOINTERLISTIBM)_getPrivateProcAddress("glEdgeFlagPointerListIBM");
    if (!_ptr) {
        _ptr = &_fail_glEdgeFlagPointerListIBM;
    }
    _glEdgeFlagPointerListIBM = _ptr;
    _glEdgeFlagPointerListIBM(stride, pointer, ptrstride);
}

PFN_GLEDGEFLAGPOINTERLISTIBM _glEdgeFlagPointerListIBM = &_get_glEdgeFlagPointerListIBM;

static void APIENTRY _fail_glFogCoordPointerListIBM(GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    const char *_name = "glFogCoordPointerListIBM";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogCoordPointerListIBM(GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    PFN_GLFOGCOORDPOINTERLISTIBM _ptr;
    _ptr = (PFN_GLFOGCOORDPOINTERLISTIBM)_getPrivateProcAddress("glFogCoordPointerListIBM");
    if (!_ptr) {
        _ptr = &_fail_glFogCoordPointerListIBM;
    }
    _glFogCoordPointerListIBM = _ptr;
    _glFogCoordPointerListIBM(type, stride, pointer, ptrstride);
}

PFN_GLFOGCOORDPOINTERLISTIBM _glFogCoordPointerListIBM = &_get_glFogCoordPointerListIBM;

static void APIENTRY _fail_glIndexPointerListIBM(GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    const char *_name = "glIndexPointerListIBM";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glIndexPointerListIBM(GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    PFN_GLINDEXPOINTERLISTIBM _ptr;
    _ptr = (PFN_GLINDEXPOINTERLISTIBM)_getPrivateProcAddress("glIndexPointerListIBM");
    if (!_ptr) {
        _ptr = &_fail_glIndexPointerListIBM;
    }
    _glIndexPointerListIBM = _ptr;
    _glIndexPointerListIBM(type, stride, pointer, ptrstride);
}

PFN_GLINDEXPOINTERLISTIBM _glIndexPointerListIBM = &_get_glIndexPointerListIBM;

static void APIENTRY _fail_glNormalPointerListIBM(GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    const char *_name = "glNormalPointerListIBM";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormalPointerListIBM(GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    PFN_GLNORMALPOINTERLISTIBM _ptr;
    _ptr = (PFN_GLNORMALPOINTERLISTIBM)_getPrivateProcAddress("glNormalPointerListIBM");
    if (!_ptr) {
        _ptr = &_fail_glNormalPointerListIBM;
    }
    _glNormalPointerListIBM = _ptr;
    _glNormalPointerListIBM(type, stride, pointer, ptrstride);
}

PFN_GLNORMALPOINTERLISTIBM _glNormalPointerListIBM = &_get_glNormalPointerListIBM;

static void APIENTRY _fail_glTexCoordPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    const char *_name = "glTexCoordPointerListIBM";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoordPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    PFN_GLTEXCOORDPOINTERLISTIBM _ptr;
    _ptr = (PFN_GLTEXCOORDPOINTERLISTIBM)_getPrivateProcAddress("glTexCoordPointerListIBM");
    if (!_ptr) {
        _ptr = &_fail_glTexCoordPointerListIBM;
    }
    _glTexCoordPointerListIBM = _ptr;
    _glTexCoordPointerListIBM(size, type, stride, pointer, ptrstride);
}

PFN_GLTEXCOORDPOINTERLISTIBM _glTexCoordPointerListIBM = &_get_glTexCoordPointerListIBM;

static void APIENTRY _fail_glVertexPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    const char *_name = "glVertexPointerListIBM";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid * * pointer, GLint ptrstride) {
    PFN_GLVERTEXPOINTERLISTIBM _ptr;
    _ptr = (PFN_GLVERTEXPOINTERLISTIBM)_getPrivateProcAddress("glVertexPointerListIBM");
    if (!_ptr) {
        _ptr = &_fail_glVertexPointerListIBM;
    }
    _glVertexPointerListIBM = _ptr;
    _glVertexPointerListIBM(size, type, stride, pointer, ptrstride);
}

PFN_GLVERTEXPOINTERLISTIBM _glVertexPointerListIBM = &_get_glVertexPointerListIBM;

static void APIENTRY _fail_glRenderbufferStorageMultisampleIMG(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glRenderbufferStorageMultisampleIMG";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRenderbufferStorageMultisampleIMG(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
    PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEIMG _ptr;
    _ptr = (PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEIMG)_getPrivateProcAddress("glRenderbufferStorageMultisampleIMG");
    if (!_ptr) {
        _ptr = &_fail_glRenderbufferStorageMultisampleIMG;
    }
    _glRenderbufferStorageMultisampleIMG = _ptr;
    _glRenderbufferStorageMultisampleIMG(target, samples, internalformat, width, height);
}

PFN_GLRENDERBUFFERSTORAGEMULTISAMPLEIMG _glRenderbufferStorageMultisampleIMG = &_get_glRenderbufferStorageMultisampleIMG;

static void APIENTRY _fail_glFramebufferTexture2DMultisampleIMG(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples) {
    const char *_name = "glFramebufferTexture2DMultisampleIMG";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferTexture2DMultisampleIMG(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples) {
    PFN_GLFRAMEBUFFERTEXTURE2DMULTISAMPLEIMG _ptr;
    _ptr = (PFN_GLFRAMEBUFFERTEXTURE2DMULTISAMPLEIMG)_getPrivateProcAddress("glFramebufferTexture2DMultisampleIMG");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferTexture2DMultisampleIMG;
    }
    _glFramebufferTexture2DMultisampleIMG = _ptr;
    _glFramebufferTexture2DMultisampleIMG(target, attachment, textarget, texture, level, samples);
}

PFN_GLFRAMEBUFFERTEXTURE2DMULTISAMPLEIMG _glFramebufferTexture2DMultisampleIMG = &_get_glFramebufferTexture2DMultisampleIMG;

static void APIENTRY _fail_glBlendFuncSeparateINGR(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) {
    const char *_name = "glBlendFuncSeparateINGR";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendFuncSeparateINGR(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) {
    PFN_GLBLENDFUNCSEPARATEINGR _ptr;
    _ptr = (PFN_GLBLENDFUNCSEPARATEINGR)_getPrivateProcAddress("glBlendFuncSeparateINGR");
    if (!_ptr) {
        _ptr = &_fail_glBlendFuncSeparateINGR;
    }
    _glBlendFuncSeparateINGR = _ptr;
    _glBlendFuncSeparateINGR(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

PFN_GLBLENDFUNCSEPARATEINGR _glBlendFuncSeparateINGR = &_get_glBlendFuncSeparateINGR;

static void APIENTRY _fail_glSyncTextureINTEL(GLuint texture) {
    const char *_name = "glSyncTextureINTEL";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSyncTextureINTEL(GLuint texture) {
    PFN_GLSYNCTEXTUREINTEL _ptr;
    _ptr = (PFN_GLSYNCTEXTUREINTEL)_getPrivateProcAddress("glSyncTextureINTEL");
    if (!_ptr) {
        _ptr = &_fail_glSyncTextureINTEL;
    }
    _glSyncTextureINTEL = _ptr;
    _glSyncTextureINTEL(texture);
}

PFN_GLSYNCTEXTUREINTEL _glSyncTextureINTEL = &_get_glSyncTextureINTEL;

static void APIENTRY _fail_glUnmapTexture2DINTEL(GLuint texture, GLint level) {
    const char *_name = "glUnmapTexture2DINTEL";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUnmapTexture2DINTEL(GLuint texture, GLint level) {
    PFN_GLUNMAPTEXTURE2DINTEL _ptr;
    _ptr = (PFN_GLUNMAPTEXTURE2DINTEL)_getPrivateProcAddress("glUnmapTexture2DINTEL");
    if (!_ptr) {
        _ptr = &_fail_glUnmapTexture2DINTEL;
    }
    _glUnmapTexture2DINTEL = _ptr;
    _glUnmapTexture2DINTEL(texture, level);
}

PFN_GLUNMAPTEXTURE2DINTEL _glUnmapTexture2DINTEL = &_get_glUnmapTexture2DINTEL;

static GLvoid * APIENTRY _fail_glMapTexture2DINTEL(GLuint texture, GLint level, GLbitfield access, GLint * stride, GLenum * layout) {
    const char *_name = "glMapTexture2DINTEL";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLvoid * APIENTRY _get_glMapTexture2DINTEL(GLuint texture, GLint level, GLbitfield access, GLint * stride, GLenum * layout) {
    PFN_GLMAPTEXTURE2DINTEL _ptr;
    _ptr = (PFN_GLMAPTEXTURE2DINTEL)_getPrivateProcAddress("glMapTexture2DINTEL");
    if (!_ptr) {
        _ptr = &_fail_glMapTexture2DINTEL;
    }
    _glMapTexture2DINTEL = _ptr;
    return _glMapTexture2DINTEL(texture, level, access, stride, layout);
}

PFN_GLMAPTEXTURE2DINTEL _glMapTexture2DINTEL = &_get_glMapTexture2DINTEL;

static void APIENTRY _fail_glVertexPointervINTEL(GLint size, GLenum type, const GLvoid * * pointer) {
    const char *_name = "glVertexPointervINTEL";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexPointervINTEL(GLint size, GLenum type, const GLvoid * * pointer) {
    PFN_GLVERTEXPOINTERVINTEL _ptr;
    _ptr = (PFN_GLVERTEXPOINTERVINTEL)_getPrivateProcAddress("glVertexPointervINTEL");
    if (!_ptr) {
        _ptr = &_fail_glVertexPointervINTEL;
    }
    _glVertexPointervINTEL = _ptr;
    _glVertexPointervINTEL(size, type, pointer);
}

PFN_GLVERTEXPOINTERVINTEL _glVertexPointervINTEL = &_get_glVertexPointervINTEL;

static void APIENTRY _fail_glNormalPointervINTEL(GLenum type, const GLvoid * * pointer) {
    const char *_name = "glNormalPointervINTEL";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormalPointervINTEL(GLenum type, const GLvoid * * pointer) {
    PFN_GLNORMALPOINTERVINTEL _ptr;
    _ptr = (PFN_GLNORMALPOINTERVINTEL)_getPrivateProcAddress("glNormalPointervINTEL");
    if (!_ptr) {
        _ptr = &_fail_glNormalPointervINTEL;
    }
    _glNormalPointervINTEL = _ptr;
    _glNormalPointervINTEL(type, pointer);
}

PFN_GLNORMALPOINTERVINTEL _glNormalPointervINTEL = &_get_glNormalPointervINTEL;

static void APIENTRY _fail_glColorPointervINTEL(GLint size, GLenum type, const GLvoid * * pointer) {
    const char *_name = "glColorPointervINTEL";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorPointervINTEL(GLint size, GLenum type, const GLvoid * * pointer) {
    PFN_GLCOLORPOINTERVINTEL _ptr;
    _ptr = (PFN_GLCOLORPOINTERVINTEL)_getPrivateProcAddress("glColorPointervINTEL");
    if (!_ptr) {
        _ptr = &_fail_glColorPointervINTEL;
    }
    _glColorPointervINTEL = _ptr;
    _glColorPointervINTEL(size, type, pointer);
}

PFN_GLCOLORPOINTERVINTEL _glColorPointervINTEL = &_get_glColorPointervINTEL;

static void APIENTRY _fail_glTexCoordPointervINTEL(GLint size, GLenum type, const GLvoid * * pointer) {
    const char *_name = "glTexCoordPointervINTEL";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoordPointervINTEL(GLint size, GLenum type, const GLvoid * * pointer) {
    PFN_GLTEXCOORDPOINTERVINTEL _ptr;
    _ptr = (PFN_GLTEXCOORDPOINTERVINTEL)_getPrivateProcAddress("glTexCoordPointervINTEL");
    if (!_ptr) {
        _ptr = &_fail_glTexCoordPointervINTEL;
    }
    _glTexCoordPointervINTEL = _ptr;
    _glTexCoordPointervINTEL(size, type, pointer);
}

PFN_GLTEXCOORDPOINTERVINTEL _glTexCoordPointervINTEL = &_get_glTexCoordPointervINTEL;

static void APIENTRY _fail_glBeginPerfQueryINTEL(GLuint queryHandle) {
    const char *_name = "glBeginPerfQueryINTEL";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBeginPerfQueryINTEL(GLuint queryHandle) {
    PFN_GLBEGINPERFQUERYINTEL _ptr;
    _ptr = (PFN_GLBEGINPERFQUERYINTEL)_getPrivateProcAddress("glBeginPerfQueryINTEL");
    if (!_ptr) {
        _ptr = &_fail_glBeginPerfQueryINTEL;
    }
    _glBeginPerfQueryINTEL = _ptr;
    _glBeginPerfQueryINTEL(queryHandle);
}

PFN_GLBEGINPERFQUERYINTEL _glBeginPerfQueryINTEL = &_get_glBeginPerfQueryINTEL;

static void APIENTRY _fail_glCreatePerfQueryINTEL(GLuint queryId, GLuint * queryHandle) {
    const char *_name = "glCreatePerfQueryINTEL";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCreatePerfQueryINTEL(GLuint queryId, GLuint * queryHandle) {
    PFN_GLCREATEPERFQUERYINTEL _ptr;
    _ptr = (PFN_GLCREATEPERFQUERYINTEL)_getPrivateProcAddress("glCreatePerfQueryINTEL");
    if (!_ptr) {
        _ptr = &_fail_glCreatePerfQueryINTEL;
    }
    _glCreatePerfQueryINTEL = _ptr;
    _glCreatePerfQueryINTEL(queryId, queryHandle);
}

PFN_GLCREATEPERFQUERYINTEL _glCreatePerfQueryINTEL = &_get_glCreatePerfQueryINTEL;

static void APIENTRY _fail_glDeletePerfQueryINTEL(GLuint queryHandle) {
    const char *_name = "glDeletePerfQueryINTEL";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeletePerfQueryINTEL(GLuint queryHandle) {
    PFN_GLDELETEPERFQUERYINTEL _ptr;
    _ptr = (PFN_GLDELETEPERFQUERYINTEL)_getPrivateProcAddress("glDeletePerfQueryINTEL");
    if (!_ptr) {
        _ptr = &_fail_glDeletePerfQueryINTEL;
    }
    _glDeletePerfQueryINTEL = _ptr;
    _glDeletePerfQueryINTEL(queryHandle);
}

PFN_GLDELETEPERFQUERYINTEL _glDeletePerfQueryINTEL = &_get_glDeletePerfQueryINTEL;

static void APIENTRY _fail_glEndPerfQueryINTEL(GLuint queryHandle) {
    const char *_name = "glEndPerfQueryINTEL";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEndPerfQueryINTEL(GLuint queryHandle) {
    PFN_GLENDPERFQUERYINTEL _ptr;
    _ptr = (PFN_GLENDPERFQUERYINTEL)_getPrivateProcAddress("glEndPerfQueryINTEL");
    if (!_ptr) {
        _ptr = &_fail_glEndPerfQueryINTEL;
    }
    _glEndPerfQueryINTEL = _ptr;
    _glEndPerfQueryINTEL(queryHandle);
}

PFN_GLENDPERFQUERYINTEL _glEndPerfQueryINTEL = &_get_glEndPerfQueryINTEL;

static void APIENTRY _fail_glGetFirstPerfQueryIdINTEL(GLuint * queryId) {
    const char *_name = "glGetFirstPerfQueryIdINTEL";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFirstPerfQueryIdINTEL(GLuint * queryId) {
    PFN_GLGETFIRSTPERFQUERYIDINTEL _ptr;
    _ptr = (PFN_GLGETFIRSTPERFQUERYIDINTEL)_getPrivateProcAddress("glGetFirstPerfQueryIdINTEL");
    if (!_ptr) {
        _ptr = &_fail_glGetFirstPerfQueryIdINTEL;
    }
    _glGetFirstPerfQueryIdINTEL = _ptr;
    _glGetFirstPerfQueryIdINTEL(queryId);
}

PFN_GLGETFIRSTPERFQUERYIDINTEL _glGetFirstPerfQueryIdINTEL = &_get_glGetFirstPerfQueryIdINTEL;

static void APIENTRY _fail_glGetNextPerfQueryIdINTEL(GLuint queryId, GLuint * nextQueryId) {
    const char *_name = "glGetNextPerfQueryIdINTEL";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNextPerfQueryIdINTEL(GLuint queryId, GLuint * nextQueryId) {
    PFN_GLGETNEXTPERFQUERYIDINTEL _ptr;
    _ptr = (PFN_GLGETNEXTPERFQUERYIDINTEL)_getPrivateProcAddress("glGetNextPerfQueryIdINTEL");
    if (!_ptr) {
        _ptr = &_fail_glGetNextPerfQueryIdINTEL;
    }
    _glGetNextPerfQueryIdINTEL = _ptr;
    _glGetNextPerfQueryIdINTEL(queryId, nextQueryId);
}

PFN_GLGETNEXTPERFQUERYIDINTEL _glGetNextPerfQueryIdINTEL = &_get_glGetNextPerfQueryIdINTEL;

static void APIENTRY _fail_glGetPerfCounterInfoINTEL(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar * counterName, GLuint counterDescLength, GLchar * counterDesc, GLuint * counterOffset, GLuint * counterDataSize, GLuint * counterTypeEnum, GLuint * counterDataTypeEnum, GLuint64 * rawCounterMaxValue) {
    const char *_name = "glGetPerfCounterInfoINTEL";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPerfCounterInfoINTEL(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar * counterName, GLuint counterDescLength, GLchar * counterDesc, GLuint * counterOffset, GLuint * counterDataSize, GLuint * counterTypeEnum, GLuint * counterDataTypeEnum, GLuint64 * rawCounterMaxValue) {
    PFN_GLGETPERFCOUNTERINFOINTEL _ptr;
    _ptr = (PFN_GLGETPERFCOUNTERINFOINTEL)_getPrivateProcAddress("glGetPerfCounterInfoINTEL");
    if (!_ptr) {
        _ptr = &_fail_glGetPerfCounterInfoINTEL;
    }
    _glGetPerfCounterInfoINTEL = _ptr;
    _glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
}

PFN_GLGETPERFCOUNTERINFOINTEL _glGetPerfCounterInfoINTEL = &_get_glGetPerfCounterInfoINTEL;

static void APIENTRY _fail_glGetPerfQueryDataINTEL(GLuint queryHandle, GLuint flags, GLsizei dataSize, GLvoid * data, GLuint * bytesWritten) {
    const char *_name = "glGetPerfQueryDataINTEL";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPerfQueryDataINTEL(GLuint queryHandle, GLuint flags, GLsizei dataSize, GLvoid * data, GLuint * bytesWritten) {
    PFN_GLGETPERFQUERYDATAINTEL _ptr;
    _ptr = (PFN_GLGETPERFQUERYDATAINTEL)_getPrivateProcAddress("glGetPerfQueryDataINTEL");
    if (!_ptr) {
        _ptr = &_fail_glGetPerfQueryDataINTEL;
    }
    _glGetPerfQueryDataINTEL = _ptr;
    _glGetPerfQueryDataINTEL(queryHandle, flags, dataSize, data, bytesWritten);
}

PFN_GLGETPERFQUERYDATAINTEL _glGetPerfQueryDataINTEL = &_get_glGetPerfQueryDataINTEL;

static void APIENTRY _fail_glGetPerfQueryIdByNameINTEL(GLchar * queryName, GLuint * queryId) {
    const char *_name = "glGetPerfQueryIdByNameINTEL";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPerfQueryIdByNameINTEL(GLchar * queryName, GLuint * queryId) {
    PFN_GLGETPERFQUERYIDBYNAMEINTEL _ptr;
    _ptr = (PFN_GLGETPERFQUERYIDBYNAMEINTEL)_getPrivateProcAddress("glGetPerfQueryIdByNameINTEL");
    if (!_ptr) {
        _ptr = &_fail_glGetPerfQueryIdByNameINTEL;
    }
    _glGetPerfQueryIdByNameINTEL = _ptr;
    _glGetPerfQueryIdByNameINTEL(queryName, queryId);
}

PFN_GLGETPERFQUERYIDBYNAMEINTEL _glGetPerfQueryIdByNameINTEL = &_get_glGetPerfQueryIdByNameINTEL;

static void APIENTRY _fail_glGetPerfQueryInfoINTEL(GLuint queryId, GLuint queryNameLength, GLchar * queryName, GLuint * dataSize, GLuint * noCounters, GLuint * noInstances, GLuint * capsMask) {
    const char *_name = "glGetPerfQueryInfoINTEL";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPerfQueryInfoINTEL(GLuint queryId, GLuint queryNameLength, GLchar * queryName, GLuint * dataSize, GLuint * noCounters, GLuint * noInstances, GLuint * capsMask) {
    PFN_GLGETPERFQUERYINFOINTEL _ptr;
    _ptr = (PFN_GLGETPERFQUERYINFOINTEL)_getPrivateProcAddress("glGetPerfQueryInfoINTEL");
    if (!_ptr) {
        _ptr = &_fail_glGetPerfQueryInfoINTEL;
    }
    _glGetPerfQueryInfoINTEL = _ptr;
    _glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
}

PFN_GLGETPERFQUERYINFOINTEL _glGetPerfQueryInfoINTEL = &_get_glGetPerfQueryInfoINTEL;

static void APIENTRY _fail_glBlendBarrierKHR(void) {
    const char *_name = "glBlendBarrierKHR";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendBarrierKHR(void) {
    PFN_GLBLENDBARRIERKHR _ptr;
    _ptr = (PFN_GLBLENDBARRIERKHR)_getPrivateProcAddress("glBlendBarrierKHR");
    if (!_ptr) {
        _ptr = &_fail_glBlendBarrierKHR;
    }
    _glBlendBarrierKHR = _ptr;
    _glBlendBarrierKHR();
}

PFN_GLBLENDBARRIERKHR _glBlendBarrierKHR = &_get_glBlendBarrierKHR;

static void APIENTRY _fail_glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled) {
}

static void APIENTRY _get_glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled) {
    PFN_GLDEBUGMESSAGECONTROL _ptr;
    _ptr = (PFN_GLDEBUGMESSAGECONTROL)_getPrivateProcAddress("glDebugMessageControl");
    if (!_ptr) {
        _ptr = &_fail_glDebugMessageControl;
    }
    _glDebugMessageControl = _ptr;
    _glDebugMessageControl(source, type, severity, count, ids, enabled);
}

PFN_GLDEBUGMESSAGECONTROL _glDebugMessageControl = &_get_glDebugMessageControl;

static void APIENTRY _fail_glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf) {
}

static void APIENTRY _get_glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf) {
    PFN_GLDEBUGMESSAGEINSERT _ptr;
    _ptr = (PFN_GLDEBUGMESSAGEINSERT)_getPrivateProcAddress("glDebugMessageInsert");
    if (!_ptr) {
        _ptr = &_fail_glDebugMessageInsert;
    }
    _glDebugMessageInsert = _ptr;
    _glDebugMessageInsert(source, type, id, severity, length, buf);
}

PFN_GLDEBUGMESSAGEINSERT _glDebugMessageInsert = &_get_glDebugMessageInsert;

static void APIENTRY _fail_glDebugMessageCallback(GLDEBUGPROC callback, const void * userParam) {
}

static void APIENTRY _get_glDebugMessageCallback(GLDEBUGPROC callback, const void * userParam) {
    PFN_GLDEBUGMESSAGECALLBACK _ptr;
    _ptr = (PFN_GLDEBUGMESSAGECALLBACK)_getPrivateProcAddress("glDebugMessageCallback");
    if (!_ptr) {
        _ptr = &_fail_glDebugMessageCallback;
    }
    _glDebugMessageCallback = _ptr;
    _glDebugMessageCallback(callback, userParam);
}

PFN_GLDEBUGMESSAGECALLBACK _glDebugMessageCallback = &_get_glDebugMessageCallback;

static GLuint APIENTRY _fail_glGetDebugMessageLog(GLuint count, GLsizei bufsize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog) {
    if (sources != 0) *sources = 0;
    if (types != 0) *types = 0;
    if (ids != 0) *ids = 0;
    if (severities != 0) *severities = 0;
    if (lengths != 0) *lengths = 0;
    if (messageLog != 0 && bufsize > 0) *messageLog = 0;
    return 0;
}

static GLuint APIENTRY _get_glGetDebugMessageLog(GLuint count, GLsizei bufsize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog) {
    PFN_GLGETDEBUGMESSAGELOG _ptr;
    _ptr = (PFN_GLGETDEBUGMESSAGELOG)_getPrivateProcAddress("glGetDebugMessageLog");
    if (!_ptr) {
        _ptr = &_fail_glGetDebugMessageLog;
    }
    _glGetDebugMessageLog = _ptr;
    return _glGetDebugMessageLog(count, bufsize, sources, types, ids, severities, lengths, messageLog);
}

PFN_GLGETDEBUGMESSAGELOG _glGetDebugMessageLog = &_get_glGetDebugMessageLog;

static void APIENTRY _fail_glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const GLchar * message) {
}

static void APIENTRY _get_glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const GLchar * message) {
    PFN_GLPUSHDEBUGGROUP _ptr;
    _ptr = (PFN_GLPUSHDEBUGGROUP)_getPrivateProcAddress("glPushDebugGroup");
    if (!_ptr) {
        _ptr = &_fail_glPushDebugGroup;
    }
    _glPushDebugGroup = _ptr;
    _glPushDebugGroup(source, id, length, message);
}

PFN_GLPUSHDEBUGGROUP _glPushDebugGroup = &_get_glPushDebugGroup;

static void APIENTRY _fail_glPopDebugGroup(void) {
}

static void APIENTRY _get_glPopDebugGroup(void) {
    PFN_GLPOPDEBUGGROUP _ptr;
    _ptr = (PFN_GLPOPDEBUGGROUP)_getPrivateProcAddress("glPopDebugGroup");
    if (!_ptr) {
        _ptr = &_fail_glPopDebugGroup;
    }
    _glPopDebugGroup = _ptr;
    _glPopDebugGroup();
}

PFN_GLPOPDEBUGGROUP _glPopDebugGroup = &_get_glPopDebugGroup;

static void APIENTRY _fail_glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const GLchar * label) {
}

static void APIENTRY _get_glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const GLchar * label) {
    PFN_GLOBJECTLABEL _ptr;
    _ptr = (PFN_GLOBJECTLABEL)_getPrivateProcAddress("glObjectLabel");
    if (!_ptr) {
        _ptr = &_fail_glObjectLabel;
    }
    _glObjectLabel = _ptr;
    _glObjectLabel(identifier, name, length, label);
}

PFN_GLOBJECTLABEL _glObjectLabel = &_get_glObjectLabel;

static void APIENTRY _fail_glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, GLchar * label) {
    if (length != 0) *length = 0;
    if (label != 0 && bufSize > 0) *label = 0;
}

static void APIENTRY _get_glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, GLchar * label) {
    PFN_GLGETOBJECTLABEL _ptr;
    _ptr = (PFN_GLGETOBJECTLABEL)_getPrivateProcAddress("glGetObjectLabel");
    if (!_ptr) {
        _ptr = &_fail_glGetObjectLabel;
    }
    _glGetObjectLabel = _ptr;
    _glGetObjectLabel(identifier, name, bufSize, length, label);
}

PFN_GLGETOBJECTLABEL _glGetObjectLabel = &_get_glGetObjectLabel;

static void APIENTRY _fail_glObjectPtrLabel(const void * ptr, GLsizei length, const GLchar * label) {
}

static void APIENTRY _get_glObjectPtrLabel(const void * ptr, GLsizei length, const GLchar * label) {
    PFN_GLOBJECTPTRLABEL _ptr;
    _ptr = (PFN_GLOBJECTPTRLABEL)_getPrivateProcAddress("glObjectPtrLabel");
    if (!_ptr) {
        _ptr = &_fail_glObjectPtrLabel;
    }
    _glObjectPtrLabel = _ptr;
    _glObjectPtrLabel(ptr, length, label);
}

PFN_GLOBJECTPTRLABEL _glObjectPtrLabel = &_get_glObjectPtrLabel;

static void APIENTRY _fail_glGetObjectPtrLabel(const void * ptr, GLsizei bufSize, GLsizei * length, GLchar * label) {
    const char *_name = "glGetObjectPtrLabel";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetObjectPtrLabel(const void * ptr, GLsizei bufSize, GLsizei * length, GLchar * label) {
    PFN_GLGETOBJECTPTRLABEL _ptr;
    _ptr = (PFN_GLGETOBJECTPTRLABEL)_getPrivateProcAddress("glGetObjectPtrLabel");
    if (!_ptr) {
        _ptr = &_fail_glGetObjectPtrLabel;
    }
    _glGetObjectPtrLabel = _ptr;
    _glGetObjectPtrLabel(ptr, bufSize, length, label);
}

PFN_GLGETOBJECTPTRLABEL _glGetObjectPtrLabel = &_get_glGetObjectPtrLabel;

static void APIENTRY _fail_glDebugMessageControlKHR(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled) {
}

static void APIENTRY _get_glDebugMessageControlKHR(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled) {
    PFN_GLDEBUGMESSAGECONTROLKHR _ptr;
    _ptr = (PFN_GLDEBUGMESSAGECONTROLKHR)_getPrivateProcAddress("glDebugMessageControlKHR");
    if (!_ptr) {
        _ptr = &_fail_glDebugMessageControlKHR;
    }
    _glDebugMessageControlKHR = _ptr;
    _glDebugMessageControlKHR(source, type, severity, count, ids, enabled);
}

PFN_GLDEBUGMESSAGECONTROLKHR _glDebugMessageControlKHR = &_get_glDebugMessageControlKHR;

static void APIENTRY _fail_glDebugMessageInsertKHR(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf) {
}

static void APIENTRY _get_glDebugMessageInsertKHR(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf) {
    PFN_GLDEBUGMESSAGEINSERTKHR _ptr;
    _ptr = (PFN_GLDEBUGMESSAGEINSERTKHR)_getPrivateProcAddress("glDebugMessageInsertKHR");
    if (!_ptr) {
        _ptr = &_fail_glDebugMessageInsertKHR;
    }
    _glDebugMessageInsertKHR = _ptr;
    _glDebugMessageInsertKHR(source, type, id, severity, length, buf);
}

PFN_GLDEBUGMESSAGEINSERTKHR _glDebugMessageInsertKHR = &_get_glDebugMessageInsertKHR;

static void APIENTRY _fail_glDebugMessageCallbackKHR(GLDEBUGPROCKHR callback, const void * userParam) {
}

static void APIENTRY _get_glDebugMessageCallbackKHR(GLDEBUGPROCKHR callback, const void * userParam) {
    PFN_GLDEBUGMESSAGECALLBACKKHR _ptr;
    _ptr = (PFN_GLDEBUGMESSAGECALLBACKKHR)_getPrivateProcAddress("glDebugMessageCallbackKHR");
    if (!_ptr) {
        _ptr = &_fail_glDebugMessageCallbackKHR;
    }
    _glDebugMessageCallbackKHR = _ptr;
    _glDebugMessageCallbackKHR(callback, userParam);
}

PFN_GLDEBUGMESSAGECALLBACKKHR _glDebugMessageCallbackKHR = &_get_glDebugMessageCallbackKHR;

static GLuint APIENTRY _fail_glGetDebugMessageLogKHR(GLuint count, GLsizei bufsize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog) {
    if (sources != 0) *sources = 0;
    if (types != 0) *types = 0;
    if (ids != 0) *ids = 0;
    if (severities != 0) *severities = 0;
    if (lengths != 0) *lengths = 0;
    if (messageLog != 0 && bufsize > 0) *messageLog = 0;
    return 0;
}

static GLuint APIENTRY _get_glGetDebugMessageLogKHR(GLuint count, GLsizei bufsize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog) {
    PFN_GLGETDEBUGMESSAGELOGKHR _ptr;
    _ptr = (PFN_GLGETDEBUGMESSAGELOGKHR)_getPrivateProcAddress("glGetDebugMessageLogKHR");
    if (!_ptr) {
        _ptr = &_fail_glGetDebugMessageLogKHR;
    }
    _glGetDebugMessageLogKHR = _ptr;
    return _glGetDebugMessageLogKHR(count, bufsize, sources, types, ids, severities, lengths, messageLog);
}

PFN_GLGETDEBUGMESSAGELOGKHR _glGetDebugMessageLogKHR = &_get_glGetDebugMessageLogKHR;

static void APIENTRY _fail_glPushDebugGroupKHR(GLenum source, GLuint id, GLsizei length, const GLchar * message) {
}

static void APIENTRY _get_glPushDebugGroupKHR(GLenum source, GLuint id, GLsizei length, const GLchar * message) {
    PFN_GLPUSHDEBUGGROUPKHR _ptr;
    _ptr = (PFN_GLPUSHDEBUGGROUPKHR)_getPrivateProcAddress("glPushDebugGroupKHR");
    if (!_ptr) {
        _ptr = &_fail_glPushDebugGroupKHR;
    }
    _glPushDebugGroupKHR = _ptr;
    _glPushDebugGroupKHR(source, id, length, message);
}

PFN_GLPUSHDEBUGGROUPKHR _glPushDebugGroupKHR = &_get_glPushDebugGroupKHR;

static void APIENTRY _fail_glPopDebugGroupKHR(void) {
}

static void APIENTRY _get_glPopDebugGroupKHR(void) {
    PFN_GLPOPDEBUGGROUPKHR _ptr;
    _ptr = (PFN_GLPOPDEBUGGROUPKHR)_getPrivateProcAddress("glPopDebugGroupKHR");
    if (!_ptr) {
        _ptr = &_fail_glPopDebugGroupKHR;
    }
    _glPopDebugGroupKHR = _ptr;
    _glPopDebugGroupKHR();
}

PFN_GLPOPDEBUGGROUPKHR _glPopDebugGroupKHR = &_get_glPopDebugGroupKHR;

static void APIENTRY _fail_glObjectLabelKHR(GLenum identifier, GLuint name, GLsizei length, const GLchar * label) {
}

static void APIENTRY _get_glObjectLabelKHR(GLenum identifier, GLuint name, GLsizei length, const GLchar * label) {
    PFN_GLOBJECTLABELKHR _ptr;
    _ptr = (PFN_GLOBJECTLABELKHR)_getPrivateProcAddress("glObjectLabelKHR");
    if (!_ptr) {
        _ptr = &_fail_glObjectLabelKHR;
    }
    _glObjectLabelKHR = _ptr;
    _glObjectLabelKHR(identifier, name, length, label);
}

PFN_GLOBJECTLABELKHR _glObjectLabelKHR = &_get_glObjectLabelKHR;

static void APIENTRY _fail_glGetObjectLabelKHR(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, GLchar * label) {
    if (length != 0) *length = 0;
    if (label != 0 && bufSize > 0) *label = 0;
}

static void APIENTRY _get_glGetObjectLabelKHR(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, GLchar * label) {
    PFN_GLGETOBJECTLABELKHR _ptr;
    _ptr = (PFN_GLGETOBJECTLABELKHR)_getPrivateProcAddress("glGetObjectLabelKHR");
    if (!_ptr) {
        _ptr = &_fail_glGetObjectLabelKHR;
    }
    _glGetObjectLabelKHR = _ptr;
    _glGetObjectLabelKHR(identifier, name, bufSize, length, label);
}

PFN_GLGETOBJECTLABELKHR _glGetObjectLabelKHR = &_get_glGetObjectLabelKHR;

static void APIENTRY _fail_glObjectPtrLabelKHR(const void * ptr, GLsizei length, const GLchar * label) {
}

static void APIENTRY _get_glObjectPtrLabelKHR(const void * ptr, GLsizei length, const GLchar * label) {
    PFN_GLOBJECTPTRLABELKHR _ptr;
    _ptr = (PFN_GLOBJECTPTRLABELKHR)_getPrivateProcAddress("glObjectPtrLabelKHR");
    if (!_ptr) {
        _ptr = &_fail_glObjectPtrLabelKHR;
    }
    _glObjectPtrLabelKHR = _ptr;
    _glObjectPtrLabelKHR(ptr, length, label);
}

PFN_GLOBJECTPTRLABELKHR _glObjectPtrLabelKHR = &_get_glObjectPtrLabelKHR;

static void APIENTRY _fail_glGetObjectPtrLabelKHR(const void * ptr, GLsizei bufSize, GLsizei * length, GLchar * label) {
    const char *_name = "glGetObjectPtrLabelKHR";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetObjectPtrLabelKHR(const void * ptr, GLsizei bufSize, GLsizei * length, GLchar * label) {
    PFN_GLGETOBJECTPTRLABELKHR _ptr;
    _ptr = (PFN_GLGETOBJECTPTRLABELKHR)_getPrivateProcAddress("glGetObjectPtrLabelKHR");
    if (!_ptr) {
        _ptr = &_fail_glGetObjectPtrLabelKHR;
    }
    _glGetObjectPtrLabelKHR = _ptr;
    _glGetObjectPtrLabelKHR(ptr, bufSize, length, label);
}

PFN_GLGETOBJECTPTRLABELKHR _glGetObjectPtrLabelKHR = &_get_glGetObjectPtrLabelKHR;

static void APIENTRY _fail_glGetPointervKHR(GLenum pname, GLvoid * * params) {
    const char *_name = "glGetPointervKHR";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPointervKHR(GLenum pname, GLvoid * * params) {
    PFN_GLGETPOINTERVKHR _ptr;
    _ptr = (PFN_GLGETPOINTERVKHR)_getPrivateProcAddress("glGetPointervKHR");
    if (!_ptr) {
        _ptr = &_fail_glGetPointervKHR;
    }
    _glGetPointervKHR = _ptr;
    _glGetPointervKHR(pname, params);
}

PFN_GLGETPOINTERVKHR _glGetPointervKHR = &_get_glGetPointervKHR;

static GLenum APIENTRY _fail_glGetGraphicsResetStatus(void) {
    const char *_name = "glGetGraphicsResetStatus";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLenum APIENTRY _get_glGetGraphicsResetStatus(void) {
    PFN_GLGETGRAPHICSRESETSTATUS _ptr;
    _ptr = (PFN_GLGETGRAPHICSRESETSTATUS)_getPrivateProcAddress("glGetGraphicsResetStatus");
    if (!_ptr) {
        _ptr = &_fail_glGetGraphicsResetStatus;
    }
    _glGetGraphicsResetStatus = _ptr;
    return _glGetGraphicsResetStatus();
}

PFN_GLGETGRAPHICSRESETSTATUS _glGetGraphicsResetStatus = &_get_glGetGraphicsResetStatus;

static void APIENTRY _fail_glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid * data) {
    const char *_name = "glReadnPixels";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid * data) {
    PFN_GLREADNPIXELS _ptr;
    _ptr = (PFN_GLREADNPIXELS)_getPrivateProcAddress("glReadnPixels");
    if (!_ptr) {
        _ptr = &_fail_glReadnPixels;
    }
    _glReadnPixels = _ptr;
    _glReadnPixels(x, y, width, height, format, type, bufSize, data);
}

PFN_GLREADNPIXELS _glReadnPixels = &_get_glReadnPixels;

static void APIENTRY _fail_glGetnUniformfv(GLuint program, GLint location, GLsizei bufSize, GLfloat * params) {
    const char *_name = "glGetnUniformfv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnUniformfv(GLuint program, GLint location, GLsizei bufSize, GLfloat * params) {
    PFN_GLGETNUNIFORMFV _ptr;
    _ptr = (PFN_GLGETNUNIFORMFV)_getPrivateProcAddress("glGetnUniformfv");
    if (!_ptr) {
        _ptr = &_fail_glGetnUniformfv;
    }
    _glGetnUniformfv = _ptr;
    _glGetnUniformfv(program, location, bufSize, params);
}

PFN_GLGETNUNIFORMFV _glGetnUniformfv = &_get_glGetnUniformfv;

static void APIENTRY _fail_glGetnUniformiv(GLuint program, GLint location, GLsizei bufSize, GLint * params) {
    const char *_name = "glGetnUniformiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnUniformiv(GLuint program, GLint location, GLsizei bufSize, GLint * params) {
    PFN_GLGETNUNIFORMIV _ptr;
    _ptr = (PFN_GLGETNUNIFORMIV)_getPrivateProcAddress("glGetnUniformiv");
    if (!_ptr) {
        _ptr = &_fail_glGetnUniformiv;
    }
    _glGetnUniformiv = _ptr;
    _glGetnUniformiv(program, location, bufSize, params);
}

PFN_GLGETNUNIFORMIV _glGetnUniformiv = &_get_glGetnUniformiv;

static void APIENTRY _fail_glGetnUniformuiv(GLuint program, GLint location, GLsizei bufSize, GLuint * params) {
    const char *_name = "glGetnUniformuiv";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetnUniformuiv(GLuint program, GLint location, GLsizei bufSize, GLuint * params) {
    PFN_GLGETNUNIFORMUIV _ptr;
    _ptr = (PFN_GLGETNUNIFORMUIV)_getPrivateProcAddress("glGetnUniformuiv");
    if (!_ptr) {
        _ptr = &_fail_glGetnUniformuiv;
    }
    _glGetnUniformuiv = _ptr;
    _glGetnUniformuiv(program, location, bufSize, params);
}

PFN_GLGETNUNIFORMUIV _glGetnUniformuiv = &_get_glGetnUniformuiv;

static GLuint APIENTRY _fail_glNewBufferRegion(GLenum type) {
    const char *_name = "glNewBufferRegion";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glNewBufferRegion(GLenum type) {
    PFN_GLNEWBUFFERREGION _ptr;
    _ptr = (PFN_GLNEWBUFFERREGION)_getPrivateProcAddress("glNewBufferRegion");
    if (!_ptr) {
        _ptr = &_fail_glNewBufferRegion;
    }
    _glNewBufferRegion = _ptr;
    return _glNewBufferRegion(type);
}

PFN_GLNEWBUFFERREGION _glNewBufferRegion = &_get_glNewBufferRegion;

static void APIENTRY _fail_glDeleteBufferRegion(GLuint region) {
    const char *_name = "glDeleteBufferRegion";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteBufferRegion(GLuint region) {
    PFN_GLDELETEBUFFERREGION _ptr;
    _ptr = (PFN_GLDELETEBUFFERREGION)_getPrivateProcAddress("glDeleteBufferRegion");
    if (!_ptr) {
        _ptr = &_fail_glDeleteBufferRegion;
    }
    _glDeleteBufferRegion = _ptr;
    _glDeleteBufferRegion(region);
}

PFN_GLDELETEBUFFERREGION _glDeleteBufferRegion = &_get_glDeleteBufferRegion;

static void APIENTRY _fail_glReadBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glReadBufferRegion";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReadBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLREADBUFFERREGION _ptr;
    _ptr = (PFN_GLREADBUFFERREGION)_getPrivateProcAddress("glReadBufferRegion");
    if (!_ptr) {
        _ptr = &_fail_glReadBufferRegion;
    }
    _glReadBufferRegion = _ptr;
    _glReadBufferRegion(region, x, y, width, height);
}

PFN_GLREADBUFFERREGION _glReadBufferRegion = &_get_glReadBufferRegion;

static void APIENTRY _fail_glDrawBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest) {
    const char *_name = "glDrawBufferRegion";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest) {
    PFN_GLDRAWBUFFERREGION _ptr;
    _ptr = (PFN_GLDRAWBUFFERREGION)_getPrivateProcAddress("glDrawBufferRegion");
    if (!_ptr) {
        _ptr = &_fail_glDrawBufferRegion;
    }
    _glDrawBufferRegion = _ptr;
    _glDrawBufferRegion(region, x, y, width, height, xDest, yDest);
}

PFN_GLDRAWBUFFERREGION _glDrawBufferRegion = &_get_glDrawBufferRegion;

static GLuint APIENTRY _fail_glBufferRegionEnabled(void) {
    const char *_name = "glBufferRegionEnabled";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glBufferRegionEnabled(void) {
    PFN_GLBUFFERREGIONENABLED _ptr;
    _ptr = (PFN_GLBUFFERREGIONENABLED)_getPrivateProcAddress("glBufferRegionEnabled");
    if (!_ptr) {
        _ptr = &_fail_glBufferRegionEnabled;
    }
    _glBufferRegionEnabled = _ptr;
    return _glBufferRegionEnabled();
}

PFN_GLBUFFERREGIONENABLED _glBufferRegionEnabled = &_get_glBufferRegionEnabled;

static void APIENTRY _fail_glResizeBuffersMESA(void) {
    const char *_name = "glResizeBuffersMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glResizeBuffersMESA(void) {
    PFN_GLRESIZEBUFFERSMESA _ptr;
    _ptr = (PFN_GLRESIZEBUFFERSMESA)_getPrivateProcAddress("glResizeBuffersMESA");
    if (!_ptr) {
        _ptr = &_fail_glResizeBuffersMESA;
    }
    _glResizeBuffersMESA = _ptr;
    _glResizeBuffersMESA();
}

PFN_GLRESIZEBUFFERSMESA _glResizeBuffersMESA = &_get_glResizeBuffersMESA;

static void APIENTRY _fail_glWindowPos2dMESA(GLdouble x, GLdouble y) {
    const char *_name = "glWindowPos2dMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2dMESA(GLdouble x, GLdouble y) {
    PFN_GLWINDOWPOS2DMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS2DMESA)_getPrivateProcAddress("glWindowPos2dMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2dMESA;
    }
    _glWindowPos2dMESA = _ptr;
    _glWindowPos2dMESA(x, y);
}

PFN_GLWINDOWPOS2DMESA _glWindowPos2dMESA = &_get_glWindowPos2dMESA;

static void APIENTRY _fail_glWindowPos2dvMESA(const GLdouble * v) {
    const char *_name = "glWindowPos2dvMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2dvMESA(const GLdouble * v) {
    PFN_GLWINDOWPOS2DVMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS2DVMESA)_getPrivateProcAddress("glWindowPos2dvMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2dvMESA;
    }
    _glWindowPos2dvMESA = _ptr;
    _glWindowPos2dvMESA(v);
}

PFN_GLWINDOWPOS2DVMESA _glWindowPos2dvMESA = &_get_glWindowPos2dvMESA;

static void APIENTRY _fail_glWindowPos2fMESA(GLfloat x, GLfloat y) {
    const char *_name = "glWindowPos2fMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2fMESA(GLfloat x, GLfloat y) {
    PFN_GLWINDOWPOS2FMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS2FMESA)_getPrivateProcAddress("glWindowPos2fMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2fMESA;
    }
    _glWindowPos2fMESA = _ptr;
    _glWindowPos2fMESA(x, y);
}

PFN_GLWINDOWPOS2FMESA _glWindowPos2fMESA = &_get_glWindowPos2fMESA;

static void APIENTRY _fail_glWindowPos2fvMESA(const GLfloat * v) {
    const char *_name = "glWindowPos2fvMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2fvMESA(const GLfloat * v) {
    PFN_GLWINDOWPOS2FVMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS2FVMESA)_getPrivateProcAddress("glWindowPos2fvMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2fvMESA;
    }
    _glWindowPos2fvMESA = _ptr;
    _glWindowPos2fvMESA(v);
}

PFN_GLWINDOWPOS2FVMESA _glWindowPos2fvMESA = &_get_glWindowPos2fvMESA;

static void APIENTRY _fail_glWindowPos2iMESA(GLint x, GLint y) {
    const char *_name = "glWindowPos2iMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2iMESA(GLint x, GLint y) {
    PFN_GLWINDOWPOS2IMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS2IMESA)_getPrivateProcAddress("glWindowPos2iMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2iMESA;
    }
    _glWindowPos2iMESA = _ptr;
    _glWindowPos2iMESA(x, y);
}

PFN_GLWINDOWPOS2IMESA _glWindowPos2iMESA = &_get_glWindowPos2iMESA;

static void APIENTRY _fail_glWindowPos2ivMESA(const GLint * v) {
    const char *_name = "glWindowPos2ivMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2ivMESA(const GLint * v) {
    PFN_GLWINDOWPOS2IVMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS2IVMESA)_getPrivateProcAddress("glWindowPos2ivMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2ivMESA;
    }
    _glWindowPos2ivMESA = _ptr;
    _glWindowPos2ivMESA(v);
}

PFN_GLWINDOWPOS2IVMESA _glWindowPos2ivMESA = &_get_glWindowPos2ivMESA;

static void APIENTRY _fail_glWindowPos2sMESA(GLshort x, GLshort y) {
    const char *_name = "glWindowPos2sMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2sMESA(GLshort x, GLshort y) {
    PFN_GLWINDOWPOS2SMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS2SMESA)_getPrivateProcAddress("glWindowPos2sMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2sMESA;
    }
    _glWindowPos2sMESA = _ptr;
    _glWindowPos2sMESA(x, y);
}

PFN_GLWINDOWPOS2SMESA _glWindowPos2sMESA = &_get_glWindowPos2sMESA;

static void APIENTRY _fail_glWindowPos2svMESA(const GLshort * v) {
    const char *_name = "glWindowPos2svMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos2svMESA(const GLshort * v) {
    PFN_GLWINDOWPOS2SVMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS2SVMESA)_getPrivateProcAddress("glWindowPos2svMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos2svMESA;
    }
    _glWindowPos2svMESA = _ptr;
    _glWindowPos2svMESA(v);
}

PFN_GLWINDOWPOS2SVMESA _glWindowPos2svMESA = &_get_glWindowPos2svMESA;

static void APIENTRY _fail_glWindowPos3dMESA(GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glWindowPos3dMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3dMESA(GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLWINDOWPOS3DMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS3DMESA)_getPrivateProcAddress("glWindowPos3dMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3dMESA;
    }
    _glWindowPos3dMESA = _ptr;
    _glWindowPos3dMESA(x, y, z);
}

PFN_GLWINDOWPOS3DMESA _glWindowPos3dMESA = &_get_glWindowPos3dMESA;

static void APIENTRY _fail_glWindowPos3dvMESA(const GLdouble * v) {
    const char *_name = "glWindowPos3dvMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3dvMESA(const GLdouble * v) {
    PFN_GLWINDOWPOS3DVMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS3DVMESA)_getPrivateProcAddress("glWindowPos3dvMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3dvMESA;
    }
    _glWindowPos3dvMESA = _ptr;
    _glWindowPos3dvMESA(v);
}

PFN_GLWINDOWPOS3DVMESA _glWindowPos3dvMESA = &_get_glWindowPos3dvMESA;

static void APIENTRY _fail_glWindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glWindowPos3fMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLWINDOWPOS3FMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS3FMESA)_getPrivateProcAddress("glWindowPos3fMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3fMESA;
    }
    _glWindowPos3fMESA = _ptr;
    _glWindowPos3fMESA(x, y, z);
}

PFN_GLWINDOWPOS3FMESA _glWindowPos3fMESA = &_get_glWindowPos3fMESA;

static void APIENTRY _fail_glWindowPos3fvMESA(const GLfloat * v) {
    const char *_name = "glWindowPos3fvMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3fvMESA(const GLfloat * v) {
    PFN_GLWINDOWPOS3FVMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS3FVMESA)_getPrivateProcAddress("glWindowPos3fvMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3fvMESA;
    }
    _glWindowPos3fvMESA = _ptr;
    _glWindowPos3fvMESA(v);
}

PFN_GLWINDOWPOS3FVMESA _glWindowPos3fvMESA = &_get_glWindowPos3fvMESA;

static void APIENTRY _fail_glWindowPos3iMESA(GLint x, GLint y, GLint z) {
    const char *_name = "glWindowPos3iMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3iMESA(GLint x, GLint y, GLint z) {
    PFN_GLWINDOWPOS3IMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS3IMESA)_getPrivateProcAddress("glWindowPos3iMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3iMESA;
    }
    _glWindowPos3iMESA = _ptr;
    _glWindowPos3iMESA(x, y, z);
}

PFN_GLWINDOWPOS3IMESA _glWindowPos3iMESA = &_get_glWindowPos3iMESA;

static void APIENTRY _fail_glWindowPos3ivMESA(const GLint * v) {
    const char *_name = "glWindowPos3ivMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3ivMESA(const GLint * v) {
    PFN_GLWINDOWPOS3IVMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS3IVMESA)_getPrivateProcAddress("glWindowPos3ivMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3ivMESA;
    }
    _glWindowPos3ivMESA = _ptr;
    _glWindowPos3ivMESA(v);
}

PFN_GLWINDOWPOS3IVMESA _glWindowPos3ivMESA = &_get_glWindowPos3ivMESA;

static void APIENTRY _fail_glWindowPos3sMESA(GLshort x, GLshort y, GLshort z) {
    const char *_name = "glWindowPos3sMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3sMESA(GLshort x, GLshort y, GLshort z) {
    PFN_GLWINDOWPOS3SMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS3SMESA)_getPrivateProcAddress("glWindowPos3sMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3sMESA;
    }
    _glWindowPos3sMESA = _ptr;
    _glWindowPos3sMESA(x, y, z);
}

PFN_GLWINDOWPOS3SMESA _glWindowPos3sMESA = &_get_glWindowPos3sMESA;

static void APIENTRY _fail_glWindowPos3svMESA(const GLshort * v) {
    const char *_name = "glWindowPos3svMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos3svMESA(const GLshort * v) {
    PFN_GLWINDOWPOS3SVMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS3SVMESA)_getPrivateProcAddress("glWindowPos3svMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos3svMESA;
    }
    _glWindowPos3svMESA = _ptr;
    _glWindowPos3svMESA(v);
}

PFN_GLWINDOWPOS3SVMESA _glWindowPos3svMESA = &_get_glWindowPos3svMESA;

static void APIENTRY _fail_glWindowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glWindowPos4dMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    PFN_GLWINDOWPOS4DMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS4DMESA)_getPrivateProcAddress("glWindowPos4dMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos4dMESA;
    }
    _glWindowPos4dMESA = _ptr;
    _glWindowPos4dMESA(x, y, z, w);
}

PFN_GLWINDOWPOS4DMESA _glWindowPos4dMESA = &_get_glWindowPos4dMESA;

static void APIENTRY _fail_glWindowPos4dvMESA(const GLdouble * v) {
    const char *_name = "glWindowPos4dvMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos4dvMESA(const GLdouble * v) {
    PFN_GLWINDOWPOS4DVMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS4DVMESA)_getPrivateProcAddress("glWindowPos4dvMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos4dvMESA;
    }
    _glWindowPos4dvMESA = _ptr;
    _glWindowPos4dvMESA(v);
}

PFN_GLWINDOWPOS4DVMESA _glWindowPos4dvMESA = &_get_glWindowPos4dvMESA;

static void APIENTRY _fail_glWindowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glWindowPos4fMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    PFN_GLWINDOWPOS4FMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS4FMESA)_getPrivateProcAddress("glWindowPos4fMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos4fMESA;
    }
    _glWindowPos4fMESA = _ptr;
    _glWindowPos4fMESA(x, y, z, w);
}

PFN_GLWINDOWPOS4FMESA _glWindowPos4fMESA = &_get_glWindowPos4fMESA;

static void APIENTRY _fail_glWindowPos4fvMESA(const GLfloat * v) {
    const char *_name = "glWindowPos4fvMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos4fvMESA(const GLfloat * v) {
    PFN_GLWINDOWPOS4FVMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS4FVMESA)_getPrivateProcAddress("glWindowPos4fvMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos4fvMESA;
    }
    _glWindowPos4fvMESA = _ptr;
    _glWindowPos4fvMESA(v);
}

PFN_GLWINDOWPOS4FVMESA _glWindowPos4fvMESA = &_get_glWindowPos4fvMESA;

static void APIENTRY _fail_glWindowPos4iMESA(GLint x, GLint y, GLint z, GLint w) {
    const char *_name = "glWindowPos4iMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos4iMESA(GLint x, GLint y, GLint z, GLint w) {
    PFN_GLWINDOWPOS4IMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS4IMESA)_getPrivateProcAddress("glWindowPos4iMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos4iMESA;
    }
    _glWindowPos4iMESA = _ptr;
    _glWindowPos4iMESA(x, y, z, w);
}

PFN_GLWINDOWPOS4IMESA _glWindowPos4iMESA = &_get_glWindowPos4iMESA;

static void APIENTRY _fail_glWindowPos4ivMESA(const GLint * v) {
    const char *_name = "glWindowPos4ivMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos4ivMESA(const GLint * v) {
    PFN_GLWINDOWPOS4IVMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS4IVMESA)_getPrivateProcAddress("glWindowPos4ivMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos4ivMESA;
    }
    _glWindowPos4ivMESA = _ptr;
    _glWindowPos4ivMESA(v);
}

PFN_GLWINDOWPOS4IVMESA _glWindowPos4ivMESA = &_get_glWindowPos4ivMESA;

static void APIENTRY _fail_glWindowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w) {
    const char *_name = "glWindowPos4sMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w) {
    PFN_GLWINDOWPOS4SMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS4SMESA)_getPrivateProcAddress("glWindowPos4sMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos4sMESA;
    }
    _glWindowPos4sMESA = _ptr;
    _glWindowPos4sMESA(x, y, z, w);
}

PFN_GLWINDOWPOS4SMESA _glWindowPos4sMESA = &_get_glWindowPos4sMESA;

static void APIENTRY _fail_glWindowPos4svMESA(const GLshort * v) {
    const char *_name = "glWindowPos4svMESA";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWindowPos4svMESA(const GLshort * v) {
    PFN_GLWINDOWPOS4SVMESA _ptr;
    _ptr = (PFN_GLWINDOWPOS4SVMESA)_getPrivateProcAddress("glWindowPos4svMESA");
    if (!_ptr) {
        _ptr = &_fail_glWindowPos4svMESA;
    }
    _glWindowPos4svMESA = _ptr;
    _glWindowPos4svMESA(v);
}

PFN_GLWINDOWPOS4SVMESA _glWindowPos4svMESA = &_get_glWindowPos4svMESA;

static void APIENTRY _fail_glBeginConditionalRenderNVX(GLuint id) {
    const char *_name = "glBeginConditionalRenderNVX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBeginConditionalRenderNVX(GLuint id) {
    PFN_GLBEGINCONDITIONALRENDERNVX _ptr;
    _ptr = (PFN_GLBEGINCONDITIONALRENDERNVX)_getPrivateProcAddress("glBeginConditionalRenderNVX");
    if (!_ptr) {
        _ptr = &_fail_glBeginConditionalRenderNVX;
    }
    _glBeginConditionalRenderNVX = _ptr;
    _glBeginConditionalRenderNVX(id);
}

PFN_GLBEGINCONDITIONALRENDERNVX _glBeginConditionalRenderNVX = &_get_glBeginConditionalRenderNVX;

static void APIENTRY _fail_glEndConditionalRenderNVX(void) {
    const char *_name = "glEndConditionalRenderNVX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEndConditionalRenderNVX(void) {
    PFN_GLENDCONDITIONALRENDERNVX _ptr;
    _ptr = (PFN_GLENDCONDITIONALRENDERNVX)_getPrivateProcAddress("glEndConditionalRenderNVX");
    if (!_ptr) {
        _ptr = &_fail_glEndConditionalRenderNVX;
    }
    _glEndConditionalRenderNVX = _ptr;
    _glEndConditionalRenderNVX();
}

PFN_GLENDCONDITIONALRENDERNVX _glEndConditionalRenderNVX = &_get_glEndConditionalRenderNVX;

static void APIENTRY _fail_glMultiDrawArraysIndirectBindlessNV(GLenum mode, const GLvoid * indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount) {
    const char *_name = "glMultiDrawArraysIndirectBindlessNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiDrawArraysIndirectBindlessNV(GLenum mode, const GLvoid * indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount) {
    PFN_GLMULTIDRAWARRAYSINDIRECTBINDLESSNV _ptr;
    _ptr = (PFN_GLMULTIDRAWARRAYSINDIRECTBINDLESSNV)_getPrivateProcAddress("glMultiDrawArraysIndirectBindlessNV");
    if (!_ptr) {
        _ptr = &_fail_glMultiDrawArraysIndirectBindlessNV;
    }
    _glMultiDrawArraysIndirectBindlessNV = _ptr;
    _glMultiDrawArraysIndirectBindlessNV(mode, indirect, drawCount, stride, vertexBufferCount);
}

PFN_GLMULTIDRAWARRAYSINDIRECTBINDLESSNV _glMultiDrawArraysIndirectBindlessNV = &_get_glMultiDrawArraysIndirectBindlessNV;

static void APIENTRY _fail_glMultiDrawElementsIndirectBindlessNV(GLenum mode, GLenum type, const GLvoid * indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount) {
    const char *_name = "glMultiDrawElementsIndirectBindlessNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiDrawElementsIndirectBindlessNV(GLenum mode, GLenum type, const GLvoid * indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount) {
    PFN_GLMULTIDRAWELEMENTSINDIRECTBINDLESSNV _ptr;
    _ptr = (PFN_GLMULTIDRAWELEMENTSINDIRECTBINDLESSNV)_getPrivateProcAddress("glMultiDrawElementsIndirectBindlessNV");
    if (!_ptr) {
        _ptr = &_fail_glMultiDrawElementsIndirectBindlessNV;
    }
    _glMultiDrawElementsIndirectBindlessNV = _ptr;
    _glMultiDrawElementsIndirectBindlessNV(mode, type, indirect, drawCount, stride, vertexBufferCount);
}

PFN_GLMULTIDRAWELEMENTSINDIRECTBINDLESSNV _glMultiDrawElementsIndirectBindlessNV = &_get_glMultiDrawElementsIndirectBindlessNV;

static GLuint64 APIENTRY _fail_glGetTextureHandleNV(GLuint texture) {
    const char *_name = "glGetTextureHandleNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint64 APIENTRY _get_glGetTextureHandleNV(GLuint texture) {
    PFN_GLGETTEXTUREHANDLENV _ptr;
    _ptr = (PFN_GLGETTEXTUREHANDLENV)_getPrivateProcAddress("glGetTextureHandleNV");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureHandleNV;
    }
    _glGetTextureHandleNV = _ptr;
    return _glGetTextureHandleNV(texture);
}

PFN_GLGETTEXTUREHANDLENV _glGetTextureHandleNV = &_get_glGetTextureHandleNV;

static GLuint64 APIENTRY _fail_glGetTextureSamplerHandleNV(GLuint texture, GLuint sampler) {
    const char *_name = "glGetTextureSamplerHandleNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint64 APIENTRY _get_glGetTextureSamplerHandleNV(GLuint texture, GLuint sampler) {
    PFN_GLGETTEXTURESAMPLERHANDLENV _ptr;
    _ptr = (PFN_GLGETTEXTURESAMPLERHANDLENV)_getPrivateProcAddress("glGetTextureSamplerHandleNV");
    if (!_ptr) {
        _ptr = &_fail_glGetTextureSamplerHandleNV;
    }
    _glGetTextureSamplerHandleNV = _ptr;
    return _glGetTextureSamplerHandleNV(texture, sampler);
}

PFN_GLGETTEXTURESAMPLERHANDLENV _glGetTextureSamplerHandleNV = &_get_glGetTextureSamplerHandleNV;

static void APIENTRY _fail_glMakeTextureHandleResidentNV(GLuint64 handle) {
    const char *_name = "glMakeTextureHandleResidentNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMakeTextureHandleResidentNV(GLuint64 handle) {
    PFN_GLMAKETEXTUREHANDLERESIDENTNV _ptr;
    _ptr = (PFN_GLMAKETEXTUREHANDLERESIDENTNV)_getPrivateProcAddress("glMakeTextureHandleResidentNV");
    if (!_ptr) {
        _ptr = &_fail_glMakeTextureHandleResidentNV;
    }
    _glMakeTextureHandleResidentNV = _ptr;
    _glMakeTextureHandleResidentNV(handle);
}

PFN_GLMAKETEXTUREHANDLERESIDENTNV _glMakeTextureHandleResidentNV = &_get_glMakeTextureHandleResidentNV;

static void APIENTRY _fail_glMakeTextureHandleNonResidentNV(GLuint64 handle) {
    const char *_name = "glMakeTextureHandleNonResidentNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMakeTextureHandleNonResidentNV(GLuint64 handle) {
    PFN_GLMAKETEXTUREHANDLENONRESIDENTNV _ptr;
    _ptr = (PFN_GLMAKETEXTUREHANDLENONRESIDENTNV)_getPrivateProcAddress("glMakeTextureHandleNonResidentNV");
    if (!_ptr) {
        _ptr = &_fail_glMakeTextureHandleNonResidentNV;
    }
    _glMakeTextureHandleNonResidentNV = _ptr;
    _glMakeTextureHandleNonResidentNV(handle);
}

PFN_GLMAKETEXTUREHANDLENONRESIDENTNV _glMakeTextureHandleNonResidentNV = &_get_glMakeTextureHandleNonResidentNV;

static GLuint64 APIENTRY _fail_glGetImageHandleNV(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format) {
    const char *_name = "glGetImageHandleNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint64 APIENTRY _get_glGetImageHandleNV(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format) {
    PFN_GLGETIMAGEHANDLENV _ptr;
    _ptr = (PFN_GLGETIMAGEHANDLENV)_getPrivateProcAddress("glGetImageHandleNV");
    if (!_ptr) {
        _ptr = &_fail_glGetImageHandleNV;
    }
    _glGetImageHandleNV = _ptr;
    return _glGetImageHandleNV(texture, level, layered, layer, format);
}

PFN_GLGETIMAGEHANDLENV _glGetImageHandleNV = &_get_glGetImageHandleNV;

static void APIENTRY _fail_glMakeImageHandleResidentNV(GLuint64 handle, GLenum access) {
    const char *_name = "glMakeImageHandleResidentNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMakeImageHandleResidentNV(GLuint64 handle, GLenum access) {
    PFN_GLMAKEIMAGEHANDLERESIDENTNV _ptr;
    _ptr = (PFN_GLMAKEIMAGEHANDLERESIDENTNV)_getPrivateProcAddress("glMakeImageHandleResidentNV");
    if (!_ptr) {
        _ptr = &_fail_glMakeImageHandleResidentNV;
    }
    _glMakeImageHandleResidentNV = _ptr;
    _glMakeImageHandleResidentNV(handle, access);
}

PFN_GLMAKEIMAGEHANDLERESIDENTNV _glMakeImageHandleResidentNV = &_get_glMakeImageHandleResidentNV;

static void APIENTRY _fail_glMakeImageHandleNonResidentNV(GLuint64 handle) {
    const char *_name = "glMakeImageHandleNonResidentNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMakeImageHandleNonResidentNV(GLuint64 handle) {
    PFN_GLMAKEIMAGEHANDLENONRESIDENTNV _ptr;
    _ptr = (PFN_GLMAKEIMAGEHANDLENONRESIDENTNV)_getPrivateProcAddress("glMakeImageHandleNonResidentNV");
    if (!_ptr) {
        _ptr = &_fail_glMakeImageHandleNonResidentNV;
    }
    _glMakeImageHandleNonResidentNV = _ptr;
    _glMakeImageHandleNonResidentNV(handle);
}

PFN_GLMAKEIMAGEHANDLENONRESIDENTNV _glMakeImageHandleNonResidentNV = &_get_glMakeImageHandleNonResidentNV;

static void APIENTRY _fail_glUniformHandleui64NV(GLint location, GLuint64 value) {
    const char *_name = "glUniformHandleui64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformHandleui64NV(GLint location, GLuint64 value) {
    PFN_GLUNIFORMHANDLEUI64NV _ptr;
    _ptr = (PFN_GLUNIFORMHANDLEUI64NV)_getPrivateProcAddress("glUniformHandleui64NV");
    if (!_ptr) {
        _ptr = &_fail_glUniformHandleui64NV;
    }
    _glUniformHandleui64NV = _ptr;
    _glUniformHandleui64NV(location, value);
}

PFN_GLUNIFORMHANDLEUI64NV _glUniformHandleui64NV = &_get_glUniformHandleui64NV;

static void APIENTRY _fail_glUniformHandleui64vNV(GLint location, GLsizei count, const GLuint64 * value) {
    const char *_name = "glUniformHandleui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformHandleui64vNV(GLint location, GLsizei count, const GLuint64 * value) {
    PFN_GLUNIFORMHANDLEUI64VNV _ptr;
    _ptr = (PFN_GLUNIFORMHANDLEUI64VNV)_getPrivateProcAddress("glUniformHandleui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glUniformHandleui64vNV;
    }
    _glUniformHandleui64vNV = _ptr;
    _glUniformHandleui64vNV(location, count, value);
}

PFN_GLUNIFORMHANDLEUI64VNV _glUniformHandleui64vNV = &_get_glUniformHandleui64vNV;

static void APIENTRY _fail_glProgramUniformHandleui64NV(GLuint program, GLint location, GLuint64 value) {
    const char *_name = "glProgramUniformHandleui64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformHandleui64NV(GLuint program, GLint location, GLuint64 value) {
    PFN_GLPROGRAMUNIFORMHANDLEUI64NV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMHANDLEUI64NV)_getPrivateProcAddress("glProgramUniformHandleui64NV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformHandleui64NV;
    }
    _glProgramUniformHandleui64NV = _ptr;
    _glProgramUniformHandleui64NV(program, location, value);
}

PFN_GLPROGRAMUNIFORMHANDLEUI64NV _glProgramUniformHandleui64NV = &_get_glProgramUniformHandleui64NV;

static void APIENTRY _fail_glProgramUniformHandleui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64 * values) {
    const char *_name = "glProgramUniformHandleui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformHandleui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64 * values) {
    PFN_GLPROGRAMUNIFORMHANDLEUI64VNV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMHANDLEUI64VNV)_getPrivateProcAddress("glProgramUniformHandleui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformHandleui64vNV;
    }
    _glProgramUniformHandleui64vNV = _ptr;
    _glProgramUniformHandleui64vNV(program, location, count, values);
}

PFN_GLPROGRAMUNIFORMHANDLEUI64VNV _glProgramUniformHandleui64vNV = &_get_glProgramUniformHandleui64vNV;

static GLboolean APIENTRY _fail_glIsTextureHandleResidentNV(GLuint64 handle) {
    const char *_name = "glIsTextureHandleResidentNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsTextureHandleResidentNV(GLuint64 handle) {
    PFN_GLISTEXTUREHANDLERESIDENTNV _ptr;
    _ptr = (PFN_GLISTEXTUREHANDLERESIDENTNV)_getPrivateProcAddress("glIsTextureHandleResidentNV");
    if (!_ptr) {
        _ptr = &_fail_glIsTextureHandleResidentNV;
    }
    _glIsTextureHandleResidentNV = _ptr;
    return _glIsTextureHandleResidentNV(handle);
}

PFN_GLISTEXTUREHANDLERESIDENTNV _glIsTextureHandleResidentNV = &_get_glIsTextureHandleResidentNV;

static GLboolean APIENTRY _fail_glIsImageHandleResidentNV(GLuint64 handle) {
    const char *_name = "glIsImageHandleResidentNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsImageHandleResidentNV(GLuint64 handle) {
    PFN_GLISIMAGEHANDLERESIDENTNV _ptr;
    _ptr = (PFN_GLISIMAGEHANDLERESIDENTNV)_getPrivateProcAddress("glIsImageHandleResidentNV");
    if (!_ptr) {
        _ptr = &_fail_glIsImageHandleResidentNV;
    }
    _glIsImageHandleResidentNV = _ptr;
    return _glIsImageHandleResidentNV(handle);
}

PFN_GLISIMAGEHANDLERESIDENTNV _glIsImageHandleResidentNV = &_get_glIsImageHandleResidentNV;

static void APIENTRY _fail_glBlendParameteriNV(GLenum pname, GLint value) {
    const char *_name = "glBlendParameteriNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendParameteriNV(GLenum pname, GLint value) {
    PFN_GLBLENDPARAMETERINV _ptr;
    _ptr = (PFN_GLBLENDPARAMETERINV)_getPrivateProcAddress("glBlendParameteriNV");
    if (!_ptr) {
        _ptr = &_fail_glBlendParameteriNV;
    }
    _glBlendParameteriNV = _ptr;
    _glBlendParameteriNV(pname, value);
}

PFN_GLBLENDPARAMETERINV _glBlendParameteriNV = &_get_glBlendParameteriNV;

static void APIENTRY _fail_glBlendBarrierNV(void) {
    const char *_name = "glBlendBarrierNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendBarrierNV(void) {
    PFN_GLBLENDBARRIERNV _ptr;
    _ptr = (PFN_GLBLENDBARRIERNV)_getPrivateProcAddress("glBlendBarrierNV");
    if (!_ptr) {
        _ptr = &_fail_glBlendBarrierNV;
    }
    _glBlendBarrierNV = _ptr;
    _glBlendBarrierNV();
}

PFN_GLBLENDBARRIERNV _glBlendBarrierNV = &_get_glBlendBarrierNV;

static void APIENTRY _fail_glBeginConditionalRenderNV(GLuint id, GLenum mode) {
    const char *_name = "glBeginConditionalRenderNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBeginConditionalRenderNV(GLuint id, GLenum mode) {
    PFN_GLBEGINCONDITIONALRENDERNV _ptr;
    _ptr = (PFN_GLBEGINCONDITIONALRENDERNV)_getPrivateProcAddress("glBeginConditionalRenderNV");
    if (!_ptr) {
        _ptr = &_fail_glBeginConditionalRenderNV;
    }
    _glBeginConditionalRenderNV = _ptr;
    _glBeginConditionalRenderNV(id, mode);
}

PFN_GLBEGINCONDITIONALRENDERNV _glBeginConditionalRenderNV = &_get_glBeginConditionalRenderNV;

static void APIENTRY _fail_glEndConditionalRenderNV(void) {
    const char *_name = "glEndConditionalRenderNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEndConditionalRenderNV(void) {
    PFN_GLENDCONDITIONALRENDERNV _ptr;
    _ptr = (PFN_GLENDCONDITIONALRENDERNV)_getPrivateProcAddress("glEndConditionalRenderNV");
    if (!_ptr) {
        _ptr = &_fail_glEndConditionalRenderNV;
    }
    _glEndConditionalRenderNV = _ptr;
    _glEndConditionalRenderNV();
}

PFN_GLENDCONDITIONALRENDERNV _glEndConditionalRenderNV = &_get_glEndConditionalRenderNV;

static void APIENTRY _fail_glCopyImageSubDataNV(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) {
    const char *_name = "glCopyImageSubDataNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyImageSubDataNV(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) {
    PFN_GLCOPYIMAGESUBDATANV _ptr;
    _ptr = (PFN_GLCOPYIMAGESUBDATANV)_getPrivateProcAddress("glCopyImageSubDataNV");
    if (!_ptr) {
        _ptr = &_fail_glCopyImageSubDataNV;
    }
    _glCopyImageSubDataNV = _ptr;
    _glCopyImageSubDataNV(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
}

PFN_GLCOPYIMAGESUBDATANV _glCopyImageSubDataNV = &_get_glCopyImageSubDataNV;

static void APIENTRY _fail_glCoverageMaskNV(GLboolean mask) {
    const char *_name = "glCoverageMaskNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCoverageMaskNV(GLboolean mask) {
    PFN_GLCOVERAGEMASKNV _ptr;
    _ptr = (PFN_GLCOVERAGEMASKNV)_getPrivateProcAddress("glCoverageMaskNV");
    if (!_ptr) {
        _ptr = &_fail_glCoverageMaskNV;
    }
    _glCoverageMaskNV = _ptr;
    _glCoverageMaskNV(mask);
}

PFN_GLCOVERAGEMASKNV _glCoverageMaskNV = &_get_glCoverageMaskNV;

static void APIENTRY _fail_glCoverageOperationNV(GLenum operation) {
    const char *_name = "glCoverageOperationNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCoverageOperationNV(GLenum operation) {
    PFN_GLCOVERAGEOPERATIONNV _ptr;
    _ptr = (PFN_GLCOVERAGEOPERATIONNV)_getPrivateProcAddress("glCoverageOperationNV");
    if (!_ptr) {
        _ptr = &_fail_glCoverageOperationNV;
    }
    _glCoverageOperationNV = _ptr;
    _glCoverageOperationNV(operation);
}

PFN_GLCOVERAGEOPERATIONNV _glCoverageOperationNV = &_get_glCoverageOperationNV;

static void APIENTRY _fail_glDepthRangedNV(GLdouble zNear, GLdouble zFar) {
    const char *_name = "glDepthRangedNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDepthRangedNV(GLdouble zNear, GLdouble zFar) {
    PFN_GLDEPTHRANGEDNV _ptr;
    _ptr = (PFN_GLDEPTHRANGEDNV)_getPrivateProcAddress("glDepthRangedNV");
    if (!_ptr) {
        _ptr = &_fail_glDepthRangedNV;
    }
    _glDepthRangedNV = _ptr;
    _glDepthRangedNV(zNear, zFar);
}

PFN_GLDEPTHRANGEDNV _glDepthRangedNV = &_get_glDepthRangedNV;

static void APIENTRY _fail_glClearDepthdNV(GLdouble depth) {
    const char *_name = "glClearDepthdNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearDepthdNV(GLdouble depth) {
    PFN_GLCLEARDEPTHDNV _ptr;
    _ptr = (PFN_GLCLEARDEPTHDNV)_getPrivateProcAddress("glClearDepthdNV");
    if (!_ptr) {
        _ptr = &_fail_glClearDepthdNV;
    }
    _glClearDepthdNV = _ptr;
    _glClearDepthdNV(depth);
}

PFN_GLCLEARDEPTHDNV _glClearDepthdNV = &_get_glClearDepthdNV;

static void APIENTRY _fail_glDepthBoundsdNV(GLdouble zmin, GLdouble zmax) {
    const char *_name = "glDepthBoundsdNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDepthBoundsdNV(GLdouble zmin, GLdouble zmax) {
    PFN_GLDEPTHBOUNDSDNV _ptr;
    _ptr = (PFN_GLDEPTHBOUNDSDNV)_getPrivateProcAddress("glDepthBoundsdNV");
    if (!_ptr) {
        _ptr = &_fail_glDepthBoundsdNV;
    }
    _glDepthBoundsdNV = _ptr;
    _glDepthBoundsdNV(zmin, zmax);
}

PFN_GLDEPTHBOUNDSDNV _glDepthBoundsdNV = &_get_glDepthBoundsdNV;

static void APIENTRY _fail_glDrawBuffersNV(GLsizei n, const GLenum * bufs) {
    const char *_name = "glDrawBuffersNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawBuffersNV(GLsizei n, const GLenum * bufs) {
    PFN_GLDRAWBUFFERSNV _ptr;
    _ptr = (PFN_GLDRAWBUFFERSNV)_getPrivateProcAddress("glDrawBuffersNV");
    if (!_ptr) {
        _ptr = &_fail_glDrawBuffersNV;
    }
    _glDrawBuffersNV = _ptr;
    _glDrawBuffersNV(n, bufs);
}

PFN_GLDRAWBUFFERSNV _glDrawBuffersNV = &_get_glDrawBuffersNV;

static void APIENTRY _fail_glDrawTextureNV(GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1) {
    const char *_name = "glDrawTextureNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawTextureNV(GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1) {
    PFN_GLDRAWTEXTURENV _ptr;
    _ptr = (PFN_GLDRAWTEXTURENV)_getPrivateProcAddress("glDrawTextureNV");
    if (!_ptr) {
        _ptr = &_fail_glDrawTextureNV;
    }
    _glDrawTextureNV = _ptr;
    _glDrawTextureNV(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
}

PFN_GLDRAWTEXTURENV _glDrawTextureNV = &_get_glDrawTextureNV;

static void APIENTRY _fail_glMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid * points) {
    const char *_name = "glMapControlPointsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid * points) {
    PFN_GLMAPCONTROLPOINTSNV _ptr;
    _ptr = (PFN_GLMAPCONTROLPOINTSNV)_getPrivateProcAddress("glMapControlPointsNV");
    if (!_ptr) {
        _ptr = &_fail_glMapControlPointsNV;
    }
    _glMapControlPointsNV = _ptr;
    _glMapControlPointsNV(target, index, type, ustride, vstride, uorder, vorder, packed, points);
}

PFN_GLMAPCONTROLPOINTSNV _glMapControlPointsNV = &_get_glMapControlPointsNV;

static void APIENTRY _fail_glMapParameterivNV(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glMapParameterivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMapParameterivNV(GLenum target, GLenum pname, const GLint * params) {
    PFN_GLMAPPARAMETERIVNV _ptr;
    _ptr = (PFN_GLMAPPARAMETERIVNV)_getPrivateProcAddress("glMapParameterivNV");
    if (!_ptr) {
        _ptr = &_fail_glMapParameterivNV;
    }
    _glMapParameterivNV = _ptr;
    _glMapParameterivNV(target, pname, params);
}

PFN_GLMAPPARAMETERIVNV _glMapParameterivNV = &_get_glMapParameterivNV;

static void APIENTRY _fail_glMapParameterfvNV(GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glMapParameterfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMapParameterfvNV(GLenum target, GLenum pname, const GLfloat * params) {
    PFN_GLMAPPARAMETERFVNV _ptr;
    _ptr = (PFN_GLMAPPARAMETERFVNV)_getPrivateProcAddress("glMapParameterfvNV");
    if (!_ptr) {
        _ptr = &_fail_glMapParameterfvNV;
    }
    _glMapParameterfvNV = _ptr;
    _glMapParameterfvNV(target, pname, params);
}

PFN_GLMAPPARAMETERFVNV _glMapParameterfvNV = &_get_glMapParameterfvNV;

static void APIENTRY _fail_glGetMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid * points) {
    const char *_name = "glGetMapControlPointsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid * points) {
    PFN_GLGETMAPCONTROLPOINTSNV _ptr;
    _ptr = (PFN_GLGETMAPCONTROLPOINTSNV)_getPrivateProcAddress("glGetMapControlPointsNV");
    if (!_ptr) {
        _ptr = &_fail_glGetMapControlPointsNV;
    }
    _glGetMapControlPointsNV = _ptr;
    _glGetMapControlPointsNV(target, index, type, ustride, vstride, packed, points);
}

PFN_GLGETMAPCONTROLPOINTSNV _glGetMapControlPointsNV = &_get_glGetMapControlPointsNV;

static void APIENTRY _fail_glGetMapParameterivNV(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetMapParameterivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMapParameterivNV(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETMAPPARAMETERIVNV _ptr;
    _ptr = (PFN_GLGETMAPPARAMETERIVNV)_getPrivateProcAddress("glGetMapParameterivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetMapParameterivNV;
    }
    _glGetMapParameterivNV = _ptr;
    _glGetMapParameterivNV(target, pname, params);
}

PFN_GLGETMAPPARAMETERIVNV _glGetMapParameterivNV = &_get_glGetMapParameterivNV;

static void APIENTRY _fail_glGetMapParameterfvNV(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetMapParameterfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMapParameterfvNV(GLenum target, GLenum pname, GLfloat * params) {
    PFN_GLGETMAPPARAMETERFVNV _ptr;
    _ptr = (PFN_GLGETMAPPARAMETERFVNV)_getPrivateProcAddress("glGetMapParameterfvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetMapParameterfvNV;
    }
    _glGetMapParameterfvNV = _ptr;
    _glGetMapParameterfvNV(target, pname, params);
}

PFN_GLGETMAPPARAMETERFVNV _glGetMapParameterfvNV = &_get_glGetMapParameterfvNV;

static void APIENTRY _fail_glGetMapAttribParameterivNV(GLenum target, GLuint index, GLenum pname, GLint * params) {
    const char *_name = "glGetMapAttribParameterivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMapAttribParameterivNV(GLenum target, GLuint index, GLenum pname, GLint * params) {
    PFN_GLGETMAPATTRIBPARAMETERIVNV _ptr;
    _ptr = (PFN_GLGETMAPATTRIBPARAMETERIVNV)_getPrivateProcAddress("glGetMapAttribParameterivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetMapAttribParameterivNV;
    }
    _glGetMapAttribParameterivNV = _ptr;
    _glGetMapAttribParameterivNV(target, index, pname, params);
}

PFN_GLGETMAPATTRIBPARAMETERIVNV _glGetMapAttribParameterivNV = &_get_glGetMapAttribParameterivNV;

static void APIENTRY _fail_glGetMapAttribParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat * params) {
    const char *_name = "glGetMapAttribParameterfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMapAttribParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat * params) {
    PFN_GLGETMAPATTRIBPARAMETERFVNV _ptr;
    _ptr = (PFN_GLGETMAPATTRIBPARAMETERFVNV)_getPrivateProcAddress("glGetMapAttribParameterfvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetMapAttribParameterfvNV;
    }
    _glGetMapAttribParameterfvNV = _ptr;
    _glGetMapAttribParameterfvNV(target, index, pname, params);
}

PFN_GLGETMAPATTRIBPARAMETERFVNV _glGetMapAttribParameterfvNV = &_get_glGetMapAttribParameterfvNV;

static void APIENTRY _fail_glEvalMapsNV(GLenum target, GLenum mode) {
    const char *_name = "glEvalMapsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEvalMapsNV(GLenum target, GLenum mode) {
    PFN_GLEVALMAPSNV _ptr;
    _ptr = (PFN_GLEVALMAPSNV)_getPrivateProcAddress("glEvalMapsNV");
    if (!_ptr) {
        _ptr = &_fail_glEvalMapsNV;
    }
    _glEvalMapsNV = _ptr;
    _glEvalMapsNV(target, mode);
}

PFN_GLEVALMAPSNV _glEvalMapsNV = &_get_glEvalMapsNV;

static void APIENTRY _fail_glGetMultisamplefvNV(GLenum pname, GLuint index, GLfloat * val) {
    const char *_name = "glGetMultisamplefvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetMultisamplefvNV(GLenum pname, GLuint index, GLfloat * val) {
    PFN_GLGETMULTISAMPLEFVNV _ptr;
    _ptr = (PFN_GLGETMULTISAMPLEFVNV)_getPrivateProcAddress("glGetMultisamplefvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetMultisamplefvNV;
    }
    _glGetMultisamplefvNV = _ptr;
    _glGetMultisamplefvNV(pname, index, val);
}

PFN_GLGETMULTISAMPLEFVNV _glGetMultisamplefvNV = &_get_glGetMultisamplefvNV;

static void APIENTRY _fail_glSampleMaskIndexedNV(GLuint index, GLbitfield mask) {
    const char *_name = "glSampleMaskIndexedNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSampleMaskIndexedNV(GLuint index, GLbitfield mask) {
    PFN_GLSAMPLEMASKINDEXEDNV _ptr;
    _ptr = (PFN_GLSAMPLEMASKINDEXEDNV)_getPrivateProcAddress("glSampleMaskIndexedNV");
    if (!_ptr) {
        _ptr = &_fail_glSampleMaskIndexedNV;
    }
    _glSampleMaskIndexedNV = _ptr;
    _glSampleMaskIndexedNV(index, mask);
}

PFN_GLSAMPLEMASKINDEXEDNV _glSampleMaskIndexedNV = &_get_glSampleMaskIndexedNV;

static void APIENTRY _fail_glTexRenderbufferNV(GLenum target, GLuint renderbuffer) {
    const char *_name = "glTexRenderbufferNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexRenderbufferNV(GLenum target, GLuint renderbuffer) {
    PFN_GLTEXRENDERBUFFERNV _ptr;
    _ptr = (PFN_GLTEXRENDERBUFFERNV)_getPrivateProcAddress("glTexRenderbufferNV");
    if (!_ptr) {
        _ptr = &_fail_glTexRenderbufferNV;
    }
    _glTexRenderbufferNV = _ptr;
    _glTexRenderbufferNV(target, renderbuffer);
}

PFN_GLTEXRENDERBUFFERNV _glTexRenderbufferNV = &_get_glTexRenderbufferNV;

static void APIENTRY _fail_glDeleteFencesNV(GLsizei n, const GLuint * fences) {
    const char *_name = "glDeleteFencesNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteFencesNV(GLsizei n, const GLuint * fences) {
    PFN_GLDELETEFENCESNV _ptr;
    _ptr = (PFN_GLDELETEFENCESNV)_getPrivateProcAddress("glDeleteFencesNV");
    if (!_ptr) {
        _ptr = &_fail_glDeleteFencesNV;
    }
    _glDeleteFencesNV = _ptr;
    _glDeleteFencesNV(n, fences);
}

PFN_GLDELETEFENCESNV _glDeleteFencesNV = &_get_glDeleteFencesNV;

static void APIENTRY _fail_glGenFencesNV(GLsizei n, GLuint * fences) {
    const char *_name = "glGenFencesNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenFencesNV(GLsizei n, GLuint * fences) {
    PFN_GLGENFENCESNV _ptr;
    _ptr = (PFN_GLGENFENCESNV)_getPrivateProcAddress("glGenFencesNV");
    if (!_ptr) {
        _ptr = &_fail_glGenFencesNV;
    }
    _glGenFencesNV = _ptr;
    _glGenFencesNV(n, fences);
}

PFN_GLGENFENCESNV _glGenFencesNV = &_get_glGenFencesNV;

static GLboolean APIENTRY _fail_glIsFenceNV(GLuint fence) {
    const char *_name = "glIsFenceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsFenceNV(GLuint fence) {
    PFN_GLISFENCENV _ptr;
    _ptr = (PFN_GLISFENCENV)_getPrivateProcAddress("glIsFenceNV");
    if (!_ptr) {
        _ptr = &_fail_glIsFenceNV;
    }
    _glIsFenceNV = _ptr;
    return _glIsFenceNV(fence);
}

PFN_GLISFENCENV _glIsFenceNV = &_get_glIsFenceNV;

static GLboolean APIENTRY _fail_glTestFenceNV(GLuint fence) {
    const char *_name = "glTestFenceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glTestFenceNV(GLuint fence) {
    PFN_GLTESTFENCENV _ptr;
    _ptr = (PFN_GLTESTFENCENV)_getPrivateProcAddress("glTestFenceNV");
    if (!_ptr) {
        _ptr = &_fail_glTestFenceNV;
    }
    _glTestFenceNV = _ptr;
    return _glTestFenceNV(fence);
}

PFN_GLTESTFENCENV _glTestFenceNV = &_get_glTestFenceNV;

static void APIENTRY _fail_glGetFenceivNV(GLuint fence, GLenum pname, GLint * params) {
    const char *_name = "glGetFenceivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFenceivNV(GLuint fence, GLenum pname, GLint * params) {
    PFN_GLGETFENCEIVNV _ptr;
    _ptr = (PFN_GLGETFENCEIVNV)_getPrivateProcAddress("glGetFenceivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetFenceivNV;
    }
    _glGetFenceivNV = _ptr;
    _glGetFenceivNV(fence, pname, params);
}

PFN_GLGETFENCEIVNV _glGetFenceivNV = &_get_glGetFenceivNV;

static void APIENTRY _fail_glFinishFenceNV(GLuint fence) {
    const char *_name = "glFinishFenceNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFinishFenceNV(GLuint fence) {
    PFN_GLFINISHFENCENV _ptr;
    _ptr = (PFN_GLFINISHFENCENV)_getPrivateProcAddress("glFinishFenceNV");
    if (!_ptr) {
        _ptr = &_fail_glFinishFenceNV;
    }
    _glFinishFenceNV = _ptr;
    _glFinishFenceNV(fence);
}

PFN_GLFINISHFENCENV _glFinishFenceNV = &_get_glFinishFenceNV;

static void APIENTRY _fail_glSetFenceNV(GLuint fence, GLenum condition) {
    const char *_name = "glSetFenceNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSetFenceNV(GLuint fence, GLenum condition) {
    PFN_GLSETFENCENV _ptr;
    _ptr = (PFN_GLSETFENCENV)_getPrivateProcAddress("glSetFenceNV");
    if (!_ptr) {
        _ptr = &_fail_glSetFenceNV;
    }
    _glSetFenceNV = _ptr;
    _glSetFenceNV(fence, condition);
}

PFN_GLSETFENCENV _glSetFenceNV = &_get_glSetFenceNV;

static void APIENTRY _fail_glProgramNamedParameter4fNV(GLuint id, GLsizei len, const GLubyte * name, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glProgramNamedParameter4fNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramNamedParameter4fNV(GLuint id, GLsizei len, const GLubyte * name, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    PFN_GLPROGRAMNAMEDPARAMETER4FNV _ptr;
    _ptr = (PFN_GLPROGRAMNAMEDPARAMETER4FNV)_getPrivateProcAddress("glProgramNamedParameter4fNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramNamedParameter4fNV;
    }
    _glProgramNamedParameter4fNV = _ptr;
    _glProgramNamedParameter4fNV(id, len, name, x, y, z, w);
}

PFN_GLPROGRAMNAMEDPARAMETER4FNV _glProgramNamedParameter4fNV = &_get_glProgramNamedParameter4fNV;

static void APIENTRY _fail_glProgramNamedParameter4dNV(GLuint id, GLsizei len, const GLubyte * name, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glProgramNamedParameter4dNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramNamedParameter4dNV(GLuint id, GLsizei len, const GLubyte * name, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    PFN_GLPROGRAMNAMEDPARAMETER4DNV _ptr;
    _ptr = (PFN_GLPROGRAMNAMEDPARAMETER4DNV)_getPrivateProcAddress("glProgramNamedParameter4dNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramNamedParameter4dNV;
    }
    _glProgramNamedParameter4dNV = _ptr;
    _glProgramNamedParameter4dNV(id, len, name, x, y, z, w);
}

PFN_GLPROGRAMNAMEDPARAMETER4DNV _glProgramNamedParameter4dNV = &_get_glProgramNamedParameter4dNV;

static void APIENTRY _fail_glProgramNamedParameter4fvNV(GLuint id, GLsizei len, const GLubyte * name, const GLfloat * v) {
    const char *_name = "glProgramNamedParameter4fvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramNamedParameter4fvNV(GLuint id, GLsizei len, const GLubyte * name, const GLfloat * v) {
    PFN_GLPROGRAMNAMEDPARAMETER4FVNV _ptr;
    _ptr = (PFN_GLPROGRAMNAMEDPARAMETER4FVNV)_getPrivateProcAddress("glProgramNamedParameter4fvNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramNamedParameter4fvNV;
    }
    _glProgramNamedParameter4fvNV = _ptr;
    _glProgramNamedParameter4fvNV(id, len, name, v);
}

PFN_GLPROGRAMNAMEDPARAMETER4FVNV _glProgramNamedParameter4fvNV = &_get_glProgramNamedParameter4fvNV;

static void APIENTRY _fail_glProgramNamedParameter4dvNV(GLuint id, GLsizei len, const GLubyte * name, const GLdouble * v) {
    const char *_name = "glProgramNamedParameter4dvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramNamedParameter4dvNV(GLuint id, GLsizei len, const GLubyte * name, const GLdouble * v) {
    PFN_GLPROGRAMNAMEDPARAMETER4DVNV _ptr;
    _ptr = (PFN_GLPROGRAMNAMEDPARAMETER4DVNV)_getPrivateProcAddress("glProgramNamedParameter4dvNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramNamedParameter4dvNV;
    }
    _glProgramNamedParameter4dvNV = _ptr;
    _glProgramNamedParameter4dvNV(id, len, name, v);
}

PFN_GLPROGRAMNAMEDPARAMETER4DVNV _glProgramNamedParameter4dvNV = &_get_glProgramNamedParameter4dvNV;

static void APIENTRY _fail_glGetProgramNamedParameterdvNV(GLuint id, GLsizei len, const GLubyte * name, GLdouble * params) {
    const char *_name = "glGetProgramNamedParameterdvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramNamedParameterdvNV(GLuint id, GLsizei len, const GLubyte * name, GLdouble * params) {
    PFN_GLGETPROGRAMNAMEDPARAMETERDVNV _ptr;
    _ptr = (PFN_GLGETPROGRAMNAMEDPARAMETERDVNV)_getPrivateProcAddress("glGetProgramNamedParameterdvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramNamedParameterdvNV;
    }
    _glGetProgramNamedParameterdvNV = _ptr;
    _glGetProgramNamedParameterdvNV(id, len, name, params);
}

PFN_GLGETPROGRAMNAMEDPARAMETERDVNV _glGetProgramNamedParameterdvNV = &_get_glGetProgramNamedParameterdvNV;

static void APIENTRY _fail_glGetProgramNamedParameterfvNV(GLuint id, GLsizei len, const GLubyte * name, GLfloat * params) {
    const char *_name = "glGetProgramNamedParameterfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramNamedParameterfvNV(GLuint id, GLsizei len, const GLubyte * name, GLfloat * params) {
    PFN_GLGETPROGRAMNAMEDPARAMETERFVNV _ptr;
    _ptr = (PFN_GLGETPROGRAMNAMEDPARAMETERFVNV)_getPrivateProcAddress("glGetProgramNamedParameterfvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramNamedParameterfvNV;
    }
    _glGetProgramNamedParameterfvNV = _ptr;
    _glGetProgramNamedParameterfvNV(id, len, name, params);
}

PFN_GLGETPROGRAMNAMEDPARAMETERFVNV _glGetProgramNamedParameterfvNV = &_get_glGetProgramNamedParameterfvNV;

static void APIENTRY _fail_glBlitFramebufferNV(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
    const char *_name = "glBlitFramebufferNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlitFramebufferNV(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
    PFN_GLBLITFRAMEBUFFERNV _ptr;
    _ptr = (PFN_GLBLITFRAMEBUFFERNV)_getPrivateProcAddress("glBlitFramebufferNV");
    if (!_ptr) {
        _ptr = &_fail_glBlitFramebufferNV;
    }
    _glBlitFramebufferNV = _ptr;
    _glBlitFramebufferNV(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

PFN_GLBLITFRAMEBUFFERNV _glBlitFramebufferNV = &_get_glBlitFramebufferNV;

static void APIENTRY _fail_glCoverageModulationTableNV(GLsizei n, const GLfloat * v) {
    const char *_name = "glCoverageModulationTableNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCoverageModulationTableNV(GLsizei n, const GLfloat * v) {
    PFN_GLCOVERAGEMODULATIONTABLENV _ptr;
    _ptr = (PFN_GLCOVERAGEMODULATIONTABLENV)_getPrivateProcAddress("glCoverageModulationTableNV");
    if (!_ptr) {
        _ptr = &_fail_glCoverageModulationTableNV;
    }
    _glCoverageModulationTableNV = _ptr;
    _glCoverageModulationTableNV(n, v);
}

PFN_GLCOVERAGEMODULATIONTABLENV _glCoverageModulationTableNV = &_get_glCoverageModulationTableNV;

static void APIENTRY _fail_glGetCoverageModulationTableNV(GLsizei bufsize, GLfloat * v) {
    const char *_name = "glGetCoverageModulationTableNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetCoverageModulationTableNV(GLsizei bufsize, GLfloat * v) {
    PFN_GLGETCOVERAGEMODULATIONTABLENV _ptr;
    _ptr = (PFN_GLGETCOVERAGEMODULATIONTABLENV)_getPrivateProcAddress("glGetCoverageModulationTableNV");
    if (!_ptr) {
        _ptr = &_fail_glGetCoverageModulationTableNV;
    }
    _glGetCoverageModulationTableNV = _ptr;
    _glGetCoverageModulationTableNV(bufsize, v);
}

PFN_GLGETCOVERAGEMODULATIONTABLENV _glGetCoverageModulationTableNV = &_get_glGetCoverageModulationTableNV;

static void APIENTRY _fail_glCoverageModulationNV(GLenum components) {
    const char *_name = "glCoverageModulationNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCoverageModulationNV(GLenum components) {
    PFN_GLCOVERAGEMODULATIONNV _ptr;
    _ptr = (PFN_GLCOVERAGEMODULATIONNV)_getPrivateProcAddress("glCoverageModulationNV");
    if (!_ptr) {
        _ptr = &_fail_glCoverageModulationNV;
    }
    _glCoverageModulationNV = _ptr;
    _glCoverageModulationNV(components);
}

PFN_GLCOVERAGEMODULATIONNV _glCoverageModulationNV = &_get_glCoverageModulationNV;

static void APIENTRY _fail_glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glRenderbufferStorageMultisampleCoverageNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height) {
    PFN_GLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENV _ptr;
    _ptr = (PFN_GLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENV)_getPrivateProcAddress("glRenderbufferStorageMultisampleCoverageNV");
    if (!_ptr) {
        _ptr = &_fail_glRenderbufferStorageMultisampleCoverageNV;
    }
    _glRenderbufferStorageMultisampleCoverageNV = _ptr;
    _glRenderbufferStorageMultisampleCoverageNV(target, coverageSamples, colorSamples, internalformat, width, height);
}

PFN_GLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENV _glRenderbufferStorageMultisampleCoverageNV = &_get_glRenderbufferStorageMultisampleCoverageNV;

static void APIENTRY _fail_glProgramVertexLimitNV(GLenum target, GLint limit) {
    const char *_name = "glProgramVertexLimitNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramVertexLimitNV(GLenum target, GLint limit) {
    PFN_GLPROGRAMVERTEXLIMITNV _ptr;
    _ptr = (PFN_GLPROGRAMVERTEXLIMITNV)_getPrivateProcAddress("glProgramVertexLimitNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramVertexLimitNV;
    }
    _glProgramVertexLimitNV = _ptr;
    _glProgramVertexLimitNV(target, limit);
}

PFN_GLPROGRAMVERTEXLIMITNV _glProgramVertexLimitNV = &_get_glProgramVertexLimitNV;

static void APIENTRY _fail_glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face) {
    const char *_name = "glFramebufferTextureFaceEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face) {
    PFN_GLFRAMEBUFFERTEXTUREFACEEXT _ptr;
    _ptr = (PFN_GLFRAMEBUFFERTEXTUREFACEEXT)_getPrivateProcAddress("glFramebufferTextureFaceEXT");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferTextureFaceEXT;
    }
    _glFramebufferTextureFaceEXT = _ptr;
    _glFramebufferTextureFaceEXT(target, attachment, texture, level, face);
}

PFN_GLFRAMEBUFFERTEXTUREFACEEXT _glFramebufferTextureFaceEXT = &_get_glFramebufferTextureFaceEXT;

static void APIENTRY _fail_glProgramLocalParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) {
    const char *_name = "glProgramLocalParameterI4iNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramLocalParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) {
    PFN_GLPROGRAMLOCALPARAMETERI4INV _ptr;
    _ptr = (PFN_GLPROGRAMLOCALPARAMETERI4INV)_getPrivateProcAddress("glProgramLocalParameterI4iNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramLocalParameterI4iNV;
    }
    _glProgramLocalParameterI4iNV = _ptr;
    _glProgramLocalParameterI4iNV(target, index, x, y, z, w);
}

PFN_GLPROGRAMLOCALPARAMETERI4INV _glProgramLocalParameterI4iNV = &_get_glProgramLocalParameterI4iNV;

static void APIENTRY _fail_glProgramLocalParameterI4ivNV(GLenum target, GLuint index, const GLint * params) {
    const char *_name = "glProgramLocalParameterI4ivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramLocalParameterI4ivNV(GLenum target, GLuint index, const GLint * params) {
    PFN_GLPROGRAMLOCALPARAMETERI4IVNV _ptr;
    _ptr = (PFN_GLPROGRAMLOCALPARAMETERI4IVNV)_getPrivateProcAddress("glProgramLocalParameterI4ivNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramLocalParameterI4ivNV;
    }
    _glProgramLocalParameterI4ivNV = _ptr;
    _glProgramLocalParameterI4ivNV(target, index, params);
}

PFN_GLPROGRAMLOCALPARAMETERI4IVNV _glProgramLocalParameterI4ivNV = &_get_glProgramLocalParameterI4ivNV;

static void APIENTRY _fail_glProgramLocalParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint * params) {
    const char *_name = "glProgramLocalParametersI4ivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramLocalParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint * params) {
    PFN_GLPROGRAMLOCALPARAMETERSI4IVNV _ptr;
    _ptr = (PFN_GLPROGRAMLOCALPARAMETERSI4IVNV)_getPrivateProcAddress("glProgramLocalParametersI4ivNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramLocalParametersI4ivNV;
    }
    _glProgramLocalParametersI4ivNV = _ptr;
    _glProgramLocalParametersI4ivNV(target, index, count, params);
}

PFN_GLPROGRAMLOCALPARAMETERSI4IVNV _glProgramLocalParametersI4ivNV = &_get_glProgramLocalParametersI4ivNV;

static void APIENTRY _fail_glProgramLocalParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
    const char *_name = "glProgramLocalParameterI4uiNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramLocalParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
    PFN_GLPROGRAMLOCALPARAMETERI4UINV _ptr;
    _ptr = (PFN_GLPROGRAMLOCALPARAMETERI4UINV)_getPrivateProcAddress("glProgramLocalParameterI4uiNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramLocalParameterI4uiNV;
    }
    _glProgramLocalParameterI4uiNV = _ptr;
    _glProgramLocalParameterI4uiNV(target, index, x, y, z, w);
}

PFN_GLPROGRAMLOCALPARAMETERI4UINV _glProgramLocalParameterI4uiNV = &_get_glProgramLocalParameterI4uiNV;

static void APIENTRY _fail_glProgramLocalParameterI4uivNV(GLenum target, GLuint index, const GLuint * params) {
    const char *_name = "glProgramLocalParameterI4uivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramLocalParameterI4uivNV(GLenum target, GLuint index, const GLuint * params) {
    PFN_GLPROGRAMLOCALPARAMETERI4UIVNV _ptr;
    _ptr = (PFN_GLPROGRAMLOCALPARAMETERI4UIVNV)_getPrivateProcAddress("glProgramLocalParameterI4uivNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramLocalParameterI4uivNV;
    }
    _glProgramLocalParameterI4uivNV = _ptr;
    _glProgramLocalParameterI4uivNV(target, index, params);
}

PFN_GLPROGRAMLOCALPARAMETERI4UIVNV _glProgramLocalParameterI4uivNV = &_get_glProgramLocalParameterI4uivNV;

static void APIENTRY _fail_glProgramLocalParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint * params) {
    const char *_name = "glProgramLocalParametersI4uivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramLocalParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint * params) {
    PFN_GLPROGRAMLOCALPARAMETERSI4UIVNV _ptr;
    _ptr = (PFN_GLPROGRAMLOCALPARAMETERSI4UIVNV)_getPrivateProcAddress("glProgramLocalParametersI4uivNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramLocalParametersI4uivNV;
    }
    _glProgramLocalParametersI4uivNV = _ptr;
    _glProgramLocalParametersI4uivNV(target, index, count, params);
}

PFN_GLPROGRAMLOCALPARAMETERSI4UIVNV _glProgramLocalParametersI4uivNV = &_get_glProgramLocalParametersI4uivNV;

static void APIENTRY _fail_glProgramEnvParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) {
    const char *_name = "glProgramEnvParameterI4iNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramEnvParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w) {
    PFN_GLPROGRAMENVPARAMETERI4INV _ptr;
    _ptr = (PFN_GLPROGRAMENVPARAMETERI4INV)_getPrivateProcAddress("glProgramEnvParameterI4iNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramEnvParameterI4iNV;
    }
    _glProgramEnvParameterI4iNV = _ptr;
    _glProgramEnvParameterI4iNV(target, index, x, y, z, w);
}

PFN_GLPROGRAMENVPARAMETERI4INV _glProgramEnvParameterI4iNV = &_get_glProgramEnvParameterI4iNV;

static void APIENTRY _fail_glProgramEnvParameterI4ivNV(GLenum target, GLuint index, const GLint * params) {
    const char *_name = "glProgramEnvParameterI4ivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramEnvParameterI4ivNV(GLenum target, GLuint index, const GLint * params) {
    PFN_GLPROGRAMENVPARAMETERI4IVNV _ptr;
    _ptr = (PFN_GLPROGRAMENVPARAMETERI4IVNV)_getPrivateProcAddress("glProgramEnvParameterI4ivNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramEnvParameterI4ivNV;
    }
    _glProgramEnvParameterI4ivNV = _ptr;
    _glProgramEnvParameterI4ivNV(target, index, params);
}

PFN_GLPROGRAMENVPARAMETERI4IVNV _glProgramEnvParameterI4ivNV = &_get_glProgramEnvParameterI4ivNV;

static void APIENTRY _fail_glProgramEnvParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint * params) {
    const char *_name = "glProgramEnvParametersI4ivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramEnvParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint * params) {
    PFN_GLPROGRAMENVPARAMETERSI4IVNV _ptr;
    _ptr = (PFN_GLPROGRAMENVPARAMETERSI4IVNV)_getPrivateProcAddress("glProgramEnvParametersI4ivNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramEnvParametersI4ivNV;
    }
    _glProgramEnvParametersI4ivNV = _ptr;
    _glProgramEnvParametersI4ivNV(target, index, count, params);
}

PFN_GLPROGRAMENVPARAMETERSI4IVNV _glProgramEnvParametersI4ivNV = &_get_glProgramEnvParametersI4ivNV;

static void APIENTRY _fail_glProgramEnvParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
    const char *_name = "glProgramEnvParameterI4uiNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramEnvParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
    PFN_GLPROGRAMENVPARAMETERI4UINV _ptr;
    _ptr = (PFN_GLPROGRAMENVPARAMETERI4UINV)_getPrivateProcAddress("glProgramEnvParameterI4uiNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramEnvParameterI4uiNV;
    }
    _glProgramEnvParameterI4uiNV = _ptr;
    _glProgramEnvParameterI4uiNV(target, index, x, y, z, w);
}

PFN_GLPROGRAMENVPARAMETERI4UINV _glProgramEnvParameterI4uiNV = &_get_glProgramEnvParameterI4uiNV;

static void APIENTRY _fail_glProgramEnvParameterI4uivNV(GLenum target, GLuint index, const GLuint * params) {
    const char *_name = "glProgramEnvParameterI4uivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramEnvParameterI4uivNV(GLenum target, GLuint index, const GLuint * params) {
    PFN_GLPROGRAMENVPARAMETERI4UIVNV _ptr;
    _ptr = (PFN_GLPROGRAMENVPARAMETERI4UIVNV)_getPrivateProcAddress("glProgramEnvParameterI4uivNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramEnvParameterI4uivNV;
    }
    _glProgramEnvParameterI4uivNV = _ptr;
    _glProgramEnvParameterI4uivNV(target, index, params);
}

PFN_GLPROGRAMENVPARAMETERI4UIVNV _glProgramEnvParameterI4uivNV = &_get_glProgramEnvParameterI4uivNV;

static void APIENTRY _fail_glProgramEnvParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint * params) {
    const char *_name = "glProgramEnvParametersI4uivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramEnvParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint * params) {
    PFN_GLPROGRAMENVPARAMETERSI4UIVNV _ptr;
    _ptr = (PFN_GLPROGRAMENVPARAMETERSI4UIVNV)_getPrivateProcAddress("glProgramEnvParametersI4uivNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramEnvParametersI4uivNV;
    }
    _glProgramEnvParametersI4uivNV = _ptr;
    _glProgramEnvParametersI4uivNV(target, index, count, params);
}

PFN_GLPROGRAMENVPARAMETERSI4UIVNV _glProgramEnvParametersI4uivNV = &_get_glProgramEnvParametersI4uivNV;

static void APIENTRY _fail_glGetProgramLocalParameterIivNV(GLenum target, GLuint index, GLint * params) {
    const char *_name = "glGetProgramLocalParameterIivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramLocalParameterIivNV(GLenum target, GLuint index, GLint * params) {
    PFN_GLGETPROGRAMLOCALPARAMETERIIVNV _ptr;
    _ptr = (PFN_GLGETPROGRAMLOCALPARAMETERIIVNV)_getPrivateProcAddress("glGetProgramLocalParameterIivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramLocalParameterIivNV;
    }
    _glGetProgramLocalParameterIivNV = _ptr;
    _glGetProgramLocalParameterIivNV(target, index, params);
}

PFN_GLGETPROGRAMLOCALPARAMETERIIVNV _glGetProgramLocalParameterIivNV = &_get_glGetProgramLocalParameterIivNV;

static void APIENTRY _fail_glGetProgramLocalParameterIuivNV(GLenum target, GLuint index, GLuint * params) {
    const char *_name = "glGetProgramLocalParameterIuivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramLocalParameterIuivNV(GLenum target, GLuint index, GLuint * params) {
    PFN_GLGETPROGRAMLOCALPARAMETERIUIVNV _ptr;
    _ptr = (PFN_GLGETPROGRAMLOCALPARAMETERIUIVNV)_getPrivateProcAddress("glGetProgramLocalParameterIuivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramLocalParameterIuivNV;
    }
    _glGetProgramLocalParameterIuivNV = _ptr;
    _glGetProgramLocalParameterIuivNV(target, index, params);
}

PFN_GLGETPROGRAMLOCALPARAMETERIUIVNV _glGetProgramLocalParameterIuivNV = &_get_glGetProgramLocalParameterIuivNV;

static void APIENTRY _fail_glGetProgramEnvParameterIivNV(GLenum target, GLuint index, GLint * params) {
    const char *_name = "glGetProgramEnvParameterIivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramEnvParameterIivNV(GLenum target, GLuint index, GLint * params) {
    PFN_GLGETPROGRAMENVPARAMETERIIVNV _ptr;
    _ptr = (PFN_GLGETPROGRAMENVPARAMETERIIVNV)_getPrivateProcAddress("glGetProgramEnvParameterIivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramEnvParameterIivNV;
    }
    _glGetProgramEnvParameterIivNV = _ptr;
    _glGetProgramEnvParameterIivNV(target, index, params);
}

PFN_GLGETPROGRAMENVPARAMETERIIVNV _glGetProgramEnvParameterIivNV = &_get_glGetProgramEnvParameterIivNV;

static void APIENTRY _fail_glGetProgramEnvParameterIuivNV(GLenum target, GLuint index, GLuint * params) {
    const char *_name = "glGetProgramEnvParameterIuivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramEnvParameterIuivNV(GLenum target, GLuint index, GLuint * params) {
    PFN_GLGETPROGRAMENVPARAMETERIUIVNV _ptr;
    _ptr = (PFN_GLGETPROGRAMENVPARAMETERIUIVNV)_getPrivateProcAddress("glGetProgramEnvParameterIuivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramEnvParameterIuivNV;
    }
    _glGetProgramEnvParameterIuivNV = _ptr;
    _glGetProgramEnvParameterIuivNV(target, index, params);
}

PFN_GLGETPROGRAMENVPARAMETERIUIVNV _glGetProgramEnvParameterIuivNV = &_get_glGetProgramEnvParameterIuivNV;

static void APIENTRY _fail_glProgramSubroutineParametersuivNV(GLenum target, GLsizei count, const GLuint * params) {
    const char *_name = "glProgramSubroutineParametersuivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramSubroutineParametersuivNV(GLenum target, GLsizei count, const GLuint * params) {
    PFN_GLPROGRAMSUBROUTINEPARAMETERSUIVNV _ptr;
    _ptr = (PFN_GLPROGRAMSUBROUTINEPARAMETERSUIVNV)_getPrivateProcAddress("glProgramSubroutineParametersuivNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramSubroutineParametersuivNV;
    }
    _glProgramSubroutineParametersuivNV = _ptr;
    _glProgramSubroutineParametersuivNV(target, count, params);
}

PFN_GLPROGRAMSUBROUTINEPARAMETERSUIVNV _glProgramSubroutineParametersuivNV = &_get_glProgramSubroutineParametersuivNV;

static void APIENTRY _fail_glGetProgramSubroutineParameteruivNV(GLenum target, GLuint index, GLuint * param) {
    const char *_name = "glGetProgramSubroutineParameteruivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramSubroutineParameteruivNV(GLenum target, GLuint index, GLuint * param) {
    PFN_GLGETPROGRAMSUBROUTINEPARAMETERUIVNV _ptr;
    _ptr = (PFN_GLGETPROGRAMSUBROUTINEPARAMETERUIVNV)_getPrivateProcAddress("glGetProgramSubroutineParameteruivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramSubroutineParameteruivNV;
    }
    _glGetProgramSubroutineParameteruivNV = _ptr;
    _glGetProgramSubroutineParameteruivNV(target, index, param);
}

PFN_GLGETPROGRAMSUBROUTINEPARAMETERUIVNV _glGetProgramSubroutineParameteruivNV = &_get_glGetProgramSubroutineParameteruivNV;

static void APIENTRY _fail_glUniform1i64NV(GLint location, GLint64EXT x) {
    const char *_name = "glUniform1i64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1i64NV(GLint location, GLint64EXT x) {
    PFN_GLUNIFORM1I64NV _ptr;
    _ptr = (PFN_GLUNIFORM1I64NV)_getPrivateProcAddress("glUniform1i64NV");
    if (!_ptr) {
        _ptr = &_fail_glUniform1i64NV;
    }
    _glUniform1i64NV = _ptr;
    _glUniform1i64NV(location, x);
}

PFN_GLUNIFORM1I64NV _glUniform1i64NV = &_get_glUniform1i64NV;

static void APIENTRY _fail_glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y) {
    const char *_name = "glUniform2i64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y) {
    PFN_GLUNIFORM2I64NV _ptr;
    _ptr = (PFN_GLUNIFORM2I64NV)_getPrivateProcAddress("glUniform2i64NV");
    if (!_ptr) {
        _ptr = &_fail_glUniform2i64NV;
    }
    _glUniform2i64NV = _ptr;
    _glUniform2i64NV(location, x, y);
}

PFN_GLUNIFORM2I64NV _glUniform2i64NV = &_get_glUniform2i64NV;

static void APIENTRY _fail_glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z) {
    const char *_name = "glUniform3i64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z) {
    PFN_GLUNIFORM3I64NV _ptr;
    _ptr = (PFN_GLUNIFORM3I64NV)_getPrivateProcAddress("glUniform3i64NV");
    if (!_ptr) {
        _ptr = &_fail_glUniform3i64NV;
    }
    _glUniform3i64NV = _ptr;
    _glUniform3i64NV(location, x, y, z);
}

PFN_GLUNIFORM3I64NV _glUniform3i64NV = &_get_glUniform3i64NV;

static void APIENTRY _fail_glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) {
    const char *_name = "glUniform4i64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) {
    PFN_GLUNIFORM4I64NV _ptr;
    _ptr = (PFN_GLUNIFORM4I64NV)_getPrivateProcAddress("glUniform4i64NV");
    if (!_ptr) {
        _ptr = &_fail_glUniform4i64NV;
    }
    _glUniform4i64NV = _ptr;
    _glUniform4i64NV(location, x, y, z, w);
}

PFN_GLUNIFORM4I64NV _glUniform4i64NV = &_get_glUniform4i64NV;

static void APIENTRY _fail_glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT * value) {
    const char *_name = "glUniform1i64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT * value) {
    PFN_GLUNIFORM1I64VNV _ptr;
    _ptr = (PFN_GLUNIFORM1I64VNV)_getPrivateProcAddress("glUniform1i64vNV");
    if (!_ptr) {
        _ptr = &_fail_glUniform1i64vNV;
    }
    _glUniform1i64vNV = _ptr;
    _glUniform1i64vNV(location, count, value);
}

PFN_GLUNIFORM1I64VNV _glUniform1i64vNV = &_get_glUniform1i64vNV;

static void APIENTRY _fail_glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT * value) {
    const char *_name = "glUniform2i64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT * value) {
    PFN_GLUNIFORM2I64VNV _ptr;
    _ptr = (PFN_GLUNIFORM2I64VNV)_getPrivateProcAddress("glUniform2i64vNV");
    if (!_ptr) {
        _ptr = &_fail_glUniform2i64vNV;
    }
    _glUniform2i64vNV = _ptr;
    _glUniform2i64vNV(location, count, value);
}

PFN_GLUNIFORM2I64VNV _glUniform2i64vNV = &_get_glUniform2i64vNV;

static void APIENTRY _fail_glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT * value) {
    const char *_name = "glUniform3i64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT * value) {
    PFN_GLUNIFORM3I64VNV _ptr;
    _ptr = (PFN_GLUNIFORM3I64VNV)_getPrivateProcAddress("glUniform3i64vNV");
    if (!_ptr) {
        _ptr = &_fail_glUniform3i64vNV;
    }
    _glUniform3i64vNV = _ptr;
    _glUniform3i64vNV(location, count, value);
}

PFN_GLUNIFORM3I64VNV _glUniform3i64vNV = &_get_glUniform3i64vNV;

static void APIENTRY _fail_glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT * value) {
    const char *_name = "glUniform4i64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT * value) {
    PFN_GLUNIFORM4I64VNV _ptr;
    _ptr = (PFN_GLUNIFORM4I64VNV)_getPrivateProcAddress("glUniform4i64vNV");
    if (!_ptr) {
        _ptr = &_fail_glUniform4i64vNV;
    }
    _glUniform4i64vNV = _ptr;
    _glUniform4i64vNV(location, count, value);
}

PFN_GLUNIFORM4I64VNV _glUniform4i64vNV = &_get_glUniform4i64vNV;

static void APIENTRY _fail_glUniform1ui64NV(GLint location, GLuint64EXT x) {
    const char *_name = "glUniform1ui64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1ui64NV(GLint location, GLuint64EXT x) {
    PFN_GLUNIFORM1UI64NV _ptr;
    _ptr = (PFN_GLUNIFORM1UI64NV)_getPrivateProcAddress("glUniform1ui64NV");
    if (!_ptr) {
        _ptr = &_fail_glUniform1ui64NV;
    }
    _glUniform1ui64NV = _ptr;
    _glUniform1ui64NV(location, x);
}

PFN_GLUNIFORM1UI64NV _glUniform1ui64NV = &_get_glUniform1ui64NV;

static void APIENTRY _fail_glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y) {
    const char *_name = "glUniform2ui64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y) {
    PFN_GLUNIFORM2UI64NV _ptr;
    _ptr = (PFN_GLUNIFORM2UI64NV)_getPrivateProcAddress("glUniform2ui64NV");
    if (!_ptr) {
        _ptr = &_fail_glUniform2ui64NV;
    }
    _glUniform2ui64NV = _ptr;
    _glUniform2ui64NV(location, x, y);
}

PFN_GLUNIFORM2UI64NV _glUniform2ui64NV = &_get_glUniform2ui64NV;

static void APIENTRY _fail_glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) {
    const char *_name = "glUniform3ui64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) {
    PFN_GLUNIFORM3UI64NV _ptr;
    _ptr = (PFN_GLUNIFORM3UI64NV)_getPrivateProcAddress("glUniform3ui64NV");
    if (!_ptr) {
        _ptr = &_fail_glUniform3ui64NV;
    }
    _glUniform3ui64NV = _ptr;
    _glUniform3ui64NV(location, x, y, z);
}

PFN_GLUNIFORM3UI64NV _glUniform3ui64NV = &_get_glUniform3ui64NV;

static void APIENTRY _fail_glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) {
    const char *_name = "glUniform4ui64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) {
    PFN_GLUNIFORM4UI64NV _ptr;
    _ptr = (PFN_GLUNIFORM4UI64NV)_getPrivateProcAddress("glUniform4ui64NV");
    if (!_ptr) {
        _ptr = &_fail_glUniform4ui64NV;
    }
    _glUniform4ui64NV = _ptr;
    _glUniform4ui64NV(location, x, y, z, w);
}

PFN_GLUNIFORM4UI64NV _glUniform4ui64NV = &_get_glUniform4ui64NV;

static void APIENTRY _fail_glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glUniform1ui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value) {
    PFN_GLUNIFORM1UI64VNV _ptr;
    _ptr = (PFN_GLUNIFORM1UI64VNV)_getPrivateProcAddress("glUniform1ui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glUniform1ui64vNV;
    }
    _glUniform1ui64vNV = _ptr;
    _glUniform1ui64vNV(location, count, value);
}

PFN_GLUNIFORM1UI64VNV _glUniform1ui64vNV = &_get_glUniform1ui64vNV;

static void APIENTRY _fail_glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glUniform2ui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value) {
    PFN_GLUNIFORM2UI64VNV _ptr;
    _ptr = (PFN_GLUNIFORM2UI64VNV)_getPrivateProcAddress("glUniform2ui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glUniform2ui64vNV;
    }
    _glUniform2ui64vNV = _ptr;
    _glUniform2ui64vNV(location, count, value);
}

PFN_GLUNIFORM2UI64VNV _glUniform2ui64vNV = &_get_glUniform2ui64vNV;

static void APIENTRY _fail_glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glUniform3ui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value) {
    PFN_GLUNIFORM3UI64VNV _ptr;
    _ptr = (PFN_GLUNIFORM3UI64VNV)_getPrivateProcAddress("glUniform3ui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glUniform3ui64vNV;
    }
    _glUniform3ui64vNV = _ptr;
    _glUniform3ui64vNV(location, count, value);
}

PFN_GLUNIFORM3UI64VNV _glUniform3ui64vNV = &_get_glUniform3ui64vNV;

static void APIENTRY _fail_glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glUniform4ui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT * value) {
    PFN_GLUNIFORM4UI64VNV _ptr;
    _ptr = (PFN_GLUNIFORM4UI64VNV)_getPrivateProcAddress("glUniform4ui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glUniform4ui64vNV;
    }
    _glUniform4ui64vNV = _ptr;
    _glUniform4ui64vNV(location, count, value);
}

PFN_GLUNIFORM4UI64VNV _glUniform4ui64vNV = &_get_glUniform4ui64vNV;

static void APIENTRY _fail_glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT * params) {
    const char *_name = "glGetUniformi64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT * params) {
    PFN_GLGETUNIFORMI64VNV _ptr;
    _ptr = (PFN_GLGETUNIFORMI64VNV)_getPrivateProcAddress("glGetUniformi64vNV");
    if (!_ptr) {
        _ptr = &_fail_glGetUniformi64vNV;
    }
    _glGetUniformi64vNV = _ptr;
    _glGetUniformi64vNV(program, location, params);
}

PFN_GLGETUNIFORMI64VNV _glGetUniformi64vNV = &_get_glGetUniformi64vNV;

static void APIENTRY _fail_glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x) {
    const char *_name = "glProgramUniform1i64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x) {
    PFN_GLPROGRAMUNIFORM1I64NV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1I64NV)_getPrivateProcAddress("glProgramUniform1i64NV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1i64NV;
    }
    _glProgramUniform1i64NV = _ptr;
    _glProgramUniform1i64NV(program, location, x);
}

PFN_GLPROGRAMUNIFORM1I64NV _glProgramUniform1i64NV = &_get_glProgramUniform1i64NV;

static void APIENTRY _fail_glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y) {
    const char *_name = "glProgramUniform2i64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y) {
    PFN_GLPROGRAMUNIFORM2I64NV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2I64NV)_getPrivateProcAddress("glProgramUniform2i64NV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2i64NV;
    }
    _glProgramUniform2i64NV = _ptr;
    _glProgramUniform2i64NV(program, location, x, y);
}

PFN_GLPROGRAMUNIFORM2I64NV _glProgramUniform2i64NV = &_get_glProgramUniform2i64NV;

static void APIENTRY _fail_glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z) {
    const char *_name = "glProgramUniform3i64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z) {
    PFN_GLPROGRAMUNIFORM3I64NV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3I64NV)_getPrivateProcAddress("glProgramUniform3i64NV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3i64NV;
    }
    _glProgramUniform3i64NV = _ptr;
    _glProgramUniform3i64NV(program, location, x, y, z);
}

PFN_GLPROGRAMUNIFORM3I64NV _glProgramUniform3i64NV = &_get_glProgramUniform3i64NV;

static void APIENTRY _fail_glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) {
    const char *_name = "glProgramUniform4i64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) {
    PFN_GLPROGRAMUNIFORM4I64NV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4I64NV)_getPrivateProcAddress("glProgramUniform4i64NV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4i64NV;
    }
    _glProgramUniform4i64NV = _ptr;
    _glProgramUniform4i64NV(program, location, x, y, z, w);
}

PFN_GLPROGRAMUNIFORM4I64NV _glProgramUniform4i64NV = &_get_glProgramUniform4i64NV;

static void APIENTRY _fail_glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value) {
    const char *_name = "glProgramUniform1i64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value) {
    PFN_GLPROGRAMUNIFORM1I64VNV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1I64VNV)_getPrivateProcAddress("glProgramUniform1i64vNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1i64vNV;
    }
    _glProgramUniform1i64vNV = _ptr;
    _glProgramUniform1i64vNV(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM1I64VNV _glProgramUniform1i64vNV = &_get_glProgramUniform1i64vNV;

static void APIENTRY _fail_glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value) {
    const char *_name = "glProgramUniform2i64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value) {
    PFN_GLPROGRAMUNIFORM2I64VNV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2I64VNV)_getPrivateProcAddress("glProgramUniform2i64vNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2i64vNV;
    }
    _glProgramUniform2i64vNV = _ptr;
    _glProgramUniform2i64vNV(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM2I64VNV _glProgramUniform2i64vNV = &_get_glProgramUniform2i64vNV;

static void APIENTRY _fail_glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value) {
    const char *_name = "glProgramUniform3i64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value) {
    PFN_GLPROGRAMUNIFORM3I64VNV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3I64VNV)_getPrivateProcAddress("glProgramUniform3i64vNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3i64vNV;
    }
    _glProgramUniform3i64vNV = _ptr;
    _glProgramUniform3i64vNV(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM3I64VNV _glProgramUniform3i64vNV = &_get_glProgramUniform3i64vNV;

static void APIENTRY _fail_glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value) {
    const char *_name = "glProgramUniform4i64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT * value) {
    PFN_GLPROGRAMUNIFORM4I64VNV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4I64VNV)_getPrivateProcAddress("glProgramUniform4i64vNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4i64vNV;
    }
    _glProgramUniform4i64vNV = _ptr;
    _glProgramUniform4i64vNV(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM4I64VNV _glProgramUniform4i64vNV = &_get_glProgramUniform4i64vNV;

static void APIENTRY _fail_glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x) {
    const char *_name = "glProgramUniform1ui64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x) {
    PFN_GLPROGRAMUNIFORM1UI64NV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1UI64NV)_getPrivateProcAddress("glProgramUniform1ui64NV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1ui64NV;
    }
    _glProgramUniform1ui64NV = _ptr;
    _glProgramUniform1ui64NV(program, location, x);
}

PFN_GLPROGRAMUNIFORM1UI64NV _glProgramUniform1ui64NV = &_get_glProgramUniform1ui64NV;

static void APIENTRY _fail_glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y) {
    const char *_name = "glProgramUniform2ui64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y) {
    PFN_GLPROGRAMUNIFORM2UI64NV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2UI64NV)_getPrivateProcAddress("glProgramUniform2ui64NV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2ui64NV;
    }
    _glProgramUniform2ui64NV = _ptr;
    _glProgramUniform2ui64NV(program, location, x, y);
}

PFN_GLPROGRAMUNIFORM2UI64NV _glProgramUniform2ui64NV = &_get_glProgramUniform2ui64NV;

static void APIENTRY _fail_glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) {
    const char *_name = "glProgramUniform3ui64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) {
    PFN_GLPROGRAMUNIFORM3UI64NV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3UI64NV)_getPrivateProcAddress("glProgramUniform3ui64NV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3ui64NV;
    }
    _glProgramUniform3ui64NV = _ptr;
    _glProgramUniform3ui64NV(program, location, x, y, z);
}

PFN_GLPROGRAMUNIFORM3UI64NV _glProgramUniform3ui64NV = &_get_glProgramUniform3ui64NV;

static void APIENTRY _fail_glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) {
    const char *_name = "glProgramUniform4ui64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) {
    PFN_GLPROGRAMUNIFORM4UI64NV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4UI64NV)_getPrivateProcAddress("glProgramUniform4ui64NV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4ui64NV;
    }
    _glProgramUniform4ui64NV = _ptr;
    _glProgramUniform4ui64NV(program, location, x, y, z, w);
}

PFN_GLPROGRAMUNIFORM4UI64NV _glProgramUniform4ui64NV = &_get_glProgramUniform4ui64NV;

static void APIENTRY _fail_glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glProgramUniform1ui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value) {
    PFN_GLPROGRAMUNIFORM1UI64VNV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM1UI64VNV)_getPrivateProcAddress("glProgramUniform1ui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform1ui64vNV;
    }
    _glProgramUniform1ui64vNV = _ptr;
    _glProgramUniform1ui64vNV(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM1UI64VNV _glProgramUniform1ui64vNV = &_get_glProgramUniform1ui64vNV;

static void APIENTRY _fail_glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glProgramUniform2ui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value) {
    PFN_GLPROGRAMUNIFORM2UI64VNV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM2UI64VNV)_getPrivateProcAddress("glProgramUniform2ui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform2ui64vNV;
    }
    _glProgramUniform2ui64vNV = _ptr;
    _glProgramUniform2ui64vNV(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM2UI64VNV _glProgramUniform2ui64vNV = &_get_glProgramUniform2ui64vNV;

static void APIENTRY _fail_glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glProgramUniform3ui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value) {
    PFN_GLPROGRAMUNIFORM3UI64VNV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM3UI64VNV)_getPrivateProcAddress("glProgramUniform3ui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform3ui64vNV;
    }
    _glProgramUniform3ui64vNV = _ptr;
    _glProgramUniform3ui64vNV(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM3UI64VNV _glProgramUniform3ui64vNV = &_get_glProgramUniform3ui64vNV;

static void APIENTRY _fail_glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glProgramUniform4ui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value) {
    PFN_GLPROGRAMUNIFORM4UI64VNV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORM4UI64VNV)_getPrivateProcAddress("glProgramUniform4ui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniform4ui64vNV;
    }
    _glProgramUniform4ui64vNV = _ptr;
    _glProgramUniform4ui64vNV(program, location, count, value);
}

PFN_GLPROGRAMUNIFORM4UI64VNV _glProgramUniform4ui64vNV = &_get_glProgramUniform4ui64vNV;

static void APIENTRY _fail_glVertex2hNV(GLhalfNV x, GLhalfNV y) {
    const char *_name = "glVertex2hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex2hNV(GLhalfNV x, GLhalfNV y) {
    PFN_GLVERTEX2HNV _ptr;
    _ptr = (PFN_GLVERTEX2HNV)_getPrivateProcAddress("glVertex2hNV");
    if (!_ptr) {
        _ptr = &_fail_glVertex2hNV;
    }
    _glVertex2hNV = _ptr;
    _glVertex2hNV(x, y);
}

PFN_GLVERTEX2HNV _glVertex2hNV = &_get_glVertex2hNV;

static void APIENTRY _fail_glVertex2hvNV(const GLhalfNV * v) {
    const char *_name = "glVertex2hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex2hvNV(const GLhalfNV * v) {
    PFN_GLVERTEX2HVNV _ptr;
    _ptr = (PFN_GLVERTEX2HVNV)_getPrivateProcAddress("glVertex2hvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertex2hvNV;
    }
    _glVertex2hvNV = _ptr;
    _glVertex2hvNV(v);
}

PFN_GLVERTEX2HVNV _glVertex2hvNV = &_get_glVertex2hvNV;

static void APIENTRY _fail_glVertex3hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z) {
    const char *_name = "glVertex3hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex3hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z) {
    PFN_GLVERTEX3HNV _ptr;
    _ptr = (PFN_GLVERTEX3HNV)_getPrivateProcAddress("glVertex3hNV");
    if (!_ptr) {
        _ptr = &_fail_glVertex3hNV;
    }
    _glVertex3hNV = _ptr;
    _glVertex3hNV(x, y, z);
}

PFN_GLVERTEX3HNV _glVertex3hNV = &_get_glVertex3hNV;

static void APIENTRY _fail_glVertex3hvNV(const GLhalfNV * v) {
    const char *_name = "glVertex3hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex3hvNV(const GLhalfNV * v) {
    PFN_GLVERTEX3HVNV _ptr;
    _ptr = (PFN_GLVERTEX3HVNV)_getPrivateProcAddress("glVertex3hvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertex3hvNV;
    }
    _glVertex3hvNV = _ptr;
    _glVertex3hvNV(v);
}

PFN_GLVERTEX3HVNV _glVertex3hvNV = &_get_glVertex3hvNV;

static void APIENTRY _fail_glVertex4hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w) {
    const char *_name = "glVertex4hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex4hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w) {
    PFN_GLVERTEX4HNV _ptr;
    _ptr = (PFN_GLVERTEX4HNV)_getPrivateProcAddress("glVertex4hNV");
    if (!_ptr) {
        _ptr = &_fail_glVertex4hNV;
    }
    _glVertex4hNV = _ptr;
    _glVertex4hNV(x, y, z, w);
}

PFN_GLVERTEX4HNV _glVertex4hNV = &_get_glVertex4hNV;

static void APIENTRY _fail_glVertex4hvNV(const GLhalfNV * v) {
    const char *_name = "glVertex4hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertex4hvNV(const GLhalfNV * v) {
    PFN_GLVERTEX4HVNV _ptr;
    _ptr = (PFN_GLVERTEX4HVNV)_getPrivateProcAddress("glVertex4hvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertex4hvNV;
    }
    _glVertex4hvNV = _ptr;
    _glVertex4hvNV(v);
}

PFN_GLVERTEX4HVNV _glVertex4hvNV = &_get_glVertex4hvNV;

static void APIENTRY _fail_glNormal3hNV(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz) {
    const char *_name = "glNormal3hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormal3hNV(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz) {
    PFN_GLNORMAL3HNV _ptr;
    _ptr = (PFN_GLNORMAL3HNV)_getPrivateProcAddress("glNormal3hNV");
    if (!_ptr) {
        _ptr = &_fail_glNormal3hNV;
    }
    _glNormal3hNV = _ptr;
    _glNormal3hNV(nx, ny, nz);
}

PFN_GLNORMAL3HNV _glNormal3hNV = &_get_glNormal3hNV;

static void APIENTRY _fail_glNormal3hvNV(const GLhalfNV * v) {
    const char *_name = "glNormal3hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormal3hvNV(const GLhalfNV * v) {
    PFN_GLNORMAL3HVNV _ptr;
    _ptr = (PFN_GLNORMAL3HVNV)_getPrivateProcAddress("glNormal3hvNV");
    if (!_ptr) {
        _ptr = &_fail_glNormal3hvNV;
    }
    _glNormal3hvNV = _ptr;
    _glNormal3hvNV(v);
}

PFN_GLNORMAL3HVNV _glNormal3hvNV = &_get_glNormal3hvNV;

static void APIENTRY _fail_glColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue) {
    const char *_name = "glColor3hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue) {
    PFN_GLCOLOR3HNV _ptr;
    _ptr = (PFN_GLCOLOR3HNV)_getPrivateProcAddress("glColor3hNV");
    if (!_ptr) {
        _ptr = &_fail_glColor3hNV;
    }
    _glColor3hNV = _ptr;
    _glColor3hNV(red, green, blue);
}

PFN_GLCOLOR3HNV _glColor3hNV = &_get_glColor3hNV;

static void APIENTRY _fail_glColor3hvNV(const GLhalfNV * v) {
    const char *_name = "glColor3hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3hvNV(const GLhalfNV * v) {
    PFN_GLCOLOR3HVNV _ptr;
    _ptr = (PFN_GLCOLOR3HVNV)_getPrivateProcAddress("glColor3hvNV");
    if (!_ptr) {
        _ptr = &_fail_glColor3hvNV;
    }
    _glColor3hvNV = _ptr;
    _glColor3hvNV(v);
}

PFN_GLCOLOR3HVNV _glColor3hvNV = &_get_glColor3hvNV;

static void APIENTRY _fail_glColor4hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha) {
    const char *_name = "glColor4hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha) {
    PFN_GLCOLOR4HNV _ptr;
    _ptr = (PFN_GLCOLOR4HNV)_getPrivateProcAddress("glColor4hNV");
    if (!_ptr) {
        _ptr = &_fail_glColor4hNV;
    }
    _glColor4hNV = _ptr;
    _glColor4hNV(red, green, blue, alpha);
}

PFN_GLCOLOR4HNV _glColor4hNV = &_get_glColor4hNV;

static void APIENTRY _fail_glColor4hvNV(const GLhalfNV * v) {
    const char *_name = "glColor4hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4hvNV(const GLhalfNV * v) {
    PFN_GLCOLOR4HVNV _ptr;
    _ptr = (PFN_GLCOLOR4HVNV)_getPrivateProcAddress("glColor4hvNV");
    if (!_ptr) {
        _ptr = &_fail_glColor4hvNV;
    }
    _glColor4hvNV = _ptr;
    _glColor4hvNV(v);
}

PFN_GLCOLOR4HVNV _glColor4hvNV = &_get_glColor4hvNV;

static void APIENTRY _fail_glTexCoord1hNV(GLhalfNV s) {
    const char *_name = "glTexCoord1hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord1hNV(GLhalfNV s) {
    PFN_GLTEXCOORD1HNV _ptr;
    _ptr = (PFN_GLTEXCOORD1HNV)_getPrivateProcAddress("glTexCoord1hNV");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord1hNV;
    }
    _glTexCoord1hNV = _ptr;
    _glTexCoord1hNV(s);
}

PFN_GLTEXCOORD1HNV _glTexCoord1hNV = &_get_glTexCoord1hNV;

static void APIENTRY _fail_glTexCoord1hvNV(const GLhalfNV * v) {
    const char *_name = "glTexCoord1hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord1hvNV(const GLhalfNV * v) {
    PFN_GLTEXCOORD1HVNV _ptr;
    _ptr = (PFN_GLTEXCOORD1HVNV)_getPrivateProcAddress("glTexCoord1hvNV");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord1hvNV;
    }
    _glTexCoord1hvNV = _ptr;
    _glTexCoord1hvNV(v);
}

PFN_GLTEXCOORD1HVNV _glTexCoord1hvNV = &_get_glTexCoord1hvNV;

static void APIENTRY _fail_glTexCoord2hNV(GLhalfNV s, GLhalfNV t) {
    const char *_name = "glTexCoord2hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2hNV(GLhalfNV s, GLhalfNV t) {
    PFN_GLTEXCOORD2HNV _ptr;
    _ptr = (PFN_GLTEXCOORD2HNV)_getPrivateProcAddress("glTexCoord2hNV");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2hNV;
    }
    _glTexCoord2hNV = _ptr;
    _glTexCoord2hNV(s, t);
}

PFN_GLTEXCOORD2HNV _glTexCoord2hNV = &_get_glTexCoord2hNV;

static void APIENTRY _fail_glTexCoord2hvNV(const GLhalfNV * v) {
    const char *_name = "glTexCoord2hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2hvNV(const GLhalfNV * v) {
    PFN_GLTEXCOORD2HVNV _ptr;
    _ptr = (PFN_GLTEXCOORD2HVNV)_getPrivateProcAddress("glTexCoord2hvNV");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2hvNV;
    }
    _glTexCoord2hvNV = _ptr;
    _glTexCoord2hvNV(v);
}

PFN_GLTEXCOORD2HVNV _glTexCoord2hvNV = &_get_glTexCoord2hvNV;

static void APIENTRY _fail_glTexCoord3hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r) {
    const char *_name = "glTexCoord3hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord3hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r) {
    PFN_GLTEXCOORD3HNV _ptr;
    _ptr = (PFN_GLTEXCOORD3HNV)_getPrivateProcAddress("glTexCoord3hNV");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord3hNV;
    }
    _glTexCoord3hNV = _ptr;
    _glTexCoord3hNV(s, t, r);
}

PFN_GLTEXCOORD3HNV _glTexCoord3hNV = &_get_glTexCoord3hNV;

static void APIENTRY _fail_glTexCoord3hvNV(const GLhalfNV * v) {
    const char *_name = "glTexCoord3hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord3hvNV(const GLhalfNV * v) {
    PFN_GLTEXCOORD3HVNV _ptr;
    _ptr = (PFN_GLTEXCOORD3HVNV)_getPrivateProcAddress("glTexCoord3hvNV");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord3hvNV;
    }
    _glTexCoord3hvNV = _ptr;
    _glTexCoord3hvNV(v);
}

PFN_GLTEXCOORD3HVNV _glTexCoord3hvNV = &_get_glTexCoord3hvNV;

static void APIENTRY _fail_glTexCoord4hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q) {
    const char *_name = "glTexCoord4hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord4hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q) {
    PFN_GLTEXCOORD4HNV _ptr;
    _ptr = (PFN_GLTEXCOORD4HNV)_getPrivateProcAddress("glTexCoord4hNV");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord4hNV;
    }
    _glTexCoord4hNV = _ptr;
    _glTexCoord4hNV(s, t, r, q);
}

PFN_GLTEXCOORD4HNV _glTexCoord4hNV = &_get_glTexCoord4hNV;

static void APIENTRY _fail_glTexCoord4hvNV(const GLhalfNV * v) {
    const char *_name = "glTexCoord4hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord4hvNV(const GLhalfNV * v) {
    PFN_GLTEXCOORD4HVNV _ptr;
    _ptr = (PFN_GLTEXCOORD4HVNV)_getPrivateProcAddress("glTexCoord4hvNV");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord4hvNV;
    }
    _glTexCoord4hvNV = _ptr;
    _glTexCoord4hvNV(v);
}

PFN_GLTEXCOORD4HVNV _glTexCoord4hvNV = &_get_glTexCoord4hvNV;

static void APIENTRY _fail_glMultiTexCoord1hNV(GLenum target, GLhalfNV s) {
    const char *_name = "glMultiTexCoord1hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord1hNV(GLenum target, GLhalfNV s) {
    PFN_GLMULTITEXCOORD1HNV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD1HNV)_getPrivateProcAddress("glMultiTexCoord1hNV");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord1hNV;
    }
    _glMultiTexCoord1hNV = _ptr;
    _glMultiTexCoord1hNV(target, s);
}

PFN_GLMULTITEXCOORD1HNV _glMultiTexCoord1hNV = &_get_glMultiTexCoord1hNV;

static void APIENTRY _fail_glMultiTexCoord1hvNV(GLenum target, const GLhalfNV * v) {
    const char *_name = "glMultiTexCoord1hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord1hvNV(GLenum target, const GLhalfNV * v) {
    PFN_GLMULTITEXCOORD1HVNV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD1HVNV)_getPrivateProcAddress("glMultiTexCoord1hvNV");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord1hvNV;
    }
    _glMultiTexCoord1hvNV = _ptr;
    _glMultiTexCoord1hvNV(target, v);
}

PFN_GLMULTITEXCOORD1HVNV _glMultiTexCoord1hvNV = &_get_glMultiTexCoord1hvNV;

static void APIENTRY _fail_glMultiTexCoord2hNV(GLenum target, GLhalfNV s, GLhalfNV t) {
    const char *_name = "glMultiTexCoord2hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord2hNV(GLenum target, GLhalfNV s, GLhalfNV t) {
    PFN_GLMULTITEXCOORD2HNV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD2HNV)_getPrivateProcAddress("glMultiTexCoord2hNV");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord2hNV;
    }
    _glMultiTexCoord2hNV = _ptr;
    _glMultiTexCoord2hNV(target, s, t);
}

PFN_GLMULTITEXCOORD2HNV _glMultiTexCoord2hNV = &_get_glMultiTexCoord2hNV;

static void APIENTRY _fail_glMultiTexCoord2hvNV(GLenum target, const GLhalfNV * v) {
    const char *_name = "glMultiTexCoord2hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord2hvNV(GLenum target, const GLhalfNV * v) {
    PFN_GLMULTITEXCOORD2HVNV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD2HVNV)_getPrivateProcAddress("glMultiTexCoord2hvNV");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord2hvNV;
    }
    _glMultiTexCoord2hvNV = _ptr;
    _glMultiTexCoord2hvNV(target, v);
}

PFN_GLMULTITEXCOORD2HVNV _glMultiTexCoord2hvNV = &_get_glMultiTexCoord2hvNV;

static void APIENTRY _fail_glMultiTexCoord3hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r) {
    const char *_name = "glMultiTexCoord3hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord3hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r) {
    PFN_GLMULTITEXCOORD3HNV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD3HNV)_getPrivateProcAddress("glMultiTexCoord3hNV");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord3hNV;
    }
    _glMultiTexCoord3hNV = _ptr;
    _glMultiTexCoord3hNV(target, s, t, r);
}

PFN_GLMULTITEXCOORD3HNV _glMultiTexCoord3hNV = &_get_glMultiTexCoord3hNV;

static void APIENTRY _fail_glMultiTexCoord3hvNV(GLenum target, const GLhalfNV * v) {
    const char *_name = "glMultiTexCoord3hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord3hvNV(GLenum target, const GLhalfNV * v) {
    PFN_GLMULTITEXCOORD3HVNV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD3HVNV)_getPrivateProcAddress("glMultiTexCoord3hvNV");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord3hvNV;
    }
    _glMultiTexCoord3hvNV = _ptr;
    _glMultiTexCoord3hvNV(target, v);
}

PFN_GLMULTITEXCOORD3HVNV _glMultiTexCoord3hvNV = &_get_glMultiTexCoord3hvNV;

static void APIENTRY _fail_glMultiTexCoord4hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q) {
    const char *_name = "glMultiTexCoord4hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q) {
    PFN_GLMULTITEXCOORD4HNV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4HNV)_getPrivateProcAddress("glMultiTexCoord4hNV");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4hNV;
    }
    _glMultiTexCoord4hNV = _ptr;
    _glMultiTexCoord4hNV(target, s, t, r, q);
}

PFN_GLMULTITEXCOORD4HNV _glMultiTexCoord4hNV = &_get_glMultiTexCoord4hNV;

static void APIENTRY _fail_glMultiTexCoord4hvNV(GLenum target, const GLhalfNV * v) {
    const char *_name = "glMultiTexCoord4hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMultiTexCoord4hvNV(GLenum target, const GLhalfNV * v) {
    PFN_GLMULTITEXCOORD4HVNV _ptr;
    _ptr = (PFN_GLMULTITEXCOORD4HVNV)_getPrivateProcAddress("glMultiTexCoord4hvNV");
    if (!_ptr) {
        _ptr = &_fail_glMultiTexCoord4hvNV;
    }
    _glMultiTexCoord4hvNV = _ptr;
    _glMultiTexCoord4hvNV(target, v);
}

PFN_GLMULTITEXCOORD4HVNV _glMultiTexCoord4hvNV = &_get_glMultiTexCoord4hvNV;

static void APIENTRY _fail_glFogCoordhNV(GLhalfNV fog) {
    const char *_name = "glFogCoordhNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogCoordhNV(GLhalfNV fog) {
    PFN_GLFOGCOORDHNV _ptr;
    _ptr = (PFN_GLFOGCOORDHNV)_getPrivateProcAddress("glFogCoordhNV");
    if (!_ptr) {
        _ptr = &_fail_glFogCoordhNV;
    }
    _glFogCoordhNV = _ptr;
    _glFogCoordhNV(fog);
}

PFN_GLFOGCOORDHNV _glFogCoordhNV = &_get_glFogCoordhNV;

static void APIENTRY _fail_glFogCoordhvNV(const GLhalfNV * fog) {
    const char *_name = "glFogCoordhvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogCoordhvNV(const GLhalfNV * fog) {
    PFN_GLFOGCOORDHVNV _ptr;
    _ptr = (PFN_GLFOGCOORDHVNV)_getPrivateProcAddress("glFogCoordhvNV");
    if (!_ptr) {
        _ptr = &_fail_glFogCoordhvNV;
    }
    _glFogCoordhvNV = _ptr;
    _glFogCoordhvNV(fog);
}

PFN_GLFOGCOORDHVNV _glFogCoordhvNV = &_get_glFogCoordhvNV;

static void APIENTRY _fail_glSecondaryColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue) {
    const char *_name = "glSecondaryColor3hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue) {
    PFN_GLSECONDARYCOLOR3HNV _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3HNV)_getPrivateProcAddress("glSecondaryColor3hNV");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3hNV;
    }
    _glSecondaryColor3hNV = _ptr;
    _glSecondaryColor3hNV(red, green, blue);
}

PFN_GLSECONDARYCOLOR3HNV _glSecondaryColor3hNV = &_get_glSecondaryColor3hNV;

static void APIENTRY _fail_glSecondaryColor3hvNV(const GLhalfNV * v) {
    const char *_name = "glSecondaryColor3hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColor3hvNV(const GLhalfNV * v) {
    PFN_GLSECONDARYCOLOR3HVNV _ptr;
    _ptr = (PFN_GLSECONDARYCOLOR3HVNV)_getPrivateProcAddress("glSecondaryColor3hvNV");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColor3hvNV;
    }
    _glSecondaryColor3hvNV = _ptr;
    _glSecondaryColor3hvNV(v);
}

PFN_GLSECONDARYCOLOR3HVNV _glSecondaryColor3hvNV = &_get_glSecondaryColor3hvNV;

static void APIENTRY _fail_glVertexWeighthNV(GLhalfNV weight) {
    const char *_name = "glVertexWeighthNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexWeighthNV(GLhalfNV weight) {
    PFN_GLVERTEXWEIGHTHNV _ptr;
    _ptr = (PFN_GLVERTEXWEIGHTHNV)_getPrivateProcAddress("glVertexWeighthNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexWeighthNV;
    }
    _glVertexWeighthNV = _ptr;
    _glVertexWeighthNV(weight);
}

PFN_GLVERTEXWEIGHTHNV _glVertexWeighthNV = &_get_glVertexWeighthNV;

static void APIENTRY _fail_glVertexWeighthvNV(const GLhalfNV * weight) {
    const char *_name = "glVertexWeighthvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexWeighthvNV(const GLhalfNV * weight) {
    PFN_GLVERTEXWEIGHTHVNV _ptr;
    _ptr = (PFN_GLVERTEXWEIGHTHVNV)_getPrivateProcAddress("glVertexWeighthvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexWeighthvNV;
    }
    _glVertexWeighthvNV = _ptr;
    _glVertexWeighthvNV(weight);
}

PFN_GLVERTEXWEIGHTHVNV _glVertexWeighthvNV = &_get_glVertexWeighthvNV;

static void APIENTRY _fail_glVertexAttrib1hNV(GLuint index, GLhalfNV x) {
    const char *_name = "glVertexAttrib1hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1hNV(GLuint index, GLhalfNV x) {
    PFN_GLVERTEXATTRIB1HNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1HNV)_getPrivateProcAddress("glVertexAttrib1hNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1hNV;
    }
    _glVertexAttrib1hNV = _ptr;
    _glVertexAttrib1hNV(index, x);
}

PFN_GLVERTEXATTRIB1HNV _glVertexAttrib1hNV = &_get_glVertexAttrib1hNV;

static void APIENTRY _fail_glVertexAttrib1hvNV(GLuint index, const GLhalfNV * v) {
    const char *_name = "glVertexAttrib1hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1hvNV(GLuint index, const GLhalfNV * v) {
    PFN_GLVERTEXATTRIB1HVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1HVNV)_getPrivateProcAddress("glVertexAttrib1hvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1hvNV;
    }
    _glVertexAttrib1hvNV = _ptr;
    _glVertexAttrib1hvNV(index, v);
}

PFN_GLVERTEXATTRIB1HVNV _glVertexAttrib1hvNV = &_get_glVertexAttrib1hvNV;

static void APIENTRY _fail_glVertexAttrib2hNV(GLuint index, GLhalfNV x, GLhalfNV y) {
    const char *_name = "glVertexAttrib2hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2hNV(GLuint index, GLhalfNV x, GLhalfNV y) {
    PFN_GLVERTEXATTRIB2HNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2HNV)_getPrivateProcAddress("glVertexAttrib2hNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2hNV;
    }
    _glVertexAttrib2hNV = _ptr;
    _glVertexAttrib2hNV(index, x, y);
}

PFN_GLVERTEXATTRIB2HNV _glVertexAttrib2hNV = &_get_glVertexAttrib2hNV;

static void APIENTRY _fail_glVertexAttrib2hvNV(GLuint index, const GLhalfNV * v) {
    const char *_name = "glVertexAttrib2hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2hvNV(GLuint index, const GLhalfNV * v) {
    PFN_GLVERTEXATTRIB2HVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2HVNV)_getPrivateProcAddress("glVertexAttrib2hvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2hvNV;
    }
    _glVertexAttrib2hvNV = _ptr;
    _glVertexAttrib2hvNV(index, v);
}

PFN_GLVERTEXATTRIB2HVNV _glVertexAttrib2hvNV = &_get_glVertexAttrib2hvNV;

static void APIENTRY _fail_glVertexAttrib3hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z) {
    const char *_name = "glVertexAttrib3hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z) {
    PFN_GLVERTEXATTRIB3HNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3HNV)_getPrivateProcAddress("glVertexAttrib3hNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3hNV;
    }
    _glVertexAttrib3hNV = _ptr;
    _glVertexAttrib3hNV(index, x, y, z);
}

PFN_GLVERTEXATTRIB3HNV _glVertexAttrib3hNV = &_get_glVertexAttrib3hNV;

static void APIENTRY _fail_glVertexAttrib3hvNV(GLuint index, const GLhalfNV * v) {
    const char *_name = "glVertexAttrib3hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3hvNV(GLuint index, const GLhalfNV * v) {
    PFN_GLVERTEXATTRIB3HVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3HVNV)_getPrivateProcAddress("glVertexAttrib3hvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3hvNV;
    }
    _glVertexAttrib3hvNV = _ptr;
    _glVertexAttrib3hvNV(index, v);
}

PFN_GLVERTEXATTRIB3HVNV _glVertexAttrib3hvNV = &_get_glVertexAttrib3hvNV;

static void APIENTRY _fail_glVertexAttrib4hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w) {
    const char *_name = "glVertexAttrib4hNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w) {
    PFN_GLVERTEXATTRIB4HNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4HNV)_getPrivateProcAddress("glVertexAttrib4hNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4hNV;
    }
    _glVertexAttrib4hNV = _ptr;
    _glVertexAttrib4hNV(index, x, y, z, w);
}

PFN_GLVERTEXATTRIB4HNV _glVertexAttrib4hNV = &_get_glVertexAttrib4hNV;

static void APIENTRY _fail_glVertexAttrib4hvNV(GLuint index, const GLhalfNV * v) {
    const char *_name = "glVertexAttrib4hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4hvNV(GLuint index, const GLhalfNV * v) {
    PFN_GLVERTEXATTRIB4HVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4HVNV)_getPrivateProcAddress("glVertexAttrib4hvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4hvNV;
    }
    _glVertexAttrib4hvNV = _ptr;
    _glVertexAttrib4hvNV(index, v);
}

PFN_GLVERTEXATTRIB4HVNV _glVertexAttrib4hvNV = &_get_glVertexAttrib4hvNV;

static void APIENTRY _fail_glVertexAttribs1hvNV(GLuint index, GLsizei n, const GLhalfNV * v) {
    const char *_name = "glVertexAttribs1hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribs1hvNV(GLuint index, GLsizei n, const GLhalfNV * v) {
    PFN_GLVERTEXATTRIBS1HVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBS1HVNV)_getPrivateProcAddress("glVertexAttribs1hvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribs1hvNV;
    }
    _glVertexAttribs1hvNV = _ptr;
    _glVertexAttribs1hvNV(index, n, v);
}

PFN_GLVERTEXATTRIBS1HVNV _glVertexAttribs1hvNV = &_get_glVertexAttribs1hvNV;

static void APIENTRY _fail_glVertexAttribs2hvNV(GLuint index, GLsizei n, const GLhalfNV * v) {
    const char *_name = "glVertexAttribs2hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribs2hvNV(GLuint index, GLsizei n, const GLhalfNV * v) {
    PFN_GLVERTEXATTRIBS2HVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBS2HVNV)_getPrivateProcAddress("glVertexAttribs2hvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribs2hvNV;
    }
    _glVertexAttribs2hvNV = _ptr;
    _glVertexAttribs2hvNV(index, n, v);
}

PFN_GLVERTEXATTRIBS2HVNV _glVertexAttribs2hvNV = &_get_glVertexAttribs2hvNV;

static void APIENTRY _fail_glVertexAttribs3hvNV(GLuint index, GLsizei n, const GLhalfNV * v) {
    const char *_name = "glVertexAttribs3hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribs3hvNV(GLuint index, GLsizei n, const GLhalfNV * v) {
    PFN_GLVERTEXATTRIBS3HVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBS3HVNV)_getPrivateProcAddress("glVertexAttribs3hvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribs3hvNV;
    }
    _glVertexAttribs3hvNV = _ptr;
    _glVertexAttribs3hvNV(index, n, v);
}

PFN_GLVERTEXATTRIBS3HVNV _glVertexAttribs3hvNV = &_get_glVertexAttribs3hvNV;

static void APIENTRY _fail_glVertexAttribs4hvNV(GLuint index, GLsizei n, const GLhalfNV * v) {
    const char *_name = "glVertexAttribs4hvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribs4hvNV(GLuint index, GLsizei n, const GLhalfNV * v) {
    PFN_GLVERTEXATTRIBS4HVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBS4HVNV)_getPrivateProcAddress("glVertexAttribs4hvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribs4hvNV;
    }
    _glVertexAttribs4hvNV = _ptr;
    _glVertexAttribs4hvNV(index, n, v);
}

PFN_GLVERTEXATTRIBS4HVNV _glVertexAttribs4hvNV = &_get_glVertexAttribs4hvNV;

static void APIENTRY _fail_glGenOcclusionQueriesNV(GLsizei n, GLuint * ids) {
    const char *_name = "glGenOcclusionQueriesNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenOcclusionQueriesNV(GLsizei n, GLuint * ids) {
    PFN_GLGENOCCLUSIONQUERIESNV _ptr;
    _ptr = (PFN_GLGENOCCLUSIONQUERIESNV)_getPrivateProcAddress("glGenOcclusionQueriesNV");
    if (!_ptr) {
        _ptr = &_fail_glGenOcclusionQueriesNV;
    }
    _glGenOcclusionQueriesNV = _ptr;
    _glGenOcclusionQueriesNV(n, ids);
}

PFN_GLGENOCCLUSIONQUERIESNV _glGenOcclusionQueriesNV = &_get_glGenOcclusionQueriesNV;

static void APIENTRY _fail_glDeleteOcclusionQueriesNV(GLsizei n, const GLuint * ids) {
    const char *_name = "glDeleteOcclusionQueriesNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteOcclusionQueriesNV(GLsizei n, const GLuint * ids) {
    PFN_GLDELETEOCCLUSIONQUERIESNV _ptr;
    _ptr = (PFN_GLDELETEOCCLUSIONQUERIESNV)_getPrivateProcAddress("glDeleteOcclusionQueriesNV");
    if (!_ptr) {
        _ptr = &_fail_glDeleteOcclusionQueriesNV;
    }
    _glDeleteOcclusionQueriesNV = _ptr;
    _glDeleteOcclusionQueriesNV(n, ids);
}

PFN_GLDELETEOCCLUSIONQUERIESNV _glDeleteOcclusionQueriesNV = &_get_glDeleteOcclusionQueriesNV;

static GLboolean APIENTRY _fail_glIsOcclusionQueryNV(GLuint id) {
    const char *_name = "glIsOcclusionQueryNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsOcclusionQueryNV(GLuint id) {
    PFN_GLISOCCLUSIONQUERYNV _ptr;
    _ptr = (PFN_GLISOCCLUSIONQUERYNV)_getPrivateProcAddress("glIsOcclusionQueryNV");
    if (!_ptr) {
        _ptr = &_fail_glIsOcclusionQueryNV;
    }
    _glIsOcclusionQueryNV = _ptr;
    return _glIsOcclusionQueryNV(id);
}

PFN_GLISOCCLUSIONQUERYNV _glIsOcclusionQueryNV = &_get_glIsOcclusionQueryNV;

static void APIENTRY _fail_glBeginOcclusionQueryNV(GLuint id) {
    const char *_name = "glBeginOcclusionQueryNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBeginOcclusionQueryNV(GLuint id) {
    PFN_GLBEGINOCCLUSIONQUERYNV _ptr;
    _ptr = (PFN_GLBEGINOCCLUSIONQUERYNV)_getPrivateProcAddress("glBeginOcclusionQueryNV");
    if (!_ptr) {
        _ptr = &_fail_glBeginOcclusionQueryNV;
    }
    _glBeginOcclusionQueryNV = _ptr;
    _glBeginOcclusionQueryNV(id);
}

PFN_GLBEGINOCCLUSIONQUERYNV _glBeginOcclusionQueryNV = &_get_glBeginOcclusionQueryNV;

static void APIENTRY _fail_glEndOcclusionQueryNV(void) {
    const char *_name = "glEndOcclusionQueryNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEndOcclusionQueryNV(void) {
    PFN_GLENDOCCLUSIONQUERYNV _ptr;
    _ptr = (PFN_GLENDOCCLUSIONQUERYNV)_getPrivateProcAddress("glEndOcclusionQueryNV");
    if (!_ptr) {
        _ptr = &_fail_glEndOcclusionQueryNV;
    }
    _glEndOcclusionQueryNV = _ptr;
    _glEndOcclusionQueryNV();
}

PFN_GLENDOCCLUSIONQUERYNV _glEndOcclusionQueryNV = &_get_glEndOcclusionQueryNV;

static void APIENTRY _fail_glGetOcclusionQueryivNV(GLuint id, GLenum pname, GLint * params) {
    const char *_name = "glGetOcclusionQueryivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetOcclusionQueryivNV(GLuint id, GLenum pname, GLint * params) {
    PFN_GLGETOCCLUSIONQUERYIVNV _ptr;
    _ptr = (PFN_GLGETOCCLUSIONQUERYIVNV)_getPrivateProcAddress("glGetOcclusionQueryivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetOcclusionQueryivNV;
    }
    _glGetOcclusionQueryivNV = _ptr;
    _glGetOcclusionQueryivNV(id, pname, params);
}

PFN_GLGETOCCLUSIONQUERYIVNV _glGetOcclusionQueryivNV = &_get_glGetOcclusionQueryivNV;

static void APIENTRY _fail_glGetOcclusionQueryuivNV(GLuint id, GLenum pname, GLuint * params) {
    const char *_name = "glGetOcclusionQueryuivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetOcclusionQueryuivNV(GLuint id, GLenum pname, GLuint * params) {
    PFN_GLGETOCCLUSIONQUERYUIVNV _ptr;
    _ptr = (PFN_GLGETOCCLUSIONQUERYUIVNV)_getPrivateProcAddress("glGetOcclusionQueryuivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetOcclusionQueryuivNV;
    }
    _glGetOcclusionQueryuivNV = _ptr;
    _glGetOcclusionQueryuivNV(id, pname, params);
}

PFN_GLGETOCCLUSIONQUERYUIVNV _glGetOcclusionQueryuivNV = &_get_glGetOcclusionQueryuivNV;

static void APIENTRY _fail_glProgramBufferParametersfvNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat * params) {
    const char *_name = "glProgramBufferParametersfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramBufferParametersfvNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat * params) {
    PFN_GLPROGRAMBUFFERPARAMETERSFVNV _ptr;
    _ptr = (PFN_GLPROGRAMBUFFERPARAMETERSFVNV)_getPrivateProcAddress("glProgramBufferParametersfvNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramBufferParametersfvNV;
    }
    _glProgramBufferParametersfvNV = _ptr;
    _glProgramBufferParametersfvNV(target, buffer, index, count, params);
}

PFN_GLPROGRAMBUFFERPARAMETERSFVNV _glProgramBufferParametersfvNV = &_get_glProgramBufferParametersfvNV;

static void APIENTRY _fail_glProgramBufferParametersIivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint * params) {
    const char *_name = "glProgramBufferParametersIivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramBufferParametersIivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint * params) {
    PFN_GLPROGRAMBUFFERPARAMETERSIIVNV _ptr;
    _ptr = (PFN_GLPROGRAMBUFFERPARAMETERSIIVNV)_getPrivateProcAddress("glProgramBufferParametersIivNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramBufferParametersIivNV;
    }
    _glProgramBufferParametersIivNV = _ptr;
    _glProgramBufferParametersIivNV(target, buffer, index, count, params);
}

PFN_GLPROGRAMBUFFERPARAMETERSIIVNV _glProgramBufferParametersIivNV = &_get_glProgramBufferParametersIivNV;

static void APIENTRY _fail_glProgramBufferParametersIuivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint * params) {
    const char *_name = "glProgramBufferParametersIuivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramBufferParametersIuivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint * params) {
    PFN_GLPROGRAMBUFFERPARAMETERSIUIVNV _ptr;
    _ptr = (PFN_GLPROGRAMBUFFERPARAMETERSIUIVNV)_getPrivateProcAddress("glProgramBufferParametersIuivNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramBufferParametersIuivNV;
    }
    _glProgramBufferParametersIuivNV = _ptr;
    _glProgramBufferParametersIuivNV(target, buffer, index, count, params);
}

PFN_GLPROGRAMBUFFERPARAMETERSIUIVNV _glProgramBufferParametersIuivNV = &_get_glProgramBufferParametersIuivNV;

static GLuint APIENTRY _fail_glGenPathsNV(GLsizei range) {
    const char *_name = "glGenPathsNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glGenPathsNV(GLsizei range) {
    PFN_GLGENPATHSNV _ptr;
    _ptr = (PFN_GLGENPATHSNV)_getPrivateProcAddress("glGenPathsNV");
    if (!_ptr) {
        _ptr = &_fail_glGenPathsNV;
    }
    _glGenPathsNV = _ptr;
    return _glGenPathsNV(range);
}

PFN_GLGENPATHSNV _glGenPathsNV = &_get_glGenPathsNV;

static void APIENTRY _fail_glDeletePathsNV(GLuint path, GLsizei range) {
    const char *_name = "glDeletePathsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeletePathsNV(GLuint path, GLsizei range) {
    PFN_GLDELETEPATHSNV _ptr;
    _ptr = (PFN_GLDELETEPATHSNV)_getPrivateProcAddress("glDeletePathsNV");
    if (!_ptr) {
        _ptr = &_fail_glDeletePathsNV;
    }
    _glDeletePathsNV = _ptr;
    _glDeletePathsNV(path, range);
}

PFN_GLDELETEPATHSNV _glDeletePathsNV = &_get_glDeletePathsNV;

static GLboolean APIENTRY _fail_glIsPathNV(GLuint path) {
    const char *_name = "glIsPathNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsPathNV(GLuint path) {
    PFN_GLISPATHNV _ptr;
    _ptr = (PFN_GLISPATHNV)_getPrivateProcAddress("glIsPathNV");
    if (!_ptr) {
        _ptr = &_fail_glIsPathNV;
    }
    _glIsPathNV = _ptr;
    return _glIsPathNV(path);
}

PFN_GLISPATHNV _glIsPathNV = &_get_glIsPathNV;

static void APIENTRY _fail_glPathCommandsNV(GLuint path, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const GLvoid * coords) {
    const char *_name = "glPathCommandsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPathCommandsNV(GLuint path, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const GLvoid * coords) {
    PFN_GLPATHCOMMANDSNV _ptr;
    _ptr = (PFN_GLPATHCOMMANDSNV)_getPrivateProcAddress("glPathCommandsNV");
    if (!_ptr) {
        _ptr = &_fail_glPathCommandsNV;
    }
    _glPathCommandsNV = _ptr;
    _glPathCommandsNV(path, numCommands, commands, numCoords, coordType, coords);
}

PFN_GLPATHCOMMANDSNV _glPathCommandsNV = &_get_glPathCommandsNV;

static void APIENTRY _fail_glPathCoordsNV(GLuint path, GLsizei numCoords, GLenum coordType, const GLvoid * coords) {
    const char *_name = "glPathCoordsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPathCoordsNV(GLuint path, GLsizei numCoords, GLenum coordType, const GLvoid * coords) {
    PFN_GLPATHCOORDSNV _ptr;
    _ptr = (PFN_GLPATHCOORDSNV)_getPrivateProcAddress("glPathCoordsNV");
    if (!_ptr) {
        _ptr = &_fail_glPathCoordsNV;
    }
    _glPathCoordsNV = _ptr;
    _glPathCoordsNV(path, numCoords, coordType, coords);
}

PFN_GLPATHCOORDSNV _glPathCoordsNV = &_get_glPathCoordsNV;

static void APIENTRY _fail_glPathSubCommandsNV(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const GLvoid * coords) {
    const char *_name = "glPathSubCommandsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPathSubCommandsNV(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const GLvoid * coords) {
    PFN_GLPATHSUBCOMMANDSNV _ptr;
    _ptr = (PFN_GLPATHSUBCOMMANDSNV)_getPrivateProcAddress("glPathSubCommandsNV");
    if (!_ptr) {
        _ptr = &_fail_glPathSubCommandsNV;
    }
    _glPathSubCommandsNV = _ptr;
    _glPathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
}

PFN_GLPATHSUBCOMMANDSNV _glPathSubCommandsNV = &_get_glPathSubCommandsNV;

static void APIENTRY _fail_glPathSubCoordsNV(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const GLvoid * coords) {
    const char *_name = "glPathSubCoordsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPathSubCoordsNV(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const GLvoid * coords) {
    PFN_GLPATHSUBCOORDSNV _ptr;
    _ptr = (PFN_GLPATHSUBCOORDSNV)_getPrivateProcAddress("glPathSubCoordsNV");
    if (!_ptr) {
        _ptr = &_fail_glPathSubCoordsNV;
    }
    _glPathSubCoordsNV = _ptr;
    _glPathSubCoordsNV(path, coordStart, numCoords, coordType, coords);
}

PFN_GLPATHSUBCOORDSNV _glPathSubCoordsNV = &_get_glPathSubCoordsNV;

static void APIENTRY _fail_glPathStringNV(GLuint path, GLenum format, GLsizei length, const GLvoid * pathString) {
    const char *_name = "glPathStringNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPathStringNV(GLuint path, GLenum format, GLsizei length, const GLvoid * pathString) {
    PFN_GLPATHSTRINGNV _ptr;
    _ptr = (PFN_GLPATHSTRINGNV)_getPrivateProcAddress("glPathStringNV");
    if (!_ptr) {
        _ptr = &_fail_glPathStringNV;
    }
    _glPathStringNV = _ptr;
    _glPathStringNV(path, format, length, pathString);
}

PFN_GLPATHSTRINGNV _glPathStringNV = &_get_glPathStringNV;

static void APIENTRY _fail_glPathGlyphsNV(GLuint firstPathName, GLenum fontTarget, const GLvoid * fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid * charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale) {
    const char *_name = "glPathGlyphsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPathGlyphsNV(GLuint firstPathName, GLenum fontTarget, const GLvoid * fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid * charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale) {
    PFN_GLPATHGLYPHSNV _ptr;
    _ptr = (PFN_GLPATHGLYPHSNV)_getPrivateProcAddress("glPathGlyphsNV");
    if (!_ptr) {
        _ptr = &_fail_glPathGlyphsNV;
    }
    _glPathGlyphsNV = _ptr;
    _glPathGlyphsNV(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
}

PFN_GLPATHGLYPHSNV _glPathGlyphsNV = &_get_glPathGlyphsNV;

static void APIENTRY _fail_glPathGlyphRangeNV(GLuint firstPathName, GLenum fontTarget, const GLvoid * fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale) {
    const char *_name = "glPathGlyphRangeNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPathGlyphRangeNV(GLuint firstPathName, GLenum fontTarget, const GLvoid * fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale) {
    PFN_GLPATHGLYPHRANGENV _ptr;
    _ptr = (PFN_GLPATHGLYPHRANGENV)_getPrivateProcAddress("glPathGlyphRangeNV");
    if (!_ptr) {
        _ptr = &_fail_glPathGlyphRangeNV;
    }
    _glPathGlyphRangeNV = _ptr;
    _glPathGlyphRangeNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
}

PFN_GLPATHGLYPHRANGENV _glPathGlyphRangeNV = &_get_glPathGlyphRangeNV;

static void APIENTRY _fail_glWeightPathsNV(GLuint resultPath, GLsizei numPaths, const GLuint * paths, const GLfloat * weights) {
    const char *_name = "glWeightPathsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWeightPathsNV(GLuint resultPath, GLsizei numPaths, const GLuint * paths, const GLfloat * weights) {
    PFN_GLWEIGHTPATHSNV _ptr;
    _ptr = (PFN_GLWEIGHTPATHSNV)_getPrivateProcAddress("glWeightPathsNV");
    if (!_ptr) {
        _ptr = &_fail_glWeightPathsNV;
    }
    _glWeightPathsNV = _ptr;
    _glWeightPathsNV(resultPath, numPaths, paths, weights);
}

PFN_GLWEIGHTPATHSNV _glWeightPathsNV = &_get_glWeightPathsNV;

static void APIENTRY _fail_glCopyPathNV(GLuint resultPath, GLuint srcPath) {
    const char *_name = "glCopyPathNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyPathNV(GLuint resultPath, GLuint srcPath) {
    PFN_GLCOPYPATHNV _ptr;
    _ptr = (PFN_GLCOPYPATHNV)_getPrivateProcAddress("glCopyPathNV");
    if (!_ptr) {
        _ptr = &_fail_glCopyPathNV;
    }
    _glCopyPathNV = _ptr;
    _glCopyPathNV(resultPath, srcPath);
}

PFN_GLCOPYPATHNV _glCopyPathNV = &_get_glCopyPathNV;

static void APIENTRY _fail_glInterpolatePathsNV(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight) {
    const char *_name = "glInterpolatePathsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glInterpolatePathsNV(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight) {
    PFN_GLINTERPOLATEPATHSNV _ptr;
    _ptr = (PFN_GLINTERPOLATEPATHSNV)_getPrivateProcAddress("glInterpolatePathsNV");
    if (!_ptr) {
        _ptr = &_fail_glInterpolatePathsNV;
    }
    _glInterpolatePathsNV = _ptr;
    _glInterpolatePathsNV(resultPath, pathA, pathB, weight);
}

PFN_GLINTERPOLATEPATHSNV _glInterpolatePathsNV = &_get_glInterpolatePathsNV;

static void APIENTRY _fail_glTransformPathNV(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat * transformValues) {
    const char *_name = "glTransformPathNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTransformPathNV(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat * transformValues) {
    PFN_GLTRANSFORMPATHNV _ptr;
    _ptr = (PFN_GLTRANSFORMPATHNV)_getPrivateProcAddress("glTransformPathNV");
    if (!_ptr) {
        _ptr = &_fail_glTransformPathNV;
    }
    _glTransformPathNV = _ptr;
    _glTransformPathNV(resultPath, srcPath, transformType, transformValues);
}

PFN_GLTRANSFORMPATHNV _glTransformPathNV = &_get_glTransformPathNV;

static void APIENTRY _fail_glPathParameterivNV(GLuint path, GLenum pname, const GLint * value) {
    const char *_name = "glPathParameterivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPathParameterivNV(GLuint path, GLenum pname, const GLint * value) {
    PFN_GLPATHPARAMETERIVNV _ptr;
    _ptr = (PFN_GLPATHPARAMETERIVNV)_getPrivateProcAddress("glPathParameterivNV");
    if (!_ptr) {
        _ptr = &_fail_glPathParameterivNV;
    }
    _glPathParameterivNV = _ptr;
    _glPathParameterivNV(path, pname, value);
}

PFN_GLPATHPARAMETERIVNV _glPathParameterivNV = &_get_glPathParameterivNV;

static void APIENTRY _fail_glPathParameteriNV(GLuint path, GLenum pname, GLint value) {
    const char *_name = "glPathParameteriNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPathParameteriNV(GLuint path, GLenum pname, GLint value) {
    PFN_GLPATHPARAMETERINV _ptr;
    _ptr = (PFN_GLPATHPARAMETERINV)_getPrivateProcAddress("glPathParameteriNV");
    if (!_ptr) {
        _ptr = &_fail_glPathParameteriNV;
    }
    _glPathParameteriNV = _ptr;
    _glPathParameteriNV(path, pname, value);
}

PFN_GLPATHPARAMETERINV _glPathParameteriNV = &_get_glPathParameteriNV;

static void APIENTRY _fail_glPathParameterfvNV(GLuint path, GLenum pname, const GLfloat * value) {
    const char *_name = "glPathParameterfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPathParameterfvNV(GLuint path, GLenum pname, const GLfloat * value) {
    PFN_GLPATHPARAMETERFVNV _ptr;
    _ptr = (PFN_GLPATHPARAMETERFVNV)_getPrivateProcAddress("glPathParameterfvNV");
    if (!_ptr) {
        _ptr = &_fail_glPathParameterfvNV;
    }
    _glPathParameterfvNV = _ptr;
    _glPathParameterfvNV(path, pname, value);
}

PFN_GLPATHPARAMETERFVNV _glPathParameterfvNV = &_get_glPathParameterfvNV;

static void APIENTRY _fail_glPathParameterfNV(GLuint path, GLenum pname, GLfloat value) {
    const char *_name = "glPathParameterfNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPathParameterfNV(GLuint path, GLenum pname, GLfloat value) {
    PFN_GLPATHPARAMETERFNV _ptr;
    _ptr = (PFN_GLPATHPARAMETERFNV)_getPrivateProcAddress("glPathParameterfNV");
    if (!_ptr) {
        _ptr = &_fail_glPathParameterfNV;
    }
    _glPathParameterfNV = _ptr;
    _glPathParameterfNV(path, pname, value);
}

PFN_GLPATHPARAMETERFNV _glPathParameterfNV = &_get_glPathParameterfNV;

static void APIENTRY _fail_glPathDashArrayNV(GLuint path, GLsizei dashCount, const GLfloat * dashArray) {
    const char *_name = "glPathDashArrayNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPathDashArrayNV(GLuint path, GLsizei dashCount, const GLfloat * dashArray) {
    PFN_GLPATHDASHARRAYNV _ptr;
    _ptr = (PFN_GLPATHDASHARRAYNV)_getPrivateProcAddress("glPathDashArrayNV");
    if (!_ptr) {
        _ptr = &_fail_glPathDashArrayNV;
    }
    _glPathDashArrayNV = _ptr;
    _glPathDashArrayNV(path, dashCount, dashArray);
}

PFN_GLPATHDASHARRAYNV _glPathDashArrayNV = &_get_glPathDashArrayNV;

static void APIENTRY _fail_glPathStencilFuncNV(GLenum func, GLint ref, GLuint mask) {
    const char *_name = "glPathStencilFuncNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPathStencilFuncNV(GLenum func, GLint ref, GLuint mask) {
    PFN_GLPATHSTENCILFUNCNV _ptr;
    _ptr = (PFN_GLPATHSTENCILFUNCNV)_getPrivateProcAddress("glPathStencilFuncNV");
    if (!_ptr) {
        _ptr = &_fail_glPathStencilFuncNV;
    }
    _glPathStencilFuncNV = _ptr;
    _glPathStencilFuncNV(func, ref, mask);
}

PFN_GLPATHSTENCILFUNCNV _glPathStencilFuncNV = &_get_glPathStencilFuncNV;

static void APIENTRY _fail_glPathStencilDepthOffsetNV(GLfloat factor, GLfloat units) {
    const char *_name = "glPathStencilDepthOffsetNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPathStencilDepthOffsetNV(GLfloat factor, GLfloat units) {
    PFN_GLPATHSTENCILDEPTHOFFSETNV _ptr;
    _ptr = (PFN_GLPATHSTENCILDEPTHOFFSETNV)_getPrivateProcAddress("glPathStencilDepthOffsetNV");
    if (!_ptr) {
        _ptr = &_fail_glPathStencilDepthOffsetNV;
    }
    _glPathStencilDepthOffsetNV = _ptr;
    _glPathStencilDepthOffsetNV(factor, units);
}

PFN_GLPATHSTENCILDEPTHOFFSETNV _glPathStencilDepthOffsetNV = &_get_glPathStencilDepthOffsetNV;

static void APIENTRY _fail_glStencilFillPathNV(GLuint path, GLenum fillMode, GLuint mask) {
    const char *_name = "glStencilFillPathNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStencilFillPathNV(GLuint path, GLenum fillMode, GLuint mask) {
    PFN_GLSTENCILFILLPATHNV _ptr;
    _ptr = (PFN_GLSTENCILFILLPATHNV)_getPrivateProcAddress("glStencilFillPathNV");
    if (!_ptr) {
        _ptr = &_fail_glStencilFillPathNV;
    }
    _glStencilFillPathNV = _ptr;
    _glStencilFillPathNV(path, fillMode, mask);
}

PFN_GLSTENCILFILLPATHNV _glStencilFillPathNV = &_get_glStencilFillPathNV;

static void APIENTRY _fail_glStencilStrokePathNV(GLuint path, GLint reference, GLuint mask) {
    const char *_name = "glStencilStrokePathNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStencilStrokePathNV(GLuint path, GLint reference, GLuint mask) {
    PFN_GLSTENCILSTROKEPATHNV _ptr;
    _ptr = (PFN_GLSTENCILSTROKEPATHNV)_getPrivateProcAddress("glStencilStrokePathNV");
    if (!_ptr) {
        _ptr = &_fail_glStencilStrokePathNV;
    }
    _glStencilStrokePathNV = _ptr;
    _glStencilStrokePathNV(path, reference, mask);
}

PFN_GLSTENCILSTROKEPATHNV _glStencilStrokePathNV = &_get_glStencilStrokePathNV;

static void APIENTRY _fail_glStencilFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat * transformValues) {
    const char *_name = "glStencilFillPathInstancedNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStencilFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat * transformValues) {
    PFN_GLSTENCILFILLPATHINSTANCEDNV _ptr;
    _ptr = (PFN_GLSTENCILFILLPATHINSTANCEDNV)_getPrivateProcAddress("glStencilFillPathInstancedNV");
    if (!_ptr) {
        _ptr = &_fail_glStencilFillPathInstancedNV;
    }
    _glStencilFillPathInstancedNV = _ptr;
    _glStencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
}

PFN_GLSTENCILFILLPATHINSTANCEDNV _glStencilFillPathInstancedNV = &_get_glStencilFillPathInstancedNV;

static void APIENTRY _fail_glStencilStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat * transformValues) {
    const char *_name = "glStencilStrokePathInstancedNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStencilStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat * transformValues) {
    PFN_GLSTENCILSTROKEPATHINSTANCEDNV _ptr;
    _ptr = (PFN_GLSTENCILSTROKEPATHINSTANCEDNV)_getPrivateProcAddress("glStencilStrokePathInstancedNV");
    if (!_ptr) {
        _ptr = &_fail_glStencilStrokePathInstancedNV;
    }
    _glStencilStrokePathInstancedNV = _ptr;
    _glStencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
}

PFN_GLSTENCILSTROKEPATHINSTANCEDNV _glStencilStrokePathInstancedNV = &_get_glStencilStrokePathInstancedNV;

static void APIENTRY _fail_glPathCoverDepthFuncNV(GLenum func) {
    const char *_name = "glPathCoverDepthFuncNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPathCoverDepthFuncNV(GLenum func) {
    PFN_GLPATHCOVERDEPTHFUNCNV _ptr;
    _ptr = (PFN_GLPATHCOVERDEPTHFUNCNV)_getPrivateProcAddress("glPathCoverDepthFuncNV");
    if (!_ptr) {
        _ptr = &_fail_glPathCoverDepthFuncNV;
    }
    _glPathCoverDepthFuncNV = _ptr;
    _glPathCoverDepthFuncNV(func);
}

PFN_GLPATHCOVERDEPTHFUNCNV _glPathCoverDepthFuncNV = &_get_glPathCoverDepthFuncNV;

static void APIENTRY _fail_glPathColorGenNV(GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat * coeffs) {
    const char *_name = "glPathColorGenNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPathColorGenNV(GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat * coeffs) {
    PFN_GLPATHCOLORGENNV _ptr;
    _ptr = (PFN_GLPATHCOLORGENNV)_getPrivateProcAddress("glPathColorGenNV");
    if (!_ptr) {
        _ptr = &_fail_glPathColorGenNV;
    }
    _glPathColorGenNV = _ptr;
    _glPathColorGenNV(color, genMode, colorFormat, coeffs);
}

PFN_GLPATHCOLORGENNV _glPathColorGenNV = &_get_glPathColorGenNV;

static void APIENTRY _fail_glPathTexGenNV(GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat * coeffs) {
    const char *_name = "glPathTexGenNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPathTexGenNV(GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat * coeffs) {
    PFN_GLPATHTEXGENNV _ptr;
    _ptr = (PFN_GLPATHTEXGENNV)_getPrivateProcAddress("glPathTexGenNV");
    if (!_ptr) {
        _ptr = &_fail_glPathTexGenNV;
    }
    _glPathTexGenNV = _ptr;
    _glPathTexGenNV(texCoordSet, genMode, components, coeffs);
}

PFN_GLPATHTEXGENNV _glPathTexGenNV = &_get_glPathTexGenNV;

static void APIENTRY _fail_glPathFogGenNV(GLenum genMode) {
    const char *_name = "glPathFogGenNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPathFogGenNV(GLenum genMode) {
    PFN_GLPATHFOGGENNV _ptr;
    _ptr = (PFN_GLPATHFOGGENNV)_getPrivateProcAddress("glPathFogGenNV");
    if (!_ptr) {
        _ptr = &_fail_glPathFogGenNV;
    }
    _glPathFogGenNV = _ptr;
    _glPathFogGenNV(genMode);
}

PFN_GLPATHFOGGENNV _glPathFogGenNV = &_get_glPathFogGenNV;

static void APIENTRY _fail_glCoverFillPathNV(GLuint path, GLenum coverMode) {
    const char *_name = "glCoverFillPathNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCoverFillPathNV(GLuint path, GLenum coverMode) {
    PFN_GLCOVERFILLPATHNV _ptr;
    _ptr = (PFN_GLCOVERFILLPATHNV)_getPrivateProcAddress("glCoverFillPathNV");
    if (!_ptr) {
        _ptr = &_fail_glCoverFillPathNV;
    }
    _glCoverFillPathNV = _ptr;
    _glCoverFillPathNV(path, coverMode);
}

PFN_GLCOVERFILLPATHNV _glCoverFillPathNV = &_get_glCoverFillPathNV;

static void APIENTRY _fail_glCoverStrokePathNV(GLuint path, GLenum coverMode) {
    const char *_name = "glCoverStrokePathNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCoverStrokePathNV(GLuint path, GLenum coverMode) {
    PFN_GLCOVERSTROKEPATHNV _ptr;
    _ptr = (PFN_GLCOVERSTROKEPATHNV)_getPrivateProcAddress("glCoverStrokePathNV");
    if (!_ptr) {
        _ptr = &_fail_glCoverStrokePathNV;
    }
    _glCoverStrokePathNV = _ptr;
    _glCoverStrokePathNV(path, coverMode);
}

PFN_GLCOVERSTROKEPATHNV _glCoverStrokePathNV = &_get_glCoverStrokePathNV;

static void APIENTRY _fail_glCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues) {
    const char *_name = "glCoverFillPathInstancedNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues) {
    PFN_GLCOVERFILLPATHINSTANCEDNV _ptr;
    _ptr = (PFN_GLCOVERFILLPATHINSTANCEDNV)_getPrivateProcAddress("glCoverFillPathInstancedNV");
    if (!_ptr) {
        _ptr = &_fail_glCoverFillPathInstancedNV;
    }
    _glCoverFillPathInstancedNV = _ptr;
    _glCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
}

PFN_GLCOVERFILLPATHINSTANCEDNV _glCoverFillPathInstancedNV = &_get_glCoverFillPathInstancedNV;

static void APIENTRY _fail_glCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues) {
    const char *_name = "glCoverStrokePathInstancedNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues) {
    PFN_GLCOVERSTROKEPATHINSTANCEDNV _ptr;
    _ptr = (PFN_GLCOVERSTROKEPATHINSTANCEDNV)_getPrivateProcAddress("glCoverStrokePathInstancedNV");
    if (!_ptr) {
        _ptr = &_fail_glCoverStrokePathInstancedNV;
    }
    _glCoverStrokePathInstancedNV = _ptr;
    _glCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
}

PFN_GLCOVERSTROKEPATHINSTANCEDNV _glCoverStrokePathInstancedNV = &_get_glCoverStrokePathInstancedNV;

static void APIENTRY _fail_glGetPathParameterivNV(GLuint path, GLenum pname, GLint * value) {
    const char *_name = "glGetPathParameterivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPathParameterivNV(GLuint path, GLenum pname, GLint * value) {
    PFN_GLGETPATHPARAMETERIVNV _ptr;
    _ptr = (PFN_GLGETPATHPARAMETERIVNV)_getPrivateProcAddress("glGetPathParameterivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetPathParameterivNV;
    }
    _glGetPathParameterivNV = _ptr;
    _glGetPathParameterivNV(path, pname, value);
}

PFN_GLGETPATHPARAMETERIVNV _glGetPathParameterivNV = &_get_glGetPathParameterivNV;

static void APIENTRY _fail_glGetPathParameterfvNV(GLuint path, GLenum pname, GLfloat * value) {
    const char *_name = "glGetPathParameterfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPathParameterfvNV(GLuint path, GLenum pname, GLfloat * value) {
    PFN_GLGETPATHPARAMETERFVNV _ptr;
    _ptr = (PFN_GLGETPATHPARAMETERFVNV)_getPrivateProcAddress("glGetPathParameterfvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetPathParameterfvNV;
    }
    _glGetPathParameterfvNV = _ptr;
    _glGetPathParameterfvNV(path, pname, value);
}

PFN_GLGETPATHPARAMETERFVNV _glGetPathParameterfvNV = &_get_glGetPathParameterfvNV;

static void APIENTRY _fail_glGetPathCommandsNV(GLuint path, GLubyte * commands) {
    const char *_name = "glGetPathCommandsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPathCommandsNV(GLuint path, GLubyte * commands) {
    PFN_GLGETPATHCOMMANDSNV _ptr;
    _ptr = (PFN_GLGETPATHCOMMANDSNV)_getPrivateProcAddress("glGetPathCommandsNV");
    if (!_ptr) {
        _ptr = &_fail_glGetPathCommandsNV;
    }
    _glGetPathCommandsNV = _ptr;
    _glGetPathCommandsNV(path, commands);
}

PFN_GLGETPATHCOMMANDSNV _glGetPathCommandsNV = &_get_glGetPathCommandsNV;

static void APIENTRY _fail_glGetPathCoordsNV(GLuint path, GLfloat * coords) {
    const char *_name = "glGetPathCoordsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPathCoordsNV(GLuint path, GLfloat * coords) {
    PFN_GLGETPATHCOORDSNV _ptr;
    _ptr = (PFN_GLGETPATHCOORDSNV)_getPrivateProcAddress("glGetPathCoordsNV");
    if (!_ptr) {
        _ptr = &_fail_glGetPathCoordsNV;
    }
    _glGetPathCoordsNV = _ptr;
    _glGetPathCoordsNV(path, coords);
}

PFN_GLGETPATHCOORDSNV _glGetPathCoordsNV = &_get_glGetPathCoordsNV;

static void APIENTRY _fail_glGetPathDashArrayNV(GLuint path, GLfloat * dashArray) {
    const char *_name = "glGetPathDashArrayNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPathDashArrayNV(GLuint path, GLfloat * dashArray) {
    PFN_GLGETPATHDASHARRAYNV _ptr;
    _ptr = (PFN_GLGETPATHDASHARRAYNV)_getPrivateProcAddress("glGetPathDashArrayNV");
    if (!_ptr) {
        _ptr = &_fail_glGetPathDashArrayNV;
    }
    _glGetPathDashArrayNV = _ptr;
    _glGetPathDashArrayNV(path, dashArray);
}

PFN_GLGETPATHDASHARRAYNV _glGetPathDashArrayNV = &_get_glGetPathDashArrayNV;

static void APIENTRY _fail_glGetPathMetricsNV(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLsizei stride, GLfloat * metrics) {
    const char *_name = "glGetPathMetricsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPathMetricsNV(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLsizei stride, GLfloat * metrics) {
    PFN_GLGETPATHMETRICSNV _ptr;
    _ptr = (PFN_GLGETPATHMETRICSNV)_getPrivateProcAddress("glGetPathMetricsNV");
    if (!_ptr) {
        _ptr = &_fail_glGetPathMetricsNV;
    }
    _glGetPathMetricsNV = _ptr;
    _glGetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
}

PFN_GLGETPATHMETRICSNV _glGetPathMetricsNV = &_get_glGetPathMetricsNV;

static void APIENTRY _fail_glGetPathMetricRangeNV(GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat * metrics) {
    const char *_name = "glGetPathMetricRangeNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPathMetricRangeNV(GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat * metrics) {
    PFN_GLGETPATHMETRICRANGENV _ptr;
    _ptr = (PFN_GLGETPATHMETRICRANGENV)_getPrivateProcAddress("glGetPathMetricRangeNV");
    if (!_ptr) {
        _ptr = &_fail_glGetPathMetricRangeNV;
    }
    _glGetPathMetricRangeNV = _ptr;
    _glGetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics);
}

PFN_GLGETPATHMETRICRANGENV _glGetPathMetricRangeNV = &_get_glGetPathMetricRangeNV;

static void APIENTRY _fail_glGetPathSpacingNV(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat * returnedSpacing) {
    const char *_name = "glGetPathSpacingNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPathSpacingNV(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat * returnedSpacing) {
    PFN_GLGETPATHSPACINGNV _ptr;
    _ptr = (PFN_GLGETPATHSPACINGNV)_getPrivateProcAddress("glGetPathSpacingNV");
    if (!_ptr) {
        _ptr = &_fail_glGetPathSpacingNV;
    }
    _glGetPathSpacingNV = _ptr;
    _glGetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
}

PFN_GLGETPATHSPACINGNV _glGetPathSpacingNV = &_get_glGetPathSpacingNV;

static void APIENTRY _fail_glGetPathColorGenivNV(GLenum color, GLenum pname, GLint * value) {
    const char *_name = "glGetPathColorGenivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPathColorGenivNV(GLenum color, GLenum pname, GLint * value) {
    PFN_GLGETPATHCOLORGENIVNV _ptr;
    _ptr = (PFN_GLGETPATHCOLORGENIVNV)_getPrivateProcAddress("glGetPathColorGenivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetPathColorGenivNV;
    }
    _glGetPathColorGenivNV = _ptr;
    _glGetPathColorGenivNV(color, pname, value);
}

PFN_GLGETPATHCOLORGENIVNV _glGetPathColorGenivNV = &_get_glGetPathColorGenivNV;

static void APIENTRY _fail_glGetPathColorGenfvNV(GLenum color, GLenum pname, GLfloat * value) {
    const char *_name = "glGetPathColorGenfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPathColorGenfvNV(GLenum color, GLenum pname, GLfloat * value) {
    PFN_GLGETPATHCOLORGENFVNV _ptr;
    _ptr = (PFN_GLGETPATHCOLORGENFVNV)_getPrivateProcAddress("glGetPathColorGenfvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetPathColorGenfvNV;
    }
    _glGetPathColorGenfvNV = _ptr;
    _glGetPathColorGenfvNV(color, pname, value);
}

PFN_GLGETPATHCOLORGENFVNV _glGetPathColorGenfvNV = &_get_glGetPathColorGenfvNV;

static void APIENTRY _fail_glGetPathTexGenivNV(GLenum texCoordSet, GLenum pname, GLint * value) {
    const char *_name = "glGetPathTexGenivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPathTexGenivNV(GLenum texCoordSet, GLenum pname, GLint * value) {
    PFN_GLGETPATHTEXGENIVNV _ptr;
    _ptr = (PFN_GLGETPATHTEXGENIVNV)_getPrivateProcAddress("glGetPathTexGenivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetPathTexGenivNV;
    }
    _glGetPathTexGenivNV = _ptr;
    _glGetPathTexGenivNV(texCoordSet, pname, value);
}

PFN_GLGETPATHTEXGENIVNV _glGetPathTexGenivNV = &_get_glGetPathTexGenivNV;

static void APIENTRY _fail_glGetPathTexGenfvNV(GLenum texCoordSet, GLenum pname, GLfloat * value) {
    const char *_name = "glGetPathTexGenfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPathTexGenfvNV(GLenum texCoordSet, GLenum pname, GLfloat * value) {
    PFN_GLGETPATHTEXGENFVNV _ptr;
    _ptr = (PFN_GLGETPATHTEXGENFVNV)_getPrivateProcAddress("glGetPathTexGenfvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetPathTexGenfvNV;
    }
    _glGetPathTexGenfvNV = _ptr;
    _glGetPathTexGenfvNV(texCoordSet, pname, value);
}

PFN_GLGETPATHTEXGENFVNV _glGetPathTexGenfvNV = &_get_glGetPathTexGenfvNV;

static GLboolean APIENTRY _fail_glIsPointInFillPathNV(GLuint path, GLuint mask, GLfloat x, GLfloat y) {
    const char *_name = "glIsPointInFillPathNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsPointInFillPathNV(GLuint path, GLuint mask, GLfloat x, GLfloat y) {
    PFN_GLISPOINTINFILLPATHNV _ptr;
    _ptr = (PFN_GLISPOINTINFILLPATHNV)_getPrivateProcAddress("glIsPointInFillPathNV");
    if (!_ptr) {
        _ptr = &_fail_glIsPointInFillPathNV;
    }
    _glIsPointInFillPathNV = _ptr;
    return _glIsPointInFillPathNV(path, mask, x, y);
}

PFN_GLISPOINTINFILLPATHNV _glIsPointInFillPathNV = &_get_glIsPointInFillPathNV;

static GLboolean APIENTRY _fail_glIsPointInStrokePathNV(GLuint path, GLfloat x, GLfloat y) {
    const char *_name = "glIsPointInStrokePathNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsPointInStrokePathNV(GLuint path, GLfloat x, GLfloat y) {
    PFN_GLISPOINTINSTROKEPATHNV _ptr;
    _ptr = (PFN_GLISPOINTINSTROKEPATHNV)_getPrivateProcAddress("glIsPointInStrokePathNV");
    if (!_ptr) {
        _ptr = &_fail_glIsPointInStrokePathNV;
    }
    _glIsPointInStrokePathNV = _ptr;
    return _glIsPointInStrokePathNV(path, x, y);
}

PFN_GLISPOINTINSTROKEPATHNV _glIsPointInStrokePathNV = &_get_glIsPointInStrokePathNV;

static GLfloat APIENTRY _fail_glGetPathLengthNV(GLuint path, GLsizei startSegment, GLsizei numSegments) {
    const char *_name = "glGetPathLengthNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLfloat APIENTRY _get_glGetPathLengthNV(GLuint path, GLsizei startSegment, GLsizei numSegments) {
    PFN_GLGETPATHLENGTHNV _ptr;
    _ptr = (PFN_GLGETPATHLENGTHNV)_getPrivateProcAddress("glGetPathLengthNV");
    if (!_ptr) {
        _ptr = &_fail_glGetPathLengthNV;
    }
    _glGetPathLengthNV = _ptr;
    return _glGetPathLengthNV(path, startSegment, numSegments);
}

PFN_GLGETPATHLENGTHNV _glGetPathLengthNV = &_get_glGetPathLengthNV;

static GLboolean APIENTRY _fail_glPointAlongPathNV(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat * x, GLfloat * y, GLfloat * tangentX, GLfloat * tangentY) {
    const char *_name = "glPointAlongPathNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glPointAlongPathNV(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat * x, GLfloat * y, GLfloat * tangentX, GLfloat * tangentY) {
    PFN_GLPOINTALONGPATHNV _ptr;
    _ptr = (PFN_GLPOINTALONGPATHNV)_getPrivateProcAddress("glPointAlongPathNV");
    if (!_ptr) {
        _ptr = &_fail_glPointAlongPathNV;
    }
    _glPointAlongPathNV = _ptr;
    return _glPointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
}

PFN_GLPOINTALONGPATHNV _glPointAlongPathNV = &_get_glPointAlongPathNV;

static void APIENTRY _fail_glMatrixLoad3x2fNV(GLenum matrixMode, const GLfloat * m) {
    const char *_name = "glMatrixLoad3x2fNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixLoad3x2fNV(GLenum matrixMode, const GLfloat * m) {
    PFN_GLMATRIXLOAD3X2FNV _ptr;
    _ptr = (PFN_GLMATRIXLOAD3X2FNV)_getPrivateProcAddress("glMatrixLoad3x2fNV");
    if (!_ptr) {
        _ptr = &_fail_glMatrixLoad3x2fNV;
    }
    _glMatrixLoad3x2fNV = _ptr;
    _glMatrixLoad3x2fNV(matrixMode, m);
}

PFN_GLMATRIXLOAD3X2FNV _glMatrixLoad3x2fNV = &_get_glMatrixLoad3x2fNV;

static void APIENTRY _fail_glMatrixLoad3x3fNV(GLenum matrixMode, const GLfloat * m) {
    const char *_name = "glMatrixLoad3x3fNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixLoad3x3fNV(GLenum matrixMode, const GLfloat * m) {
    PFN_GLMATRIXLOAD3X3FNV _ptr;
    _ptr = (PFN_GLMATRIXLOAD3X3FNV)_getPrivateProcAddress("glMatrixLoad3x3fNV");
    if (!_ptr) {
        _ptr = &_fail_glMatrixLoad3x3fNV;
    }
    _glMatrixLoad3x3fNV = _ptr;
    _glMatrixLoad3x3fNV(matrixMode, m);
}

PFN_GLMATRIXLOAD3X3FNV _glMatrixLoad3x3fNV = &_get_glMatrixLoad3x3fNV;

static void APIENTRY _fail_glMatrixLoadTranspose3x3fNV(GLenum matrixMode, const GLfloat * m) {
    const char *_name = "glMatrixLoadTranspose3x3fNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixLoadTranspose3x3fNV(GLenum matrixMode, const GLfloat * m) {
    PFN_GLMATRIXLOADTRANSPOSE3X3FNV _ptr;
    _ptr = (PFN_GLMATRIXLOADTRANSPOSE3X3FNV)_getPrivateProcAddress("glMatrixLoadTranspose3x3fNV");
    if (!_ptr) {
        _ptr = &_fail_glMatrixLoadTranspose3x3fNV;
    }
    _glMatrixLoadTranspose3x3fNV = _ptr;
    _glMatrixLoadTranspose3x3fNV(matrixMode, m);
}

PFN_GLMATRIXLOADTRANSPOSE3X3FNV _glMatrixLoadTranspose3x3fNV = &_get_glMatrixLoadTranspose3x3fNV;

static void APIENTRY _fail_glMatrixMult3x2fNV(GLenum matrixMode, const GLfloat * m) {
    const char *_name = "glMatrixMult3x2fNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixMult3x2fNV(GLenum matrixMode, const GLfloat * m) {
    PFN_GLMATRIXMULT3X2FNV _ptr;
    _ptr = (PFN_GLMATRIXMULT3X2FNV)_getPrivateProcAddress("glMatrixMult3x2fNV");
    if (!_ptr) {
        _ptr = &_fail_glMatrixMult3x2fNV;
    }
    _glMatrixMult3x2fNV = _ptr;
    _glMatrixMult3x2fNV(matrixMode, m);
}

PFN_GLMATRIXMULT3X2FNV _glMatrixMult3x2fNV = &_get_glMatrixMult3x2fNV;

static void APIENTRY _fail_glMatrixMult3x3fNV(GLenum matrixMode, const GLfloat * m) {
    const char *_name = "glMatrixMult3x3fNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixMult3x3fNV(GLenum matrixMode, const GLfloat * m) {
    PFN_GLMATRIXMULT3X3FNV _ptr;
    _ptr = (PFN_GLMATRIXMULT3X3FNV)_getPrivateProcAddress("glMatrixMult3x3fNV");
    if (!_ptr) {
        _ptr = &_fail_glMatrixMult3x3fNV;
    }
    _glMatrixMult3x3fNV = _ptr;
    _glMatrixMult3x3fNV(matrixMode, m);
}

PFN_GLMATRIXMULT3X3FNV _glMatrixMult3x3fNV = &_get_glMatrixMult3x3fNV;

static void APIENTRY _fail_glMatrixMultTranspose3x3fNV(GLenum matrixMode, const GLfloat * m) {
    const char *_name = "glMatrixMultTranspose3x3fNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixMultTranspose3x3fNV(GLenum matrixMode, const GLfloat * m) {
    PFN_GLMATRIXMULTTRANSPOSE3X3FNV _ptr;
    _ptr = (PFN_GLMATRIXMULTTRANSPOSE3X3FNV)_getPrivateProcAddress("glMatrixMultTranspose3x3fNV");
    if (!_ptr) {
        _ptr = &_fail_glMatrixMultTranspose3x3fNV;
    }
    _glMatrixMultTranspose3x3fNV = _ptr;
    _glMatrixMultTranspose3x3fNV(matrixMode, m);
}

PFN_GLMATRIXMULTTRANSPOSE3X3FNV _glMatrixMultTranspose3x3fNV = &_get_glMatrixMultTranspose3x3fNV;

static void APIENTRY _fail_glStencilThenCoverFillPathNV(GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode) {
    const char *_name = "glStencilThenCoverFillPathNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStencilThenCoverFillPathNV(GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode) {
    PFN_GLSTENCILTHENCOVERFILLPATHNV _ptr;
    _ptr = (PFN_GLSTENCILTHENCOVERFILLPATHNV)_getPrivateProcAddress("glStencilThenCoverFillPathNV");
    if (!_ptr) {
        _ptr = &_fail_glStencilThenCoverFillPathNV;
    }
    _glStencilThenCoverFillPathNV = _ptr;
    _glStencilThenCoverFillPathNV(path, fillMode, mask, coverMode);
}

PFN_GLSTENCILTHENCOVERFILLPATHNV _glStencilThenCoverFillPathNV = &_get_glStencilThenCoverFillPathNV;

static void APIENTRY _fail_glStencilThenCoverStrokePathNV(GLuint path, GLint reference, GLuint mask, GLenum coverMode) {
    const char *_name = "glStencilThenCoverStrokePathNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStencilThenCoverStrokePathNV(GLuint path, GLint reference, GLuint mask, GLenum coverMode) {
    PFN_GLSTENCILTHENCOVERSTROKEPATHNV _ptr;
    _ptr = (PFN_GLSTENCILTHENCOVERSTROKEPATHNV)_getPrivateProcAddress("glStencilThenCoverStrokePathNV");
    if (!_ptr) {
        _ptr = &_fail_glStencilThenCoverStrokePathNV;
    }
    _glStencilThenCoverStrokePathNV = _ptr;
    _glStencilThenCoverStrokePathNV(path, reference, mask, coverMode);
}

PFN_GLSTENCILTHENCOVERSTROKEPATHNV _glStencilThenCoverStrokePathNV = &_get_glStencilThenCoverStrokePathNV;

static void APIENTRY _fail_glStencilThenCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat * transformValues) {
    const char *_name = "glStencilThenCoverFillPathInstancedNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStencilThenCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat * transformValues) {
    PFN_GLSTENCILTHENCOVERFILLPATHINSTANCEDNV _ptr;
    _ptr = (PFN_GLSTENCILTHENCOVERFILLPATHINSTANCEDNV)_getPrivateProcAddress("glStencilThenCoverFillPathInstancedNV");
    if (!_ptr) {
        _ptr = &_fail_glStencilThenCoverFillPathInstancedNV;
    }
    _glStencilThenCoverFillPathInstancedNV = _ptr;
    _glStencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
}

PFN_GLSTENCILTHENCOVERFILLPATHINSTANCEDNV _glStencilThenCoverFillPathInstancedNV = &_get_glStencilThenCoverFillPathInstancedNV;

static void APIENTRY _fail_glStencilThenCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat * transformValues) {
    const char *_name = "glStencilThenCoverStrokePathInstancedNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStencilThenCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat * transformValues) {
    PFN_GLSTENCILTHENCOVERSTROKEPATHINSTANCEDNV _ptr;
    _ptr = (PFN_GLSTENCILTHENCOVERSTROKEPATHINSTANCEDNV)_getPrivateProcAddress("glStencilThenCoverStrokePathInstancedNV");
    if (!_ptr) {
        _ptr = &_fail_glStencilThenCoverStrokePathInstancedNV;
    }
    _glStencilThenCoverStrokePathInstancedNV = _ptr;
    _glStencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
}

PFN_GLSTENCILTHENCOVERSTROKEPATHINSTANCEDNV _glStencilThenCoverStrokePathInstancedNV = &_get_glStencilThenCoverStrokePathInstancedNV;

static GLenum APIENTRY _fail_glPathGlyphIndexRangeNV(GLenum fontTarget, const GLvoid * fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint * baseAndCount) {
    const char *_name = "glPathGlyphIndexRangeNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLenum APIENTRY _get_glPathGlyphIndexRangeNV(GLenum fontTarget, const GLvoid * fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint * baseAndCount) {
    PFN_GLPATHGLYPHINDEXRANGENV _ptr;
    _ptr = (PFN_GLPATHGLYPHINDEXRANGENV)_getPrivateProcAddress("glPathGlyphIndexRangeNV");
    if (!_ptr) {
        _ptr = &_fail_glPathGlyphIndexRangeNV;
    }
    _glPathGlyphIndexRangeNV = _ptr;
    return _glPathGlyphIndexRangeNV(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
}

PFN_GLPATHGLYPHINDEXRANGENV _glPathGlyphIndexRangeNV = &_get_glPathGlyphIndexRangeNV;

static GLenum APIENTRY _fail_glPathGlyphIndexArrayNV(GLuint firstPathName, GLenum fontTarget, const GLvoid * fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale) {
    const char *_name = "glPathGlyphIndexArrayNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLenum APIENTRY _get_glPathGlyphIndexArrayNV(GLuint firstPathName, GLenum fontTarget, const GLvoid * fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale) {
    PFN_GLPATHGLYPHINDEXARRAYNV _ptr;
    _ptr = (PFN_GLPATHGLYPHINDEXARRAYNV)_getPrivateProcAddress("glPathGlyphIndexArrayNV");
    if (!_ptr) {
        _ptr = &_fail_glPathGlyphIndexArrayNV;
    }
    _glPathGlyphIndexArrayNV = _ptr;
    return _glPathGlyphIndexArrayNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
}

PFN_GLPATHGLYPHINDEXARRAYNV _glPathGlyphIndexArrayNV = &_get_glPathGlyphIndexArrayNV;

static GLenum APIENTRY _fail_glPathMemoryGlyphIndexArrayNV(GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void * fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale) {
    const char *_name = "glPathMemoryGlyphIndexArrayNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLenum APIENTRY _get_glPathMemoryGlyphIndexArrayNV(GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void * fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale) {
    PFN_GLPATHMEMORYGLYPHINDEXARRAYNV _ptr;
    _ptr = (PFN_GLPATHMEMORYGLYPHINDEXARRAYNV)_getPrivateProcAddress("glPathMemoryGlyphIndexArrayNV");
    if (!_ptr) {
        _ptr = &_fail_glPathMemoryGlyphIndexArrayNV;
    }
    _glPathMemoryGlyphIndexArrayNV = _ptr;
    return _glPathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
}

PFN_GLPATHMEMORYGLYPHINDEXARRAYNV _glPathMemoryGlyphIndexArrayNV = &_get_glPathMemoryGlyphIndexArrayNV;

static void APIENTRY _fail_glProgramPathFragmentInputGenNV(GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat * coeffs) {
    const char *_name = "glProgramPathFragmentInputGenNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramPathFragmentInputGenNV(GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat * coeffs) {
    PFN_GLPROGRAMPATHFRAGMENTINPUTGENNV _ptr;
    _ptr = (PFN_GLPROGRAMPATHFRAGMENTINPUTGENNV)_getPrivateProcAddress("glProgramPathFragmentInputGenNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramPathFragmentInputGenNV;
    }
    _glProgramPathFragmentInputGenNV = _ptr;
    _glProgramPathFragmentInputGenNV(program, location, genMode, components, coeffs);
}

PFN_GLPROGRAMPATHFRAGMENTINPUTGENNV _glProgramPathFragmentInputGenNV = &_get_glProgramPathFragmentInputGenNV;

static void APIENTRY _fail_glGetProgramResourcefvNV(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei bufSize, GLsizei * length, GLfloat * params) {
    const char *_name = "glGetProgramResourcefvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramResourcefvNV(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei bufSize, GLsizei * length, GLfloat * params) {
    PFN_GLGETPROGRAMRESOURCEFVNV _ptr;
    _ptr = (PFN_GLGETPROGRAMRESOURCEFVNV)_getPrivateProcAddress("glGetProgramResourcefvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramResourcefvNV;
    }
    _glGetProgramResourcefvNV = _ptr;
    _glGetProgramResourcefvNV(program, programInterface, index, propCount, props, bufSize, length, params);
}

PFN_GLGETPROGRAMRESOURCEFVNV _glGetProgramResourcefvNV = &_get_glGetProgramResourcefvNV;

static void APIENTRY _fail_glPixelDataRangeNV(GLenum target, GLsizei length, const GLvoid * pointer) {
    const char *_name = "glPixelDataRangeNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPixelDataRangeNV(GLenum target, GLsizei length, const GLvoid * pointer) {
    PFN_GLPIXELDATARANGENV _ptr;
    _ptr = (PFN_GLPIXELDATARANGENV)_getPrivateProcAddress("glPixelDataRangeNV");
    if (!_ptr) {
        _ptr = &_fail_glPixelDataRangeNV;
    }
    _glPixelDataRangeNV = _ptr;
    _glPixelDataRangeNV(target, length, pointer);
}

PFN_GLPIXELDATARANGENV _glPixelDataRangeNV = &_get_glPixelDataRangeNV;

static void APIENTRY _fail_glFlushPixelDataRangeNV(GLenum target) {
    const char *_name = "glFlushPixelDataRangeNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFlushPixelDataRangeNV(GLenum target) {
    PFN_GLFLUSHPIXELDATARANGENV _ptr;
    _ptr = (PFN_GLFLUSHPIXELDATARANGENV)_getPrivateProcAddress("glFlushPixelDataRangeNV");
    if (!_ptr) {
        _ptr = &_fail_glFlushPixelDataRangeNV;
    }
    _glFlushPixelDataRangeNV = _ptr;
    _glFlushPixelDataRangeNV(target);
}

PFN_GLFLUSHPIXELDATARANGENV _glFlushPixelDataRangeNV = &_get_glFlushPixelDataRangeNV;

static void APIENTRY _fail_glPointParameteriNV(GLenum pname, GLint param) {
    const char *_name = "glPointParameteriNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPointParameteriNV(GLenum pname, GLint param) {
    PFN_GLPOINTPARAMETERINV _ptr;
    _ptr = (PFN_GLPOINTPARAMETERINV)_getPrivateProcAddress("glPointParameteriNV");
    if (!_ptr) {
        _ptr = &_fail_glPointParameteriNV;
    }
    _glPointParameteriNV = _ptr;
    _glPointParameteriNV(pname, param);
}

PFN_GLPOINTPARAMETERINV _glPointParameteriNV = &_get_glPointParameteriNV;

static void APIENTRY _fail_glPointParameterivNV(GLenum pname, const GLint * params) {
    const char *_name = "glPointParameterivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPointParameterivNV(GLenum pname, const GLint * params) {
    PFN_GLPOINTPARAMETERIVNV _ptr;
    _ptr = (PFN_GLPOINTPARAMETERIVNV)_getPrivateProcAddress("glPointParameterivNV");
    if (!_ptr) {
        _ptr = &_fail_glPointParameterivNV;
    }
    _glPointParameterivNV = _ptr;
    _glPointParameterivNV(pname, params);
}

PFN_GLPOINTPARAMETERIVNV _glPointParameterivNV = &_get_glPointParameterivNV;

static void APIENTRY _fail_glPresentFrameKeyedNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1) {
    const char *_name = "glPresentFrameKeyedNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPresentFrameKeyedNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1) {
    PFN_GLPRESENTFRAMEKEYEDNV _ptr;
    _ptr = (PFN_GLPRESENTFRAMEKEYEDNV)_getPrivateProcAddress("glPresentFrameKeyedNV");
    if (!_ptr) {
        _ptr = &_fail_glPresentFrameKeyedNV;
    }
    _glPresentFrameKeyedNV = _ptr;
    _glPresentFrameKeyedNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
}

PFN_GLPRESENTFRAMEKEYEDNV _glPresentFrameKeyedNV = &_get_glPresentFrameKeyedNV;

static void APIENTRY _fail_glPresentFrameDualFillNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3) {
    const char *_name = "glPresentFrameDualFillNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPresentFrameDualFillNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3) {
    PFN_GLPRESENTFRAMEDUALFILLNV _ptr;
    _ptr = (PFN_GLPRESENTFRAMEDUALFILLNV)_getPrivateProcAddress("glPresentFrameDualFillNV");
    if (!_ptr) {
        _ptr = &_fail_glPresentFrameDualFillNV;
    }
    _glPresentFrameDualFillNV = _ptr;
    _glPresentFrameDualFillNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
}

PFN_GLPRESENTFRAMEDUALFILLNV _glPresentFrameDualFillNV = &_get_glPresentFrameDualFillNV;

static void APIENTRY _fail_glGetVideoivNV(GLuint video_slot, GLenum pname, GLint * params) {
    const char *_name = "glGetVideoivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVideoivNV(GLuint video_slot, GLenum pname, GLint * params) {
    PFN_GLGETVIDEOIVNV _ptr;
    _ptr = (PFN_GLGETVIDEOIVNV)_getPrivateProcAddress("glGetVideoivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetVideoivNV;
    }
    _glGetVideoivNV = _ptr;
    _glGetVideoivNV(video_slot, pname, params);
}

PFN_GLGETVIDEOIVNV _glGetVideoivNV = &_get_glGetVideoivNV;

static void APIENTRY _fail_glGetVideouivNV(GLuint video_slot, GLenum pname, GLuint * params) {
    const char *_name = "glGetVideouivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVideouivNV(GLuint video_slot, GLenum pname, GLuint * params) {
    PFN_GLGETVIDEOUIVNV _ptr;
    _ptr = (PFN_GLGETVIDEOUIVNV)_getPrivateProcAddress("glGetVideouivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetVideouivNV;
    }
    _glGetVideouivNV = _ptr;
    _glGetVideouivNV(video_slot, pname, params);
}

PFN_GLGETVIDEOUIVNV _glGetVideouivNV = &_get_glGetVideouivNV;

static void APIENTRY _fail_glGetVideoi64vNV(GLuint video_slot, GLenum pname, GLint64EXT * params) {
    const char *_name = "glGetVideoi64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVideoi64vNV(GLuint video_slot, GLenum pname, GLint64EXT * params) {
    PFN_GLGETVIDEOI64VNV _ptr;
    _ptr = (PFN_GLGETVIDEOI64VNV)_getPrivateProcAddress("glGetVideoi64vNV");
    if (!_ptr) {
        _ptr = &_fail_glGetVideoi64vNV;
    }
    _glGetVideoi64vNV = _ptr;
    _glGetVideoi64vNV(video_slot, pname, params);
}

PFN_GLGETVIDEOI64VNV _glGetVideoi64vNV = &_get_glGetVideoi64vNV;

static void APIENTRY _fail_glGetVideoui64vNV(GLuint video_slot, GLenum pname, GLuint64EXT * params) {
    const char *_name = "glGetVideoui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVideoui64vNV(GLuint video_slot, GLenum pname, GLuint64EXT * params) {
    PFN_GLGETVIDEOUI64VNV _ptr;
    _ptr = (PFN_GLGETVIDEOUI64VNV)_getPrivateProcAddress("glGetVideoui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glGetVideoui64vNV;
    }
    _glGetVideoui64vNV = _ptr;
    _glGetVideoui64vNV(video_slot, pname, params);
}

PFN_GLGETVIDEOUI64VNV _glGetVideoui64vNV = &_get_glGetVideoui64vNV;

static void APIENTRY _fail_glPrimitiveRestartNV(void) {
    const char *_name = "glPrimitiveRestartNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPrimitiveRestartNV(void) {
    PFN_GLPRIMITIVERESTARTNV _ptr;
    _ptr = (PFN_GLPRIMITIVERESTARTNV)_getPrivateProcAddress("glPrimitiveRestartNV");
    if (!_ptr) {
        _ptr = &_fail_glPrimitiveRestartNV;
    }
    _glPrimitiveRestartNV = _ptr;
    _glPrimitiveRestartNV();
}

PFN_GLPRIMITIVERESTARTNV _glPrimitiveRestartNV = &_get_glPrimitiveRestartNV;

static void APIENTRY _fail_glPrimitiveRestartIndexNV(GLuint index) {
    const char *_name = "glPrimitiveRestartIndexNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPrimitiveRestartIndexNV(GLuint index) {
    PFN_GLPRIMITIVERESTARTINDEXNV _ptr;
    _ptr = (PFN_GLPRIMITIVERESTARTINDEXNV)_getPrivateProcAddress("glPrimitiveRestartIndexNV");
    if (!_ptr) {
        _ptr = &_fail_glPrimitiveRestartIndexNV;
    }
    _glPrimitiveRestartIndexNV = _ptr;
    _glPrimitiveRestartIndexNV(index);
}

PFN_GLPRIMITIVERESTARTINDEXNV _glPrimitiveRestartIndexNV = &_get_glPrimitiveRestartIndexNV;

static void APIENTRY _fail_glReadBufferNV(GLenum mode) {
    const char *_name = "glReadBufferNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReadBufferNV(GLenum mode) {
    PFN_GLREADBUFFERNV _ptr;
    _ptr = (PFN_GLREADBUFFERNV)_getPrivateProcAddress("glReadBufferNV");
    if (!_ptr) {
        _ptr = &_fail_glReadBufferNV;
    }
    _glReadBufferNV = _ptr;
    _glReadBufferNV(mode);
}

PFN_GLREADBUFFERNV _glReadBufferNV = &_get_glReadBufferNV;

static void APIENTRY _fail_glCombinerParameterfvNV(GLenum pname, const GLfloat * params) {
    const char *_name = "glCombinerParameterfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCombinerParameterfvNV(GLenum pname, const GLfloat * params) {
    PFN_GLCOMBINERPARAMETERFVNV _ptr;
    _ptr = (PFN_GLCOMBINERPARAMETERFVNV)_getPrivateProcAddress("glCombinerParameterfvNV");
    if (!_ptr) {
        _ptr = &_fail_glCombinerParameterfvNV;
    }
    _glCombinerParameterfvNV = _ptr;
    _glCombinerParameterfvNV(pname, params);
}

PFN_GLCOMBINERPARAMETERFVNV _glCombinerParameterfvNV = &_get_glCombinerParameterfvNV;

static void APIENTRY _fail_glCombinerParameterfNV(GLenum pname, GLfloat param) {
    const char *_name = "glCombinerParameterfNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCombinerParameterfNV(GLenum pname, GLfloat param) {
    PFN_GLCOMBINERPARAMETERFNV _ptr;
    _ptr = (PFN_GLCOMBINERPARAMETERFNV)_getPrivateProcAddress("glCombinerParameterfNV");
    if (!_ptr) {
        _ptr = &_fail_glCombinerParameterfNV;
    }
    _glCombinerParameterfNV = _ptr;
    _glCombinerParameterfNV(pname, param);
}

PFN_GLCOMBINERPARAMETERFNV _glCombinerParameterfNV = &_get_glCombinerParameterfNV;

static void APIENTRY _fail_glCombinerParameterivNV(GLenum pname, const GLint * params) {
    const char *_name = "glCombinerParameterivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCombinerParameterivNV(GLenum pname, const GLint * params) {
    PFN_GLCOMBINERPARAMETERIVNV _ptr;
    _ptr = (PFN_GLCOMBINERPARAMETERIVNV)_getPrivateProcAddress("glCombinerParameterivNV");
    if (!_ptr) {
        _ptr = &_fail_glCombinerParameterivNV;
    }
    _glCombinerParameterivNV = _ptr;
    _glCombinerParameterivNV(pname, params);
}

PFN_GLCOMBINERPARAMETERIVNV _glCombinerParameterivNV = &_get_glCombinerParameterivNV;

static void APIENTRY _fail_glCombinerParameteriNV(GLenum pname, GLint param) {
    const char *_name = "glCombinerParameteriNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCombinerParameteriNV(GLenum pname, GLint param) {
    PFN_GLCOMBINERPARAMETERINV _ptr;
    _ptr = (PFN_GLCOMBINERPARAMETERINV)_getPrivateProcAddress("glCombinerParameteriNV");
    if (!_ptr) {
        _ptr = &_fail_glCombinerParameteriNV;
    }
    _glCombinerParameteriNV = _ptr;
    _glCombinerParameteriNV(pname, param);
}

PFN_GLCOMBINERPARAMETERINV _glCombinerParameteriNV = &_get_glCombinerParameteriNV;

static void APIENTRY _fail_glCombinerInputNV(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage) {
    const char *_name = "glCombinerInputNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCombinerInputNV(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage) {
    PFN_GLCOMBINERINPUTNV _ptr;
    _ptr = (PFN_GLCOMBINERINPUTNV)_getPrivateProcAddress("glCombinerInputNV");
    if (!_ptr) {
        _ptr = &_fail_glCombinerInputNV;
    }
    _glCombinerInputNV = _ptr;
    _glCombinerInputNV(stage, portion, variable, input, mapping, componentUsage);
}

PFN_GLCOMBINERINPUTNV _glCombinerInputNV = &_get_glCombinerInputNV;

static void APIENTRY _fail_glCombinerOutputNV(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum) {
    const char *_name = "glCombinerOutputNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCombinerOutputNV(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum) {
    PFN_GLCOMBINEROUTPUTNV _ptr;
    _ptr = (PFN_GLCOMBINEROUTPUTNV)_getPrivateProcAddress("glCombinerOutputNV");
    if (!_ptr) {
        _ptr = &_fail_glCombinerOutputNV;
    }
    _glCombinerOutputNV = _ptr;
    _glCombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
}

PFN_GLCOMBINEROUTPUTNV _glCombinerOutputNV = &_get_glCombinerOutputNV;

static void APIENTRY _fail_glFinalCombinerInputNV(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage) {
    const char *_name = "glFinalCombinerInputNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFinalCombinerInputNV(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage) {
    PFN_GLFINALCOMBINERINPUTNV _ptr;
    _ptr = (PFN_GLFINALCOMBINERINPUTNV)_getPrivateProcAddress("glFinalCombinerInputNV");
    if (!_ptr) {
        _ptr = &_fail_glFinalCombinerInputNV;
    }
    _glFinalCombinerInputNV = _ptr;
    _glFinalCombinerInputNV(variable, input, mapping, componentUsage);
}

PFN_GLFINALCOMBINERINPUTNV _glFinalCombinerInputNV = &_get_glFinalCombinerInputNV;

static void APIENTRY _fail_glGetCombinerInputParameterfvNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat * params) {
    const char *_name = "glGetCombinerInputParameterfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetCombinerInputParameterfvNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat * params) {
    PFN_GLGETCOMBINERINPUTPARAMETERFVNV _ptr;
    _ptr = (PFN_GLGETCOMBINERINPUTPARAMETERFVNV)_getPrivateProcAddress("glGetCombinerInputParameterfvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetCombinerInputParameterfvNV;
    }
    _glGetCombinerInputParameterfvNV = _ptr;
    _glGetCombinerInputParameterfvNV(stage, portion, variable, pname, params);
}

PFN_GLGETCOMBINERINPUTPARAMETERFVNV _glGetCombinerInputParameterfvNV = &_get_glGetCombinerInputParameterfvNV;

static void APIENTRY _fail_glGetCombinerInputParameterivNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint * params) {
    const char *_name = "glGetCombinerInputParameterivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetCombinerInputParameterivNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint * params) {
    PFN_GLGETCOMBINERINPUTPARAMETERIVNV _ptr;
    _ptr = (PFN_GLGETCOMBINERINPUTPARAMETERIVNV)_getPrivateProcAddress("glGetCombinerInputParameterivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetCombinerInputParameterivNV;
    }
    _glGetCombinerInputParameterivNV = _ptr;
    _glGetCombinerInputParameterivNV(stage, portion, variable, pname, params);
}

PFN_GLGETCOMBINERINPUTPARAMETERIVNV _glGetCombinerInputParameterivNV = &_get_glGetCombinerInputParameterivNV;

static void APIENTRY _fail_glGetCombinerOutputParameterfvNV(GLenum stage, GLenum portion, GLenum pname, GLfloat * params) {
    const char *_name = "glGetCombinerOutputParameterfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetCombinerOutputParameterfvNV(GLenum stage, GLenum portion, GLenum pname, GLfloat * params) {
    PFN_GLGETCOMBINEROUTPUTPARAMETERFVNV _ptr;
    _ptr = (PFN_GLGETCOMBINEROUTPUTPARAMETERFVNV)_getPrivateProcAddress("glGetCombinerOutputParameterfvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetCombinerOutputParameterfvNV;
    }
    _glGetCombinerOutputParameterfvNV = _ptr;
    _glGetCombinerOutputParameterfvNV(stage, portion, pname, params);
}

PFN_GLGETCOMBINEROUTPUTPARAMETERFVNV _glGetCombinerOutputParameterfvNV = &_get_glGetCombinerOutputParameterfvNV;

static void APIENTRY _fail_glGetCombinerOutputParameterivNV(GLenum stage, GLenum portion, GLenum pname, GLint * params) {
    const char *_name = "glGetCombinerOutputParameterivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetCombinerOutputParameterivNV(GLenum stage, GLenum portion, GLenum pname, GLint * params) {
    PFN_GLGETCOMBINEROUTPUTPARAMETERIVNV _ptr;
    _ptr = (PFN_GLGETCOMBINEROUTPUTPARAMETERIVNV)_getPrivateProcAddress("glGetCombinerOutputParameterivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetCombinerOutputParameterivNV;
    }
    _glGetCombinerOutputParameterivNV = _ptr;
    _glGetCombinerOutputParameterivNV(stage, portion, pname, params);
}

PFN_GLGETCOMBINEROUTPUTPARAMETERIVNV _glGetCombinerOutputParameterivNV = &_get_glGetCombinerOutputParameterivNV;

static void APIENTRY _fail_glGetFinalCombinerInputParameterfvNV(GLenum variable, GLenum pname, GLfloat * params) {
    const char *_name = "glGetFinalCombinerInputParameterfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFinalCombinerInputParameterfvNV(GLenum variable, GLenum pname, GLfloat * params) {
    PFN_GLGETFINALCOMBINERINPUTPARAMETERFVNV _ptr;
    _ptr = (PFN_GLGETFINALCOMBINERINPUTPARAMETERFVNV)_getPrivateProcAddress("glGetFinalCombinerInputParameterfvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetFinalCombinerInputParameterfvNV;
    }
    _glGetFinalCombinerInputParameterfvNV = _ptr;
    _glGetFinalCombinerInputParameterfvNV(variable, pname, params);
}

PFN_GLGETFINALCOMBINERINPUTPARAMETERFVNV _glGetFinalCombinerInputParameterfvNV = &_get_glGetFinalCombinerInputParameterfvNV;

static void APIENTRY _fail_glGetFinalCombinerInputParameterivNV(GLenum variable, GLenum pname, GLint * params) {
    const char *_name = "glGetFinalCombinerInputParameterivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFinalCombinerInputParameterivNV(GLenum variable, GLenum pname, GLint * params) {
    PFN_GLGETFINALCOMBINERINPUTPARAMETERIVNV _ptr;
    _ptr = (PFN_GLGETFINALCOMBINERINPUTPARAMETERIVNV)_getPrivateProcAddress("glGetFinalCombinerInputParameterivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetFinalCombinerInputParameterivNV;
    }
    _glGetFinalCombinerInputParameterivNV = _ptr;
    _glGetFinalCombinerInputParameterivNV(variable, pname, params);
}

PFN_GLGETFINALCOMBINERINPUTPARAMETERIVNV _glGetFinalCombinerInputParameterivNV = &_get_glGetFinalCombinerInputParameterivNV;

static void APIENTRY _fail_glCombinerStageParameterfvNV(GLenum stage, GLenum pname, const GLfloat * params) {
    const char *_name = "glCombinerStageParameterfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCombinerStageParameterfvNV(GLenum stage, GLenum pname, const GLfloat * params) {
    PFN_GLCOMBINERSTAGEPARAMETERFVNV _ptr;
    _ptr = (PFN_GLCOMBINERSTAGEPARAMETERFVNV)_getPrivateProcAddress("glCombinerStageParameterfvNV");
    if (!_ptr) {
        _ptr = &_fail_glCombinerStageParameterfvNV;
    }
    _glCombinerStageParameterfvNV = _ptr;
    _glCombinerStageParameterfvNV(stage, pname, params);
}

PFN_GLCOMBINERSTAGEPARAMETERFVNV _glCombinerStageParameterfvNV = &_get_glCombinerStageParameterfvNV;

static void APIENTRY _fail_glGetCombinerStageParameterfvNV(GLenum stage, GLenum pname, GLfloat * params) {
    const char *_name = "glGetCombinerStageParameterfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetCombinerStageParameterfvNV(GLenum stage, GLenum pname, GLfloat * params) {
    PFN_GLGETCOMBINERSTAGEPARAMETERFVNV _ptr;
    _ptr = (PFN_GLGETCOMBINERSTAGEPARAMETERFVNV)_getPrivateProcAddress("glGetCombinerStageParameterfvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetCombinerStageParameterfvNV;
    }
    _glGetCombinerStageParameterfvNV = _ptr;
    _glGetCombinerStageParameterfvNV(stage, pname, params);
}

PFN_GLGETCOMBINERSTAGEPARAMETERFVNV _glGetCombinerStageParameterfvNV = &_get_glGetCombinerStageParameterfvNV;

static void APIENTRY _fail_glMakeBufferResidentNV(GLenum target, GLenum access) {
    const char *_name = "glMakeBufferResidentNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMakeBufferResidentNV(GLenum target, GLenum access) {
    PFN_GLMAKEBUFFERRESIDENTNV _ptr;
    _ptr = (PFN_GLMAKEBUFFERRESIDENTNV)_getPrivateProcAddress("glMakeBufferResidentNV");
    if (!_ptr) {
        _ptr = &_fail_glMakeBufferResidentNV;
    }
    _glMakeBufferResidentNV = _ptr;
    _glMakeBufferResidentNV(target, access);
}

PFN_GLMAKEBUFFERRESIDENTNV _glMakeBufferResidentNV = &_get_glMakeBufferResidentNV;

static void APIENTRY _fail_glMakeBufferNonResidentNV(GLenum target) {
    const char *_name = "glMakeBufferNonResidentNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMakeBufferNonResidentNV(GLenum target) {
    PFN_GLMAKEBUFFERNONRESIDENTNV _ptr;
    _ptr = (PFN_GLMAKEBUFFERNONRESIDENTNV)_getPrivateProcAddress("glMakeBufferNonResidentNV");
    if (!_ptr) {
        _ptr = &_fail_glMakeBufferNonResidentNV;
    }
    _glMakeBufferNonResidentNV = _ptr;
    _glMakeBufferNonResidentNV(target);
}

PFN_GLMAKEBUFFERNONRESIDENTNV _glMakeBufferNonResidentNV = &_get_glMakeBufferNonResidentNV;

static GLboolean APIENTRY _fail_glIsBufferResidentNV(GLenum target) {
    const char *_name = "glIsBufferResidentNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsBufferResidentNV(GLenum target) {
    PFN_GLISBUFFERRESIDENTNV _ptr;
    _ptr = (PFN_GLISBUFFERRESIDENTNV)_getPrivateProcAddress("glIsBufferResidentNV");
    if (!_ptr) {
        _ptr = &_fail_glIsBufferResidentNV;
    }
    _glIsBufferResidentNV = _ptr;
    return _glIsBufferResidentNV(target);
}

PFN_GLISBUFFERRESIDENTNV _glIsBufferResidentNV = &_get_glIsBufferResidentNV;

static void APIENTRY _fail_glMakeNamedBufferResidentNV(GLuint buffer, GLenum access) {
    const char *_name = "glMakeNamedBufferResidentNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMakeNamedBufferResidentNV(GLuint buffer, GLenum access) {
    PFN_GLMAKENAMEDBUFFERRESIDENTNV _ptr;
    _ptr = (PFN_GLMAKENAMEDBUFFERRESIDENTNV)_getPrivateProcAddress("glMakeNamedBufferResidentNV");
    if (!_ptr) {
        _ptr = &_fail_glMakeNamedBufferResidentNV;
    }
    _glMakeNamedBufferResidentNV = _ptr;
    _glMakeNamedBufferResidentNV(buffer, access);
}

PFN_GLMAKENAMEDBUFFERRESIDENTNV _glMakeNamedBufferResidentNV = &_get_glMakeNamedBufferResidentNV;

static void APIENTRY _fail_glMakeNamedBufferNonResidentNV(GLuint buffer) {
    const char *_name = "glMakeNamedBufferNonResidentNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMakeNamedBufferNonResidentNV(GLuint buffer) {
    PFN_GLMAKENAMEDBUFFERNONRESIDENTNV _ptr;
    _ptr = (PFN_GLMAKENAMEDBUFFERNONRESIDENTNV)_getPrivateProcAddress("glMakeNamedBufferNonResidentNV");
    if (!_ptr) {
        _ptr = &_fail_glMakeNamedBufferNonResidentNV;
    }
    _glMakeNamedBufferNonResidentNV = _ptr;
    _glMakeNamedBufferNonResidentNV(buffer);
}

PFN_GLMAKENAMEDBUFFERNONRESIDENTNV _glMakeNamedBufferNonResidentNV = &_get_glMakeNamedBufferNonResidentNV;

static GLboolean APIENTRY _fail_glIsNamedBufferResidentNV(GLuint buffer) {
    const char *_name = "glIsNamedBufferResidentNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsNamedBufferResidentNV(GLuint buffer) {
    PFN_GLISNAMEDBUFFERRESIDENTNV _ptr;
    _ptr = (PFN_GLISNAMEDBUFFERRESIDENTNV)_getPrivateProcAddress("glIsNamedBufferResidentNV");
    if (!_ptr) {
        _ptr = &_fail_glIsNamedBufferResidentNV;
    }
    _glIsNamedBufferResidentNV = _ptr;
    return _glIsNamedBufferResidentNV(buffer);
}

PFN_GLISNAMEDBUFFERRESIDENTNV _glIsNamedBufferResidentNV = &_get_glIsNamedBufferResidentNV;

static void APIENTRY _fail_glGetBufferParameterui64vNV(GLenum target, GLenum pname, GLuint64EXT * params) {
    const char *_name = "glGetBufferParameterui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetBufferParameterui64vNV(GLenum target, GLenum pname, GLuint64EXT * params) {
    PFN_GLGETBUFFERPARAMETERUI64VNV _ptr;
    _ptr = (PFN_GLGETBUFFERPARAMETERUI64VNV)_getPrivateProcAddress("glGetBufferParameterui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glGetBufferParameterui64vNV;
    }
    _glGetBufferParameterui64vNV = _ptr;
    _glGetBufferParameterui64vNV(target, pname, params);
}

PFN_GLGETBUFFERPARAMETERUI64VNV _glGetBufferParameterui64vNV = &_get_glGetBufferParameterui64vNV;

static void APIENTRY _fail_glGetNamedBufferParameterui64vNV(GLuint buffer, GLenum pname, GLuint64EXT * params) {
    const char *_name = "glGetNamedBufferParameterui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetNamedBufferParameterui64vNV(GLuint buffer, GLenum pname, GLuint64EXT * params) {
    PFN_GLGETNAMEDBUFFERPARAMETERUI64VNV _ptr;
    _ptr = (PFN_GLGETNAMEDBUFFERPARAMETERUI64VNV)_getPrivateProcAddress("glGetNamedBufferParameterui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glGetNamedBufferParameterui64vNV;
    }
    _glGetNamedBufferParameterui64vNV = _ptr;
    _glGetNamedBufferParameterui64vNV(buffer, pname, params);
}

PFN_GLGETNAMEDBUFFERPARAMETERUI64VNV _glGetNamedBufferParameterui64vNV = &_get_glGetNamedBufferParameterui64vNV;

static void APIENTRY _fail_glGetIntegerui64vNV(GLenum value, GLuint64EXT * result) {
    const char *_name = "glGetIntegerui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetIntegerui64vNV(GLenum value, GLuint64EXT * result) {
    PFN_GLGETINTEGERUI64VNV _ptr;
    _ptr = (PFN_GLGETINTEGERUI64VNV)_getPrivateProcAddress("glGetIntegerui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glGetIntegerui64vNV;
    }
    _glGetIntegerui64vNV = _ptr;
    _glGetIntegerui64vNV(value, result);
}

PFN_GLGETINTEGERUI64VNV _glGetIntegerui64vNV = &_get_glGetIntegerui64vNV;

static void APIENTRY _fail_glUniformui64NV(GLint location, GLuint64EXT value) {
    const char *_name = "glUniformui64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformui64NV(GLint location, GLuint64EXT value) {
    PFN_GLUNIFORMUI64NV _ptr;
    _ptr = (PFN_GLUNIFORMUI64NV)_getPrivateProcAddress("glUniformui64NV");
    if (!_ptr) {
        _ptr = &_fail_glUniformui64NV;
    }
    _glUniformui64NV = _ptr;
    _glUniformui64NV(location, value);
}

PFN_GLUNIFORMUI64NV _glUniformui64NV = &_get_glUniformui64NV;

static void APIENTRY _fail_glUniformui64vNV(GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glUniformui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glUniformui64vNV(GLint location, GLsizei count, const GLuint64EXT * value) {
    PFN_GLUNIFORMUI64VNV _ptr;
    _ptr = (PFN_GLUNIFORMUI64VNV)_getPrivateProcAddress("glUniformui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glUniformui64vNV;
    }
    _glUniformui64vNV = _ptr;
    _glUniformui64vNV(location, count, value);
}

PFN_GLUNIFORMUI64VNV _glUniformui64vNV = &_get_glUniformui64vNV;

static void APIENTRY _fail_glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT * params) {
    const char *_name = "glGetUniformui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT * params) {
    PFN_GLGETUNIFORMUI64VNV _ptr;
    _ptr = (PFN_GLGETUNIFORMUI64VNV)_getPrivateProcAddress("glGetUniformui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glGetUniformui64vNV;
    }
    _glGetUniformui64vNV = _ptr;
    _glGetUniformui64vNV(program, location, params);
}

PFN_GLGETUNIFORMUI64VNV _glGetUniformui64vNV = &_get_glGetUniformui64vNV;

static void APIENTRY _fail_glProgramUniformui64NV(GLuint program, GLint location, GLuint64EXT value) {
    const char *_name = "glProgramUniformui64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformui64NV(GLuint program, GLint location, GLuint64EXT value) {
    PFN_GLPROGRAMUNIFORMUI64NV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMUI64NV)_getPrivateProcAddress("glProgramUniformui64NV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformui64NV;
    }
    _glProgramUniformui64NV = _ptr;
    _glProgramUniformui64NV(program, location, value);
}

PFN_GLPROGRAMUNIFORMUI64NV _glProgramUniformui64NV = &_get_glProgramUniformui64NV;

static void APIENTRY _fail_glProgramUniformui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value) {
    const char *_name = "glProgramUniformui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramUniformui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT * value) {
    PFN_GLPROGRAMUNIFORMUI64VNV _ptr;
    _ptr = (PFN_GLPROGRAMUNIFORMUI64VNV)_getPrivateProcAddress("glProgramUniformui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramUniformui64vNV;
    }
    _glProgramUniformui64vNV = _ptr;
    _glProgramUniformui64vNV(program, location, count, value);
}

PFN_GLPROGRAMUNIFORMUI64VNV _glProgramUniformui64vNV = &_get_glProgramUniformui64vNV;

static void APIENTRY _fail_glTextureBarrierNV(void) {
    const char *_name = "glTextureBarrierNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureBarrierNV(void) {
    PFN_GLTEXTUREBARRIERNV _ptr;
    _ptr = (PFN_GLTEXTUREBARRIERNV)_getPrivateProcAddress("glTextureBarrierNV");
    if (!_ptr) {
        _ptr = &_fail_glTextureBarrierNV;
    }
    _glTextureBarrierNV = _ptr;
    _glTextureBarrierNV();
}

PFN_GLTEXTUREBARRIERNV _glTextureBarrierNV = &_get_glTextureBarrierNV;

static void APIENTRY _fail_glTexImage2DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) {
    const char *_name = "glTexImage2DMultisampleCoverageNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexImage2DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) {
    PFN_GLTEXIMAGE2DMULTISAMPLECOVERAGENV _ptr;
    _ptr = (PFN_GLTEXIMAGE2DMULTISAMPLECOVERAGENV)_getPrivateProcAddress("glTexImage2DMultisampleCoverageNV");
    if (!_ptr) {
        _ptr = &_fail_glTexImage2DMultisampleCoverageNV;
    }
    _glTexImage2DMultisampleCoverageNV = _ptr;
    _glTexImage2DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
}

PFN_GLTEXIMAGE2DMULTISAMPLECOVERAGENV _glTexImage2DMultisampleCoverageNV = &_get_glTexImage2DMultisampleCoverageNV;

static void APIENTRY _fail_glTexImage3DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) {
    const char *_name = "glTexImage3DMultisampleCoverageNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexImage3DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) {
    PFN_GLTEXIMAGE3DMULTISAMPLECOVERAGENV _ptr;
    _ptr = (PFN_GLTEXIMAGE3DMULTISAMPLECOVERAGENV)_getPrivateProcAddress("glTexImage3DMultisampleCoverageNV");
    if (!_ptr) {
        _ptr = &_fail_glTexImage3DMultisampleCoverageNV;
    }
    _glTexImage3DMultisampleCoverageNV = _ptr;
    _glTexImage3DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
}

PFN_GLTEXIMAGE3DMULTISAMPLECOVERAGENV _glTexImage3DMultisampleCoverageNV = &_get_glTexImage3DMultisampleCoverageNV;

static void APIENTRY _fail_glTextureImage2DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) {
    const char *_name = "glTextureImage2DMultisampleNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureImage2DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) {
    PFN_GLTEXTUREIMAGE2DMULTISAMPLENV _ptr;
    _ptr = (PFN_GLTEXTUREIMAGE2DMULTISAMPLENV)_getPrivateProcAddress("glTextureImage2DMultisampleNV");
    if (!_ptr) {
        _ptr = &_fail_glTextureImage2DMultisampleNV;
    }
    _glTextureImage2DMultisampleNV = _ptr;
    _glTextureImage2DMultisampleNV(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
}

PFN_GLTEXTUREIMAGE2DMULTISAMPLENV _glTextureImage2DMultisampleNV = &_get_glTextureImage2DMultisampleNV;

static void APIENTRY _fail_glTextureImage3DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) {
    const char *_name = "glTextureImage3DMultisampleNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureImage3DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) {
    PFN_GLTEXTUREIMAGE3DMULTISAMPLENV _ptr;
    _ptr = (PFN_GLTEXTUREIMAGE3DMULTISAMPLENV)_getPrivateProcAddress("glTextureImage3DMultisampleNV");
    if (!_ptr) {
        _ptr = &_fail_glTextureImage3DMultisampleNV;
    }
    _glTextureImage3DMultisampleNV = _ptr;
    _glTextureImage3DMultisampleNV(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
}

PFN_GLTEXTUREIMAGE3DMULTISAMPLENV _glTextureImage3DMultisampleNV = &_get_glTextureImage3DMultisampleNV;

static void APIENTRY _fail_glTextureImage2DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) {
    const char *_name = "glTextureImage2DMultisampleCoverageNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureImage2DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) {
    PFN_GLTEXTUREIMAGE2DMULTISAMPLECOVERAGENV _ptr;
    _ptr = (PFN_GLTEXTUREIMAGE2DMULTISAMPLECOVERAGENV)_getPrivateProcAddress("glTextureImage2DMultisampleCoverageNV");
    if (!_ptr) {
        _ptr = &_fail_glTextureImage2DMultisampleCoverageNV;
    }
    _glTextureImage2DMultisampleCoverageNV = _ptr;
    _glTextureImage2DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
}

PFN_GLTEXTUREIMAGE2DMULTISAMPLECOVERAGENV _glTextureImage2DMultisampleCoverageNV = &_get_glTextureImage2DMultisampleCoverageNV;

static void APIENTRY _fail_glTextureImage3DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) {
    const char *_name = "glTextureImage3DMultisampleCoverageNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureImage3DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) {
    PFN_GLTEXTUREIMAGE3DMULTISAMPLECOVERAGENV _ptr;
    _ptr = (PFN_GLTEXTUREIMAGE3DMULTISAMPLECOVERAGENV)_getPrivateProcAddress("glTextureImage3DMultisampleCoverageNV");
    if (!_ptr) {
        _ptr = &_fail_glTextureImage3DMultisampleCoverageNV;
    }
    _glTextureImage3DMultisampleCoverageNV = _ptr;
    _glTextureImage3DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
}

PFN_GLTEXTUREIMAGE3DMULTISAMPLECOVERAGENV _glTextureImage3DMultisampleCoverageNV = &_get_glTextureImage3DMultisampleCoverageNV;

static void APIENTRY _fail_glBeginTransformFeedbackNV(GLenum primitiveMode) {
    const char *_name = "glBeginTransformFeedbackNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBeginTransformFeedbackNV(GLenum primitiveMode) {
    PFN_GLBEGINTRANSFORMFEEDBACKNV _ptr;
    _ptr = (PFN_GLBEGINTRANSFORMFEEDBACKNV)_getPrivateProcAddress("glBeginTransformFeedbackNV");
    if (!_ptr) {
        _ptr = &_fail_glBeginTransformFeedbackNV;
    }
    _glBeginTransformFeedbackNV = _ptr;
    _glBeginTransformFeedbackNV(primitiveMode);
}

PFN_GLBEGINTRANSFORMFEEDBACKNV _glBeginTransformFeedbackNV = &_get_glBeginTransformFeedbackNV;

static void APIENTRY _fail_glEndTransformFeedbackNV(void) {
    const char *_name = "glEndTransformFeedbackNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEndTransformFeedbackNV(void) {
    PFN_GLENDTRANSFORMFEEDBACKNV _ptr;
    _ptr = (PFN_GLENDTRANSFORMFEEDBACKNV)_getPrivateProcAddress("glEndTransformFeedbackNV");
    if (!_ptr) {
        _ptr = &_fail_glEndTransformFeedbackNV;
    }
    _glEndTransformFeedbackNV = _ptr;
    _glEndTransformFeedbackNV();
}

PFN_GLENDTRANSFORMFEEDBACKNV _glEndTransformFeedbackNV = &_get_glEndTransformFeedbackNV;

static void APIENTRY _fail_glTransformFeedbackAttribsNV(GLsizei count, const GLint * attribs, GLenum bufferMode) {
    const char *_name = "glTransformFeedbackAttribsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTransformFeedbackAttribsNV(GLsizei count, const GLint * attribs, GLenum bufferMode) {
    PFN_GLTRANSFORMFEEDBACKATTRIBSNV _ptr;
    _ptr = (PFN_GLTRANSFORMFEEDBACKATTRIBSNV)_getPrivateProcAddress("glTransformFeedbackAttribsNV");
    if (!_ptr) {
        _ptr = &_fail_glTransformFeedbackAttribsNV;
    }
    _glTransformFeedbackAttribsNV = _ptr;
    _glTransformFeedbackAttribsNV(count, attribs, bufferMode);
}

PFN_GLTRANSFORMFEEDBACKATTRIBSNV _glTransformFeedbackAttribsNV = &_get_glTransformFeedbackAttribsNV;

static void APIENTRY _fail_glBindBufferRangeNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    const char *_name = "glBindBufferRangeNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindBufferRangeNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) {
    PFN_GLBINDBUFFERRANGENV _ptr;
    _ptr = (PFN_GLBINDBUFFERRANGENV)_getPrivateProcAddress("glBindBufferRangeNV");
    if (!_ptr) {
        _ptr = &_fail_glBindBufferRangeNV;
    }
    _glBindBufferRangeNV = _ptr;
    _glBindBufferRangeNV(target, index, buffer, offset, size);
}

PFN_GLBINDBUFFERRANGENV _glBindBufferRangeNV = &_get_glBindBufferRangeNV;

static void APIENTRY _fail_glBindBufferOffsetNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset) {
    const char *_name = "glBindBufferOffsetNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindBufferOffsetNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset) {
    PFN_GLBINDBUFFEROFFSETNV _ptr;
    _ptr = (PFN_GLBINDBUFFEROFFSETNV)_getPrivateProcAddress("glBindBufferOffsetNV");
    if (!_ptr) {
        _ptr = &_fail_glBindBufferOffsetNV;
    }
    _glBindBufferOffsetNV = _ptr;
    _glBindBufferOffsetNV(target, index, buffer, offset);
}

PFN_GLBINDBUFFEROFFSETNV _glBindBufferOffsetNV = &_get_glBindBufferOffsetNV;

static void APIENTRY _fail_glBindBufferBaseNV(GLenum target, GLuint index, GLuint buffer) {
    const char *_name = "glBindBufferBaseNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindBufferBaseNV(GLenum target, GLuint index, GLuint buffer) {
    PFN_GLBINDBUFFERBASENV _ptr;
    _ptr = (PFN_GLBINDBUFFERBASENV)_getPrivateProcAddress("glBindBufferBaseNV");
    if (!_ptr) {
        _ptr = &_fail_glBindBufferBaseNV;
    }
    _glBindBufferBaseNV = _ptr;
    _glBindBufferBaseNV(target, index, buffer);
}

PFN_GLBINDBUFFERBASENV _glBindBufferBaseNV = &_get_glBindBufferBaseNV;

static void APIENTRY _fail_glTransformFeedbackVaryingsNV(GLuint program, GLsizei count, const GLint * locations, GLenum bufferMode) {
    const char *_name = "glTransformFeedbackVaryingsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTransformFeedbackVaryingsNV(GLuint program, GLsizei count, const GLint * locations, GLenum bufferMode) {
    PFN_GLTRANSFORMFEEDBACKVARYINGSNV _ptr;
    _ptr = (PFN_GLTRANSFORMFEEDBACKVARYINGSNV)_getPrivateProcAddress("glTransformFeedbackVaryingsNV");
    if (!_ptr) {
        _ptr = &_fail_glTransformFeedbackVaryingsNV;
    }
    _glTransformFeedbackVaryingsNV = _ptr;
    _glTransformFeedbackVaryingsNV(program, count, locations, bufferMode);
}

PFN_GLTRANSFORMFEEDBACKVARYINGSNV _glTransformFeedbackVaryingsNV = &_get_glTransformFeedbackVaryingsNV;

static void APIENTRY _fail_glActiveVaryingNV(GLuint program, const GLchar * name) {
    const char *_name = "glActiveVaryingNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glActiveVaryingNV(GLuint program, const GLchar * name) {
    PFN_GLACTIVEVARYINGNV _ptr;
    _ptr = (PFN_GLACTIVEVARYINGNV)_getPrivateProcAddress("glActiveVaryingNV");
    if (!_ptr) {
        _ptr = &_fail_glActiveVaryingNV;
    }
    _glActiveVaryingNV = _ptr;
    _glActiveVaryingNV(program, name);
}

PFN_GLACTIVEVARYINGNV _glActiveVaryingNV = &_get_glActiveVaryingNV;

static GLint APIENTRY _fail_glGetVaryingLocationNV(GLuint program, const GLchar * name) {
    const char *_name = "glGetVaryingLocationNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLint APIENTRY _get_glGetVaryingLocationNV(GLuint program, const GLchar * name) {
    PFN_GLGETVARYINGLOCATIONNV _ptr;
    _ptr = (PFN_GLGETVARYINGLOCATIONNV)_getPrivateProcAddress("glGetVaryingLocationNV");
    if (!_ptr) {
        _ptr = &_fail_glGetVaryingLocationNV;
    }
    _glGetVaryingLocationNV = _ptr;
    return _glGetVaryingLocationNV(program, name);
}

PFN_GLGETVARYINGLOCATIONNV _glGetVaryingLocationNV = &_get_glGetVaryingLocationNV;

static void APIENTRY _fail_glGetActiveVaryingNV(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name) {
    const char *_name = "glGetActiveVaryingNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetActiveVaryingNV(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name) {
    PFN_GLGETACTIVEVARYINGNV _ptr;
    _ptr = (PFN_GLGETACTIVEVARYINGNV)_getPrivateProcAddress("glGetActiveVaryingNV");
    if (!_ptr) {
        _ptr = &_fail_glGetActiveVaryingNV;
    }
    _glGetActiveVaryingNV = _ptr;
    _glGetActiveVaryingNV(program, index, bufSize, length, size, type, name);
}

PFN_GLGETACTIVEVARYINGNV _glGetActiveVaryingNV = &_get_glGetActiveVaryingNV;

static void APIENTRY _fail_glGetTransformFeedbackVaryingNV(GLuint program, GLuint index, GLint * location) {
    const char *_name = "glGetTransformFeedbackVaryingNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTransformFeedbackVaryingNV(GLuint program, GLuint index, GLint * location) {
    PFN_GLGETTRANSFORMFEEDBACKVARYINGNV _ptr;
    _ptr = (PFN_GLGETTRANSFORMFEEDBACKVARYINGNV)_getPrivateProcAddress("glGetTransformFeedbackVaryingNV");
    if (!_ptr) {
        _ptr = &_fail_glGetTransformFeedbackVaryingNV;
    }
    _glGetTransformFeedbackVaryingNV = _ptr;
    _glGetTransformFeedbackVaryingNV(program, index, location);
}

PFN_GLGETTRANSFORMFEEDBACKVARYINGNV _glGetTransformFeedbackVaryingNV = &_get_glGetTransformFeedbackVaryingNV;

static void APIENTRY _fail_glTransformFeedbackStreamAttribsNV(GLsizei count, const GLint * attribs, GLsizei nbuffers, const GLint * bufstreams, GLenum bufferMode) {
    const char *_name = "glTransformFeedbackStreamAttribsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTransformFeedbackStreamAttribsNV(GLsizei count, const GLint * attribs, GLsizei nbuffers, const GLint * bufstreams, GLenum bufferMode) {
    PFN_GLTRANSFORMFEEDBACKSTREAMATTRIBSNV _ptr;
    _ptr = (PFN_GLTRANSFORMFEEDBACKSTREAMATTRIBSNV)_getPrivateProcAddress("glTransformFeedbackStreamAttribsNV");
    if (!_ptr) {
        _ptr = &_fail_glTransformFeedbackStreamAttribsNV;
    }
    _glTransformFeedbackStreamAttribsNV = _ptr;
    _glTransformFeedbackStreamAttribsNV(count, attribs, nbuffers, bufstreams, bufferMode);
}

PFN_GLTRANSFORMFEEDBACKSTREAMATTRIBSNV _glTransformFeedbackStreamAttribsNV = &_get_glTransformFeedbackStreamAttribsNV;

static void APIENTRY _fail_glBindTransformFeedbackNV(GLenum target, GLuint id) {
    const char *_name = "glBindTransformFeedbackNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindTransformFeedbackNV(GLenum target, GLuint id) {
    PFN_GLBINDTRANSFORMFEEDBACKNV _ptr;
    _ptr = (PFN_GLBINDTRANSFORMFEEDBACKNV)_getPrivateProcAddress("glBindTransformFeedbackNV");
    if (!_ptr) {
        _ptr = &_fail_glBindTransformFeedbackNV;
    }
    _glBindTransformFeedbackNV = _ptr;
    _glBindTransformFeedbackNV(target, id);
}

PFN_GLBINDTRANSFORMFEEDBACKNV _glBindTransformFeedbackNV = &_get_glBindTransformFeedbackNV;

static void APIENTRY _fail_glDeleteTransformFeedbacksNV(GLsizei n, const GLuint * ids) {
    const char *_name = "glDeleteTransformFeedbacksNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteTransformFeedbacksNV(GLsizei n, const GLuint * ids) {
    PFN_GLDELETETRANSFORMFEEDBACKSNV _ptr;
    _ptr = (PFN_GLDELETETRANSFORMFEEDBACKSNV)_getPrivateProcAddress("glDeleteTransformFeedbacksNV");
    if (!_ptr) {
        _ptr = &_fail_glDeleteTransformFeedbacksNV;
    }
    _glDeleteTransformFeedbacksNV = _ptr;
    _glDeleteTransformFeedbacksNV(n, ids);
}

PFN_GLDELETETRANSFORMFEEDBACKSNV _glDeleteTransformFeedbacksNV = &_get_glDeleteTransformFeedbacksNV;

static void APIENTRY _fail_glGenTransformFeedbacksNV(GLsizei n, GLuint * ids) {
    const char *_name = "glGenTransformFeedbacksNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenTransformFeedbacksNV(GLsizei n, GLuint * ids) {
    PFN_GLGENTRANSFORMFEEDBACKSNV _ptr;
    _ptr = (PFN_GLGENTRANSFORMFEEDBACKSNV)_getPrivateProcAddress("glGenTransformFeedbacksNV");
    if (!_ptr) {
        _ptr = &_fail_glGenTransformFeedbacksNV;
    }
    _glGenTransformFeedbacksNV = _ptr;
    _glGenTransformFeedbacksNV(n, ids);
}

PFN_GLGENTRANSFORMFEEDBACKSNV _glGenTransformFeedbacksNV = &_get_glGenTransformFeedbacksNV;

static GLboolean APIENTRY _fail_glIsTransformFeedbackNV(GLuint id) {
    const char *_name = "glIsTransformFeedbackNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsTransformFeedbackNV(GLuint id) {
    PFN_GLISTRANSFORMFEEDBACKNV _ptr;
    _ptr = (PFN_GLISTRANSFORMFEEDBACKNV)_getPrivateProcAddress("glIsTransformFeedbackNV");
    if (!_ptr) {
        _ptr = &_fail_glIsTransformFeedbackNV;
    }
    _glIsTransformFeedbackNV = _ptr;
    return _glIsTransformFeedbackNV(id);
}

PFN_GLISTRANSFORMFEEDBACKNV _glIsTransformFeedbackNV = &_get_glIsTransformFeedbackNV;

static void APIENTRY _fail_glPauseTransformFeedbackNV(void) {
    const char *_name = "glPauseTransformFeedbackNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPauseTransformFeedbackNV(void) {
    PFN_GLPAUSETRANSFORMFEEDBACKNV _ptr;
    _ptr = (PFN_GLPAUSETRANSFORMFEEDBACKNV)_getPrivateProcAddress("glPauseTransformFeedbackNV");
    if (!_ptr) {
        _ptr = &_fail_glPauseTransformFeedbackNV;
    }
    _glPauseTransformFeedbackNV = _ptr;
    _glPauseTransformFeedbackNV();
}

PFN_GLPAUSETRANSFORMFEEDBACKNV _glPauseTransformFeedbackNV = &_get_glPauseTransformFeedbackNV;

static void APIENTRY _fail_glResumeTransformFeedbackNV(void) {
    const char *_name = "glResumeTransformFeedbackNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glResumeTransformFeedbackNV(void) {
    PFN_GLRESUMETRANSFORMFEEDBACKNV _ptr;
    _ptr = (PFN_GLRESUMETRANSFORMFEEDBACKNV)_getPrivateProcAddress("glResumeTransformFeedbackNV");
    if (!_ptr) {
        _ptr = &_fail_glResumeTransformFeedbackNV;
    }
    _glResumeTransformFeedbackNV = _ptr;
    _glResumeTransformFeedbackNV();
}

PFN_GLRESUMETRANSFORMFEEDBACKNV _glResumeTransformFeedbackNV = &_get_glResumeTransformFeedbackNV;

static void APIENTRY _fail_glDrawTransformFeedbackNV(GLenum mode, GLuint id) {
    const char *_name = "glDrawTransformFeedbackNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawTransformFeedbackNV(GLenum mode, GLuint id) {
    PFN_GLDRAWTRANSFORMFEEDBACKNV _ptr;
    _ptr = (PFN_GLDRAWTRANSFORMFEEDBACKNV)_getPrivateProcAddress("glDrawTransformFeedbackNV");
    if (!_ptr) {
        _ptr = &_fail_glDrawTransformFeedbackNV;
    }
    _glDrawTransformFeedbackNV = _ptr;
    _glDrawTransformFeedbackNV(mode, id);
}

PFN_GLDRAWTRANSFORMFEEDBACKNV _glDrawTransformFeedbackNV = &_get_glDrawTransformFeedbackNV;

static void APIENTRY _fail_glVDPAUInitNV(const GLvoid * vdpDevice, const GLvoid * getProcAddress) {
    const char *_name = "glVDPAUInitNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVDPAUInitNV(const GLvoid * vdpDevice, const GLvoid * getProcAddress) {
    PFN_GLVDPAUINITNV _ptr;
    _ptr = (PFN_GLVDPAUINITNV)_getPrivateProcAddress("glVDPAUInitNV");
    if (!_ptr) {
        _ptr = &_fail_glVDPAUInitNV;
    }
    _glVDPAUInitNV = _ptr;
    _glVDPAUInitNV(vdpDevice, getProcAddress);
}

PFN_GLVDPAUINITNV _glVDPAUInitNV = &_get_glVDPAUInitNV;

static void APIENTRY _fail_glVDPAUFiniNV(void) {
    const char *_name = "glVDPAUFiniNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVDPAUFiniNV(void) {
    PFN_GLVDPAUFININV _ptr;
    _ptr = (PFN_GLVDPAUFININV)_getPrivateProcAddress("glVDPAUFiniNV");
    if (!_ptr) {
        _ptr = &_fail_glVDPAUFiniNV;
    }
    _glVDPAUFiniNV = _ptr;
    _glVDPAUFiniNV();
}

PFN_GLVDPAUFININV _glVDPAUFiniNV = &_get_glVDPAUFiniNV;

static GLvdpauSurfaceNV APIENTRY _fail_glVDPAURegisterVideoSurfaceNV(const GLvoid * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames) {
    const char *_name = "glVDPAURegisterVideoSurfaceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLvdpauSurfaceNV APIENTRY _get_glVDPAURegisterVideoSurfaceNV(const GLvoid * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames) {
    PFN_GLVDPAUREGISTERVIDEOSURFACENV _ptr;
    _ptr = (PFN_GLVDPAUREGISTERVIDEOSURFACENV)_getPrivateProcAddress("glVDPAURegisterVideoSurfaceNV");
    if (!_ptr) {
        _ptr = &_fail_glVDPAURegisterVideoSurfaceNV;
    }
    _glVDPAURegisterVideoSurfaceNV = _ptr;
    return _glVDPAURegisterVideoSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
}

PFN_GLVDPAUREGISTERVIDEOSURFACENV _glVDPAURegisterVideoSurfaceNV = &_get_glVDPAURegisterVideoSurfaceNV;

static GLvdpauSurfaceNV APIENTRY _fail_glVDPAURegisterOutputSurfaceNV(const GLvoid * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames) {
    const char *_name = "glVDPAURegisterOutputSurfaceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLvdpauSurfaceNV APIENTRY _get_glVDPAURegisterOutputSurfaceNV(const GLvoid * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames) {
    PFN_GLVDPAUREGISTEROUTPUTSURFACENV _ptr;
    _ptr = (PFN_GLVDPAUREGISTEROUTPUTSURFACENV)_getPrivateProcAddress("glVDPAURegisterOutputSurfaceNV");
    if (!_ptr) {
        _ptr = &_fail_glVDPAURegisterOutputSurfaceNV;
    }
    _glVDPAURegisterOutputSurfaceNV = _ptr;
    return _glVDPAURegisterOutputSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
}

PFN_GLVDPAUREGISTEROUTPUTSURFACENV _glVDPAURegisterOutputSurfaceNV = &_get_glVDPAURegisterOutputSurfaceNV;

static GLboolean APIENTRY _fail_glVDPAUIsSurfaceNV(GLvdpauSurfaceNV surface) {
    const char *_name = "glVDPAUIsSurfaceNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glVDPAUIsSurfaceNV(GLvdpauSurfaceNV surface) {
    PFN_GLVDPAUISSURFACENV _ptr;
    _ptr = (PFN_GLVDPAUISSURFACENV)_getPrivateProcAddress("glVDPAUIsSurfaceNV");
    if (!_ptr) {
        _ptr = &_fail_glVDPAUIsSurfaceNV;
    }
    _glVDPAUIsSurfaceNV = _ptr;
    return _glVDPAUIsSurfaceNV(surface);
}

PFN_GLVDPAUISSURFACENV _glVDPAUIsSurfaceNV = &_get_glVDPAUIsSurfaceNV;

static void APIENTRY _fail_glVDPAUUnregisterSurfaceNV(GLvdpauSurfaceNV surface) {
    const char *_name = "glVDPAUUnregisterSurfaceNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVDPAUUnregisterSurfaceNV(GLvdpauSurfaceNV surface) {
    PFN_GLVDPAUUNREGISTERSURFACENV _ptr;
    _ptr = (PFN_GLVDPAUUNREGISTERSURFACENV)_getPrivateProcAddress("glVDPAUUnregisterSurfaceNV");
    if (!_ptr) {
        _ptr = &_fail_glVDPAUUnregisterSurfaceNV;
    }
    _glVDPAUUnregisterSurfaceNV = _ptr;
    _glVDPAUUnregisterSurfaceNV(surface);
}

PFN_GLVDPAUUNREGISTERSURFACENV _glVDPAUUnregisterSurfaceNV = &_get_glVDPAUUnregisterSurfaceNV;

static void APIENTRY _fail_glVDPAUGetSurfaceivNV(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values) {
    const char *_name = "glVDPAUGetSurfaceivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVDPAUGetSurfaceivNV(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values) {
    PFN_GLVDPAUGETSURFACEIVNV _ptr;
    _ptr = (PFN_GLVDPAUGETSURFACEIVNV)_getPrivateProcAddress("glVDPAUGetSurfaceivNV");
    if (!_ptr) {
        _ptr = &_fail_glVDPAUGetSurfaceivNV;
    }
    _glVDPAUGetSurfaceivNV = _ptr;
    _glVDPAUGetSurfaceivNV(surface, pname, bufSize, length, values);
}

PFN_GLVDPAUGETSURFACEIVNV _glVDPAUGetSurfaceivNV = &_get_glVDPAUGetSurfaceivNV;

static void APIENTRY _fail_glVDPAUSurfaceAccessNV(GLvdpauSurfaceNV surface, GLenum access) {
    const char *_name = "glVDPAUSurfaceAccessNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVDPAUSurfaceAccessNV(GLvdpauSurfaceNV surface, GLenum access) {
    PFN_GLVDPAUSURFACEACCESSNV _ptr;
    _ptr = (PFN_GLVDPAUSURFACEACCESSNV)_getPrivateProcAddress("glVDPAUSurfaceAccessNV");
    if (!_ptr) {
        _ptr = &_fail_glVDPAUSurfaceAccessNV;
    }
    _glVDPAUSurfaceAccessNV = _ptr;
    _glVDPAUSurfaceAccessNV(surface, access);
}

PFN_GLVDPAUSURFACEACCESSNV _glVDPAUSurfaceAccessNV = &_get_glVDPAUSurfaceAccessNV;

static void APIENTRY _fail_glVDPAUMapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV * surfaces) {
    const char *_name = "glVDPAUMapSurfacesNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVDPAUMapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV * surfaces) {
    PFN_GLVDPAUMAPSURFACESNV _ptr;
    _ptr = (PFN_GLVDPAUMAPSURFACESNV)_getPrivateProcAddress("glVDPAUMapSurfacesNV");
    if (!_ptr) {
        _ptr = &_fail_glVDPAUMapSurfacesNV;
    }
    _glVDPAUMapSurfacesNV = _ptr;
    _glVDPAUMapSurfacesNV(numSurfaces, surfaces);
}

PFN_GLVDPAUMAPSURFACESNV _glVDPAUMapSurfacesNV = &_get_glVDPAUMapSurfacesNV;

static void APIENTRY _fail_glVDPAUUnmapSurfacesNV(GLsizei numSurface, const GLvdpauSurfaceNV * surfaces) {
    const char *_name = "glVDPAUUnmapSurfacesNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVDPAUUnmapSurfacesNV(GLsizei numSurface, const GLvdpauSurfaceNV * surfaces) {
    PFN_GLVDPAUUNMAPSURFACESNV _ptr;
    _ptr = (PFN_GLVDPAUUNMAPSURFACESNV)_getPrivateProcAddress("glVDPAUUnmapSurfacesNV");
    if (!_ptr) {
        _ptr = &_fail_glVDPAUUnmapSurfacesNV;
    }
    _glVDPAUUnmapSurfacesNV = _ptr;
    _glVDPAUUnmapSurfacesNV(numSurface, surfaces);
}

PFN_GLVDPAUUNMAPSURFACESNV _glVDPAUUnmapSurfacesNV = &_get_glVDPAUUnmapSurfacesNV;

static void APIENTRY _fail_glFlushVertexArrayRangeNV(void) {
    const char *_name = "glFlushVertexArrayRangeNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFlushVertexArrayRangeNV(void) {
    PFN_GLFLUSHVERTEXARRAYRANGENV _ptr;
    _ptr = (PFN_GLFLUSHVERTEXARRAYRANGENV)_getPrivateProcAddress("glFlushVertexArrayRangeNV");
    if (!_ptr) {
        _ptr = &_fail_glFlushVertexArrayRangeNV;
    }
    _glFlushVertexArrayRangeNV = _ptr;
    _glFlushVertexArrayRangeNV();
}

PFN_GLFLUSHVERTEXARRAYRANGENV _glFlushVertexArrayRangeNV = &_get_glFlushVertexArrayRangeNV;

static void APIENTRY _fail_glVertexArrayRangeNV(GLsizei length, const GLvoid * pointer) {
    const char *_name = "glVertexArrayRangeNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexArrayRangeNV(GLsizei length, const GLvoid * pointer) {
    PFN_GLVERTEXARRAYRANGENV _ptr;
    _ptr = (PFN_GLVERTEXARRAYRANGENV)_getPrivateProcAddress("glVertexArrayRangeNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexArrayRangeNV;
    }
    _glVertexArrayRangeNV = _ptr;
    _glVertexArrayRangeNV(length, pointer);
}

PFN_GLVERTEXARRAYRANGENV _glVertexArrayRangeNV = &_get_glVertexArrayRangeNV;

static void APIENTRY _fail_glVertexAttribL1i64NV(GLuint index, GLint64EXT x) {
    const char *_name = "glVertexAttribL1i64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL1i64NV(GLuint index, GLint64EXT x) {
    PFN_GLVERTEXATTRIBL1I64NV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL1I64NV)_getPrivateProcAddress("glVertexAttribL1i64NV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL1i64NV;
    }
    _glVertexAttribL1i64NV = _ptr;
    _glVertexAttribL1i64NV(index, x);
}

PFN_GLVERTEXATTRIBL1I64NV _glVertexAttribL1i64NV = &_get_glVertexAttribL1i64NV;

static void APIENTRY _fail_glVertexAttribL2i64NV(GLuint index, GLint64EXT x, GLint64EXT y) {
    const char *_name = "glVertexAttribL2i64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL2i64NV(GLuint index, GLint64EXT x, GLint64EXT y) {
    PFN_GLVERTEXATTRIBL2I64NV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL2I64NV)_getPrivateProcAddress("glVertexAttribL2i64NV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL2i64NV;
    }
    _glVertexAttribL2i64NV = _ptr;
    _glVertexAttribL2i64NV(index, x, y);
}

PFN_GLVERTEXATTRIBL2I64NV _glVertexAttribL2i64NV = &_get_glVertexAttribL2i64NV;

static void APIENTRY _fail_glVertexAttribL3i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z) {
    const char *_name = "glVertexAttribL3i64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL3i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z) {
    PFN_GLVERTEXATTRIBL3I64NV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL3I64NV)_getPrivateProcAddress("glVertexAttribL3i64NV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL3i64NV;
    }
    _glVertexAttribL3i64NV = _ptr;
    _glVertexAttribL3i64NV(index, x, y, z);
}

PFN_GLVERTEXATTRIBL3I64NV _glVertexAttribL3i64NV = &_get_glVertexAttribL3i64NV;

static void APIENTRY _fail_glVertexAttribL4i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) {
    const char *_name = "glVertexAttribL4i64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL4i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) {
    PFN_GLVERTEXATTRIBL4I64NV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL4I64NV)_getPrivateProcAddress("glVertexAttribL4i64NV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL4i64NV;
    }
    _glVertexAttribL4i64NV = _ptr;
    _glVertexAttribL4i64NV(index, x, y, z, w);
}

PFN_GLVERTEXATTRIBL4I64NV _glVertexAttribL4i64NV = &_get_glVertexAttribL4i64NV;

static void APIENTRY _fail_glVertexAttribL1i64vNV(GLuint index, const GLint64EXT * v) {
    const char *_name = "glVertexAttribL1i64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL1i64vNV(GLuint index, const GLint64EXT * v) {
    PFN_GLVERTEXATTRIBL1I64VNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL1I64VNV)_getPrivateProcAddress("glVertexAttribL1i64vNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL1i64vNV;
    }
    _glVertexAttribL1i64vNV = _ptr;
    _glVertexAttribL1i64vNV(index, v);
}

PFN_GLVERTEXATTRIBL1I64VNV _glVertexAttribL1i64vNV = &_get_glVertexAttribL1i64vNV;

static void APIENTRY _fail_glVertexAttribL2i64vNV(GLuint index, const GLint64EXT * v) {
    const char *_name = "glVertexAttribL2i64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL2i64vNV(GLuint index, const GLint64EXT * v) {
    PFN_GLVERTEXATTRIBL2I64VNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL2I64VNV)_getPrivateProcAddress("glVertexAttribL2i64vNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL2i64vNV;
    }
    _glVertexAttribL2i64vNV = _ptr;
    _glVertexAttribL2i64vNV(index, v);
}

PFN_GLVERTEXATTRIBL2I64VNV _glVertexAttribL2i64vNV = &_get_glVertexAttribL2i64vNV;

static void APIENTRY _fail_glVertexAttribL3i64vNV(GLuint index, const GLint64EXT * v) {
    const char *_name = "glVertexAttribL3i64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL3i64vNV(GLuint index, const GLint64EXT * v) {
    PFN_GLVERTEXATTRIBL3I64VNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL3I64VNV)_getPrivateProcAddress("glVertexAttribL3i64vNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL3i64vNV;
    }
    _glVertexAttribL3i64vNV = _ptr;
    _glVertexAttribL3i64vNV(index, v);
}

PFN_GLVERTEXATTRIBL3I64VNV _glVertexAttribL3i64vNV = &_get_glVertexAttribL3i64vNV;

static void APIENTRY _fail_glVertexAttribL4i64vNV(GLuint index, const GLint64EXT * v) {
    const char *_name = "glVertexAttribL4i64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL4i64vNV(GLuint index, const GLint64EXT * v) {
    PFN_GLVERTEXATTRIBL4I64VNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL4I64VNV)_getPrivateProcAddress("glVertexAttribL4i64vNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL4i64vNV;
    }
    _glVertexAttribL4i64vNV = _ptr;
    _glVertexAttribL4i64vNV(index, v);
}

PFN_GLVERTEXATTRIBL4I64VNV _glVertexAttribL4i64vNV = &_get_glVertexAttribL4i64vNV;

static void APIENTRY _fail_glVertexAttribL1ui64NV(GLuint index, GLuint64EXT x) {
    const char *_name = "glVertexAttribL1ui64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL1ui64NV(GLuint index, GLuint64EXT x) {
    PFN_GLVERTEXATTRIBL1UI64NV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL1UI64NV)_getPrivateProcAddress("glVertexAttribL1ui64NV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL1ui64NV;
    }
    _glVertexAttribL1ui64NV = _ptr;
    _glVertexAttribL1ui64NV(index, x);
}

PFN_GLVERTEXATTRIBL1UI64NV _glVertexAttribL1ui64NV = &_get_glVertexAttribL1ui64NV;

static void APIENTRY _fail_glVertexAttribL2ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y) {
    const char *_name = "glVertexAttribL2ui64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL2ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y) {
    PFN_GLVERTEXATTRIBL2UI64NV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL2UI64NV)_getPrivateProcAddress("glVertexAttribL2ui64NV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL2ui64NV;
    }
    _glVertexAttribL2ui64NV = _ptr;
    _glVertexAttribL2ui64NV(index, x, y);
}

PFN_GLVERTEXATTRIBL2UI64NV _glVertexAttribL2ui64NV = &_get_glVertexAttribL2ui64NV;

static void APIENTRY _fail_glVertexAttribL3ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) {
    const char *_name = "glVertexAttribL3ui64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL3ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) {
    PFN_GLVERTEXATTRIBL3UI64NV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL3UI64NV)_getPrivateProcAddress("glVertexAttribL3ui64NV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL3ui64NV;
    }
    _glVertexAttribL3ui64NV = _ptr;
    _glVertexAttribL3ui64NV(index, x, y, z);
}

PFN_GLVERTEXATTRIBL3UI64NV _glVertexAttribL3ui64NV = &_get_glVertexAttribL3ui64NV;

static void APIENTRY _fail_glVertexAttribL4ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) {
    const char *_name = "glVertexAttribL4ui64NV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL4ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) {
    PFN_GLVERTEXATTRIBL4UI64NV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL4UI64NV)_getPrivateProcAddress("glVertexAttribL4ui64NV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL4ui64NV;
    }
    _glVertexAttribL4ui64NV = _ptr;
    _glVertexAttribL4ui64NV(index, x, y, z, w);
}

PFN_GLVERTEXATTRIBL4UI64NV _glVertexAttribL4ui64NV = &_get_glVertexAttribL4ui64NV;

static void APIENTRY _fail_glVertexAttribL1ui64vNV(GLuint index, const GLuint64EXT * v) {
    const char *_name = "glVertexAttribL1ui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL1ui64vNV(GLuint index, const GLuint64EXT * v) {
    PFN_GLVERTEXATTRIBL1UI64VNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL1UI64VNV)_getPrivateProcAddress("glVertexAttribL1ui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL1ui64vNV;
    }
    _glVertexAttribL1ui64vNV = _ptr;
    _glVertexAttribL1ui64vNV(index, v);
}

PFN_GLVERTEXATTRIBL1UI64VNV _glVertexAttribL1ui64vNV = &_get_glVertexAttribL1ui64vNV;

static void APIENTRY _fail_glVertexAttribL2ui64vNV(GLuint index, const GLuint64EXT * v) {
    const char *_name = "glVertexAttribL2ui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL2ui64vNV(GLuint index, const GLuint64EXT * v) {
    PFN_GLVERTEXATTRIBL2UI64VNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL2UI64VNV)_getPrivateProcAddress("glVertexAttribL2ui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL2ui64vNV;
    }
    _glVertexAttribL2ui64vNV = _ptr;
    _glVertexAttribL2ui64vNV(index, v);
}

PFN_GLVERTEXATTRIBL2UI64VNV _glVertexAttribL2ui64vNV = &_get_glVertexAttribL2ui64vNV;

static void APIENTRY _fail_glVertexAttribL3ui64vNV(GLuint index, const GLuint64EXT * v) {
    const char *_name = "glVertexAttribL3ui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL3ui64vNV(GLuint index, const GLuint64EXT * v) {
    PFN_GLVERTEXATTRIBL3UI64VNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL3UI64VNV)_getPrivateProcAddress("glVertexAttribL3ui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL3ui64vNV;
    }
    _glVertexAttribL3ui64vNV = _ptr;
    _glVertexAttribL3ui64vNV(index, v);
}

PFN_GLVERTEXATTRIBL3UI64VNV _glVertexAttribL3ui64vNV = &_get_glVertexAttribL3ui64vNV;

static void APIENTRY _fail_glVertexAttribL4ui64vNV(GLuint index, const GLuint64EXT * v) {
    const char *_name = "glVertexAttribL4ui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribL4ui64vNV(GLuint index, const GLuint64EXT * v) {
    PFN_GLVERTEXATTRIBL4UI64VNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBL4UI64VNV)_getPrivateProcAddress("glVertexAttribL4ui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribL4ui64vNV;
    }
    _glVertexAttribL4ui64vNV = _ptr;
    _glVertexAttribL4ui64vNV(index, v);
}

PFN_GLVERTEXATTRIBL4UI64VNV _glVertexAttribL4ui64vNV = &_get_glVertexAttribL4ui64vNV;

static void APIENTRY _fail_glGetVertexAttribLi64vNV(GLuint index, GLenum pname, GLint64EXT * params) {
    const char *_name = "glGetVertexAttribLi64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribLi64vNV(GLuint index, GLenum pname, GLint64EXT * params) {
    PFN_GLGETVERTEXATTRIBLI64VNV _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBLI64VNV)_getPrivateProcAddress("glGetVertexAttribLi64vNV");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribLi64vNV;
    }
    _glGetVertexAttribLi64vNV = _ptr;
    _glGetVertexAttribLi64vNV(index, pname, params);
}

PFN_GLGETVERTEXATTRIBLI64VNV _glGetVertexAttribLi64vNV = &_get_glGetVertexAttribLi64vNV;

static void APIENTRY _fail_glGetVertexAttribLui64vNV(GLuint index, GLenum pname, GLuint64EXT * params) {
    const char *_name = "glGetVertexAttribLui64vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribLui64vNV(GLuint index, GLenum pname, GLuint64EXT * params) {
    PFN_GLGETVERTEXATTRIBLUI64VNV _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBLUI64VNV)_getPrivateProcAddress("glGetVertexAttribLui64vNV");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribLui64vNV;
    }
    _glGetVertexAttribLui64vNV = _ptr;
    _glGetVertexAttribLui64vNV(index, pname, params);
}

PFN_GLGETVERTEXATTRIBLUI64VNV _glGetVertexAttribLui64vNV = &_get_glGetVertexAttribLui64vNV;

static void APIENTRY _fail_glVertexAttribLFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride) {
    const char *_name = "glVertexAttribLFormatNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribLFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride) {
    PFN_GLVERTEXATTRIBLFORMATNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBLFORMATNV)_getPrivateProcAddress("glVertexAttribLFormatNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribLFormatNV;
    }
    _glVertexAttribLFormatNV = _ptr;
    _glVertexAttribLFormatNV(index, size, type, stride);
}

PFN_GLVERTEXATTRIBLFORMATNV _glVertexAttribLFormatNV = &_get_glVertexAttribLFormatNV;

static void APIENTRY _fail_glBufferAddressRangeNV(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length) {
    const char *_name = "glBufferAddressRangeNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBufferAddressRangeNV(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length) {
    PFN_GLBUFFERADDRESSRANGENV _ptr;
    _ptr = (PFN_GLBUFFERADDRESSRANGENV)_getPrivateProcAddress("glBufferAddressRangeNV");
    if (!_ptr) {
        _ptr = &_fail_glBufferAddressRangeNV;
    }
    _glBufferAddressRangeNV = _ptr;
    _glBufferAddressRangeNV(pname, index, address, length);
}

PFN_GLBUFFERADDRESSRANGENV _glBufferAddressRangeNV = &_get_glBufferAddressRangeNV;

static void APIENTRY _fail_glVertexFormatNV(GLint size, GLenum type, GLsizei stride) {
    const char *_name = "glVertexFormatNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexFormatNV(GLint size, GLenum type, GLsizei stride) {
    PFN_GLVERTEXFORMATNV _ptr;
    _ptr = (PFN_GLVERTEXFORMATNV)_getPrivateProcAddress("glVertexFormatNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexFormatNV;
    }
    _glVertexFormatNV = _ptr;
    _glVertexFormatNV(size, type, stride);
}

PFN_GLVERTEXFORMATNV _glVertexFormatNV = &_get_glVertexFormatNV;

static void APIENTRY _fail_glNormalFormatNV(GLenum type, GLsizei stride) {
    const char *_name = "glNormalFormatNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormalFormatNV(GLenum type, GLsizei stride) {
    PFN_GLNORMALFORMATNV _ptr;
    _ptr = (PFN_GLNORMALFORMATNV)_getPrivateProcAddress("glNormalFormatNV");
    if (!_ptr) {
        _ptr = &_fail_glNormalFormatNV;
    }
    _glNormalFormatNV = _ptr;
    _glNormalFormatNV(type, stride);
}

PFN_GLNORMALFORMATNV _glNormalFormatNV = &_get_glNormalFormatNV;

static void APIENTRY _fail_glColorFormatNV(GLint size, GLenum type, GLsizei stride) {
    const char *_name = "glColorFormatNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorFormatNV(GLint size, GLenum type, GLsizei stride) {
    PFN_GLCOLORFORMATNV _ptr;
    _ptr = (PFN_GLCOLORFORMATNV)_getPrivateProcAddress("glColorFormatNV");
    if (!_ptr) {
        _ptr = &_fail_glColorFormatNV;
    }
    _glColorFormatNV = _ptr;
    _glColorFormatNV(size, type, stride);
}

PFN_GLCOLORFORMATNV _glColorFormatNV = &_get_glColorFormatNV;

static void APIENTRY _fail_glIndexFormatNV(GLenum type, GLsizei stride) {
    const char *_name = "glIndexFormatNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glIndexFormatNV(GLenum type, GLsizei stride) {
    PFN_GLINDEXFORMATNV _ptr;
    _ptr = (PFN_GLINDEXFORMATNV)_getPrivateProcAddress("glIndexFormatNV");
    if (!_ptr) {
        _ptr = &_fail_glIndexFormatNV;
    }
    _glIndexFormatNV = _ptr;
    _glIndexFormatNV(type, stride);
}

PFN_GLINDEXFORMATNV _glIndexFormatNV = &_get_glIndexFormatNV;

static void APIENTRY _fail_glTexCoordFormatNV(GLint size, GLenum type, GLsizei stride) {
    const char *_name = "glTexCoordFormatNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoordFormatNV(GLint size, GLenum type, GLsizei stride) {
    PFN_GLTEXCOORDFORMATNV _ptr;
    _ptr = (PFN_GLTEXCOORDFORMATNV)_getPrivateProcAddress("glTexCoordFormatNV");
    if (!_ptr) {
        _ptr = &_fail_glTexCoordFormatNV;
    }
    _glTexCoordFormatNV = _ptr;
    _glTexCoordFormatNV(size, type, stride);
}

PFN_GLTEXCOORDFORMATNV _glTexCoordFormatNV = &_get_glTexCoordFormatNV;

static void APIENTRY _fail_glEdgeFlagFormatNV(GLsizei stride) {
    const char *_name = "glEdgeFlagFormatNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEdgeFlagFormatNV(GLsizei stride) {
    PFN_GLEDGEFLAGFORMATNV _ptr;
    _ptr = (PFN_GLEDGEFLAGFORMATNV)_getPrivateProcAddress("glEdgeFlagFormatNV");
    if (!_ptr) {
        _ptr = &_fail_glEdgeFlagFormatNV;
    }
    _glEdgeFlagFormatNV = _ptr;
    _glEdgeFlagFormatNV(stride);
}

PFN_GLEDGEFLAGFORMATNV _glEdgeFlagFormatNV = &_get_glEdgeFlagFormatNV;

static void APIENTRY _fail_glSecondaryColorFormatNV(GLint size, GLenum type, GLsizei stride) {
    const char *_name = "glSecondaryColorFormatNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSecondaryColorFormatNV(GLint size, GLenum type, GLsizei stride) {
    PFN_GLSECONDARYCOLORFORMATNV _ptr;
    _ptr = (PFN_GLSECONDARYCOLORFORMATNV)_getPrivateProcAddress("glSecondaryColorFormatNV");
    if (!_ptr) {
        _ptr = &_fail_glSecondaryColorFormatNV;
    }
    _glSecondaryColorFormatNV = _ptr;
    _glSecondaryColorFormatNV(size, type, stride);
}

PFN_GLSECONDARYCOLORFORMATNV _glSecondaryColorFormatNV = &_get_glSecondaryColorFormatNV;

static void APIENTRY _fail_glFogCoordFormatNV(GLenum type, GLsizei stride) {
    const char *_name = "glFogCoordFormatNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogCoordFormatNV(GLenum type, GLsizei stride) {
    PFN_GLFOGCOORDFORMATNV _ptr;
    _ptr = (PFN_GLFOGCOORDFORMATNV)_getPrivateProcAddress("glFogCoordFormatNV");
    if (!_ptr) {
        _ptr = &_fail_glFogCoordFormatNV;
    }
    _glFogCoordFormatNV = _ptr;
    _glFogCoordFormatNV(type, stride);
}

PFN_GLFOGCOORDFORMATNV _glFogCoordFormatNV = &_get_glFogCoordFormatNV;

static void APIENTRY _fail_glVertexAttribFormatNV(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride) {
    const char *_name = "glVertexAttribFormatNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribFormatNV(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride) {
    PFN_GLVERTEXATTRIBFORMATNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBFORMATNV)_getPrivateProcAddress("glVertexAttribFormatNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribFormatNV;
    }
    _glVertexAttribFormatNV = _ptr;
    _glVertexAttribFormatNV(index, size, type, normalized, stride);
}

PFN_GLVERTEXATTRIBFORMATNV _glVertexAttribFormatNV = &_get_glVertexAttribFormatNV;

static void APIENTRY _fail_glVertexAttribIFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride) {
    const char *_name = "glVertexAttribIFormatNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribIFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride) {
    PFN_GLVERTEXATTRIBIFORMATNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBIFORMATNV)_getPrivateProcAddress("glVertexAttribIFormatNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribIFormatNV;
    }
    _glVertexAttribIFormatNV = _ptr;
    _glVertexAttribIFormatNV(index, size, type, stride);
}

PFN_GLVERTEXATTRIBIFORMATNV _glVertexAttribIFormatNV = &_get_glVertexAttribIFormatNV;

static void APIENTRY _fail_glGetIntegerui64i_vNV(GLenum value, GLuint index, GLuint64EXT * result) {
    const char *_name = "glGetIntegerui64i_vNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetIntegerui64i_vNV(GLenum value, GLuint index, GLuint64EXT * result) {
    PFN_GLGETINTEGERUI64I_VNV _ptr;
    _ptr = (PFN_GLGETINTEGERUI64I_VNV)_getPrivateProcAddress("glGetIntegerui64i_vNV");
    if (!_ptr) {
        _ptr = &_fail_glGetIntegerui64i_vNV;
    }
    _glGetIntegerui64i_vNV = _ptr;
    _glGetIntegerui64i_vNV(value, index, result);
}

PFN_GLGETINTEGERUI64I_VNV _glGetIntegerui64i_vNV = &_get_glGetIntegerui64i_vNV;

static GLboolean APIENTRY _fail_glAreProgramsResidentNV(GLsizei n, const GLuint * ids, GLboolean * residences) {
    const char *_name = "glAreProgramsResidentNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glAreProgramsResidentNV(GLsizei n, const GLuint * ids, GLboolean * residences) {
    PFN_GLAREPROGRAMSRESIDENTNV _ptr;
    _ptr = (PFN_GLAREPROGRAMSRESIDENTNV)_getPrivateProcAddress("glAreProgramsResidentNV");
    if (!_ptr) {
        _ptr = &_fail_glAreProgramsResidentNV;
    }
    _glAreProgramsResidentNV = _ptr;
    return _glAreProgramsResidentNV(n, ids, residences);
}

PFN_GLAREPROGRAMSRESIDENTNV _glAreProgramsResidentNV = &_get_glAreProgramsResidentNV;

static void APIENTRY _fail_glBindProgramNV(GLenum target, GLuint program) {
    const char *_name = "glBindProgramNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindProgramNV(GLenum target, GLuint program) {
    PFN_GLBINDPROGRAMNV _ptr;
    _ptr = (PFN_GLBINDPROGRAMNV)_getPrivateProcAddress("glBindProgramNV");
    if (!_ptr) {
        _ptr = &_fail_glBindProgramNV;
    }
    _glBindProgramNV = _ptr;
    _glBindProgramNV(target, program);
}

PFN_GLBINDPROGRAMNV _glBindProgramNV = &_get_glBindProgramNV;

static void APIENTRY _fail_glDeleteProgramsNV(GLsizei n, const GLuint * programs) {
    const char *_name = "glDeleteProgramsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteProgramsNV(GLsizei n, const GLuint * programs) {
    PFN_GLDELETEPROGRAMSNV _ptr;
    _ptr = (PFN_GLDELETEPROGRAMSNV)_getPrivateProcAddress("glDeleteProgramsNV");
    if (!_ptr) {
        _ptr = &_fail_glDeleteProgramsNV;
    }
    _glDeleteProgramsNV = _ptr;
    _glDeleteProgramsNV(n, programs);
}

PFN_GLDELETEPROGRAMSNV _glDeleteProgramsNV = &_get_glDeleteProgramsNV;

static void APIENTRY _fail_glExecuteProgramNV(GLenum target, GLuint id, const GLfloat * params) {
    const char *_name = "glExecuteProgramNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glExecuteProgramNV(GLenum target, GLuint id, const GLfloat * params) {
    PFN_GLEXECUTEPROGRAMNV _ptr;
    _ptr = (PFN_GLEXECUTEPROGRAMNV)_getPrivateProcAddress("glExecuteProgramNV");
    if (!_ptr) {
        _ptr = &_fail_glExecuteProgramNV;
    }
    _glExecuteProgramNV = _ptr;
    _glExecuteProgramNV(target, id, params);
}

PFN_GLEXECUTEPROGRAMNV _glExecuteProgramNV = &_get_glExecuteProgramNV;

static void APIENTRY _fail_glGenProgramsNV(GLsizei n, GLuint * programs) {
    const char *_name = "glGenProgramsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenProgramsNV(GLsizei n, GLuint * programs) {
    PFN_GLGENPROGRAMSNV _ptr;
    _ptr = (PFN_GLGENPROGRAMSNV)_getPrivateProcAddress("glGenProgramsNV");
    if (!_ptr) {
        _ptr = &_fail_glGenProgramsNV;
    }
    _glGenProgramsNV = _ptr;
    _glGenProgramsNV(n, programs);
}

PFN_GLGENPROGRAMSNV _glGenProgramsNV = &_get_glGenProgramsNV;

static void APIENTRY _fail_glGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble * params) {
    const char *_name = "glGetProgramParameterdvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble * params) {
    PFN_GLGETPROGRAMPARAMETERDVNV _ptr;
    _ptr = (PFN_GLGETPROGRAMPARAMETERDVNV)_getPrivateProcAddress("glGetProgramParameterdvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramParameterdvNV;
    }
    _glGetProgramParameterdvNV = _ptr;
    _glGetProgramParameterdvNV(target, index, pname, params);
}

PFN_GLGETPROGRAMPARAMETERDVNV _glGetProgramParameterdvNV = &_get_glGetProgramParameterdvNV;

static void APIENTRY _fail_glGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat * params) {
    const char *_name = "glGetProgramParameterfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat * params) {
    PFN_GLGETPROGRAMPARAMETERFVNV _ptr;
    _ptr = (PFN_GLGETPROGRAMPARAMETERFVNV)_getPrivateProcAddress("glGetProgramParameterfvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramParameterfvNV;
    }
    _glGetProgramParameterfvNV = _ptr;
    _glGetProgramParameterfvNV(target, index, pname, params);
}

PFN_GLGETPROGRAMPARAMETERFVNV _glGetProgramParameterfvNV = &_get_glGetProgramParameterfvNV;

static void APIENTRY _fail_glGetProgramivNV(GLuint id, GLenum pname, GLint * params) {
    const char *_name = "glGetProgramivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramivNV(GLuint id, GLenum pname, GLint * params) {
    PFN_GLGETPROGRAMIVNV _ptr;
    _ptr = (PFN_GLGETPROGRAMIVNV)_getPrivateProcAddress("glGetProgramivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramivNV;
    }
    _glGetProgramivNV = _ptr;
    _glGetProgramivNV(id, pname, params);
}

PFN_GLGETPROGRAMIVNV _glGetProgramivNV = &_get_glGetProgramivNV;

static void APIENTRY _fail_glGetProgramStringNV(GLuint id, GLenum pname, GLubyte * program) {
    const char *_name = "glGetProgramStringNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramStringNV(GLuint id, GLenum pname, GLubyte * program) {
    PFN_GLGETPROGRAMSTRINGNV _ptr;
    _ptr = (PFN_GLGETPROGRAMSTRINGNV)_getPrivateProcAddress("glGetProgramStringNV");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramStringNV;
    }
    _glGetProgramStringNV = _ptr;
    _glGetProgramStringNV(id, pname, program);
}

PFN_GLGETPROGRAMSTRINGNV _glGetProgramStringNV = &_get_glGetProgramStringNV;

static void APIENTRY _fail_glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint * params) {
    const char *_name = "glGetTrackMatrixivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint * params) {
    PFN_GLGETTRACKMATRIXIVNV _ptr;
    _ptr = (PFN_GLGETTRACKMATRIXIVNV)_getPrivateProcAddress("glGetTrackMatrixivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetTrackMatrixivNV;
    }
    _glGetTrackMatrixivNV = _ptr;
    _glGetTrackMatrixivNV(target, address, pname, params);
}

PFN_GLGETTRACKMATRIXIVNV _glGetTrackMatrixivNV = &_get_glGetTrackMatrixivNV;

static void APIENTRY _fail_glGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble * params) {
    const char *_name = "glGetVertexAttribdvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble * params) {
    PFN_GLGETVERTEXATTRIBDVNV _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBDVNV)_getPrivateProcAddress("glGetVertexAttribdvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribdvNV;
    }
    _glGetVertexAttribdvNV = _ptr;
    _glGetVertexAttribdvNV(index, pname, params);
}

PFN_GLGETVERTEXATTRIBDVNV _glGetVertexAttribdvNV = &_get_glGetVertexAttribdvNV;

static void APIENTRY _fail_glGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat * params) {
    const char *_name = "glGetVertexAttribfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat * params) {
    PFN_GLGETVERTEXATTRIBFVNV _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBFVNV)_getPrivateProcAddress("glGetVertexAttribfvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribfvNV;
    }
    _glGetVertexAttribfvNV = _ptr;
    _glGetVertexAttribfvNV(index, pname, params);
}

PFN_GLGETVERTEXATTRIBFVNV _glGetVertexAttribfvNV = &_get_glGetVertexAttribfvNV;

static void APIENTRY _fail_glGetVertexAttribivNV(GLuint index, GLenum pname, GLint * params) {
    const char *_name = "glGetVertexAttribivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribivNV(GLuint index, GLenum pname, GLint * params) {
    PFN_GLGETVERTEXATTRIBIVNV _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBIVNV)_getPrivateProcAddress("glGetVertexAttribivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribivNV;
    }
    _glGetVertexAttribivNV = _ptr;
    _glGetVertexAttribivNV(index, pname, params);
}

PFN_GLGETVERTEXATTRIBIVNV _glGetVertexAttribivNV = &_get_glGetVertexAttribivNV;

static void APIENTRY _fail_glGetVertexAttribPointervNV(GLuint index, GLenum pname, GLvoid * * pointer) {
    const char *_name = "glGetVertexAttribPointervNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribPointervNV(GLuint index, GLenum pname, GLvoid * * pointer) {
    PFN_GLGETVERTEXATTRIBPOINTERVNV _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBPOINTERVNV)_getPrivateProcAddress("glGetVertexAttribPointervNV");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribPointervNV;
    }
    _glGetVertexAttribPointervNV = _ptr;
    _glGetVertexAttribPointervNV(index, pname, pointer);
}

PFN_GLGETVERTEXATTRIBPOINTERVNV _glGetVertexAttribPointervNV = &_get_glGetVertexAttribPointervNV;

static GLboolean APIENTRY _fail_glIsProgramNV(GLuint program) {
    const char *_name = "glIsProgramNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsProgramNV(GLuint program) {
    PFN_GLISPROGRAMNV _ptr;
    _ptr = (PFN_GLISPROGRAMNV)_getPrivateProcAddress("glIsProgramNV");
    if (!_ptr) {
        _ptr = &_fail_glIsProgramNV;
    }
    _glIsProgramNV = _ptr;
    return _glIsProgramNV(program);
}

PFN_GLISPROGRAMNV _glIsProgramNV = &_get_glIsProgramNV;

static void APIENTRY _fail_glLoadProgramNV(GLenum target, GLuint id, GLsizei len, const GLubyte * program) {
    const char *_name = "glLoadProgramNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLoadProgramNV(GLenum target, GLuint id, GLsizei len, const GLubyte * program) {
    PFN_GLLOADPROGRAMNV _ptr;
    _ptr = (PFN_GLLOADPROGRAMNV)_getPrivateProcAddress("glLoadProgramNV");
    if (!_ptr) {
        _ptr = &_fail_glLoadProgramNV;
    }
    _glLoadProgramNV = _ptr;
    _glLoadProgramNV(target, id, len, program);
}

PFN_GLLOADPROGRAMNV _glLoadProgramNV = &_get_glLoadProgramNV;

static void APIENTRY _fail_glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glProgramParameter4dNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    PFN_GLPROGRAMPARAMETER4DNV _ptr;
    _ptr = (PFN_GLPROGRAMPARAMETER4DNV)_getPrivateProcAddress("glProgramParameter4dNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramParameter4dNV;
    }
    _glProgramParameter4dNV = _ptr;
    _glProgramParameter4dNV(target, index, x, y, z, w);
}

PFN_GLPROGRAMPARAMETER4DNV _glProgramParameter4dNV = &_get_glProgramParameter4dNV;

static void APIENTRY _fail_glProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble * v) {
    const char *_name = "glProgramParameter4dvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble * v) {
    PFN_GLPROGRAMPARAMETER4DVNV _ptr;
    _ptr = (PFN_GLPROGRAMPARAMETER4DVNV)_getPrivateProcAddress("glProgramParameter4dvNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramParameter4dvNV;
    }
    _glProgramParameter4dvNV = _ptr;
    _glProgramParameter4dvNV(target, index, v);
}

PFN_GLPROGRAMPARAMETER4DVNV _glProgramParameter4dvNV = &_get_glProgramParameter4dvNV;

static void APIENTRY _fail_glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glProgramParameter4fNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    PFN_GLPROGRAMPARAMETER4FNV _ptr;
    _ptr = (PFN_GLPROGRAMPARAMETER4FNV)_getPrivateProcAddress("glProgramParameter4fNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramParameter4fNV;
    }
    _glProgramParameter4fNV = _ptr;
    _glProgramParameter4fNV(target, index, x, y, z, w);
}

PFN_GLPROGRAMPARAMETER4FNV _glProgramParameter4fNV = &_get_glProgramParameter4fNV;

static void APIENTRY _fail_glProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat * v) {
    const char *_name = "glProgramParameter4fvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat * v) {
    PFN_GLPROGRAMPARAMETER4FVNV _ptr;
    _ptr = (PFN_GLPROGRAMPARAMETER4FVNV)_getPrivateProcAddress("glProgramParameter4fvNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramParameter4fvNV;
    }
    _glProgramParameter4fvNV = _ptr;
    _glProgramParameter4fvNV(target, index, v);
}

PFN_GLPROGRAMPARAMETER4FVNV _glProgramParameter4fvNV = &_get_glProgramParameter4fvNV;

static void APIENTRY _fail_glProgramParameters4dvNV(GLenum target, GLuint index, GLsizei count, const GLdouble * v) {
    const char *_name = "glProgramParameters4dvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramParameters4dvNV(GLenum target, GLuint index, GLsizei count, const GLdouble * v) {
    PFN_GLPROGRAMPARAMETERS4DVNV _ptr;
    _ptr = (PFN_GLPROGRAMPARAMETERS4DVNV)_getPrivateProcAddress("glProgramParameters4dvNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramParameters4dvNV;
    }
    _glProgramParameters4dvNV = _ptr;
    _glProgramParameters4dvNV(target, index, count, v);
}

PFN_GLPROGRAMPARAMETERS4DVNV _glProgramParameters4dvNV = &_get_glProgramParameters4dvNV;

static void APIENTRY _fail_glProgramParameters4fvNV(GLenum target, GLuint index, GLsizei count, const GLfloat * v) {
    const char *_name = "glProgramParameters4fvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramParameters4fvNV(GLenum target, GLuint index, GLsizei count, const GLfloat * v) {
    PFN_GLPROGRAMPARAMETERS4FVNV _ptr;
    _ptr = (PFN_GLPROGRAMPARAMETERS4FVNV)_getPrivateProcAddress("glProgramParameters4fvNV");
    if (!_ptr) {
        _ptr = &_fail_glProgramParameters4fvNV;
    }
    _glProgramParameters4fvNV = _ptr;
    _glProgramParameters4fvNV(target, index, count, v);
}

PFN_GLPROGRAMPARAMETERS4FVNV _glProgramParameters4fvNV = &_get_glProgramParameters4fvNV;

static void APIENTRY _fail_glRequestResidentProgramsNV(GLsizei n, const GLuint * programs) {
    const char *_name = "glRequestResidentProgramsNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRequestResidentProgramsNV(GLsizei n, const GLuint * programs) {
    PFN_GLREQUESTRESIDENTPROGRAMSNV _ptr;
    _ptr = (PFN_GLREQUESTRESIDENTPROGRAMSNV)_getPrivateProcAddress("glRequestResidentProgramsNV");
    if (!_ptr) {
        _ptr = &_fail_glRequestResidentProgramsNV;
    }
    _glRequestResidentProgramsNV = _ptr;
    _glRequestResidentProgramsNV(n, programs);
}

PFN_GLREQUESTRESIDENTPROGRAMSNV _glRequestResidentProgramsNV = &_get_glRequestResidentProgramsNV;

static void APIENTRY _fail_glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform) {
    const char *_name = "glTrackMatrixNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform) {
    PFN_GLTRACKMATRIXNV _ptr;
    _ptr = (PFN_GLTRACKMATRIXNV)_getPrivateProcAddress("glTrackMatrixNV");
    if (!_ptr) {
        _ptr = &_fail_glTrackMatrixNV;
    }
    _glTrackMatrixNV = _ptr;
    _glTrackMatrixNV(target, address, matrix, transform);
}

PFN_GLTRACKMATRIXNV _glTrackMatrixNV = &_get_glTrackMatrixNV;

static void APIENTRY _fail_glVertexAttribPointerNV(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glVertexAttribPointerNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribPointerNV(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLVERTEXATTRIBPOINTERNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBPOINTERNV)_getPrivateProcAddress("glVertexAttribPointerNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribPointerNV;
    }
    _glVertexAttribPointerNV = _ptr;
    _glVertexAttribPointerNV(index, size, type, stride, pointer);
}

PFN_GLVERTEXATTRIBPOINTERNV _glVertexAttribPointerNV = &_get_glVertexAttribPointerNV;

static void APIENTRY _fail_glVertexAttrib1dNV(GLuint index, GLdouble x) {
    const char *_name = "glVertexAttrib1dNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1dNV(GLuint index, GLdouble x) {
    PFN_GLVERTEXATTRIB1DNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1DNV)_getPrivateProcAddress("glVertexAttrib1dNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1dNV;
    }
    _glVertexAttrib1dNV = _ptr;
    _glVertexAttrib1dNV(index, x);
}

PFN_GLVERTEXATTRIB1DNV _glVertexAttrib1dNV = &_get_glVertexAttrib1dNV;

static void APIENTRY _fail_glVertexAttrib1dvNV(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib1dvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1dvNV(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIB1DVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1DVNV)_getPrivateProcAddress("glVertexAttrib1dvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1dvNV;
    }
    _glVertexAttrib1dvNV = _ptr;
    _glVertexAttrib1dvNV(index, v);
}

PFN_GLVERTEXATTRIB1DVNV _glVertexAttrib1dvNV = &_get_glVertexAttrib1dvNV;

static void APIENTRY _fail_glVertexAttrib1fNV(GLuint index, GLfloat x) {
    const char *_name = "glVertexAttrib1fNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1fNV(GLuint index, GLfloat x) {
    PFN_GLVERTEXATTRIB1FNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1FNV)_getPrivateProcAddress("glVertexAttrib1fNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1fNV;
    }
    _glVertexAttrib1fNV = _ptr;
    _glVertexAttrib1fNV(index, x);
}

PFN_GLVERTEXATTRIB1FNV _glVertexAttrib1fNV = &_get_glVertexAttrib1fNV;

static void APIENTRY _fail_glVertexAttrib1fvNV(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib1fvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1fvNV(GLuint index, const GLfloat * v) {
    PFN_GLVERTEXATTRIB1FVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1FVNV)_getPrivateProcAddress("glVertexAttrib1fvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1fvNV;
    }
    _glVertexAttrib1fvNV = _ptr;
    _glVertexAttrib1fvNV(index, v);
}

PFN_GLVERTEXATTRIB1FVNV _glVertexAttrib1fvNV = &_get_glVertexAttrib1fvNV;

static void APIENTRY _fail_glVertexAttrib1sNV(GLuint index, GLshort x) {
    const char *_name = "glVertexAttrib1sNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1sNV(GLuint index, GLshort x) {
    PFN_GLVERTEXATTRIB1SNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1SNV)_getPrivateProcAddress("glVertexAttrib1sNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1sNV;
    }
    _glVertexAttrib1sNV = _ptr;
    _glVertexAttrib1sNV(index, x);
}

PFN_GLVERTEXATTRIB1SNV _glVertexAttrib1sNV = &_get_glVertexAttrib1sNV;

static void APIENTRY _fail_glVertexAttrib1svNV(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib1svNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib1svNV(GLuint index, const GLshort * v) {
    PFN_GLVERTEXATTRIB1SVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB1SVNV)_getPrivateProcAddress("glVertexAttrib1svNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib1svNV;
    }
    _glVertexAttrib1svNV = _ptr;
    _glVertexAttrib1svNV(index, v);
}

PFN_GLVERTEXATTRIB1SVNV _glVertexAttrib1svNV = &_get_glVertexAttrib1svNV;

static void APIENTRY _fail_glVertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y) {
    const char *_name = "glVertexAttrib2dNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y) {
    PFN_GLVERTEXATTRIB2DNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2DNV)_getPrivateProcAddress("glVertexAttrib2dNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2dNV;
    }
    _glVertexAttrib2dNV = _ptr;
    _glVertexAttrib2dNV(index, x, y);
}

PFN_GLVERTEXATTRIB2DNV _glVertexAttrib2dNV = &_get_glVertexAttrib2dNV;

static void APIENTRY _fail_glVertexAttrib2dvNV(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib2dvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2dvNV(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIB2DVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2DVNV)_getPrivateProcAddress("glVertexAttrib2dvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2dvNV;
    }
    _glVertexAttrib2dvNV = _ptr;
    _glVertexAttrib2dvNV(index, v);
}

PFN_GLVERTEXATTRIB2DVNV _glVertexAttrib2dvNV = &_get_glVertexAttrib2dvNV;

static void APIENTRY _fail_glVertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y) {
    const char *_name = "glVertexAttrib2fNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y) {
    PFN_GLVERTEXATTRIB2FNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2FNV)_getPrivateProcAddress("glVertexAttrib2fNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2fNV;
    }
    _glVertexAttrib2fNV = _ptr;
    _glVertexAttrib2fNV(index, x, y);
}

PFN_GLVERTEXATTRIB2FNV _glVertexAttrib2fNV = &_get_glVertexAttrib2fNV;

static void APIENTRY _fail_glVertexAttrib2fvNV(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib2fvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2fvNV(GLuint index, const GLfloat * v) {
    PFN_GLVERTEXATTRIB2FVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2FVNV)_getPrivateProcAddress("glVertexAttrib2fvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2fvNV;
    }
    _glVertexAttrib2fvNV = _ptr;
    _glVertexAttrib2fvNV(index, v);
}

PFN_GLVERTEXATTRIB2FVNV _glVertexAttrib2fvNV = &_get_glVertexAttrib2fvNV;

static void APIENTRY _fail_glVertexAttrib2sNV(GLuint index, GLshort x, GLshort y) {
    const char *_name = "glVertexAttrib2sNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2sNV(GLuint index, GLshort x, GLshort y) {
    PFN_GLVERTEXATTRIB2SNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2SNV)_getPrivateProcAddress("glVertexAttrib2sNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2sNV;
    }
    _glVertexAttrib2sNV = _ptr;
    _glVertexAttrib2sNV(index, x, y);
}

PFN_GLVERTEXATTRIB2SNV _glVertexAttrib2sNV = &_get_glVertexAttrib2sNV;

static void APIENTRY _fail_glVertexAttrib2svNV(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib2svNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib2svNV(GLuint index, const GLshort * v) {
    PFN_GLVERTEXATTRIB2SVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB2SVNV)_getPrivateProcAddress("glVertexAttrib2svNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib2svNV;
    }
    _glVertexAttrib2svNV = _ptr;
    _glVertexAttrib2svNV(index, v);
}

PFN_GLVERTEXATTRIB2SVNV _glVertexAttrib2svNV = &_get_glVertexAttrib2svNV;

static void APIENTRY _fail_glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
    const char *_name = "glVertexAttrib3dNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
    PFN_GLVERTEXATTRIB3DNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3DNV)_getPrivateProcAddress("glVertexAttrib3dNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3dNV;
    }
    _glVertexAttrib3dNV = _ptr;
    _glVertexAttrib3dNV(index, x, y, z);
}

PFN_GLVERTEXATTRIB3DNV _glVertexAttrib3dNV = &_get_glVertexAttrib3dNV;

static void APIENTRY _fail_glVertexAttrib3dvNV(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib3dvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3dvNV(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIB3DVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3DVNV)_getPrivateProcAddress("glVertexAttrib3dvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3dvNV;
    }
    _glVertexAttrib3dvNV = _ptr;
    _glVertexAttrib3dvNV(index, v);
}

PFN_GLVERTEXATTRIB3DVNV _glVertexAttrib3dvNV = &_get_glVertexAttrib3dvNV;

static void APIENTRY _fail_glVertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glVertexAttrib3fNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLVERTEXATTRIB3FNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3FNV)_getPrivateProcAddress("glVertexAttrib3fNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3fNV;
    }
    _glVertexAttrib3fNV = _ptr;
    _glVertexAttrib3fNV(index, x, y, z);
}

PFN_GLVERTEXATTRIB3FNV _glVertexAttrib3fNV = &_get_glVertexAttrib3fNV;

static void APIENTRY _fail_glVertexAttrib3fvNV(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib3fvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3fvNV(GLuint index, const GLfloat * v) {
    PFN_GLVERTEXATTRIB3FVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3FVNV)_getPrivateProcAddress("glVertexAttrib3fvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3fvNV;
    }
    _glVertexAttrib3fvNV = _ptr;
    _glVertexAttrib3fvNV(index, v);
}

PFN_GLVERTEXATTRIB3FVNV _glVertexAttrib3fvNV = &_get_glVertexAttrib3fvNV;

static void APIENTRY _fail_glVertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z) {
    const char *_name = "glVertexAttrib3sNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z) {
    PFN_GLVERTEXATTRIB3SNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3SNV)_getPrivateProcAddress("glVertexAttrib3sNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3sNV;
    }
    _glVertexAttrib3sNV = _ptr;
    _glVertexAttrib3sNV(index, x, y, z);
}

PFN_GLVERTEXATTRIB3SNV _glVertexAttrib3sNV = &_get_glVertexAttrib3sNV;

static void APIENTRY _fail_glVertexAttrib3svNV(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib3svNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib3svNV(GLuint index, const GLshort * v) {
    PFN_GLVERTEXATTRIB3SVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB3SVNV)_getPrivateProcAddress("glVertexAttrib3svNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib3svNV;
    }
    _glVertexAttrib3svNV = _ptr;
    _glVertexAttrib3svNV(index, v);
}

PFN_GLVERTEXATTRIB3SVNV _glVertexAttrib3svNV = &_get_glVertexAttrib3svNV;

static void APIENTRY _fail_glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    const char *_name = "glVertexAttrib4dNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    PFN_GLVERTEXATTRIB4DNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4DNV)_getPrivateProcAddress("glVertexAttrib4dNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4dNV;
    }
    _glVertexAttrib4dNV = _ptr;
    _glVertexAttrib4dNV(index, x, y, z, w);
}

PFN_GLVERTEXATTRIB4DNV _glVertexAttrib4dNV = &_get_glVertexAttrib4dNV;

static void APIENTRY _fail_glVertexAttrib4dvNV(GLuint index, const GLdouble * v) {
    const char *_name = "glVertexAttrib4dvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4dvNV(GLuint index, const GLdouble * v) {
    PFN_GLVERTEXATTRIB4DVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4DVNV)_getPrivateProcAddress("glVertexAttrib4dvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4dvNV;
    }
    _glVertexAttrib4dvNV = _ptr;
    _glVertexAttrib4dvNV(index, v);
}

PFN_GLVERTEXATTRIB4DVNV _glVertexAttrib4dvNV = &_get_glVertexAttrib4dvNV;

static void APIENTRY _fail_glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glVertexAttrib4fNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    PFN_GLVERTEXATTRIB4FNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4FNV)_getPrivateProcAddress("glVertexAttrib4fNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4fNV;
    }
    _glVertexAttrib4fNV = _ptr;
    _glVertexAttrib4fNV(index, x, y, z, w);
}

PFN_GLVERTEXATTRIB4FNV _glVertexAttrib4fNV = &_get_glVertexAttrib4fNV;

static void APIENTRY _fail_glVertexAttrib4fvNV(GLuint index, const GLfloat * v) {
    const char *_name = "glVertexAttrib4fvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4fvNV(GLuint index, const GLfloat * v) {
    PFN_GLVERTEXATTRIB4FVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4FVNV)_getPrivateProcAddress("glVertexAttrib4fvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4fvNV;
    }
    _glVertexAttrib4fvNV = _ptr;
    _glVertexAttrib4fvNV(index, v);
}

PFN_GLVERTEXATTRIB4FVNV _glVertexAttrib4fvNV = &_get_glVertexAttrib4fvNV;

static void APIENTRY _fail_glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) {
    const char *_name = "glVertexAttrib4sNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) {
    PFN_GLVERTEXATTRIB4SNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4SNV)_getPrivateProcAddress("glVertexAttrib4sNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4sNV;
    }
    _glVertexAttrib4sNV = _ptr;
    _glVertexAttrib4sNV(index, x, y, z, w);
}

PFN_GLVERTEXATTRIB4SNV _glVertexAttrib4sNV = &_get_glVertexAttrib4sNV;

static void APIENTRY _fail_glVertexAttrib4svNV(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttrib4svNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4svNV(GLuint index, const GLshort * v) {
    PFN_GLVERTEXATTRIB4SVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4SVNV)_getPrivateProcAddress("glVertexAttrib4svNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4svNV;
    }
    _glVertexAttrib4svNV = _ptr;
    _glVertexAttrib4svNV(index, v);
}

PFN_GLVERTEXATTRIB4SVNV _glVertexAttrib4svNV = &_get_glVertexAttrib4svNV;

static void APIENTRY _fail_glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) {
    const char *_name = "glVertexAttrib4ubNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) {
    PFN_GLVERTEXATTRIB4UBNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4UBNV)_getPrivateProcAddress("glVertexAttrib4ubNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4ubNV;
    }
    _glVertexAttrib4ubNV = _ptr;
    _glVertexAttrib4ubNV(index, x, y, z, w);
}

PFN_GLVERTEXATTRIB4UBNV _glVertexAttrib4ubNV = &_get_glVertexAttrib4ubNV;

static void APIENTRY _fail_glVertexAttrib4ubvNV(GLuint index, const GLubyte * v) {
    const char *_name = "glVertexAttrib4ubvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttrib4ubvNV(GLuint index, const GLubyte * v) {
    PFN_GLVERTEXATTRIB4UBVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIB4UBVNV)_getPrivateProcAddress("glVertexAttrib4ubvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttrib4ubvNV;
    }
    _glVertexAttrib4ubvNV = _ptr;
    _glVertexAttrib4ubvNV(index, v);
}

PFN_GLVERTEXATTRIB4UBVNV _glVertexAttrib4ubvNV = &_get_glVertexAttrib4ubvNV;

static void APIENTRY _fail_glVertexAttribs1dvNV(GLuint index, GLsizei count, const GLdouble * v) {
    const char *_name = "glVertexAttribs1dvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribs1dvNV(GLuint index, GLsizei count, const GLdouble * v) {
    PFN_GLVERTEXATTRIBS1DVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBS1DVNV)_getPrivateProcAddress("glVertexAttribs1dvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribs1dvNV;
    }
    _glVertexAttribs1dvNV = _ptr;
    _glVertexAttribs1dvNV(index, count, v);
}

PFN_GLVERTEXATTRIBS1DVNV _glVertexAttribs1dvNV = &_get_glVertexAttribs1dvNV;

static void APIENTRY _fail_glVertexAttribs1fvNV(GLuint index, GLsizei count, const GLfloat * v) {
    const char *_name = "glVertexAttribs1fvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribs1fvNV(GLuint index, GLsizei count, const GLfloat * v) {
    PFN_GLVERTEXATTRIBS1FVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBS1FVNV)_getPrivateProcAddress("glVertexAttribs1fvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribs1fvNV;
    }
    _glVertexAttribs1fvNV = _ptr;
    _glVertexAttribs1fvNV(index, count, v);
}

PFN_GLVERTEXATTRIBS1FVNV _glVertexAttribs1fvNV = &_get_glVertexAttribs1fvNV;

static void APIENTRY _fail_glVertexAttribs1svNV(GLuint index, GLsizei count, const GLshort * v) {
    const char *_name = "glVertexAttribs1svNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribs1svNV(GLuint index, GLsizei count, const GLshort * v) {
    PFN_GLVERTEXATTRIBS1SVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBS1SVNV)_getPrivateProcAddress("glVertexAttribs1svNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribs1svNV;
    }
    _glVertexAttribs1svNV = _ptr;
    _glVertexAttribs1svNV(index, count, v);
}

PFN_GLVERTEXATTRIBS1SVNV _glVertexAttribs1svNV = &_get_glVertexAttribs1svNV;

static void APIENTRY _fail_glVertexAttribs2dvNV(GLuint index, GLsizei count, const GLdouble * v) {
    const char *_name = "glVertexAttribs2dvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribs2dvNV(GLuint index, GLsizei count, const GLdouble * v) {
    PFN_GLVERTEXATTRIBS2DVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBS2DVNV)_getPrivateProcAddress("glVertexAttribs2dvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribs2dvNV;
    }
    _glVertexAttribs2dvNV = _ptr;
    _glVertexAttribs2dvNV(index, count, v);
}

PFN_GLVERTEXATTRIBS2DVNV _glVertexAttribs2dvNV = &_get_glVertexAttribs2dvNV;

static void APIENTRY _fail_glVertexAttribs2fvNV(GLuint index, GLsizei count, const GLfloat * v) {
    const char *_name = "glVertexAttribs2fvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribs2fvNV(GLuint index, GLsizei count, const GLfloat * v) {
    PFN_GLVERTEXATTRIBS2FVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBS2FVNV)_getPrivateProcAddress("glVertexAttribs2fvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribs2fvNV;
    }
    _glVertexAttribs2fvNV = _ptr;
    _glVertexAttribs2fvNV(index, count, v);
}

PFN_GLVERTEXATTRIBS2FVNV _glVertexAttribs2fvNV = &_get_glVertexAttribs2fvNV;

static void APIENTRY _fail_glVertexAttribs2svNV(GLuint index, GLsizei count, const GLshort * v) {
    const char *_name = "glVertexAttribs2svNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribs2svNV(GLuint index, GLsizei count, const GLshort * v) {
    PFN_GLVERTEXATTRIBS2SVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBS2SVNV)_getPrivateProcAddress("glVertexAttribs2svNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribs2svNV;
    }
    _glVertexAttribs2svNV = _ptr;
    _glVertexAttribs2svNV(index, count, v);
}

PFN_GLVERTEXATTRIBS2SVNV _glVertexAttribs2svNV = &_get_glVertexAttribs2svNV;

static void APIENTRY _fail_glVertexAttribs3dvNV(GLuint index, GLsizei count, const GLdouble * v) {
    const char *_name = "glVertexAttribs3dvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribs3dvNV(GLuint index, GLsizei count, const GLdouble * v) {
    PFN_GLVERTEXATTRIBS3DVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBS3DVNV)_getPrivateProcAddress("glVertexAttribs3dvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribs3dvNV;
    }
    _glVertexAttribs3dvNV = _ptr;
    _glVertexAttribs3dvNV(index, count, v);
}

PFN_GLVERTEXATTRIBS3DVNV _glVertexAttribs3dvNV = &_get_glVertexAttribs3dvNV;

static void APIENTRY _fail_glVertexAttribs3fvNV(GLuint index, GLsizei count, const GLfloat * v) {
    const char *_name = "glVertexAttribs3fvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribs3fvNV(GLuint index, GLsizei count, const GLfloat * v) {
    PFN_GLVERTEXATTRIBS3FVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBS3FVNV)_getPrivateProcAddress("glVertexAttribs3fvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribs3fvNV;
    }
    _glVertexAttribs3fvNV = _ptr;
    _glVertexAttribs3fvNV(index, count, v);
}

PFN_GLVERTEXATTRIBS3FVNV _glVertexAttribs3fvNV = &_get_glVertexAttribs3fvNV;

static void APIENTRY _fail_glVertexAttribs3svNV(GLuint index, GLsizei count, const GLshort * v) {
    const char *_name = "glVertexAttribs3svNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribs3svNV(GLuint index, GLsizei count, const GLshort * v) {
    PFN_GLVERTEXATTRIBS3SVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBS3SVNV)_getPrivateProcAddress("glVertexAttribs3svNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribs3svNV;
    }
    _glVertexAttribs3svNV = _ptr;
    _glVertexAttribs3svNV(index, count, v);
}

PFN_GLVERTEXATTRIBS3SVNV _glVertexAttribs3svNV = &_get_glVertexAttribs3svNV;

static void APIENTRY _fail_glVertexAttribs4dvNV(GLuint index, GLsizei count, const GLdouble * v) {
    const char *_name = "glVertexAttribs4dvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribs4dvNV(GLuint index, GLsizei count, const GLdouble * v) {
    PFN_GLVERTEXATTRIBS4DVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBS4DVNV)_getPrivateProcAddress("glVertexAttribs4dvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribs4dvNV;
    }
    _glVertexAttribs4dvNV = _ptr;
    _glVertexAttribs4dvNV(index, count, v);
}

PFN_GLVERTEXATTRIBS4DVNV _glVertexAttribs4dvNV = &_get_glVertexAttribs4dvNV;

static void APIENTRY _fail_glVertexAttribs4fvNV(GLuint index, GLsizei count, const GLfloat * v) {
    const char *_name = "glVertexAttribs4fvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribs4fvNV(GLuint index, GLsizei count, const GLfloat * v) {
    PFN_GLVERTEXATTRIBS4FVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBS4FVNV)_getPrivateProcAddress("glVertexAttribs4fvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribs4fvNV;
    }
    _glVertexAttribs4fvNV = _ptr;
    _glVertexAttribs4fvNV(index, count, v);
}

PFN_GLVERTEXATTRIBS4FVNV _glVertexAttribs4fvNV = &_get_glVertexAttribs4fvNV;

static void APIENTRY _fail_glVertexAttribs4svNV(GLuint index, GLsizei count, const GLshort * v) {
    const char *_name = "glVertexAttribs4svNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribs4svNV(GLuint index, GLsizei count, const GLshort * v) {
    PFN_GLVERTEXATTRIBS4SVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBS4SVNV)_getPrivateProcAddress("glVertexAttribs4svNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribs4svNV;
    }
    _glVertexAttribs4svNV = _ptr;
    _glVertexAttribs4svNV(index, count, v);
}

PFN_GLVERTEXATTRIBS4SVNV _glVertexAttribs4svNV = &_get_glVertexAttribs4svNV;

static void APIENTRY _fail_glVertexAttribs4ubvNV(GLuint index, GLsizei count, const GLubyte * v) {
    const char *_name = "glVertexAttribs4ubvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribs4ubvNV(GLuint index, GLsizei count, const GLubyte * v) {
    PFN_GLVERTEXATTRIBS4UBVNV _ptr;
    _ptr = (PFN_GLVERTEXATTRIBS4UBVNV)_getPrivateProcAddress("glVertexAttribs4ubvNV");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribs4ubvNV;
    }
    _glVertexAttribs4ubvNV = _ptr;
    _glVertexAttribs4ubvNV(index, count, v);
}

PFN_GLVERTEXATTRIBS4UBVNV _glVertexAttribs4ubvNV = &_get_glVertexAttribs4ubvNV;

static void APIENTRY _fail_glVertexAttribI1iEXT(GLuint index, GLint x) {
    const char *_name = "glVertexAttribI1iEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI1iEXT(GLuint index, GLint x) {
    PFN_GLVERTEXATTRIBI1IEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI1IEXT)_getPrivateProcAddress("glVertexAttribI1iEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI1iEXT;
    }
    _glVertexAttribI1iEXT = _ptr;
    _glVertexAttribI1iEXT(index, x);
}

PFN_GLVERTEXATTRIBI1IEXT _glVertexAttribI1iEXT = &_get_glVertexAttribI1iEXT;

static void APIENTRY _fail_glVertexAttribI2iEXT(GLuint index, GLint x, GLint y) {
    const char *_name = "glVertexAttribI2iEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI2iEXT(GLuint index, GLint x, GLint y) {
    PFN_GLVERTEXATTRIBI2IEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI2IEXT)_getPrivateProcAddress("glVertexAttribI2iEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI2iEXT;
    }
    _glVertexAttribI2iEXT = _ptr;
    _glVertexAttribI2iEXT(index, x, y);
}

PFN_GLVERTEXATTRIBI2IEXT _glVertexAttribI2iEXT = &_get_glVertexAttribI2iEXT;

static void APIENTRY _fail_glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z) {
    const char *_name = "glVertexAttribI3iEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z) {
    PFN_GLVERTEXATTRIBI3IEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI3IEXT)_getPrivateProcAddress("glVertexAttribI3iEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI3iEXT;
    }
    _glVertexAttribI3iEXT = _ptr;
    _glVertexAttribI3iEXT(index, x, y, z);
}

PFN_GLVERTEXATTRIBI3IEXT _glVertexAttribI3iEXT = &_get_glVertexAttribI3iEXT;

static void APIENTRY _fail_glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w) {
    const char *_name = "glVertexAttribI4iEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w) {
    PFN_GLVERTEXATTRIBI4IEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI4IEXT)_getPrivateProcAddress("glVertexAttribI4iEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI4iEXT;
    }
    _glVertexAttribI4iEXT = _ptr;
    _glVertexAttribI4iEXT(index, x, y, z, w);
}

PFN_GLVERTEXATTRIBI4IEXT _glVertexAttribI4iEXT = &_get_glVertexAttribI4iEXT;

static void APIENTRY _fail_glVertexAttribI1uiEXT(GLuint index, GLuint x) {
    const char *_name = "glVertexAttribI1uiEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI1uiEXT(GLuint index, GLuint x) {
    PFN_GLVERTEXATTRIBI1UIEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI1UIEXT)_getPrivateProcAddress("glVertexAttribI1uiEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI1uiEXT;
    }
    _glVertexAttribI1uiEXT = _ptr;
    _glVertexAttribI1uiEXT(index, x);
}

PFN_GLVERTEXATTRIBI1UIEXT _glVertexAttribI1uiEXT = &_get_glVertexAttribI1uiEXT;

static void APIENTRY _fail_glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y) {
    const char *_name = "glVertexAttribI2uiEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y) {
    PFN_GLVERTEXATTRIBI2UIEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI2UIEXT)_getPrivateProcAddress("glVertexAttribI2uiEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI2uiEXT;
    }
    _glVertexAttribI2uiEXT = _ptr;
    _glVertexAttribI2uiEXT(index, x, y);
}

PFN_GLVERTEXATTRIBI2UIEXT _glVertexAttribI2uiEXT = &_get_glVertexAttribI2uiEXT;

static void APIENTRY _fail_glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z) {
    const char *_name = "glVertexAttribI3uiEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z) {
    PFN_GLVERTEXATTRIBI3UIEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI3UIEXT)_getPrivateProcAddress("glVertexAttribI3uiEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI3uiEXT;
    }
    _glVertexAttribI3uiEXT = _ptr;
    _glVertexAttribI3uiEXT(index, x, y, z);
}

PFN_GLVERTEXATTRIBI3UIEXT _glVertexAttribI3uiEXT = &_get_glVertexAttribI3uiEXT;

static void APIENTRY _fail_glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
    const char *_name = "glVertexAttribI4uiEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
    PFN_GLVERTEXATTRIBI4UIEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI4UIEXT)_getPrivateProcAddress("glVertexAttribI4uiEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI4uiEXT;
    }
    _glVertexAttribI4uiEXT = _ptr;
    _glVertexAttribI4uiEXT(index, x, y, z, w);
}

PFN_GLVERTEXATTRIBI4UIEXT _glVertexAttribI4uiEXT = &_get_glVertexAttribI4uiEXT;

static void APIENTRY _fail_glVertexAttribI1ivEXT(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttribI1ivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI1ivEXT(GLuint index, const GLint * v) {
    PFN_GLVERTEXATTRIBI1IVEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI1IVEXT)_getPrivateProcAddress("glVertexAttribI1ivEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI1ivEXT;
    }
    _glVertexAttribI1ivEXT = _ptr;
    _glVertexAttribI1ivEXT(index, v);
}

PFN_GLVERTEXATTRIBI1IVEXT _glVertexAttribI1ivEXT = &_get_glVertexAttribI1ivEXT;

static void APIENTRY _fail_glVertexAttribI2ivEXT(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttribI2ivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI2ivEXT(GLuint index, const GLint * v) {
    PFN_GLVERTEXATTRIBI2IVEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI2IVEXT)_getPrivateProcAddress("glVertexAttribI2ivEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI2ivEXT;
    }
    _glVertexAttribI2ivEXT = _ptr;
    _glVertexAttribI2ivEXT(index, v);
}

PFN_GLVERTEXATTRIBI2IVEXT _glVertexAttribI2ivEXT = &_get_glVertexAttribI2ivEXT;

static void APIENTRY _fail_glVertexAttribI3ivEXT(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttribI3ivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI3ivEXT(GLuint index, const GLint * v) {
    PFN_GLVERTEXATTRIBI3IVEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI3IVEXT)_getPrivateProcAddress("glVertexAttribI3ivEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI3ivEXT;
    }
    _glVertexAttribI3ivEXT = _ptr;
    _glVertexAttribI3ivEXT(index, v);
}

PFN_GLVERTEXATTRIBI3IVEXT _glVertexAttribI3ivEXT = &_get_glVertexAttribI3ivEXT;

static void APIENTRY _fail_glVertexAttribI4ivEXT(GLuint index, const GLint * v) {
    const char *_name = "glVertexAttribI4ivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI4ivEXT(GLuint index, const GLint * v) {
    PFN_GLVERTEXATTRIBI4IVEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI4IVEXT)_getPrivateProcAddress("glVertexAttribI4ivEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI4ivEXT;
    }
    _glVertexAttribI4ivEXT = _ptr;
    _glVertexAttribI4ivEXT(index, v);
}

PFN_GLVERTEXATTRIBI4IVEXT _glVertexAttribI4ivEXT = &_get_glVertexAttribI4ivEXT;

static void APIENTRY _fail_glVertexAttribI1uivEXT(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttribI1uivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI1uivEXT(GLuint index, const GLuint * v) {
    PFN_GLVERTEXATTRIBI1UIVEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI1UIVEXT)_getPrivateProcAddress("glVertexAttribI1uivEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI1uivEXT;
    }
    _glVertexAttribI1uivEXT = _ptr;
    _glVertexAttribI1uivEXT(index, v);
}

PFN_GLVERTEXATTRIBI1UIVEXT _glVertexAttribI1uivEXT = &_get_glVertexAttribI1uivEXT;

static void APIENTRY _fail_glVertexAttribI2uivEXT(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttribI2uivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI2uivEXT(GLuint index, const GLuint * v) {
    PFN_GLVERTEXATTRIBI2UIVEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI2UIVEXT)_getPrivateProcAddress("glVertexAttribI2uivEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI2uivEXT;
    }
    _glVertexAttribI2uivEXT = _ptr;
    _glVertexAttribI2uivEXT(index, v);
}

PFN_GLVERTEXATTRIBI2UIVEXT _glVertexAttribI2uivEXT = &_get_glVertexAttribI2uivEXT;

static void APIENTRY _fail_glVertexAttribI3uivEXT(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttribI3uivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI3uivEXT(GLuint index, const GLuint * v) {
    PFN_GLVERTEXATTRIBI3UIVEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI3UIVEXT)_getPrivateProcAddress("glVertexAttribI3uivEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI3uivEXT;
    }
    _glVertexAttribI3uivEXT = _ptr;
    _glVertexAttribI3uivEXT(index, v);
}

PFN_GLVERTEXATTRIBI3UIVEXT _glVertexAttribI3uivEXT = &_get_glVertexAttribI3uivEXT;

static void APIENTRY _fail_glVertexAttribI4uivEXT(GLuint index, const GLuint * v) {
    const char *_name = "glVertexAttribI4uivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI4uivEXT(GLuint index, const GLuint * v) {
    PFN_GLVERTEXATTRIBI4UIVEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI4UIVEXT)_getPrivateProcAddress("glVertexAttribI4uivEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI4uivEXT;
    }
    _glVertexAttribI4uivEXT = _ptr;
    _glVertexAttribI4uivEXT(index, v);
}

PFN_GLVERTEXATTRIBI4UIVEXT _glVertexAttribI4uivEXT = &_get_glVertexAttribI4uivEXT;

static void APIENTRY _fail_glVertexAttribI4bvEXT(GLuint index, const GLbyte * v) {
    const char *_name = "glVertexAttribI4bvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI4bvEXT(GLuint index, const GLbyte * v) {
    PFN_GLVERTEXATTRIBI4BVEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI4BVEXT)_getPrivateProcAddress("glVertexAttribI4bvEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI4bvEXT;
    }
    _glVertexAttribI4bvEXT = _ptr;
    _glVertexAttribI4bvEXT(index, v);
}

PFN_GLVERTEXATTRIBI4BVEXT _glVertexAttribI4bvEXT = &_get_glVertexAttribI4bvEXT;

static void APIENTRY _fail_glVertexAttribI4svEXT(GLuint index, const GLshort * v) {
    const char *_name = "glVertexAttribI4svEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI4svEXT(GLuint index, const GLshort * v) {
    PFN_GLVERTEXATTRIBI4SVEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI4SVEXT)_getPrivateProcAddress("glVertexAttribI4svEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI4svEXT;
    }
    _glVertexAttribI4svEXT = _ptr;
    _glVertexAttribI4svEXT(index, v);
}

PFN_GLVERTEXATTRIBI4SVEXT _glVertexAttribI4svEXT = &_get_glVertexAttribI4svEXT;

static void APIENTRY _fail_glVertexAttribI4ubvEXT(GLuint index, const GLubyte * v) {
    const char *_name = "glVertexAttribI4ubvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI4ubvEXT(GLuint index, const GLubyte * v) {
    PFN_GLVERTEXATTRIBI4UBVEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI4UBVEXT)_getPrivateProcAddress("glVertexAttribI4ubvEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI4ubvEXT;
    }
    _glVertexAttribI4ubvEXT = _ptr;
    _glVertexAttribI4ubvEXT(index, v);
}

PFN_GLVERTEXATTRIBI4UBVEXT _glVertexAttribI4ubvEXT = &_get_glVertexAttribI4ubvEXT;

static void APIENTRY _fail_glVertexAttribI4usvEXT(GLuint index, const GLushort * v) {
    const char *_name = "glVertexAttribI4usvEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribI4usvEXT(GLuint index, const GLushort * v) {
    PFN_GLVERTEXATTRIBI4USVEXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBI4USVEXT)_getPrivateProcAddress("glVertexAttribI4usvEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribI4usvEXT;
    }
    _glVertexAttribI4usvEXT = _ptr;
    _glVertexAttribI4usvEXT(index, v);
}

PFN_GLVERTEXATTRIBI4USVEXT _glVertexAttribI4usvEXT = &_get_glVertexAttribI4usvEXT;

static void APIENTRY _fail_glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glVertexAttribIPointerEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLVERTEXATTRIBIPOINTEREXT _ptr;
    _ptr = (PFN_GLVERTEXATTRIBIPOINTEREXT)_getPrivateProcAddress("glVertexAttribIPointerEXT");
    if (!_ptr) {
        _ptr = &_fail_glVertexAttribIPointerEXT;
    }
    _glVertexAttribIPointerEXT = _ptr;
    _glVertexAttribIPointerEXT(index, size, type, stride, pointer);
}

PFN_GLVERTEXATTRIBIPOINTEREXT _glVertexAttribIPointerEXT = &_get_glVertexAttribIPointerEXT;

static void APIENTRY _fail_glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint * params) {
    const char *_name = "glGetVertexAttribIivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint * params) {
    PFN_GLGETVERTEXATTRIBIIVEXT _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBIIVEXT)_getPrivateProcAddress("glGetVertexAttribIivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribIivEXT;
    }
    _glGetVertexAttribIivEXT = _ptr;
    _glGetVertexAttribIivEXT(index, pname, params);
}

PFN_GLGETVERTEXATTRIBIIVEXT _glGetVertexAttribIivEXT = &_get_glGetVertexAttribIivEXT;

static void APIENTRY _fail_glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint * params) {
    const char *_name = "glGetVertexAttribIuivEXT";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint * params) {
    PFN_GLGETVERTEXATTRIBIUIVEXT _ptr;
    _ptr = (PFN_GLGETVERTEXATTRIBIUIVEXT)_getPrivateProcAddress("glGetVertexAttribIuivEXT");
    if (!_ptr) {
        _ptr = &_fail_glGetVertexAttribIuivEXT;
    }
    _glGetVertexAttribIuivEXT = _ptr;
    _glGetVertexAttribIuivEXT(index, pname, params);
}

PFN_GLGETVERTEXATTRIBIUIVEXT _glGetVertexAttribIuivEXT = &_get_glGetVertexAttribIuivEXT;

static void APIENTRY _fail_glBeginVideoCaptureNV(GLuint video_capture_slot) {
    const char *_name = "glBeginVideoCaptureNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBeginVideoCaptureNV(GLuint video_capture_slot) {
    PFN_GLBEGINVIDEOCAPTURENV _ptr;
    _ptr = (PFN_GLBEGINVIDEOCAPTURENV)_getPrivateProcAddress("glBeginVideoCaptureNV");
    if (!_ptr) {
        _ptr = &_fail_glBeginVideoCaptureNV;
    }
    _glBeginVideoCaptureNV = _ptr;
    _glBeginVideoCaptureNV(video_capture_slot);
}

PFN_GLBEGINVIDEOCAPTURENV _glBeginVideoCaptureNV = &_get_glBeginVideoCaptureNV;

static void APIENTRY _fail_glBindVideoCaptureStreamBufferNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset) {
    const char *_name = "glBindVideoCaptureStreamBufferNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindVideoCaptureStreamBufferNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset) {
    PFN_GLBINDVIDEOCAPTURESTREAMBUFFERNV _ptr;
    _ptr = (PFN_GLBINDVIDEOCAPTURESTREAMBUFFERNV)_getPrivateProcAddress("glBindVideoCaptureStreamBufferNV");
    if (!_ptr) {
        _ptr = &_fail_glBindVideoCaptureStreamBufferNV;
    }
    _glBindVideoCaptureStreamBufferNV = _ptr;
    _glBindVideoCaptureStreamBufferNV(video_capture_slot, stream, frame_region, offset);
}

PFN_GLBINDVIDEOCAPTURESTREAMBUFFERNV _glBindVideoCaptureStreamBufferNV = &_get_glBindVideoCaptureStreamBufferNV;

static void APIENTRY _fail_glBindVideoCaptureStreamTextureNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture) {
    const char *_name = "glBindVideoCaptureStreamTextureNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindVideoCaptureStreamTextureNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture) {
    PFN_GLBINDVIDEOCAPTURESTREAMTEXTURENV _ptr;
    _ptr = (PFN_GLBINDVIDEOCAPTURESTREAMTEXTURENV)_getPrivateProcAddress("glBindVideoCaptureStreamTextureNV");
    if (!_ptr) {
        _ptr = &_fail_glBindVideoCaptureStreamTextureNV;
    }
    _glBindVideoCaptureStreamTextureNV = _ptr;
    _glBindVideoCaptureStreamTextureNV(video_capture_slot, stream, frame_region, target, texture);
}

PFN_GLBINDVIDEOCAPTURESTREAMTEXTURENV _glBindVideoCaptureStreamTextureNV = &_get_glBindVideoCaptureStreamTextureNV;

static void APIENTRY _fail_glEndVideoCaptureNV(GLuint video_capture_slot) {
    const char *_name = "glEndVideoCaptureNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glEndVideoCaptureNV(GLuint video_capture_slot) {
    PFN_GLENDVIDEOCAPTURENV _ptr;
    _ptr = (PFN_GLENDVIDEOCAPTURENV)_getPrivateProcAddress("glEndVideoCaptureNV");
    if (!_ptr) {
        _ptr = &_fail_glEndVideoCaptureNV;
    }
    _glEndVideoCaptureNV = _ptr;
    _glEndVideoCaptureNV(video_capture_slot);
}

PFN_GLENDVIDEOCAPTURENV _glEndVideoCaptureNV = &_get_glEndVideoCaptureNV;

static void APIENTRY _fail_glGetVideoCaptureivNV(GLuint video_capture_slot, GLenum pname, GLint * params) {
    const char *_name = "glGetVideoCaptureivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVideoCaptureivNV(GLuint video_capture_slot, GLenum pname, GLint * params) {
    PFN_GLGETVIDEOCAPTUREIVNV _ptr;
    _ptr = (PFN_GLGETVIDEOCAPTUREIVNV)_getPrivateProcAddress("glGetVideoCaptureivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetVideoCaptureivNV;
    }
    _glGetVideoCaptureivNV = _ptr;
    _glGetVideoCaptureivNV(video_capture_slot, pname, params);
}

PFN_GLGETVIDEOCAPTUREIVNV _glGetVideoCaptureivNV = &_get_glGetVideoCaptureivNV;

static void APIENTRY _fail_glGetVideoCaptureStreamivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint * params) {
    const char *_name = "glGetVideoCaptureStreamivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVideoCaptureStreamivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint * params) {
    PFN_GLGETVIDEOCAPTURESTREAMIVNV _ptr;
    _ptr = (PFN_GLGETVIDEOCAPTURESTREAMIVNV)_getPrivateProcAddress("glGetVideoCaptureStreamivNV");
    if (!_ptr) {
        _ptr = &_fail_glGetVideoCaptureStreamivNV;
    }
    _glGetVideoCaptureStreamivNV = _ptr;
    _glGetVideoCaptureStreamivNV(video_capture_slot, stream, pname, params);
}

PFN_GLGETVIDEOCAPTURESTREAMIVNV _glGetVideoCaptureStreamivNV = &_get_glGetVideoCaptureStreamivNV;

static void APIENTRY _fail_glGetVideoCaptureStreamfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat * params) {
    const char *_name = "glGetVideoCaptureStreamfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVideoCaptureStreamfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat * params) {
    PFN_GLGETVIDEOCAPTURESTREAMFVNV _ptr;
    _ptr = (PFN_GLGETVIDEOCAPTURESTREAMFVNV)_getPrivateProcAddress("glGetVideoCaptureStreamfvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetVideoCaptureStreamfvNV;
    }
    _glGetVideoCaptureStreamfvNV = _ptr;
    _glGetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, params);
}

PFN_GLGETVIDEOCAPTURESTREAMFVNV _glGetVideoCaptureStreamfvNV = &_get_glGetVideoCaptureStreamfvNV;

static void APIENTRY _fail_glGetVideoCaptureStreamdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble * params) {
    const char *_name = "glGetVideoCaptureStreamdvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetVideoCaptureStreamdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble * params) {
    PFN_GLGETVIDEOCAPTURESTREAMDVNV _ptr;
    _ptr = (PFN_GLGETVIDEOCAPTURESTREAMDVNV)_getPrivateProcAddress("glGetVideoCaptureStreamdvNV");
    if (!_ptr) {
        _ptr = &_fail_glGetVideoCaptureStreamdvNV;
    }
    _glGetVideoCaptureStreamdvNV = _ptr;
    _glGetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, params);
}

PFN_GLGETVIDEOCAPTURESTREAMDVNV _glGetVideoCaptureStreamdvNV = &_get_glGetVideoCaptureStreamdvNV;

static GLenum APIENTRY _fail_glVideoCaptureNV(GLuint video_capture_slot, GLuint * sequence_num, GLuint64EXT * capture_time) {
    const char *_name = "glVideoCaptureNV";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLenum APIENTRY _get_glVideoCaptureNV(GLuint video_capture_slot, GLuint * sequence_num, GLuint64EXT * capture_time) {
    PFN_GLVIDEOCAPTURENV _ptr;
    _ptr = (PFN_GLVIDEOCAPTURENV)_getPrivateProcAddress("glVideoCaptureNV");
    if (!_ptr) {
        _ptr = &_fail_glVideoCaptureNV;
    }
    _glVideoCaptureNV = _ptr;
    return _glVideoCaptureNV(video_capture_slot, sequence_num, capture_time);
}

PFN_GLVIDEOCAPTURENV _glVideoCaptureNV = &_get_glVideoCaptureNV;

static void APIENTRY _fail_glVideoCaptureStreamParameterivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint * params) {
    const char *_name = "glVideoCaptureStreamParameterivNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVideoCaptureStreamParameterivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint * params) {
    PFN_GLVIDEOCAPTURESTREAMPARAMETERIVNV _ptr;
    _ptr = (PFN_GLVIDEOCAPTURESTREAMPARAMETERIVNV)_getPrivateProcAddress("glVideoCaptureStreamParameterivNV");
    if (!_ptr) {
        _ptr = &_fail_glVideoCaptureStreamParameterivNV;
    }
    _glVideoCaptureStreamParameterivNV = _ptr;
    _glVideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, params);
}

PFN_GLVIDEOCAPTURESTREAMPARAMETERIVNV _glVideoCaptureStreamParameterivNV = &_get_glVideoCaptureStreamParameterivNV;

static void APIENTRY _fail_glVideoCaptureStreamParameterfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat * params) {
    const char *_name = "glVideoCaptureStreamParameterfvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVideoCaptureStreamParameterfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat * params) {
    PFN_GLVIDEOCAPTURESTREAMPARAMETERFVNV _ptr;
    _ptr = (PFN_GLVIDEOCAPTURESTREAMPARAMETERFVNV)_getPrivateProcAddress("glVideoCaptureStreamParameterfvNV");
    if (!_ptr) {
        _ptr = &_fail_glVideoCaptureStreamParameterfvNV;
    }
    _glVideoCaptureStreamParameterfvNV = _ptr;
    _glVideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, params);
}

PFN_GLVIDEOCAPTURESTREAMPARAMETERFVNV _glVideoCaptureStreamParameterfvNV = &_get_glVideoCaptureStreamParameterfvNV;

static void APIENTRY _fail_glVideoCaptureStreamParameterdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble * params) {
    const char *_name = "glVideoCaptureStreamParameterdvNV";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glVideoCaptureStreamParameterdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble * params) {
    PFN_GLVIDEOCAPTURESTREAMPARAMETERDVNV _ptr;
    _ptr = (PFN_GLVIDEOCAPTURESTREAMPARAMETERDVNV)_getPrivateProcAddress("glVideoCaptureStreamParameterdvNV");
    if (!_ptr) {
        _ptr = &_fail_glVideoCaptureStreamParameterdvNV;
    }
    _glVideoCaptureStreamParameterdvNV = _ptr;
    _glVideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, params);
}

PFN_GLVIDEOCAPTURESTREAMPARAMETERDVNV _glVideoCaptureStreamParameterdvNV = &_get_glVideoCaptureStreamParameterdvNV;

static void APIENTRY _fail_glBlendEquationSeparateOES(GLenum modeRGB, GLenum modeAlpha) {
    const char *_name = "glBlendEquationSeparateOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendEquationSeparateOES(GLenum modeRGB, GLenum modeAlpha) {
    PFN_GLBLENDEQUATIONSEPARATEOES _ptr;
    _ptr = (PFN_GLBLENDEQUATIONSEPARATEOES)_getPrivateProcAddress("glBlendEquationSeparateOES");
    if (!_ptr) {
        _ptr = &_fail_glBlendEquationSeparateOES;
    }
    _glBlendEquationSeparateOES = _ptr;
    _glBlendEquationSeparateOES(modeRGB, modeAlpha);
}

PFN_GLBLENDEQUATIONSEPARATEOES _glBlendEquationSeparateOES = &_get_glBlendEquationSeparateOES;

static void APIENTRY _fail_glBlendFuncSeparateOES(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) {
    const char *_name = "glBlendFuncSeparateOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendFuncSeparateOES(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) {
    PFN_GLBLENDFUNCSEPARATEOES _ptr;
    _ptr = (PFN_GLBLENDFUNCSEPARATEOES)_getPrivateProcAddress("glBlendFuncSeparateOES");
    if (!_ptr) {
        _ptr = &_fail_glBlendFuncSeparateOES;
    }
    _glBlendFuncSeparateOES = _ptr;
    _glBlendFuncSeparateOES(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

PFN_GLBLENDFUNCSEPARATEOES _glBlendFuncSeparateOES = &_get_glBlendFuncSeparateOES;

static void APIENTRY _fail_glBlendEquationOES(GLenum mode) {
    const char *_name = "glBlendEquationOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBlendEquationOES(GLenum mode) {
    PFN_GLBLENDEQUATIONOES _ptr;
    _ptr = (PFN_GLBLENDEQUATIONOES)_getPrivateProcAddress("glBlendEquationOES");
    if (!_ptr) {
        _ptr = &_fail_glBlendEquationOES;
    }
    _glBlendEquationOES = _ptr;
    _glBlendEquationOES(mode);
}

PFN_GLBLENDEQUATIONOES _glBlendEquationOES = &_get_glBlendEquationOES;

static void APIENTRY _fail_glDrawTexfOES(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height) {
    const char *_name = "glDrawTexfOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawTexfOES(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height) {
    PFN_GLDRAWTEXFOES _ptr;
    _ptr = (PFN_GLDRAWTEXFOES)_getPrivateProcAddress("glDrawTexfOES");
    if (!_ptr) {
        _ptr = &_fail_glDrawTexfOES;
    }
    _glDrawTexfOES = _ptr;
    _glDrawTexfOES(x, y, z, width, height);
}

PFN_GLDRAWTEXFOES _glDrawTexfOES = &_get_glDrawTexfOES;

static void APIENTRY _fail_glDrawTexfvOES(const GLfloat * coords) {
    const char *_name = "glDrawTexfvOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawTexfvOES(const GLfloat * coords) {
    PFN_GLDRAWTEXFVOES _ptr;
    _ptr = (PFN_GLDRAWTEXFVOES)_getPrivateProcAddress("glDrawTexfvOES");
    if (!_ptr) {
        _ptr = &_fail_glDrawTexfvOES;
    }
    _glDrawTexfvOES = _ptr;
    _glDrawTexfvOES(coords);
}

PFN_GLDRAWTEXFVOES _glDrawTexfvOES = &_get_glDrawTexfvOES;

static void APIENTRY _fail_glDrawTexiOES(GLint x, GLint y, GLint z, GLint width, GLint height) {
    const char *_name = "glDrawTexiOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawTexiOES(GLint x, GLint y, GLint z, GLint width, GLint height) {
    PFN_GLDRAWTEXIOES _ptr;
    _ptr = (PFN_GLDRAWTEXIOES)_getPrivateProcAddress("glDrawTexiOES");
    if (!_ptr) {
        _ptr = &_fail_glDrawTexiOES;
    }
    _glDrawTexiOES = _ptr;
    _glDrawTexiOES(x, y, z, width, height);
}

PFN_GLDRAWTEXIOES _glDrawTexiOES = &_get_glDrawTexiOES;

static void APIENTRY _fail_glDrawTexivOES(const GLint * coords) {
    const char *_name = "glDrawTexivOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawTexivOES(const GLint * coords) {
    PFN_GLDRAWTEXIVOES _ptr;
    _ptr = (PFN_GLDRAWTEXIVOES)_getPrivateProcAddress("glDrawTexivOES");
    if (!_ptr) {
        _ptr = &_fail_glDrawTexivOES;
    }
    _glDrawTexivOES = _ptr;
    _glDrawTexivOES(coords);
}

PFN_GLDRAWTEXIVOES _glDrawTexivOES = &_get_glDrawTexivOES;

static void APIENTRY _fail_glDrawTexsOES(GLshort x, GLshort y, GLshort z, GLshort width, GLshort height) {
    const char *_name = "glDrawTexsOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawTexsOES(GLshort x, GLshort y, GLshort z, GLshort width, GLshort height) {
    PFN_GLDRAWTEXSOES _ptr;
    _ptr = (PFN_GLDRAWTEXSOES)_getPrivateProcAddress("glDrawTexsOES");
    if (!_ptr) {
        _ptr = &_fail_glDrawTexsOES;
    }
    _glDrawTexsOES = _ptr;
    _glDrawTexsOES(x, y, z, width, height);
}

PFN_GLDRAWTEXSOES _glDrawTexsOES = &_get_glDrawTexsOES;

static void APIENTRY _fail_glDrawTexsvOES(const GLshort * coords) {
    const char *_name = "glDrawTexsvOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawTexsvOES(const GLshort * coords) {
    PFN_GLDRAWTEXSVOES _ptr;
    _ptr = (PFN_GLDRAWTEXSVOES)_getPrivateProcAddress("glDrawTexsvOES");
    if (!_ptr) {
        _ptr = &_fail_glDrawTexsvOES;
    }
    _glDrawTexsvOES = _ptr;
    _glDrawTexsvOES(coords);
}

PFN_GLDRAWTEXSVOES _glDrawTexsvOES = &_get_glDrawTexsvOES;

static GLboolean APIENTRY _fail_glIsRenderbufferOES(GLuint renderbuffer) {
    const char *_name = "glIsRenderbufferOES";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsRenderbufferOES(GLuint renderbuffer) {
    PFN_GLISRENDERBUFFEROES _ptr;
    _ptr = (PFN_GLISRENDERBUFFEROES)_getPrivateProcAddress("glIsRenderbufferOES");
    if (!_ptr) {
        _ptr = &_fail_glIsRenderbufferOES;
    }
    _glIsRenderbufferOES = _ptr;
    return _glIsRenderbufferOES(renderbuffer);
}

PFN_GLISRENDERBUFFEROES _glIsRenderbufferOES = &_get_glIsRenderbufferOES;

static void APIENTRY _fail_glBindRenderbufferOES(GLenum target, GLuint renderbuffer) {
    const char *_name = "glBindRenderbufferOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindRenderbufferOES(GLenum target, GLuint renderbuffer) {
    PFN_GLBINDRENDERBUFFEROES _ptr;
    _ptr = (PFN_GLBINDRENDERBUFFEROES)_getPrivateProcAddress("glBindRenderbufferOES");
    if (!_ptr) {
        _ptr = &_fail_glBindRenderbufferOES;
    }
    _glBindRenderbufferOES = _ptr;
    _glBindRenderbufferOES(target, renderbuffer);
}

PFN_GLBINDRENDERBUFFEROES _glBindRenderbufferOES = &_get_glBindRenderbufferOES;

static void APIENTRY _fail_glDeleteRenderbuffersOES(GLsizei n, const GLuint * renderbuffers) {
    const char *_name = "glDeleteRenderbuffersOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteRenderbuffersOES(GLsizei n, const GLuint * renderbuffers) {
    PFN_GLDELETERENDERBUFFERSOES _ptr;
    _ptr = (PFN_GLDELETERENDERBUFFERSOES)_getPrivateProcAddress("glDeleteRenderbuffersOES");
    if (!_ptr) {
        _ptr = &_fail_glDeleteRenderbuffersOES;
    }
    _glDeleteRenderbuffersOES = _ptr;
    _glDeleteRenderbuffersOES(n, renderbuffers);
}

PFN_GLDELETERENDERBUFFERSOES _glDeleteRenderbuffersOES = &_get_glDeleteRenderbuffersOES;

static void APIENTRY _fail_glGenRenderbuffersOES(GLsizei n, GLuint * renderbuffers) {
    const char *_name = "glGenRenderbuffersOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenRenderbuffersOES(GLsizei n, GLuint * renderbuffers) {
    PFN_GLGENRENDERBUFFERSOES _ptr;
    _ptr = (PFN_GLGENRENDERBUFFERSOES)_getPrivateProcAddress("glGenRenderbuffersOES");
    if (!_ptr) {
        _ptr = &_fail_glGenRenderbuffersOES;
    }
    _glGenRenderbuffersOES = _ptr;
    _glGenRenderbuffersOES(n, renderbuffers);
}

PFN_GLGENRENDERBUFFERSOES _glGenRenderbuffersOES = &_get_glGenRenderbuffersOES;

static void APIENTRY _fail_glRenderbufferStorageOES(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) {
    const char *_name = "glRenderbufferStorageOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glRenderbufferStorageOES(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) {
    PFN_GLRENDERBUFFERSTORAGEOES _ptr;
    _ptr = (PFN_GLRENDERBUFFERSTORAGEOES)_getPrivateProcAddress("glRenderbufferStorageOES");
    if (!_ptr) {
        _ptr = &_fail_glRenderbufferStorageOES;
    }
    _glRenderbufferStorageOES = _ptr;
    _glRenderbufferStorageOES(target, internalformat, width, height);
}

PFN_GLRENDERBUFFERSTORAGEOES _glRenderbufferStorageOES = &_get_glRenderbufferStorageOES;

static void APIENTRY _fail_glGetRenderbufferParameterivOES(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetRenderbufferParameterivOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetRenderbufferParameterivOES(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETRENDERBUFFERPARAMETERIVOES _ptr;
    _ptr = (PFN_GLGETRENDERBUFFERPARAMETERIVOES)_getPrivateProcAddress("glGetRenderbufferParameterivOES");
    if (!_ptr) {
        _ptr = &_fail_glGetRenderbufferParameterivOES;
    }
    _glGetRenderbufferParameterivOES = _ptr;
    _glGetRenderbufferParameterivOES(target, pname, params);
}

PFN_GLGETRENDERBUFFERPARAMETERIVOES _glGetRenderbufferParameterivOES = &_get_glGetRenderbufferParameterivOES;

static GLboolean APIENTRY _fail_glIsFramebufferOES(GLuint framebuffer) {
    const char *_name = "glIsFramebufferOES";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsFramebufferOES(GLuint framebuffer) {
    PFN_GLISFRAMEBUFFEROES _ptr;
    _ptr = (PFN_GLISFRAMEBUFFEROES)_getPrivateProcAddress("glIsFramebufferOES");
    if (!_ptr) {
        _ptr = &_fail_glIsFramebufferOES;
    }
    _glIsFramebufferOES = _ptr;
    return _glIsFramebufferOES(framebuffer);
}

PFN_GLISFRAMEBUFFEROES _glIsFramebufferOES = &_get_glIsFramebufferOES;

static void APIENTRY _fail_glBindFramebufferOES(GLenum target, GLuint framebuffer) {
    const char *_name = "glBindFramebufferOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindFramebufferOES(GLenum target, GLuint framebuffer) {
    PFN_GLBINDFRAMEBUFFEROES _ptr;
    _ptr = (PFN_GLBINDFRAMEBUFFEROES)_getPrivateProcAddress("glBindFramebufferOES");
    if (!_ptr) {
        _ptr = &_fail_glBindFramebufferOES;
    }
    _glBindFramebufferOES = _ptr;
    _glBindFramebufferOES(target, framebuffer);
}

PFN_GLBINDFRAMEBUFFEROES _glBindFramebufferOES = &_get_glBindFramebufferOES;

static void APIENTRY _fail_glDeleteFramebuffersOES(GLsizei n, const GLuint * framebuffers) {
    const char *_name = "glDeleteFramebuffersOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteFramebuffersOES(GLsizei n, const GLuint * framebuffers) {
    PFN_GLDELETEFRAMEBUFFERSOES _ptr;
    _ptr = (PFN_GLDELETEFRAMEBUFFERSOES)_getPrivateProcAddress("glDeleteFramebuffersOES");
    if (!_ptr) {
        _ptr = &_fail_glDeleteFramebuffersOES;
    }
    _glDeleteFramebuffersOES = _ptr;
    _glDeleteFramebuffersOES(n, framebuffers);
}

PFN_GLDELETEFRAMEBUFFERSOES _glDeleteFramebuffersOES = &_get_glDeleteFramebuffersOES;

static void APIENTRY _fail_glGenFramebuffersOES(GLsizei n, GLuint * framebuffers) {
    const char *_name = "glGenFramebuffersOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenFramebuffersOES(GLsizei n, GLuint * framebuffers) {
    PFN_GLGENFRAMEBUFFERSOES _ptr;
    _ptr = (PFN_GLGENFRAMEBUFFERSOES)_getPrivateProcAddress("glGenFramebuffersOES");
    if (!_ptr) {
        _ptr = &_fail_glGenFramebuffersOES;
    }
    _glGenFramebuffersOES = _ptr;
    _glGenFramebuffersOES(n, framebuffers);
}

PFN_GLGENFRAMEBUFFERSOES _glGenFramebuffersOES = &_get_glGenFramebuffersOES;

static GLenum APIENTRY _fail_glCheckFramebufferStatusOES(GLenum target) {
    const char *_name = "glCheckFramebufferStatusOES";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLenum APIENTRY _get_glCheckFramebufferStatusOES(GLenum target) {
    PFN_GLCHECKFRAMEBUFFERSTATUSOES _ptr;
    _ptr = (PFN_GLCHECKFRAMEBUFFERSTATUSOES)_getPrivateProcAddress("glCheckFramebufferStatusOES");
    if (!_ptr) {
        _ptr = &_fail_glCheckFramebufferStatusOES;
    }
    _glCheckFramebufferStatusOES = _ptr;
    return _glCheckFramebufferStatusOES(target);
}

PFN_GLCHECKFRAMEBUFFERSTATUSOES _glCheckFramebufferStatusOES = &_get_glCheckFramebufferStatusOES;

static void APIENTRY _fail_glFramebufferTexture2DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    const char *_name = "glFramebufferTexture2DOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferTexture2DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
    PFN_GLFRAMEBUFFERTEXTURE2DOES _ptr;
    _ptr = (PFN_GLFRAMEBUFFERTEXTURE2DOES)_getPrivateProcAddress("glFramebufferTexture2DOES");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferTexture2DOES;
    }
    _glFramebufferTexture2DOES = _ptr;
    _glFramebufferTexture2DOES(target, attachment, textarget, texture, level);
}

PFN_GLFRAMEBUFFERTEXTURE2DOES _glFramebufferTexture2DOES = &_get_glFramebufferTexture2DOES;

static void APIENTRY _fail_glFramebufferRenderbufferOES(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) {
    const char *_name = "glFramebufferRenderbufferOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferRenderbufferOES(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) {
    PFN_GLFRAMEBUFFERRENDERBUFFEROES _ptr;
    _ptr = (PFN_GLFRAMEBUFFERRENDERBUFFEROES)_getPrivateProcAddress("glFramebufferRenderbufferOES");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferRenderbufferOES;
    }
    _glFramebufferRenderbufferOES = _ptr;
    _glFramebufferRenderbufferOES(target, attachment, renderbuffertarget, renderbuffer);
}

PFN_GLFRAMEBUFFERRENDERBUFFEROES _glFramebufferRenderbufferOES = &_get_glFramebufferRenderbufferOES;

static void APIENTRY _fail_glGetFramebufferAttachmentParameterivOES(GLenum target, GLenum attachment, GLenum pname, GLint * params) {
    const char *_name = "glGetFramebufferAttachmentParameterivOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFramebufferAttachmentParameterivOES(GLenum target, GLenum attachment, GLenum pname, GLint * params) {
    PFN_GLGETFRAMEBUFFERATTACHMENTPARAMETERIVOES _ptr;
    _ptr = (PFN_GLGETFRAMEBUFFERATTACHMENTPARAMETERIVOES)_getPrivateProcAddress("glGetFramebufferAttachmentParameterivOES");
    if (!_ptr) {
        _ptr = &_fail_glGetFramebufferAttachmentParameterivOES;
    }
    _glGetFramebufferAttachmentParameterivOES = _ptr;
    _glGetFramebufferAttachmentParameterivOES(target, attachment, pname, params);
}

PFN_GLGETFRAMEBUFFERATTACHMENTPARAMETERIVOES _glGetFramebufferAttachmentParameterivOES = &_get_glGetFramebufferAttachmentParameterivOES;

static void APIENTRY _fail_glGenerateMipmapOES(GLenum target) {
    const char *_name = "glGenerateMipmapOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenerateMipmapOES(GLenum target) {
    PFN_GLGENERATEMIPMAPOES _ptr;
    _ptr = (PFN_GLGENERATEMIPMAPOES)_getPrivateProcAddress("glGenerateMipmapOES");
    if (!_ptr) {
        _ptr = &_fail_glGenerateMipmapOES;
    }
    _glGenerateMipmapOES = _ptr;
    _glGenerateMipmapOES(target);
}

PFN_GLGENERATEMIPMAPOES _glGenerateMipmapOES = &_get_glGenerateMipmapOES;

static void APIENTRY _fail_glGetProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, GLvoid * binary) {
    const char *_name = "glGetProgramBinaryOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, GLvoid * binary) {
    PFN_GLGETPROGRAMBINARYOES _ptr;
    _ptr = (PFN_GLGETPROGRAMBINARYOES)_getPrivateProcAddress("glGetProgramBinaryOES");
    if (!_ptr) {
        _ptr = &_fail_glGetProgramBinaryOES;
    }
    _glGetProgramBinaryOES = _ptr;
    _glGetProgramBinaryOES(program, bufSize, length, binaryFormat, binary);
}

PFN_GLGETPROGRAMBINARYOES _glGetProgramBinaryOES = &_get_glGetProgramBinaryOES;

static void APIENTRY _fail_glProgramBinaryOES(GLuint program, GLenum binaryFormat, const GLvoid * binary, GLsizei length) {
    const char *_name = "glProgramBinaryOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glProgramBinaryOES(GLuint program, GLenum binaryFormat, const GLvoid * binary, GLsizei length) {
    PFN_GLPROGRAMBINARYOES _ptr;
    _ptr = (PFN_GLPROGRAMBINARYOES)_getPrivateProcAddress("glProgramBinaryOES");
    if (!_ptr) {
        _ptr = &_fail_glProgramBinaryOES;
    }
    _glProgramBinaryOES = _ptr;
    _glProgramBinaryOES(program, binaryFormat, binary, length);
}

PFN_GLPROGRAMBINARYOES _glProgramBinaryOES = &_get_glProgramBinaryOES;

static void APIENTRY _fail_glGetBufferPointervOES(GLenum target, GLenum pname, GLvoid * * params) {
    const char *_name = "glGetBufferPointervOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetBufferPointervOES(GLenum target, GLenum pname, GLvoid * * params) {
    PFN_GLGETBUFFERPOINTERVOES _ptr;
    _ptr = (PFN_GLGETBUFFERPOINTERVOES)_getPrivateProcAddress("glGetBufferPointervOES");
    if (!_ptr) {
        _ptr = &_fail_glGetBufferPointervOES;
    }
    _glGetBufferPointervOES = _ptr;
    _glGetBufferPointervOES(target, pname, params);
}

PFN_GLGETBUFFERPOINTERVOES _glGetBufferPointervOES = &_get_glGetBufferPointervOES;

static GLvoid * APIENTRY _fail_glMapBufferOES(GLenum target, GLenum access) {
    const char *_name = "glMapBufferOES";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLvoid * APIENTRY _get_glMapBufferOES(GLenum target, GLenum access) {
    PFN_GLMAPBUFFEROES _ptr;
    _ptr = (PFN_GLMAPBUFFEROES)_getPrivateProcAddress("glMapBufferOES");
    if (!_ptr) {
        _ptr = &_fail_glMapBufferOES;
    }
    _glMapBufferOES = _ptr;
    return _glMapBufferOES(target, access);
}

PFN_GLMAPBUFFEROES _glMapBufferOES = &_get_glMapBufferOES;

static GLboolean APIENTRY _fail_glUnmapBufferOES(GLenum target) {
    const char *_name = "glUnmapBufferOES";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glUnmapBufferOES(GLenum target) {
    PFN_GLUNMAPBUFFEROES _ptr;
    _ptr = (PFN_GLUNMAPBUFFEROES)_getPrivateProcAddress("glUnmapBufferOES");
    if (!_ptr) {
        _ptr = &_fail_glUnmapBufferOES;
    }
    _glUnmapBufferOES = _ptr;
    return _glUnmapBufferOES(target);
}

PFN_GLUNMAPBUFFEROES _glUnmapBufferOES = &_get_glUnmapBufferOES;

static void APIENTRY _fail_glCurrentPaletteMatrixOES(GLuint index) {
    const char *_name = "glCurrentPaletteMatrixOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCurrentPaletteMatrixOES(GLuint index) {
    PFN_GLCURRENTPALETTEMATRIXOES _ptr;
    _ptr = (PFN_GLCURRENTPALETTEMATRIXOES)_getPrivateProcAddress("glCurrentPaletteMatrixOES");
    if (!_ptr) {
        _ptr = &_fail_glCurrentPaletteMatrixOES;
    }
    _glCurrentPaletteMatrixOES = _ptr;
    _glCurrentPaletteMatrixOES(index);
}

PFN_GLCURRENTPALETTEMATRIXOES _glCurrentPaletteMatrixOES = &_get_glCurrentPaletteMatrixOES;

static void APIENTRY _fail_glLoadPaletteFromModelViewMatrixOES(void) {
    const char *_name = "glLoadPaletteFromModelViewMatrixOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLoadPaletteFromModelViewMatrixOES(void) {
    PFN_GLLOADPALETTEFROMMODELVIEWMATRIXOES _ptr;
    _ptr = (PFN_GLLOADPALETTEFROMMODELVIEWMATRIXOES)_getPrivateProcAddress("glLoadPaletteFromModelViewMatrixOES");
    if (!_ptr) {
        _ptr = &_fail_glLoadPaletteFromModelViewMatrixOES;
    }
    _glLoadPaletteFromModelViewMatrixOES = _ptr;
    _glLoadPaletteFromModelViewMatrixOES();
}

PFN_GLLOADPALETTEFROMMODELVIEWMATRIXOES _glLoadPaletteFromModelViewMatrixOES = &_get_glLoadPaletteFromModelViewMatrixOES;

static void APIENTRY _fail_glMatrixIndexPointerOES(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glMatrixIndexPointerOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glMatrixIndexPointerOES(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLMATRIXINDEXPOINTEROES _ptr;
    _ptr = (PFN_GLMATRIXINDEXPOINTEROES)_getPrivateProcAddress("glMatrixIndexPointerOES");
    if (!_ptr) {
        _ptr = &_fail_glMatrixIndexPointerOES;
    }
    _glMatrixIndexPointerOES = _ptr;
    _glMatrixIndexPointerOES(size, type, stride, pointer);
}

PFN_GLMATRIXINDEXPOINTEROES _glMatrixIndexPointerOES = &_get_glMatrixIndexPointerOES;

static void APIENTRY _fail_glWeightPointerOES(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    const char *_name = "glWeightPointerOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glWeightPointerOES(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer) {
    PFN_GLWEIGHTPOINTEROES _ptr;
    _ptr = (PFN_GLWEIGHTPOINTEROES)_getPrivateProcAddress("glWeightPointerOES");
    if (!_ptr) {
        _ptr = &_fail_glWeightPointerOES;
    }
    _glWeightPointerOES = _ptr;
    _glWeightPointerOES(size, type, stride, pointer);
}

PFN_GLWEIGHTPOINTEROES _glWeightPointerOES = &_get_glWeightPointerOES;

static void APIENTRY _fail_glPointSizePointerOES(GLenum type, GLsizei stride, const GLvoid * ptr) {
    const char *_name = "glPointSizePointerOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPointSizePointerOES(GLenum type, GLsizei stride, const GLvoid * ptr) {
    PFN_GLPOINTSIZEPOINTEROES _ptr;
    _ptr = (PFN_GLPOINTSIZEPOINTEROES)_getPrivateProcAddress("glPointSizePointerOES");
    if (!_ptr) {
        _ptr = &_fail_glPointSizePointerOES;
    }
    _glPointSizePointerOES = _ptr;
    _glPointSizePointerOES(type, stride, ptr);
}

PFN_GLPOINTSIZEPOINTEROES _glPointSizePointerOES = &_get_glPointSizePointerOES;

static GLbitfield APIENTRY _fail_glQueryMatrixxOES(GLfixed * mantissa, GLint * exponent) {
    const char *_name = "glQueryMatrixxOES";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLbitfield APIENTRY _get_glQueryMatrixxOES(GLfixed * mantissa, GLint * exponent) {
    PFN_GLQUERYMATRIXXOES _ptr;
    _ptr = (PFN_GLQUERYMATRIXXOES)_getPrivateProcAddress("glQueryMatrixxOES");
    if (!_ptr) {
        _ptr = &_fail_glQueryMatrixxOES;
    }
    _glQueryMatrixxOES = _ptr;
    return _glQueryMatrixxOES(mantissa, exponent);
}

PFN_GLQUERYMATRIXXOES _glQueryMatrixxOES = &_get_glQueryMatrixxOES;

static void APIENTRY _fail_glClearDepthfOES(GLclampf depth) {
    const char *_name = "glClearDepthfOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClearDepthfOES(GLclampf depth) {
    PFN_GLCLEARDEPTHFOES _ptr;
    _ptr = (PFN_GLCLEARDEPTHFOES)_getPrivateProcAddress("glClearDepthfOES");
    if (!_ptr) {
        _ptr = &_fail_glClearDepthfOES;
    }
    _glClearDepthfOES = _ptr;
    _glClearDepthfOES(depth);
}

PFN_GLCLEARDEPTHFOES _glClearDepthfOES = &_get_glClearDepthfOES;

static void APIENTRY _fail_glClipPlanefOES(GLenum plane, const GLfloat * equation) {
    const char *_name = "glClipPlanefOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glClipPlanefOES(GLenum plane, const GLfloat * equation) {
    PFN_GLCLIPPLANEFOES _ptr;
    _ptr = (PFN_GLCLIPPLANEFOES)_getPrivateProcAddress("glClipPlanefOES");
    if (!_ptr) {
        _ptr = &_fail_glClipPlanefOES;
    }
    _glClipPlanefOES = _ptr;
    _glClipPlanefOES(plane, equation);
}

PFN_GLCLIPPLANEFOES _glClipPlanefOES = &_get_glClipPlanefOES;

static void APIENTRY _fail_glDepthRangefOES(GLclampf n, GLclampf f) {
    const char *_name = "glDepthRangefOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDepthRangefOES(GLclampf n, GLclampf f) {
    PFN_GLDEPTHRANGEFOES _ptr;
    _ptr = (PFN_GLDEPTHRANGEFOES)_getPrivateProcAddress("glDepthRangefOES");
    if (!_ptr) {
        _ptr = &_fail_glDepthRangefOES;
    }
    _glDepthRangefOES = _ptr;
    _glDepthRangefOES(n, f);
}

PFN_GLDEPTHRANGEFOES _glDepthRangefOES = &_get_glDepthRangefOES;

static void APIENTRY _fail_glFrustumfOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) {
    const char *_name = "glFrustumfOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFrustumfOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) {
    PFN_GLFRUSTUMFOES _ptr;
    _ptr = (PFN_GLFRUSTUMFOES)_getPrivateProcAddress("glFrustumfOES");
    if (!_ptr) {
        _ptr = &_fail_glFrustumfOES;
    }
    _glFrustumfOES = _ptr;
    _glFrustumfOES(l, r, b, t, n, f);
}

PFN_GLFRUSTUMFOES _glFrustumfOES = &_get_glFrustumfOES;

static void APIENTRY _fail_glGetClipPlanefOES(GLenum plane, GLfloat * equation) {
    const char *_name = "glGetClipPlanefOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetClipPlanefOES(GLenum plane, GLfloat * equation) {
    PFN_GLGETCLIPPLANEFOES _ptr;
    _ptr = (PFN_GLGETCLIPPLANEFOES)_getPrivateProcAddress("glGetClipPlanefOES");
    if (!_ptr) {
        _ptr = &_fail_glGetClipPlanefOES;
    }
    _glGetClipPlanefOES = _ptr;
    _glGetClipPlanefOES(plane, equation);
}

PFN_GLGETCLIPPLANEFOES _glGetClipPlanefOES = &_get_glGetClipPlanefOES;

static void APIENTRY _fail_glOrthofOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) {
    const char *_name = "glOrthofOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glOrthofOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) {
    PFN_GLORTHOFOES _ptr;
    _ptr = (PFN_GLORTHOFOES)_getPrivateProcAddress("glOrthofOES");
    if (!_ptr) {
        _ptr = &_fail_glOrthofOES;
    }
    _glOrthofOES = _ptr;
    _glOrthofOES(l, r, b, t, n, f);
}

PFN_GLORTHOFOES _glOrthofOES = &_get_glOrthofOES;

static void APIENTRY _fail_glTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexImage3DOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXIMAGE3DOES _ptr;
    _ptr = (PFN_GLTEXIMAGE3DOES)_getPrivateProcAddress("glTexImage3DOES");
    if (!_ptr) {
        _ptr = &_fail_glTexImage3DOES;
    }
    _glTexImage3DOES = _ptr;
    _glTexImage3DOES(target, level, internalformat, width, height, depth, border, format, type, pixels);
}

PFN_GLTEXIMAGE3DOES _glTexImage3DOES = &_get_glTexImage3DOES;

static void APIENTRY _fail_glTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexSubImage3DOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXSUBIMAGE3DOES _ptr;
    _ptr = (PFN_GLTEXSUBIMAGE3DOES)_getPrivateProcAddress("glTexSubImage3DOES");
    if (!_ptr) {
        _ptr = &_fail_glTexSubImage3DOES;
    }
    _glTexSubImage3DOES = _ptr;
    _glTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

PFN_GLTEXSUBIMAGE3DOES _glTexSubImage3DOES = &_get_glTexSubImage3DOES;

static void APIENTRY _fail_glCopyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glCopyTexSubImage3DOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLCOPYTEXSUBIMAGE3DOES _ptr;
    _ptr = (PFN_GLCOPYTEXSUBIMAGE3DOES)_getPrivateProcAddress("glCopyTexSubImage3DOES");
    if (!_ptr) {
        _ptr = &_fail_glCopyTexSubImage3DOES;
    }
    _glCopyTexSubImage3DOES = _ptr;
    _glCopyTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

PFN_GLCOPYTEXSUBIMAGE3DOES _glCopyTexSubImage3DOES = &_get_glCopyTexSubImage3DOES;

static void APIENTRY _fail_glCompressedTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexImage3DOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data) {
    PFN_GLCOMPRESSEDTEXIMAGE3DOES _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXIMAGE3DOES)_getPrivateProcAddress("glCompressedTexImage3DOES");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTexImage3DOES;
    }
    _glCompressedTexImage3DOES = _ptr;
    _glCompressedTexImage3DOES(target, level, internalformat, width, height, depth, border, imageSize, data);
}

PFN_GLCOMPRESSEDTEXIMAGE3DOES _glCompressedTexImage3DOES = &_get_glCompressedTexImage3DOES;

static void APIENTRY _fail_glCompressedTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data) {
    const char *_name = "glCompressedTexSubImage3DOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCompressedTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data) {
    PFN_GLCOMPRESSEDTEXSUBIMAGE3DOES _ptr;
    _ptr = (PFN_GLCOMPRESSEDTEXSUBIMAGE3DOES)_getPrivateProcAddress("glCompressedTexSubImage3DOES");
    if (!_ptr) {
        _ptr = &_fail_glCompressedTexSubImage3DOES;
    }
    _glCompressedTexSubImage3DOES = _ptr;
    _glCompressedTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

PFN_GLCOMPRESSEDTEXSUBIMAGE3DOES _glCompressedTexSubImage3DOES = &_get_glCompressedTexSubImage3DOES;

static void APIENTRY _fail_glFramebufferTexture3DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) {
    const char *_name = "glFramebufferTexture3DOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFramebufferTexture3DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) {
    PFN_GLFRAMEBUFFERTEXTURE3DOES _ptr;
    _ptr = (PFN_GLFRAMEBUFFERTEXTURE3DOES)_getPrivateProcAddress("glFramebufferTexture3DOES");
    if (!_ptr) {
        _ptr = &_fail_glFramebufferTexture3DOES;
    }
    _glFramebufferTexture3DOES = _ptr;
    _glFramebufferTexture3DOES(target, attachment, textarget, texture, level, zoffset);
}

PFN_GLFRAMEBUFFERTEXTURE3DOES _glFramebufferTexture3DOES = &_get_glFramebufferTexture3DOES;

static void APIENTRY _fail_glTexGenfOES(GLenum coord, GLenum pname, GLfloat param) {
    const char *_name = "glTexGenfOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexGenfOES(GLenum coord, GLenum pname, GLfloat param) {
    PFN_GLTEXGENFOES _ptr;
    _ptr = (PFN_GLTEXGENFOES)_getPrivateProcAddress("glTexGenfOES");
    if (!_ptr) {
        _ptr = &_fail_glTexGenfOES;
    }
    _glTexGenfOES = _ptr;
    _glTexGenfOES(coord, pname, param);
}

PFN_GLTEXGENFOES _glTexGenfOES = &_get_glTexGenfOES;

static void APIENTRY _fail_glTexGenfvOES(GLenum coord, GLenum pname, const GLfloat * params) {
    const char *_name = "glTexGenfvOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexGenfvOES(GLenum coord, GLenum pname, const GLfloat * params) {
    PFN_GLTEXGENFVOES _ptr;
    _ptr = (PFN_GLTEXGENFVOES)_getPrivateProcAddress("glTexGenfvOES");
    if (!_ptr) {
        _ptr = &_fail_glTexGenfvOES;
    }
    _glTexGenfvOES = _ptr;
    _glTexGenfvOES(coord, pname, params);
}

PFN_GLTEXGENFVOES _glTexGenfvOES = &_get_glTexGenfvOES;

static void APIENTRY _fail_glTexGeniOES(GLenum coord, GLenum pname, GLint param) {
    const char *_name = "glTexGeniOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexGeniOES(GLenum coord, GLenum pname, GLint param) {
    PFN_GLTEXGENIOES _ptr;
    _ptr = (PFN_GLTEXGENIOES)_getPrivateProcAddress("glTexGeniOES");
    if (!_ptr) {
        _ptr = &_fail_glTexGeniOES;
    }
    _glTexGeniOES = _ptr;
    _glTexGeniOES(coord, pname, param);
}

PFN_GLTEXGENIOES _glTexGeniOES = &_get_glTexGeniOES;

static void APIENTRY _fail_glTexGenivOES(GLenum coord, GLenum pname, const GLint * params) {
    const char *_name = "glTexGenivOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexGenivOES(GLenum coord, GLenum pname, const GLint * params) {
    PFN_GLTEXGENIVOES _ptr;
    _ptr = (PFN_GLTEXGENIVOES)_getPrivateProcAddress("glTexGenivOES");
    if (!_ptr) {
        _ptr = &_fail_glTexGenivOES;
    }
    _glTexGenivOES = _ptr;
    _glTexGenivOES(coord, pname, params);
}

PFN_GLTEXGENIVOES _glTexGenivOES = &_get_glTexGenivOES;

static void APIENTRY _fail_glTexGenxOES(GLenum coord, GLenum pname, GLfixed param) {
    const char *_name = "glTexGenxOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexGenxOES(GLenum coord, GLenum pname, GLfixed param) {
    PFN_GLTEXGENXOES _ptr;
    _ptr = (PFN_GLTEXGENXOES)_getPrivateProcAddress("glTexGenxOES");
    if (!_ptr) {
        _ptr = &_fail_glTexGenxOES;
    }
    _glTexGenxOES = _ptr;
    _glTexGenxOES(coord, pname, param);
}

PFN_GLTEXGENXOES _glTexGenxOES = &_get_glTexGenxOES;

static void APIENTRY _fail_glTexGenxvOES(GLenum coord, GLenum pname, const GLfixed * params) {
    const char *_name = "glTexGenxvOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexGenxvOES(GLenum coord, GLenum pname, const GLfixed * params) {
    PFN_GLTEXGENXVOES _ptr;
    _ptr = (PFN_GLTEXGENXVOES)_getPrivateProcAddress("glTexGenxvOES");
    if (!_ptr) {
        _ptr = &_fail_glTexGenxvOES;
    }
    _glTexGenxvOES = _ptr;
    _glTexGenxvOES(coord, pname, params);
}

PFN_GLTEXGENXVOES _glTexGenxvOES = &_get_glTexGenxvOES;

static void APIENTRY _fail_glGetTexGenfvOES(GLenum coord, GLenum pname, GLfloat * params) {
    const char *_name = "glGetTexGenfvOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexGenfvOES(GLenum coord, GLenum pname, GLfloat * params) {
    PFN_GLGETTEXGENFVOES _ptr;
    _ptr = (PFN_GLGETTEXGENFVOES)_getPrivateProcAddress("glGetTexGenfvOES");
    if (!_ptr) {
        _ptr = &_fail_glGetTexGenfvOES;
    }
    _glGetTexGenfvOES = _ptr;
    _glGetTexGenfvOES(coord, pname, params);
}

PFN_GLGETTEXGENFVOES _glGetTexGenfvOES = &_get_glGetTexGenfvOES;

static void APIENTRY _fail_glGetTexGenivOES(GLenum coord, GLenum pname, GLint * params) {
    const char *_name = "glGetTexGenivOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexGenivOES(GLenum coord, GLenum pname, GLint * params) {
    PFN_GLGETTEXGENIVOES _ptr;
    _ptr = (PFN_GLGETTEXGENIVOES)_getPrivateProcAddress("glGetTexGenivOES");
    if (!_ptr) {
        _ptr = &_fail_glGetTexGenivOES;
    }
    _glGetTexGenivOES = _ptr;
    _glGetTexGenivOES(coord, pname, params);
}

PFN_GLGETTEXGENIVOES _glGetTexGenivOES = &_get_glGetTexGenivOES;

static void APIENTRY _fail_glGetTexGenxvOES(GLenum coord, GLenum pname, GLfixed * params) {
    const char *_name = "glGetTexGenxvOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexGenxvOES(GLenum coord, GLenum pname, GLfixed * params) {
    PFN_GLGETTEXGENXVOES _ptr;
    _ptr = (PFN_GLGETTEXGENXVOES)_getPrivateProcAddress("glGetTexGenxvOES");
    if (!_ptr) {
        _ptr = &_fail_glGetTexGenxvOES;
    }
    _glGetTexGenxvOES = _ptr;
    _glGetTexGenxvOES(coord, pname, params);
}

PFN_GLGETTEXGENXVOES _glGetTexGenxvOES = &_get_glGetTexGenxvOES;

static void APIENTRY _fail_glBindVertexArrayOES(GLuint array) {
    const char *_name = "glBindVertexArrayOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glBindVertexArrayOES(GLuint array) {
    PFN_GLBINDVERTEXARRAYOES _ptr;
    _ptr = (PFN_GLBINDVERTEXARRAYOES)_getPrivateProcAddress("glBindVertexArrayOES");
    if (!_ptr) {
        _ptr = &_fail_glBindVertexArrayOES;
    }
    _glBindVertexArrayOES = _ptr;
    _glBindVertexArrayOES(array);
}

PFN_GLBINDVERTEXARRAYOES _glBindVertexArrayOES = &_get_glBindVertexArrayOES;

static void APIENTRY _fail_glDeleteVertexArraysOES(GLsizei n, const GLuint * arrays) {
    const char *_name = "glDeleteVertexArraysOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteVertexArraysOES(GLsizei n, const GLuint * arrays) {
    PFN_GLDELETEVERTEXARRAYSOES _ptr;
    _ptr = (PFN_GLDELETEVERTEXARRAYSOES)_getPrivateProcAddress("glDeleteVertexArraysOES");
    if (!_ptr) {
        _ptr = &_fail_glDeleteVertexArraysOES;
    }
    _glDeleteVertexArraysOES = _ptr;
    _glDeleteVertexArraysOES(n, arrays);
}

PFN_GLDELETEVERTEXARRAYSOES _glDeleteVertexArraysOES = &_get_glDeleteVertexArraysOES;

static void APIENTRY _fail_glGenVertexArraysOES(GLsizei n, GLuint * arrays) {
    const char *_name = "glGenVertexArraysOES";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGenVertexArraysOES(GLsizei n, GLuint * arrays) {
    PFN_GLGENVERTEXARRAYSOES _ptr;
    _ptr = (PFN_GLGENVERTEXARRAYSOES)_getPrivateProcAddress("glGenVertexArraysOES");
    if (!_ptr) {
        _ptr = &_fail_glGenVertexArraysOES;
    }
    _glGenVertexArraysOES = _ptr;
    _glGenVertexArraysOES(n, arrays);
}

PFN_GLGENVERTEXARRAYSOES _glGenVertexArraysOES = &_get_glGenVertexArraysOES;

static GLboolean APIENTRY _fail_glIsVertexArrayOES(GLuint array) {
    const char *_name = "glIsVertexArrayOES";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsVertexArrayOES(GLuint array) {
    PFN_GLISVERTEXARRAYOES _ptr;
    _ptr = (PFN_GLISVERTEXARRAYOES)_getPrivateProcAddress("glIsVertexArrayOES");
    if (!_ptr) {
        _ptr = &_fail_glIsVertexArrayOES;
    }
    _glIsVertexArrayOES = _ptr;
    return _glIsVertexArrayOES(array);
}

PFN_GLISVERTEXARRAYOES _glIsVertexArrayOES = &_get_glIsVertexArrayOES;

static void APIENTRY _fail_glHintPGI(GLenum target, GLint mode) {
    const char *_name = "glHintPGI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glHintPGI(GLenum target, GLint mode) {
    PFN_GLHINTPGI _ptr;
    _ptr = (PFN_GLHINTPGI)_getPrivateProcAddress("glHintPGI");
    if (!_ptr) {
        _ptr = &_fail_glHintPGI;
    }
    _glHintPGI = _ptr;
    _glHintPGI(target, mode);
}

PFN_GLHINTPGI _glHintPGI = &_get_glHintPGI;

static void APIENTRY _fail_glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat * points) {
    const char *_name = "glDetailTexFuncSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat * points) {
    PFN_GLDETAILTEXFUNCSGIS _ptr;
    _ptr = (PFN_GLDETAILTEXFUNCSGIS)_getPrivateProcAddress("glDetailTexFuncSGIS");
    if (!_ptr) {
        _ptr = &_fail_glDetailTexFuncSGIS;
    }
    _glDetailTexFuncSGIS = _ptr;
    _glDetailTexFuncSGIS(target, n, points);
}

PFN_GLDETAILTEXFUNCSGIS _glDetailTexFuncSGIS = &_get_glDetailTexFuncSGIS;

static void APIENTRY _fail_glGetDetailTexFuncSGIS(GLenum target, GLfloat * points) {
    const char *_name = "glGetDetailTexFuncSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetDetailTexFuncSGIS(GLenum target, GLfloat * points) {
    PFN_GLGETDETAILTEXFUNCSGIS _ptr;
    _ptr = (PFN_GLGETDETAILTEXFUNCSGIS)_getPrivateProcAddress("glGetDetailTexFuncSGIS");
    if (!_ptr) {
        _ptr = &_fail_glGetDetailTexFuncSGIS;
    }
    _glGetDetailTexFuncSGIS = _ptr;
    _glGetDetailTexFuncSGIS(target, points);
}

PFN_GLGETDETAILTEXFUNCSGIS _glGetDetailTexFuncSGIS = &_get_glGetDetailTexFuncSGIS;

static void APIENTRY _fail_glFogFuncSGIS(GLsizei n, const GLfloat * points) {
    const char *_name = "glFogFuncSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFogFuncSGIS(GLsizei n, const GLfloat * points) {
    PFN_GLFOGFUNCSGIS _ptr;
    _ptr = (PFN_GLFOGFUNCSGIS)_getPrivateProcAddress("glFogFuncSGIS");
    if (!_ptr) {
        _ptr = &_fail_glFogFuncSGIS;
    }
    _glFogFuncSGIS = _ptr;
    _glFogFuncSGIS(n, points);
}

PFN_GLFOGFUNCSGIS _glFogFuncSGIS = &_get_glFogFuncSGIS;

static void APIENTRY _fail_glGetFogFuncSGIS(GLfloat * points) {
    const char *_name = "glGetFogFuncSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFogFuncSGIS(GLfloat * points) {
    PFN_GLGETFOGFUNCSGIS _ptr;
    _ptr = (PFN_GLGETFOGFUNCSGIS)_getPrivateProcAddress("glGetFogFuncSGIS");
    if (!_ptr) {
        _ptr = &_fail_glGetFogFuncSGIS;
    }
    _glGetFogFuncSGIS = _ptr;
    _glGetFogFuncSGIS(points);
}

PFN_GLGETFOGFUNCSGIS _glGetFogFuncSGIS = &_get_glGetFogFuncSGIS;

static void APIENTRY _fail_glSampleMaskSGIS(GLclampf value, GLboolean invert) {
    const char *_name = "glSampleMaskSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSampleMaskSGIS(GLclampf value, GLboolean invert) {
    PFN_GLSAMPLEMASKSGIS _ptr;
    _ptr = (PFN_GLSAMPLEMASKSGIS)_getPrivateProcAddress("glSampleMaskSGIS");
    if (!_ptr) {
        _ptr = &_fail_glSampleMaskSGIS;
    }
    _glSampleMaskSGIS = _ptr;
    _glSampleMaskSGIS(value, invert);
}

PFN_GLSAMPLEMASKSGIS _glSampleMaskSGIS = &_get_glSampleMaskSGIS;

static void APIENTRY _fail_glSamplePatternSGIS(GLenum pattern) {
    const char *_name = "glSamplePatternSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSamplePatternSGIS(GLenum pattern) {
    PFN_GLSAMPLEPATTERNSGIS _ptr;
    _ptr = (PFN_GLSAMPLEPATTERNSGIS)_getPrivateProcAddress("glSamplePatternSGIS");
    if (!_ptr) {
        _ptr = &_fail_glSamplePatternSGIS;
    }
    _glSamplePatternSGIS = _ptr;
    _glSamplePatternSGIS(pattern);
}

PFN_GLSAMPLEPATTERNSGIS _glSamplePatternSGIS = &_get_glSamplePatternSGIS;

static void APIENTRY _fail_glPixelTexGenParameteriSGIS(GLenum pname, GLint param) {
    const char *_name = "glPixelTexGenParameteriSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPixelTexGenParameteriSGIS(GLenum pname, GLint param) {
    PFN_GLPIXELTEXGENPARAMETERISGIS _ptr;
    _ptr = (PFN_GLPIXELTEXGENPARAMETERISGIS)_getPrivateProcAddress("glPixelTexGenParameteriSGIS");
    if (!_ptr) {
        _ptr = &_fail_glPixelTexGenParameteriSGIS;
    }
    _glPixelTexGenParameteriSGIS = _ptr;
    _glPixelTexGenParameteriSGIS(pname, param);
}

PFN_GLPIXELTEXGENPARAMETERISGIS _glPixelTexGenParameteriSGIS = &_get_glPixelTexGenParameteriSGIS;

static void APIENTRY _fail_glPixelTexGenParameterivSGIS(GLenum pname, const GLint * params) {
    const char *_name = "glPixelTexGenParameterivSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPixelTexGenParameterivSGIS(GLenum pname, const GLint * params) {
    PFN_GLPIXELTEXGENPARAMETERIVSGIS _ptr;
    _ptr = (PFN_GLPIXELTEXGENPARAMETERIVSGIS)_getPrivateProcAddress("glPixelTexGenParameterivSGIS");
    if (!_ptr) {
        _ptr = &_fail_glPixelTexGenParameterivSGIS;
    }
    _glPixelTexGenParameterivSGIS = _ptr;
    _glPixelTexGenParameterivSGIS(pname, params);
}

PFN_GLPIXELTEXGENPARAMETERIVSGIS _glPixelTexGenParameterivSGIS = &_get_glPixelTexGenParameterivSGIS;

static void APIENTRY _fail_glPixelTexGenParameterfSGIS(GLenum pname, GLfloat param) {
    const char *_name = "glPixelTexGenParameterfSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPixelTexGenParameterfSGIS(GLenum pname, GLfloat param) {
    PFN_GLPIXELTEXGENPARAMETERFSGIS _ptr;
    _ptr = (PFN_GLPIXELTEXGENPARAMETERFSGIS)_getPrivateProcAddress("glPixelTexGenParameterfSGIS");
    if (!_ptr) {
        _ptr = &_fail_glPixelTexGenParameterfSGIS;
    }
    _glPixelTexGenParameterfSGIS = _ptr;
    _glPixelTexGenParameterfSGIS(pname, param);
}

PFN_GLPIXELTEXGENPARAMETERFSGIS _glPixelTexGenParameterfSGIS = &_get_glPixelTexGenParameterfSGIS;

static void APIENTRY _fail_glPixelTexGenParameterfvSGIS(GLenum pname, const GLfloat * params) {
    const char *_name = "glPixelTexGenParameterfvSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPixelTexGenParameterfvSGIS(GLenum pname, const GLfloat * params) {
    PFN_GLPIXELTEXGENPARAMETERFVSGIS _ptr;
    _ptr = (PFN_GLPIXELTEXGENPARAMETERFVSGIS)_getPrivateProcAddress("glPixelTexGenParameterfvSGIS");
    if (!_ptr) {
        _ptr = &_fail_glPixelTexGenParameterfvSGIS;
    }
    _glPixelTexGenParameterfvSGIS = _ptr;
    _glPixelTexGenParameterfvSGIS(pname, params);
}

PFN_GLPIXELTEXGENPARAMETERFVSGIS _glPixelTexGenParameterfvSGIS = &_get_glPixelTexGenParameterfvSGIS;

static void APIENTRY _fail_glGetPixelTexGenParameterivSGIS(GLenum pname, GLint * params) {
    const char *_name = "glGetPixelTexGenParameterivSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPixelTexGenParameterivSGIS(GLenum pname, GLint * params) {
    PFN_GLGETPIXELTEXGENPARAMETERIVSGIS _ptr;
    _ptr = (PFN_GLGETPIXELTEXGENPARAMETERIVSGIS)_getPrivateProcAddress("glGetPixelTexGenParameterivSGIS");
    if (!_ptr) {
        _ptr = &_fail_glGetPixelTexGenParameterivSGIS;
    }
    _glGetPixelTexGenParameterivSGIS = _ptr;
    _glGetPixelTexGenParameterivSGIS(pname, params);
}

PFN_GLGETPIXELTEXGENPARAMETERIVSGIS _glGetPixelTexGenParameterivSGIS = &_get_glGetPixelTexGenParameterivSGIS;

static void APIENTRY _fail_glGetPixelTexGenParameterfvSGIS(GLenum pname, GLfloat * params) {
    const char *_name = "glGetPixelTexGenParameterfvSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetPixelTexGenParameterfvSGIS(GLenum pname, GLfloat * params) {
    PFN_GLGETPIXELTEXGENPARAMETERFVSGIS _ptr;
    _ptr = (PFN_GLGETPIXELTEXGENPARAMETERFVSGIS)_getPrivateProcAddress("glGetPixelTexGenParameterfvSGIS");
    if (!_ptr) {
        _ptr = &_fail_glGetPixelTexGenParameterfvSGIS;
    }
    _glGetPixelTexGenParameterfvSGIS = _ptr;
    _glGetPixelTexGenParameterfvSGIS(pname, params);
}

PFN_GLGETPIXELTEXGENPARAMETERFVSGIS _glGetPixelTexGenParameterfvSGIS = &_get_glGetPixelTexGenParameterfvSGIS;

static void APIENTRY _fail_glPointParameterfSGIS(GLenum pname, GLfloat param) {
    const char *_name = "glPointParameterfSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPointParameterfSGIS(GLenum pname, GLfloat param) {
    PFN_GLPOINTPARAMETERFSGIS _ptr;
    _ptr = (PFN_GLPOINTPARAMETERFSGIS)_getPrivateProcAddress("glPointParameterfSGIS");
    if (!_ptr) {
        _ptr = &_fail_glPointParameterfSGIS;
    }
    _glPointParameterfSGIS = _ptr;
    _glPointParameterfSGIS(pname, param);
}

PFN_GLPOINTPARAMETERFSGIS _glPointParameterfSGIS = &_get_glPointParameterfSGIS;

static void APIENTRY _fail_glPointParameterfvSGIS(GLenum pname, const GLfloat * params) {
    const char *_name = "glPointParameterfvSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPointParameterfvSGIS(GLenum pname, const GLfloat * params) {
    PFN_GLPOINTPARAMETERFVSGIS _ptr;
    _ptr = (PFN_GLPOINTPARAMETERFVSGIS)_getPrivateProcAddress("glPointParameterfvSGIS");
    if (!_ptr) {
        _ptr = &_fail_glPointParameterfvSGIS;
    }
    _glPointParameterfvSGIS = _ptr;
    _glPointParameterfvSGIS(pname, params);
}

PFN_GLPOINTPARAMETERFVSGIS _glPointParameterfvSGIS = &_get_glPointParameterfvSGIS;

static void APIENTRY _fail_glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat * points) {
    const char *_name = "glSharpenTexFuncSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat * points) {
    PFN_GLSHARPENTEXFUNCSGIS _ptr;
    _ptr = (PFN_GLSHARPENTEXFUNCSGIS)_getPrivateProcAddress("glSharpenTexFuncSGIS");
    if (!_ptr) {
        _ptr = &_fail_glSharpenTexFuncSGIS;
    }
    _glSharpenTexFuncSGIS = _ptr;
    _glSharpenTexFuncSGIS(target, n, points);
}

PFN_GLSHARPENTEXFUNCSGIS _glSharpenTexFuncSGIS = &_get_glSharpenTexFuncSGIS;

static void APIENTRY _fail_glGetSharpenTexFuncSGIS(GLenum target, GLfloat * points) {
    const char *_name = "glGetSharpenTexFuncSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetSharpenTexFuncSGIS(GLenum target, GLfloat * points) {
    PFN_GLGETSHARPENTEXFUNCSGIS _ptr;
    _ptr = (PFN_GLGETSHARPENTEXFUNCSGIS)_getPrivateProcAddress("glGetSharpenTexFuncSGIS");
    if (!_ptr) {
        _ptr = &_fail_glGetSharpenTexFuncSGIS;
    }
    _glGetSharpenTexFuncSGIS = _ptr;
    _glGetSharpenTexFuncSGIS(target, points);
}

PFN_GLGETSHARPENTEXFUNCSGIS _glGetSharpenTexFuncSGIS = &_get_glGetSharpenTexFuncSGIS;

static void APIENTRY _fail_glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexImage4DSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXIMAGE4DSGIS _ptr;
    _ptr = (PFN_GLTEXIMAGE4DSGIS)_getPrivateProcAddress("glTexImage4DSGIS");
    if (!_ptr) {
        _ptr = &_fail_glTexImage4DSGIS;
    }
    _glTexImage4DSGIS = _ptr;
    _glTexImage4DSGIS(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
}

PFN_GLTEXIMAGE4DSGIS _glTexImage4DSGIS = &_get_glTexImage4DSGIS;

static void APIENTRY _fail_glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid * pixels) {
    const char *_name = "glTexSubImage4DSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid * pixels) {
    PFN_GLTEXSUBIMAGE4DSGIS _ptr;
    _ptr = (PFN_GLTEXSUBIMAGE4DSGIS)_getPrivateProcAddress("glTexSubImage4DSGIS");
    if (!_ptr) {
        _ptr = &_fail_glTexSubImage4DSGIS;
    }
    _glTexSubImage4DSGIS = _ptr;
    _glTexSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
}

PFN_GLTEXSUBIMAGE4DSGIS _glTexSubImage4DSGIS = &_get_glTexSubImage4DSGIS;

static void APIENTRY _fail_glTextureColorMaskSGIS(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {
    const char *_name = "glTextureColorMaskSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTextureColorMaskSGIS(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {
    PFN_GLTEXTURECOLORMASKSGIS _ptr;
    _ptr = (PFN_GLTEXTURECOLORMASKSGIS)_getPrivateProcAddress("glTextureColorMaskSGIS");
    if (!_ptr) {
        _ptr = &_fail_glTextureColorMaskSGIS;
    }
    _glTextureColorMaskSGIS = _ptr;
    _glTextureColorMaskSGIS(red, green, blue, alpha);
}

PFN_GLTEXTURECOLORMASKSGIS _glTextureColorMaskSGIS = &_get_glTextureColorMaskSGIS;

static void APIENTRY _fail_glGetTexFilterFuncSGIS(GLenum target, GLenum filter, GLfloat * weights) {
    const char *_name = "glGetTexFilterFuncSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetTexFilterFuncSGIS(GLenum target, GLenum filter, GLfloat * weights) {
    PFN_GLGETTEXFILTERFUNCSGIS _ptr;
    _ptr = (PFN_GLGETTEXFILTERFUNCSGIS)_getPrivateProcAddress("glGetTexFilterFuncSGIS");
    if (!_ptr) {
        _ptr = &_fail_glGetTexFilterFuncSGIS;
    }
    _glGetTexFilterFuncSGIS = _ptr;
    _glGetTexFilterFuncSGIS(target, filter, weights);
}

PFN_GLGETTEXFILTERFUNCSGIS _glGetTexFilterFuncSGIS = &_get_glGetTexFilterFuncSGIS;

static void APIENTRY _fail_glTexFilterFuncSGIS(GLenum target, GLenum filter, GLsizei n, const GLfloat * weights) {
    const char *_name = "glTexFilterFuncSGIS";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexFilterFuncSGIS(GLenum target, GLenum filter, GLsizei n, const GLfloat * weights) {
    PFN_GLTEXFILTERFUNCSGIS _ptr;
    _ptr = (PFN_GLTEXFILTERFUNCSGIS)_getPrivateProcAddress("glTexFilterFuncSGIS");
    if (!_ptr) {
        _ptr = &_fail_glTexFilterFuncSGIS;
    }
    _glTexFilterFuncSGIS = _ptr;
    _glTexFilterFuncSGIS(target, filter, n, weights);
}

PFN_GLTEXFILTERFUNCSGIS _glTexFilterFuncSGIS = &_get_glTexFilterFuncSGIS;

static void APIENTRY _fail_glAsyncMarkerSGIX(GLuint marker) {
    const char *_name = "glAsyncMarkerSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glAsyncMarkerSGIX(GLuint marker) {
    PFN_GLASYNCMARKERSGIX _ptr;
    _ptr = (PFN_GLASYNCMARKERSGIX)_getPrivateProcAddress("glAsyncMarkerSGIX");
    if (!_ptr) {
        _ptr = &_fail_glAsyncMarkerSGIX;
    }
    _glAsyncMarkerSGIX = _ptr;
    _glAsyncMarkerSGIX(marker);
}

PFN_GLASYNCMARKERSGIX _glAsyncMarkerSGIX = &_get_glAsyncMarkerSGIX;

static GLint APIENTRY _fail_glFinishAsyncSGIX(GLuint * markerp) {
    const char *_name = "glFinishAsyncSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLint APIENTRY _get_glFinishAsyncSGIX(GLuint * markerp) {
    PFN_GLFINISHASYNCSGIX _ptr;
    _ptr = (PFN_GLFINISHASYNCSGIX)_getPrivateProcAddress("glFinishAsyncSGIX");
    if (!_ptr) {
        _ptr = &_fail_glFinishAsyncSGIX;
    }
    _glFinishAsyncSGIX = _ptr;
    return _glFinishAsyncSGIX(markerp);
}

PFN_GLFINISHASYNCSGIX _glFinishAsyncSGIX = &_get_glFinishAsyncSGIX;

static GLint APIENTRY _fail_glPollAsyncSGIX(GLuint * markerp) {
    const char *_name = "glPollAsyncSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLint APIENTRY _get_glPollAsyncSGIX(GLuint * markerp) {
    PFN_GLPOLLASYNCSGIX _ptr;
    _ptr = (PFN_GLPOLLASYNCSGIX)_getPrivateProcAddress("glPollAsyncSGIX");
    if (!_ptr) {
        _ptr = &_fail_glPollAsyncSGIX;
    }
    _glPollAsyncSGIX = _ptr;
    return _glPollAsyncSGIX(markerp);
}

PFN_GLPOLLASYNCSGIX _glPollAsyncSGIX = &_get_glPollAsyncSGIX;

static GLuint APIENTRY _fail_glGenAsyncMarkersSGIX(GLsizei range) {
    const char *_name = "glGenAsyncMarkersSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLuint APIENTRY _get_glGenAsyncMarkersSGIX(GLsizei range) {
    PFN_GLGENASYNCMARKERSSGIX _ptr;
    _ptr = (PFN_GLGENASYNCMARKERSSGIX)_getPrivateProcAddress("glGenAsyncMarkersSGIX");
    if (!_ptr) {
        _ptr = &_fail_glGenAsyncMarkersSGIX;
    }
    _glGenAsyncMarkersSGIX = _ptr;
    return _glGenAsyncMarkersSGIX(range);
}

PFN_GLGENASYNCMARKERSSGIX _glGenAsyncMarkersSGIX = &_get_glGenAsyncMarkersSGIX;

static void APIENTRY _fail_glDeleteAsyncMarkersSGIX(GLuint marker, GLsizei range) {
    const char *_name = "glDeleteAsyncMarkersSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeleteAsyncMarkersSGIX(GLuint marker, GLsizei range) {
    PFN_GLDELETEASYNCMARKERSSGIX _ptr;
    _ptr = (PFN_GLDELETEASYNCMARKERSSGIX)_getPrivateProcAddress("glDeleteAsyncMarkersSGIX");
    if (!_ptr) {
        _ptr = &_fail_glDeleteAsyncMarkersSGIX;
    }
    _glDeleteAsyncMarkersSGIX = _ptr;
    _glDeleteAsyncMarkersSGIX(marker, range);
}

PFN_GLDELETEASYNCMARKERSSGIX _glDeleteAsyncMarkersSGIX = &_get_glDeleteAsyncMarkersSGIX;

static GLboolean APIENTRY _fail_glIsAsyncMarkerSGIX(GLuint marker) {
    const char *_name = "glIsAsyncMarkerSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLboolean APIENTRY _get_glIsAsyncMarkerSGIX(GLuint marker) {
    PFN_GLISASYNCMARKERSGIX _ptr;
    _ptr = (PFN_GLISASYNCMARKERSGIX)_getPrivateProcAddress("glIsAsyncMarkerSGIX");
    if (!_ptr) {
        _ptr = &_fail_glIsAsyncMarkerSGIX;
    }
    _glIsAsyncMarkerSGIX = _ptr;
    return _glIsAsyncMarkerSGIX(marker);
}

PFN_GLISASYNCMARKERSGIX _glIsAsyncMarkerSGIX = &_get_glIsAsyncMarkerSGIX;

static void APIENTRY _fail_glFlushRasterSGIX(void) {
    const char *_name = "glFlushRasterSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFlushRasterSGIX(void) {
    PFN_GLFLUSHRASTERSGIX _ptr;
    _ptr = (PFN_GLFLUSHRASTERSGIX)_getPrivateProcAddress("glFlushRasterSGIX");
    if (!_ptr) {
        _ptr = &_fail_glFlushRasterSGIX;
    }
    _glFlushRasterSGIX = _ptr;
    _glFlushRasterSGIX();
}

PFN_GLFLUSHRASTERSGIX _glFlushRasterSGIX = &_get_glFlushRasterSGIX;

static void APIENTRY _fail_glFragmentColorMaterialSGIX(GLenum face, GLenum mode) {
    const char *_name = "glFragmentColorMaterialSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFragmentColorMaterialSGIX(GLenum face, GLenum mode) {
    PFN_GLFRAGMENTCOLORMATERIALSGIX _ptr;
    _ptr = (PFN_GLFRAGMENTCOLORMATERIALSGIX)_getPrivateProcAddress("glFragmentColorMaterialSGIX");
    if (!_ptr) {
        _ptr = &_fail_glFragmentColorMaterialSGIX;
    }
    _glFragmentColorMaterialSGIX = _ptr;
    _glFragmentColorMaterialSGIX(face, mode);
}

PFN_GLFRAGMENTCOLORMATERIALSGIX _glFragmentColorMaterialSGIX = &_get_glFragmentColorMaterialSGIX;

static void APIENTRY _fail_glFragmentLightfSGIX(GLenum light, GLenum pname, GLfloat param) {
    const char *_name = "glFragmentLightfSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFragmentLightfSGIX(GLenum light, GLenum pname, GLfloat param) {
    PFN_GLFRAGMENTLIGHTFSGIX _ptr;
    _ptr = (PFN_GLFRAGMENTLIGHTFSGIX)_getPrivateProcAddress("glFragmentLightfSGIX");
    if (!_ptr) {
        _ptr = &_fail_glFragmentLightfSGIX;
    }
    _glFragmentLightfSGIX = _ptr;
    _glFragmentLightfSGIX(light, pname, param);
}

PFN_GLFRAGMENTLIGHTFSGIX _glFragmentLightfSGIX = &_get_glFragmentLightfSGIX;

static void APIENTRY _fail_glFragmentLightfvSGIX(GLenum light, GLenum pname, const GLfloat * params) {
    const char *_name = "glFragmentLightfvSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFragmentLightfvSGIX(GLenum light, GLenum pname, const GLfloat * params) {
    PFN_GLFRAGMENTLIGHTFVSGIX _ptr;
    _ptr = (PFN_GLFRAGMENTLIGHTFVSGIX)_getPrivateProcAddress("glFragmentLightfvSGIX");
    if (!_ptr) {
        _ptr = &_fail_glFragmentLightfvSGIX;
    }
    _glFragmentLightfvSGIX = _ptr;
    _glFragmentLightfvSGIX(light, pname, params);
}

PFN_GLFRAGMENTLIGHTFVSGIX _glFragmentLightfvSGIX = &_get_glFragmentLightfvSGIX;

static void APIENTRY _fail_glFragmentLightiSGIX(GLenum light, GLenum pname, GLint param) {
    const char *_name = "glFragmentLightiSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFragmentLightiSGIX(GLenum light, GLenum pname, GLint param) {
    PFN_GLFRAGMENTLIGHTISGIX _ptr;
    _ptr = (PFN_GLFRAGMENTLIGHTISGIX)_getPrivateProcAddress("glFragmentLightiSGIX");
    if (!_ptr) {
        _ptr = &_fail_glFragmentLightiSGIX;
    }
    _glFragmentLightiSGIX = _ptr;
    _glFragmentLightiSGIX(light, pname, param);
}

PFN_GLFRAGMENTLIGHTISGIX _glFragmentLightiSGIX = &_get_glFragmentLightiSGIX;

static void APIENTRY _fail_glFragmentLightivSGIX(GLenum light, GLenum pname, const GLint * params) {
    const char *_name = "glFragmentLightivSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFragmentLightivSGIX(GLenum light, GLenum pname, const GLint * params) {
    PFN_GLFRAGMENTLIGHTIVSGIX _ptr;
    _ptr = (PFN_GLFRAGMENTLIGHTIVSGIX)_getPrivateProcAddress("glFragmentLightivSGIX");
    if (!_ptr) {
        _ptr = &_fail_glFragmentLightivSGIX;
    }
    _glFragmentLightivSGIX = _ptr;
    _glFragmentLightivSGIX(light, pname, params);
}

PFN_GLFRAGMENTLIGHTIVSGIX _glFragmentLightivSGIX = &_get_glFragmentLightivSGIX;

static void APIENTRY _fail_glFragmentLightModelfSGIX(GLenum pname, GLfloat param) {
    const char *_name = "glFragmentLightModelfSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFragmentLightModelfSGIX(GLenum pname, GLfloat param) {
    PFN_GLFRAGMENTLIGHTMODELFSGIX _ptr;
    _ptr = (PFN_GLFRAGMENTLIGHTMODELFSGIX)_getPrivateProcAddress("glFragmentLightModelfSGIX");
    if (!_ptr) {
        _ptr = &_fail_glFragmentLightModelfSGIX;
    }
    _glFragmentLightModelfSGIX = _ptr;
    _glFragmentLightModelfSGIX(pname, param);
}

PFN_GLFRAGMENTLIGHTMODELFSGIX _glFragmentLightModelfSGIX = &_get_glFragmentLightModelfSGIX;

static void APIENTRY _fail_glFragmentLightModelfvSGIX(GLenum pname, const GLfloat * params) {
    const char *_name = "glFragmentLightModelfvSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFragmentLightModelfvSGIX(GLenum pname, const GLfloat * params) {
    PFN_GLFRAGMENTLIGHTMODELFVSGIX _ptr;
    _ptr = (PFN_GLFRAGMENTLIGHTMODELFVSGIX)_getPrivateProcAddress("glFragmentLightModelfvSGIX");
    if (!_ptr) {
        _ptr = &_fail_glFragmentLightModelfvSGIX;
    }
    _glFragmentLightModelfvSGIX = _ptr;
    _glFragmentLightModelfvSGIX(pname, params);
}

PFN_GLFRAGMENTLIGHTMODELFVSGIX _glFragmentLightModelfvSGIX = &_get_glFragmentLightModelfvSGIX;

static void APIENTRY _fail_glFragmentLightModeliSGIX(GLenum pname, GLint param) {
    const char *_name = "glFragmentLightModeliSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFragmentLightModeliSGIX(GLenum pname, GLint param) {
    PFN_GLFRAGMENTLIGHTMODELISGIX _ptr;
    _ptr = (PFN_GLFRAGMENTLIGHTMODELISGIX)_getPrivateProcAddress("glFragmentLightModeliSGIX");
    if (!_ptr) {
        _ptr = &_fail_glFragmentLightModeliSGIX;
    }
    _glFragmentLightModeliSGIX = _ptr;
    _glFragmentLightModeliSGIX(pname, param);
}

PFN_GLFRAGMENTLIGHTMODELISGIX _glFragmentLightModeliSGIX = &_get_glFragmentLightModeliSGIX;

static void APIENTRY _fail_glFragmentLightModelivSGIX(GLenum pname, const GLint * params) {
    const char *_name = "glFragmentLightModelivSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFragmentLightModelivSGIX(GLenum pname, const GLint * params) {
    PFN_GLFRAGMENTLIGHTMODELIVSGIX _ptr;
    _ptr = (PFN_GLFRAGMENTLIGHTMODELIVSGIX)_getPrivateProcAddress("glFragmentLightModelivSGIX");
    if (!_ptr) {
        _ptr = &_fail_glFragmentLightModelivSGIX;
    }
    _glFragmentLightModelivSGIX = _ptr;
    _glFragmentLightModelivSGIX(pname, params);
}

PFN_GLFRAGMENTLIGHTMODELIVSGIX _glFragmentLightModelivSGIX = &_get_glFragmentLightModelivSGIX;

static void APIENTRY _fail_glFragmentMaterialfSGIX(GLenum face, GLenum pname, GLfloat param) {
    const char *_name = "glFragmentMaterialfSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFragmentMaterialfSGIX(GLenum face, GLenum pname, GLfloat param) {
    PFN_GLFRAGMENTMATERIALFSGIX _ptr;
    _ptr = (PFN_GLFRAGMENTMATERIALFSGIX)_getPrivateProcAddress("glFragmentMaterialfSGIX");
    if (!_ptr) {
        _ptr = &_fail_glFragmentMaterialfSGIX;
    }
    _glFragmentMaterialfSGIX = _ptr;
    _glFragmentMaterialfSGIX(face, pname, param);
}

PFN_GLFRAGMENTMATERIALFSGIX _glFragmentMaterialfSGIX = &_get_glFragmentMaterialfSGIX;

static void APIENTRY _fail_glFragmentMaterialfvSGIX(GLenum face, GLenum pname, const GLfloat * params) {
    const char *_name = "glFragmentMaterialfvSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFragmentMaterialfvSGIX(GLenum face, GLenum pname, const GLfloat * params) {
    PFN_GLFRAGMENTMATERIALFVSGIX _ptr;
    _ptr = (PFN_GLFRAGMENTMATERIALFVSGIX)_getPrivateProcAddress("glFragmentMaterialfvSGIX");
    if (!_ptr) {
        _ptr = &_fail_glFragmentMaterialfvSGIX;
    }
    _glFragmentMaterialfvSGIX = _ptr;
    _glFragmentMaterialfvSGIX(face, pname, params);
}

PFN_GLFRAGMENTMATERIALFVSGIX _glFragmentMaterialfvSGIX = &_get_glFragmentMaterialfvSGIX;

static void APIENTRY _fail_glFragmentMaterialiSGIX(GLenum face, GLenum pname, GLint param) {
    const char *_name = "glFragmentMaterialiSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFragmentMaterialiSGIX(GLenum face, GLenum pname, GLint param) {
    PFN_GLFRAGMENTMATERIALISGIX _ptr;
    _ptr = (PFN_GLFRAGMENTMATERIALISGIX)_getPrivateProcAddress("glFragmentMaterialiSGIX");
    if (!_ptr) {
        _ptr = &_fail_glFragmentMaterialiSGIX;
    }
    _glFragmentMaterialiSGIX = _ptr;
    _glFragmentMaterialiSGIX(face, pname, param);
}

PFN_GLFRAGMENTMATERIALISGIX _glFragmentMaterialiSGIX = &_get_glFragmentMaterialiSGIX;

static void APIENTRY _fail_glFragmentMaterialivSGIX(GLenum face, GLenum pname, const GLint * params) {
    const char *_name = "glFragmentMaterialivSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFragmentMaterialivSGIX(GLenum face, GLenum pname, const GLint * params) {
    PFN_GLFRAGMENTMATERIALIVSGIX _ptr;
    _ptr = (PFN_GLFRAGMENTMATERIALIVSGIX)_getPrivateProcAddress("glFragmentMaterialivSGIX");
    if (!_ptr) {
        _ptr = &_fail_glFragmentMaterialivSGIX;
    }
    _glFragmentMaterialivSGIX = _ptr;
    _glFragmentMaterialivSGIX(face, pname, params);
}

PFN_GLFRAGMENTMATERIALIVSGIX _glFragmentMaterialivSGIX = &_get_glFragmentMaterialivSGIX;

static void APIENTRY _fail_glGetFragmentLightfvSGIX(GLenum light, GLenum pname, GLfloat * params) {
    const char *_name = "glGetFragmentLightfvSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFragmentLightfvSGIX(GLenum light, GLenum pname, GLfloat * params) {
    PFN_GLGETFRAGMENTLIGHTFVSGIX _ptr;
    _ptr = (PFN_GLGETFRAGMENTLIGHTFVSGIX)_getPrivateProcAddress("glGetFragmentLightfvSGIX");
    if (!_ptr) {
        _ptr = &_fail_glGetFragmentLightfvSGIX;
    }
    _glGetFragmentLightfvSGIX = _ptr;
    _glGetFragmentLightfvSGIX(light, pname, params);
}

PFN_GLGETFRAGMENTLIGHTFVSGIX _glGetFragmentLightfvSGIX = &_get_glGetFragmentLightfvSGIX;

static void APIENTRY _fail_glGetFragmentLightivSGIX(GLenum light, GLenum pname, GLint * params) {
    const char *_name = "glGetFragmentLightivSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFragmentLightivSGIX(GLenum light, GLenum pname, GLint * params) {
    PFN_GLGETFRAGMENTLIGHTIVSGIX _ptr;
    _ptr = (PFN_GLGETFRAGMENTLIGHTIVSGIX)_getPrivateProcAddress("glGetFragmentLightivSGIX");
    if (!_ptr) {
        _ptr = &_fail_glGetFragmentLightivSGIX;
    }
    _glGetFragmentLightivSGIX = _ptr;
    _glGetFragmentLightivSGIX(light, pname, params);
}

PFN_GLGETFRAGMENTLIGHTIVSGIX _glGetFragmentLightivSGIX = &_get_glGetFragmentLightivSGIX;

static void APIENTRY _fail_glGetFragmentMaterialfvSGIX(GLenum face, GLenum pname, GLfloat * params) {
    const char *_name = "glGetFragmentMaterialfvSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFragmentMaterialfvSGIX(GLenum face, GLenum pname, GLfloat * params) {
    PFN_GLGETFRAGMENTMATERIALFVSGIX _ptr;
    _ptr = (PFN_GLGETFRAGMENTMATERIALFVSGIX)_getPrivateProcAddress("glGetFragmentMaterialfvSGIX");
    if (!_ptr) {
        _ptr = &_fail_glGetFragmentMaterialfvSGIX;
    }
    _glGetFragmentMaterialfvSGIX = _ptr;
    _glGetFragmentMaterialfvSGIX(face, pname, params);
}

PFN_GLGETFRAGMENTMATERIALFVSGIX _glGetFragmentMaterialfvSGIX = &_get_glGetFragmentMaterialfvSGIX;

static void APIENTRY _fail_glGetFragmentMaterialivSGIX(GLenum face, GLenum pname, GLint * params) {
    const char *_name = "glGetFragmentMaterialivSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetFragmentMaterialivSGIX(GLenum face, GLenum pname, GLint * params) {
    PFN_GLGETFRAGMENTMATERIALIVSGIX _ptr;
    _ptr = (PFN_GLGETFRAGMENTMATERIALIVSGIX)_getPrivateProcAddress("glGetFragmentMaterialivSGIX");
    if (!_ptr) {
        _ptr = &_fail_glGetFragmentMaterialivSGIX;
    }
    _glGetFragmentMaterialivSGIX = _ptr;
    _glGetFragmentMaterialivSGIX(face, pname, params);
}

PFN_GLGETFRAGMENTMATERIALIVSGIX _glGetFragmentMaterialivSGIX = &_get_glGetFragmentMaterialivSGIX;

static void APIENTRY _fail_glLightEnviSGIX(GLenum pname, GLint param) {
    const char *_name = "glLightEnviSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLightEnviSGIX(GLenum pname, GLint param) {
    PFN_GLLIGHTENVISGIX _ptr;
    _ptr = (PFN_GLLIGHTENVISGIX)_getPrivateProcAddress("glLightEnviSGIX");
    if (!_ptr) {
        _ptr = &_fail_glLightEnviSGIX;
    }
    _glLightEnviSGIX = _ptr;
    _glLightEnviSGIX(pname, param);
}

PFN_GLLIGHTENVISGIX _glLightEnviSGIX = &_get_glLightEnviSGIX;

static void APIENTRY _fail_glFrameZoomSGIX(GLint factor) {
    const char *_name = "glFrameZoomSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFrameZoomSGIX(GLint factor) {
    PFN_GLFRAMEZOOMSGIX _ptr;
    _ptr = (PFN_GLFRAMEZOOMSGIX)_getPrivateProcAddress("glFrameZoomSGIX");
    if (!_ptr) {
        _ptr = &_fail_glFrameZoomSGIX;
    }
    _glFrameZoomSGIX = _ptr;
    _glFrameZoomSGIX(factor);
}

PFN_GLFRAMEZOOMSGIX _glFrameZoomSGIX = &_get_glFrameZoomSGIX;

static void APIENTRY _fail_glIglooInterfaceSGIX(GLenum pname, const GLvoid * params) {
    const char *_name = "glIglooInterfaceSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glIglooInterfaceSGIX(GLenum pname, const GLvoid * params) {
    PFN_GLIGLOOINTERFACESGIX _ptr;
    _ptr = (PFN_GLIGLOOINTERFACESGIX)_getPrivateProcAddress("glIglooInterfaceSGIX");
    if (!_ptr) {
        _ptr = &_fail_glIglooInterfaceSGIX;
    }
    _glIglooInterfaceSGIX = _ptr;
    _glIglooInterfaceSGIX(pname, params);
}

PFN_GLIGLOOINTERFACESGIX _glIglooInterfaceSGIX = &_get_glIglooInterfaceSGIX;

static GLint APIENTRY _fail_glGetInstrumentsSGIX(void) {
    const char *_name = "glGetInstrumentsSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLint APIENTRY _get_glGetInstrumentsSGIX(void) {
    PFN_GLGETINSTRUMENTSSGIX _ptr;
    _ptr = (PFN_GLGETINSTRUMENTSSGIX)_getPrivateProcAddress("glGetInstrumentsSGIX");
    if (!_ptr) {
        _ptr = &_fail_glGetInstrumentsSGIX;
    }
    _glGetInstrumentsSGIX = _ptr;
    return _glGetInstrumentsSGIX();
}

PFN_GLGETINSTRUMENTSSGIX _glGetInstrumentsSGIX = &_get_glGetInstrumentsSGIX;

static void APIENTRY _fail_glInstrumentsBufferSGIX(GLsizei size, GLint * buffer) {
    const char *_name = "glInstrumentsBufferSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glInstrumentsBufferSGIX(GLsizei size, GLint * buffer) {
    PFN_GLINSTRUMENTSBUFFERSGIX _ptr;
    _ptr = (PFN_GLINSTRUMENTSBUFFERSGIX)_getPrivateProcAddress("glInstrumentsBufferSGIX");
    if (!_ptr) {
        _ptr = &_fail_glInstrumentsBufferSGIX;
    }
    _glInstrumentsBufferSGIX = _ptr;
    _glInstrumentsBufferSGIX(size, buffer);
}

PFN_GLINSTRUMENTSBUFFERSGIX _glInstrumentsBufferSGIX = &_get_glInstrumentsBufferSGIX;

static GLint APIENTRY _fail_glPollInstrumentsSGIX(GLint * marker_p) {
    const char *_name = "glPollInstrumentsSGIX";
    os::log("error: unavailable function %s\n", _name);
    os::abort();
}

static GLint APIENTRY _get_glPollInstrumentsSGIX(GLint * marker_p) {
    PFN_GLPOLLINSTRUMENTSSGIX _ptr;
    _ptr = (PFN_GLPOLLINSTRUMENTSSGIX)_getPrivateProcAddress("glPollInstrumentsSGIX");
    if (!_ptr) {
        _ptr = &_fail_glPollInstrumentsSGIX;
    }
    _glPollInstrumentsSGIX = _ptr;
    return _glPollInstrumentsSGIX(marker_p);
}

PFN_GLPOLLINSTRUMENTSSGIX _glPollInstrumentsSGIX = &_get_glPollInstrumentsSGIX;

static void APIENTRY _fail_glReadInstrumentsSGIX(GLint marker) {
    const char *_name = "glReadInstrumentsSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReadInstrumentsSGIX(GLint marker) {
    PFN_GLREADINSTRUMENTSSGIX _ptr;
    _ptr = (PFN_GLREADINSTRUMENTSSGIX)_getPrivateProcAddress("glReadInstrumentsSGIX");
    if (!_ptr) {
        _ptr = &_fail_glReadInstrumentsSGIX;
    }
    _glReadInstrumentsSGIX = _ptr;
    _glReadInstrumentsSGIX(marker);
}

PFN_GLREADINSTRUMENTSSGIX _glReadInstrumentsSGIX = &_get_glReadInstrumentsSGIX;

static void APIENTRY _fail_glStartInstrumentsSGIX(void) {
    const char *_name = "glStartInstrumentsSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStartInstrumentsSGIX(void) {
    PFN_GLSTARTINSTRUMENTSSGIX _ptr;
    _ptr = (PFN_GLSTARTINSTRUMENTSSGIX)_getPrivateProcAddress("glStartInstrumentsSGIX");
    if (!_ptr) {
        _ptr = &_fail_glStartInstrumentsSGIX;
    }
    _glStartInstrumentsSGIX = _ptr;
    _glStartInstrumentsSGIX();
}

PFN_GLSTARTINSTRUMENTSSGIX _glStartInstrumentsSGIX = &_get_glStartInstrumentsSGIX;

static void APIENTRY _fail_glStopInstrumentsSGIX(GLint marker) {
    const char *_name = "glStopInstrumentsSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glStopInstrumentsSGIX(GLint marker) {
    PFN_GLSTOPINSTRUMENTSSGIX _ptr;
    _ptr = (PFN_GLSTOPINSTRUMENTSSGIX)_getPrivateProcAddress("glStopInstrumentsSGIX");
    if (!_ptr) {
        _ptr = &_fail_glStopInstrumentsSGIX;
    }
    _glStopInstrumentsSGIX = _ptr;
    _glStopInstrumentsSGIX(marker);
}

PFN_GLSTOPINSTRUMENTSSGIX _glStopInstrumentsSGIX = &_get_glStopInstrumentsSGIX;

static void APIENTRY _fail_glGetListParameterfvSGIX(GLuint list, GLenum pname, GLfloat * params) {
    const char *_name = "glGetListParameterfvSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetListParameterfvSGIX(GLuint list, GLenum pname, GLfloat * params) {
    PFN_GLGETLISTPARAMETERFVSGIX _ptr;
    _ptr = (PFN_GLGETLISTPARAMETERFVSGIX)_getPrivateProcAddress("glGetListParameterfvSGIX");
    if (!_ptr) {
        _ptr = &_fail_glGetListParameterfvSGIX;
    }
    _glGetListParameterfvSGIX = _ptr;
    _glGetListParameterfvSGIX(list, pname, params);
}

PFN_GLGETLISTPARAMETERFVSGIX _glGetListParameterfvSGIX = &_get_glGetListParameterfvSGIX;

static void APIENTRY _fail_glGetListParameterivSGIX(GLuint list, GLenum pname, GLint * params) {
    const char *_name = "glGetListParameterivSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetListParameterivSGIX(GLuint list, GLenum pname, GLint * params) {
    PFN_GLGETLISTPARAMETERIVSGIX _ptr;
    _ptr = (PFN_GLGETLISTPARAMETERIVSGIX)_getPrivateProcAddress("glGetListParameterivSGIX");
    if (!_ptr) {
        _ptr = &_fail_glGetListParameterivSGIX;
    }
    _glGetListParameterivSGIX = _ptr;
    _glGetListParameterivSGIX(list, pname, params);
}

PFN_GLGETLISTPARAMETERIVSGIX _glGetListParameterivSGIX = &_get_glGetListParameterivSGIX;

static void APIENTRY _fail_glListParameterfSGIX(GLuint list, GLenum pname, GLfloat param) {
    const char *_name = "glListParameterfSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glListParameterfSGIX(GLuint list, GLenum pname, GLfloat param) {
    PFN_GLLISTPARAMETERFSGIX _ptr;
    _ptr = (PFN_GLLISTPARAMETERFSGIX)_getPrivateProcAddress("glListParameterfSGIX");
    if (!_ptr) {
        _ptr = &_fail_glListParameterfSGIX;
    }
    _glListParameterfSGIX = _ptr;
    _glListParameterfSGIX(list, pname, param);
}

PFN_GLLISTPARAMETERFSGIX _glListParameterfSGIX = &_get_glListParameterfSGIX;

static void APIENTRY _fail_glListParameterfvSGIX(GLuint list, GLenum pname, const GLfloat * params) {
    const char *_name = "glListParameterfvSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glListParameterfvSGIX(GLuint list, GLenum pname, const GLfloat * params) {
    PFN_GLLISTPARAMETERFVSGIX _ptr;
    _ptr = (PFN_GLLISTPARAMETERFVSGIX)_getPrivateProcAddress("glListParameterfvSGIX");
    if (!_ptr) {
        _ptr = &_fail_glListParameterfvSGIX;
    }
    _glListParameterfvSGIX = _ptr;
    _glListParameterfvSGIX(list, pname, params);
}

PFN_GLLISTPARAMETERFVSGIX _glListParameterfvSGIX = &_get_glListParameterfvSGIX;

static void APIENTRY _fail_glListParameteriSGIX(GLuint list, GLenum pname, GLint param) {
    const char *_name = "glListParameteriSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glListParameteriSGIX(GLuint list, GLenum pname, GLint param) {
    PFN_GLLISTPARAMETERISGIX _ptr;
    _ptr = (PFN_GLLISTPARAMETERISGIX)_getPrivateProcAddress("glListParameteriSGIX");
    if (!_ptr) {
        _ptr = &_fail_glListParameteriSGIX;
    }
    _glListParameteriSGIX = _ptr;
    _glListParameteriSGIX(list, pname, param);
}

PFN_GLLISTPARAMETERISGIX _glListParameteriSGIX = &_get_glListParameteriSGIX;

static void APIENTRY _fail_glListParameterivSGIX(GLuint list, GLenum pname, const GLint * params) {
    const char *_name = "glListParameterivSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glListParameterivSGIX(GLuint list, GLenum pname, const GLint * params) {
    PFN_GLLISTPARAMETERIVSGIX _ptr;
    _ptr = (PFN_GLLISTPARAMETERIVSGIX)_getPrivateProcAddress("glListParameterivSGIX");
    if (!_ptr) {
        _ptr = &_fail_glListParameterivSGIX;
    }
    _glListParameterivSGIX = _ptr;
    _glListParameterivSGIX(list, pname, params);
}

PFN_GLLISTPARAMETERIVSGIX _glListParameterivSGIX = &_get_glListParameterivSGIX;

static void APIENTRY _fail_glPixelTexGenSGIX(GLenum mode) {
    const char *_name = "glPixelTexGenSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glPixelTexGenSGIX(GLenum mode) {
    PFN_GLPIXELTEXGENSGIX _ptr;
    _ptr = (PFN_GLPIXELTEXGENSGIX)_getPrivateProcAddress("glPixelTexGenSGIX");
    if (!_ptr) {
        _ptr = &_fail_glPixelTexGenSGIX;
    }
    _glPixelTexGenSGIX = _ptr;
    _glPixelTexGenSGIX(mode);
}

PFN_GLPIXELTEXGENSGIX _glPixelTexGenSGIX = &_get_glPixelTexGenSGIX;

static void APIENTRY _fail_glDeformationMap3dSGIX(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble * points) {
    const char *_name = "glDeformationMap3dSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeformationMap3dSGIX(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble * points) {
    PFN_GLDEFORMATIONMAP3DSGIX _ptr;
    _ptr = (PFN_GLDEFORMATIONMAP3DSGIX)_getPrivateProcAddress("glDeformationMap3dSGIX");
    if (!_ptr) {
        _ptr = &_fail_glDeformationMap3dSGIX;
    }
    _glDeformationMap3dSGIX = _ptr;
    _glDeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
}

PFN_GLDEFORMATIONMAP3DSGIX _glDeformationMap3dSGIX = &_get_glDeformationMap3dSGIX;

static void APIENTRY _fail_glDeformationMap3fSGIX(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat * points) {
    const char *_name = "glDeformationMap3fSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeformationMap3fSGIX(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat * points) {
    PFN_GLDEFORMATIONMAP3FSGIX _ptr;
    _ptr = (PFN_GLDEFORMATIONMAP3FSGIX)_getPrivateProcAddress("glDeformationMap3fSGIX");
    if (!_ptr) {
        _ptr = &_fail_glDeformationMap3fSGIX;
    }
    _glDeformationMap3fSGIX = _ptr;
    _glDeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
}

PFN_GLDEFORMATIONMAP3FSGIX _glDeformationMap3fSGIX = &_get_glDeformationMap3fSGIX;

static void APIENTRY _fail_glDeformSGIX(GLbitfield mask) {
    const char *_name = "glDeformSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDeformSGIX(GLbitfield mask) {
    PFN_GLDEFORMSGIX _ptr;
    _ptr = (PFN_GLDEFORMSGIX)_getPrivateProcAddress("glDeformSGIX");
    if (!_ptr) {
        _ptr = &_fail_glDeformSGIX;
    }
    _glDeformSGIX = _ptr;
    _glDeformSGIX(mask);
}

PFN_GLDEFORMSGIX _glDeformSGIX = &_get_glDeformSGIX;

static void APIENTRY _fail_glLoadIdentityDeformationMapSGIX(GLbitfield mask) {
    const char *_name = "glLoadIdentityDeformationMapSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glLoadIdentityDeformationMapSGIX(GLbitfield mask) {
    PFN_GLLOADIDENTITYDEFORMATIONMAPSGIX _ptr;
    _ptr = (PFN_GLLOADIDENTITYDEFORMATIONMAPSGIX)_getPrivateProcAddress("glLoadIdentityDeformationMapSGIX");
    if (!_ptr) {
        _ptr = &_fail_glLoadIdentityDeformationMapSGIX;
    }
    _glLoadIdentityDeformationMapSGIX = _ptr;
    _glLoadIdentityDeformationMapSGIX(mask);
}

PFN_GLLOADIDENTITYDEFORMATIONMAPSGIX _glLoadIdentityDeformationMapSGIX = &_get_glLoadIdentityDeformationMapSGIX;

static void APIENTRY _fail_glReferencePlaneSGIX(const GLdouble * equation) {
    const char *_name = "glReferencePlaneSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReferencePlaneSGIX(const GLdouble * equation) {
    PFN_GLREFERENCEPLANESGIX _ptr;
    _ptr = (PFN_GLREFERENCEPLANESGIX)_getPrivateProcAddress("glReferencePlaneSGIX");
    if (!_ptr) {
        _ptr = &_fail_glReferencePlaneSGIX;
    }
    _glReferencePlaneSGIX = _ptr;
    _glReferencePlaneSGIX(equation);
}

PFN_GLREFERENCEPLANESGIX _glReferencePlaneSGIX = &_get_glReferencePlaneSGIX;

static void APIENTRY _fail_glSpriteParameterfSGIX(GLenum pname, GLfloat param) {
    const char *_name = "glSpriteParameterfSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSpriteParameterfSGIX(GLenum pname, GLfloat param) {
    PFN_GLSPRITEPARAMETERFSGIX _ptr;
    _ptr = (PFN_GLSPRITEPARAMETERFSGIX)_getPrivateProcAddress("glSpriteParameterfSGIX");
    if (!_ptr) {
        _ptr = &_fail_glSpriteParameterfSGIX;
    }
    _glSpriteParameterfSGIX = _ptr;
    _glSpriteParameterfSGIX(pname, param);
}

PFN_GLSPRITEPARAMETERFSGIX _glSpriteParameterfSGIX = &_get_glSpriteParameterfSGIX;

static void APIENTRY _fail_glSpriteParameterfvSGIX(GLenum pname, const GLfloat * params) {
    const char *_name = "glSpriteParameterfvSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSpriteParameterfvSGIX(GLenum pname, const GLfloat * params) {
    PFN_GLSPRITEPARAMETERFVSGIX _ptr;
    _ptr = (PFN_GLSPRITEPARAMETERFVSGIX)_getPrivateProcAddress("glSpriteParameterfvSGIX");
    if (!_ptr) {
        _ptr = &_fail_glSpriteParameterfvSGIX;
    }
    _glSpriteParameterfvSGIX = _ptr;
    _glSpriteParameterfvSGIX(pname, params);
}

PFN_GLSPRITEPARAMETERFVSGIX _glSpriteParameterfvSGIX = &_get_glSpriteParameterfvSGIX;

static void APIENTRY _fail_glSpriteParameteriSGIX(GLenum pname, GLint param) {
    const char *_name = "glSpriteParameteriSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSpriteParameteriSGIX(GLenum pname, GLint param) {
    PFN_GLSPRITEPARAMETERISGIX _ptr;
    _ptr = (PFN_GLSPRITEPARAMETERISGIX)_getPrivateProcAddress("glSpriteParameteriSGIX");
    if (!_ptr) {
        _ptr = &_fail_glSpriteParameteriSGIX;
    }
    _glSpriteParameteriSGIX = _ptr;
    _glSpriteParameteriSGIX(pname, param);
}

PFN_GLSPRITEPARAMETERISGIX _glSpriteParameteriSGIX = &_get_glSpriteParameteriSGIX;

static void APIENTRY _fail_glSpriteParameterivSGIX(GLenum pname, const GLint * params) {
    const char *_name = "glSpriteParameterivSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glSpriteParameterivSGIX(GLenum pname, const GLint * params) {
    PFN_GLSPRITEPARAMETERIVSGIX _ptr;
    _ptr = (PFN_GLSPRITEPARAMETERIVSGIX)_getPrivateProcAddress("glSpriteParameterivSGIX");
    if (!_ptr) {
        _ptr = &_fail_glSpriteParameterivSGIX;
    }
    _glSpriteParameterivSGIX = _ptr;
    _glSpriteParameterivSGIX(pname, params);
}

PFN_GLSPRITEPARAMETERIVSGIX _glSpriteParameterivSGIX = &_get_glSpriteParameterivSGIX;

static void APIENTRY _fail_glTagSampleBufferSGIX(void) {
    const char *_name = "glTagSampleBufferSGIX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTagSampleBufferSGIX(void) {
    PFN_GLTAGSAMPLEBUFFERSGIX _ptr;
    _ptr = (PFN_GLTAGSAMPLEBUFFERSGIX)_getPrivateProcAddress("glTagSampleBufferSGIX");
    if (!_ptr) {
        _ptr = &_fail_glTagSampleBufferSGIX;
    }
    _glTagSampleBufferSGIX = _ptr;
    _glTagSampleBufferSGIX();
}

PFN_GLTAGSAMPLEBUFFERSGIX _glTagSampleBufferSGIX = &_get_glTagSampleBufferSGIX;

static void APIENTRY _fail_glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table) {
    const char *_name = "glColorTableSGI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table) {
    PFN_GLCOLORTABLESGI _ptr;
    _ptr = (PFN_GLCOLORTABLESGI)_getPrivateProcAddress("glColorTableSGI");
    if (!_ptr) {
        _ptr = &_fail_glColorTableSGI;
    }
    _glColorTableSGI = _ptr;
    _glColorTableSGI(target, internalformat, width, format, type, table);
}

PFN_GLCOLORTABLESGI _glColorTableSGI = &_get_glColorTableSGI;

static void APIENTRY _fail_glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat * params) {
    const char *_name = "glColorTableParameterfvSGI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat * params) {
    PFN_GLCOLORTABLEPARAMETERFVSGI _ptr;
    _ptr = (PFN_GLCOLORTABLEPARAMETERFVSGI)_getPrivateProcAddress("glColorTableParameterfvSGI");
    if (!_ptr) {
        _ptr = &_fail_glColorTableParameterfvSGI;
    }
    _glColorTableParameterfvSGI = _ptr;
    _glColorTableParameterfvSGI(target, pname, params);
}

PFN_GLCOLORTABLEPARAMETERFVSGI _glColorTableParameterfvSGI = &_get_glColorTableParameterfvSGI;

static void APIENTRY _fail_glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint * params) {
    const char *_name = "glColorTableParameterivSGI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint * params) {
    PFN_GLCOLORTABLEPARAMETERIVSGI _ptr;
    _ptr = (PFN_GLCOLORTABLEPARAMETERIVSGI)_getPrivateProcAddress("glColorTableParameterivSGI");
    if (!_ptr) {
        _ptr = &_fail_glColorTableParameterivSGI;
    }
    _glColorTableParameterivSGI = _ptr;
    _glColorTableParameterivSGI(target, pname, params);
}

PFN_GLCOLORTABLEPARAMETERIVSGI _glColorTableParameterivSGI = &_get_glColorTableParameterivSGI;

static void APIENTRY _fail_glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    const char *_name = "glCopyColorTableSGI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    PFN_GLCOPYCOLORTABLESGI _ptr;
    _ptr = (PFN_GLCOPYCOLORTABLESGI)_getPrivateProcAddress("glCopyColorTableSGI");
    if (!_ptr) {
        _ptr = &_fail_glCopyColorTableSGI;
    }
    _glCopyColorTableSGI = _ptr;
    _glCopyColorTableSGI(target, internalformat, x, y, width);
}

PFN_GLCOPYCOLORTABLESGI _glCopyColorTableSGI = &_get_glCopyColorTableSGI;

static void APIENTRY _fail_glGetColorTableSGI(GLenum target, GLenum format, GLenum type, GLvoid * table) {
    const char *_name = "glGetColorTableSGI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetColorTableSGI(GLenum target, GLenum format, GLenum type, GLvoid * table) {
    PFN_GLGETCOLORTABLESGI _ptr;
    _ptr = (PFN_GLGETCOLORTABLESGI)_getPrivateProcAddress("glGetColorTableSGI");
    if (!_ptr) {
        _ptr = &_fail_glGetColorTableSGI;
    }
    _glGetColorTableSGI = _ptr;
    _glGetColorTableSGI(target, format, type, table);
}

PFN_GLGETCOLORTABLESGI _glGetColorTableSGI = &_get_glGetColorTableSGI;

static void APIENTRY _fail_glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat * params) {
    const char *_name = "glGetColorTableParameterfvSGI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat * params) {
    PFN_GLGETCOLORTABLEPARAMETERFVSGI _ptr;
    _ptr = (PFN_GLGETCOLORTABLEPARAMETERFVSGI)_getPrivateProcAddress("glGetColorTableParameterfvSGI");
    if (!_ptr) {
        _ptr = &_fail_glGetColorTableParameterfvSGI;
    }
    _glGetColorTableParameterfvSGI = _ptr;
    _glGetColorTableParameterfvSGI(target, pname, params);
}

PFN_GLGETCOLORTABLEPARAMETERFVSGI _glGetColorTableParameterfvSGI = &_get_glGetColorTableParameterfvSGI;

static void APIENTRY _fail_glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint * params) {
    const char *_name = "glGetColorTableParameterivSGI";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint * params) {
    PFN_GLGETCOLORTABLEPARAMETERIVSGI _ptr;
    _ptr = (PFN_GLGETCOLORTABLEPARAMETERIVSGI)_getPrivateProcAddress("glGetColorTableParameterivSGI");
    if (!_ptr) {
        _ptr = &_fail_glGetColorTableParameterivSGI;
    }
    _glGetColorTableParameterivSGI = _ptr;
    _glGetColorTableParameterivSGI(target, pname, params);
}

PFN_GLGETCOLORTABLEPARAMETERIVSGI _glGetColorTableParameterivSGI = &_get_glGetColorTableParameterivSGI;

static void APIENTRY _fail_glFinishTextureSUNX(void) {
    const char *_name = "glFinishTextureSUNX";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glFinishTextureSUNX(void) {
    PFN_GLFINISHTEXTURESUNX _ptr;
    _ptr = (PFN_GLFINISHTEXTURESUNX)_getPrivateProcAddress("glFinishTextureSUNX");
    if (!_ptr) {
        _ptr = &_fail_glFinishTextureSUNX;
    }
    _glFinishTextureSUNX = _ptr;
    _glFinishTextureSUNX();
}

PFN_GLFINISHTEXTURESUNX _glFinishTextureSUNX = &_get_glFinishTextureSUNX;

static void APIENTRY _fail_glGlobalAlphaFactorbSUN(GLbyte factor) {
    const char *_name = "glGlobalAlphaFactorbSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGlobalAlphaFactorbSUN(GLbyte factor) {
    PFN_GLGLOBALALPHAFACTORBSUN _ptr;
    _ptr = (PFN_GLGLOBALALPHAFACTORBSUN)_getPrivateProcAddress("glGlobalAlphaFactorbSUN");
    if (!_ptr) {
        _ptr = &_fail_glGlobalAlphaFactorbSUN;
    }
    _glGlobalAlphaFactorbSUN = _ptr;
    _glGlobalAlphaFactorbSUN(factor);
}

PFN_GLGLOBALALPHAFACTORBSUN _glGlobalAlphaFactorbSUN = &_get_glGlobalAlphaFactorbSUN;

static void APIENTRY _fail_glGlobalAlphaFactorsSUN(GLshort factor) {
    const char *_name = "glGlobalAlphaFactorsSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGlobalAlphaFactorsSUN(GLshort factor) {
    PFN_GLGLOBALALPHAFACTORSSUN _ptr;
    _ptr = (PFN_GLGLOBALALPHAFACTORSSUN)_getPrivateProcAddress("glGlobalAlphaFactorsSUN");
    if (!_ptr) {
        _ptr = &_fail_glGlobalAlphaFactorsSUN;
    }
    _glGlobalAlphaFactorsSUN = _ptr;
    _glGlobalAlphaFactorsSUN(factor);
}

PFN_GLGLOBALALPHAFACTORSSUN _glGlobalAlphaFactorsSUN = &_get_glGlobalAlphaFactorsSUN;

static void APIENTRY _fail_glGlobalAlphaFactoriSUN(GLint factor) {
    const char *_name = "glGlobalAlphaFactoriSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGlobalAlphaFactoriSUN(GLint factor) {
    PFN_GLGLOBALALPHAFACTORISUN _ptr;
    _ptr = (PFN_GLGLOBALALPHAFACTORISUN)_getPrivateProcAddress("glGlobalAlphaFactoriSUN");
    if (!_ptr) {
        _ptr = &_fail_glGlobalAlphaFactoriSUN;
    }
    _glGlobalAlphaFactoriSUN = _ptr;
    _glGlobalAlphaFactoriSUN(factor);
}

PFN_GLGLOBALALPHAFACTORISUN _glGlobalAlphaFactoriSUN = &_get_glGlobalAlphaFactoriSUN;

static void APIENTRY _fail_glGlobalAlphaFactorfSUN(GLfloat factor) {
    const char *_name = "glGlobalAlphaFactorfSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGlobalAlphaFactorfSUN(GLfloat factor) {
    PFN_GLGLOBALALPHAFACTORFSUN _ptr;
    _ptr = (PFN_GLGLOBALALPHAFACTORFSUN)_getPrivateProcAddress("glGlobalAlphaFactorfSUN");
    if (!_ptr) {
        _ptr = &_fail_glGlobalAlphaFactorfSUN;
    }
    _glGlobalAlphaFactorfSUN = _ptr;
    _glGlobalAlphaFactorfSUN(factor);
}

PFN_GLGLOBALALPHAFACTORFSUN _glGlobalAlphaFactorfSUN = &_get_glGlobalAlphaFactorfSUN;

static void APIENTRY _fail_glGlobalAlphaFactordSUN(GLdouble factor) {
    const char *_name = "glGlobalAlphaFactordSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGlobalAlphaFactordSUN(GLdouble factor) {
    PFN_GLGLOBALALPHAFACTORDSUN _ptr;
    _ptr = (PFN_GLGLOBALALPHAFACTORDSUN)_getPrivateProcAddress("glGlobalAlphaFactordSUN");
    if (!_ptr) {
        _ptr = &_fail_glGlobalAlphaFactordSUN;
    }
    _glGlobalAlphaFactordSUN = _ptr;
    _glGlobalAlphaFactordSUN(factor);
}

PFN_GLGLOBALALPHAFACTORDSUN _glGlobalAlphaFactordSUN = &_get_glGlobalAlphaFactordSUN;

static void APIENTRY _fail_glGlobalAlphaFactorubSUN(GLubyte factor) {
    const char *_name = "glGlobalAlphaFactorubSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGlobalAlphaFactorubSUN(GLubyte factor) {
    PFN_GLGLOBALALPHAFACTORUBSUN _ptr;
    _ptr = (PFN_GLGLOBALALPHAFACTORUBSUN)_getPrivateProcAddress("glGlobalAlphaFactorubSUN");
    if (!_ptr) {
        _ptr = &_fail_glGlobalAlphaFactorubSUN;
    }
    _glGlobalAlphaFactorubSUN = _ptr;
    _glGlobalAlphaFactorubSUN(factor);
}

PFN_GLGLOBALALPHAFACTORUBSUN _glGlobalAlphaFactorubSUN = &_get_glGlobalAlphaFactorubSUN;

static void APIENTRY _fail_glGlobalAlphaFactorusSUN(GLushort factor) {
    const char *_name = "glGlobalAlphaFactorusSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGlobalAlphaFactorusSUN(GLushort factor) {
    PFN_GLGLOBALALPHAFACTORUSSUN _ptr;
    _ptr = (PFN_GLGLOBALALPHAFACTORUSSUN)_getPrivateProcAddress("glGlobalAlphaFactorusSUN");
    if (!_ptr) {
        _ptr = &_fail_glGlobalAlphaFactorusSUN;
    }
    _glGlobalAlphaFactorusSUN = _ptr;
    _glGlobalAlphaFactorusSUN(factor);
}

PFN_GLGLOBALALPHAFACTORUSSUN _glGlobalAlphaFactorusSUN = &_get_glGlobalAlphaFactorusSUN;

static void APIENTRY _fail_glGlobalAlphaFactoruiSUN(GLuint factor) {
    const char *_name = "glGlobalAlphaFactoruiSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glGlobalAlphaFactoruiSUN(GLuint factor) {
    PFN_GLGLOBALALPHAFACTORUISUN _ptr;
    _ptr = (PFN_GLGLOBALALPHAFACTORUISUN)_getPrivateProcAddress("glGlobalAlphaFactoruiSUN");
    if (!_ptr) {
        _ptr = &_fail_glGlobalAlphaFactoruiSUN;
    }
    _glGlobalAlphaFactoruiSUN = _ptr;
    _glGlobalAlphaFactoruiSUN(factor);
}

PFN_GLGLOBALALPHAFACTORUISUN _glGlobalAlphaFactoruiSUN = &_get_glGlobalAlphaFactoruiSUN;

static void APIENTRY _fail_glDrawMeshArraysSUN(GLenum mode, GLint first, GLsizei count, GLsizei width) {
    const char *_name = "glDrawMeshArraysSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glDrawMeshArraysSUN(GLenum mode, GLint first, GLsizei count, GLsizei width) {
    PFN_GLDRAWMESHARRAYSSUN _ptr;
    _ptr = (PFN_GLDRAWMESHARRAYSSUN)_getPrivateProcAddress("glDrawMeshArraysSUN");
    if (!_ptr) {
        _ptr = &_fail_glDrawMeshArraysSUN;
    }
    _glDrawMeshArraysSUN = _ptr;
    _glDrawMeshArraysSUN(mode, first, count, width);
}

PFN_GLDRAWMESHARRAYSSUN _glDrawMeshArraysSUN = &_get_glDrawMeshArraysSUN;

static void APIENTRY _fail_glReplacementCodeuiSUN(GLuint code) {
    const char *_name = "glReplacementCodeuiSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeuiSUN(GLuint code) {
    PFN_GLREPLACEMENTCODEUISUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUISUN)_getPrivateProcAddress("glReplacementCodeuiSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeuiSUN;
    }
    _glReplacementCodeuiSUN = _ptr;
    _glReplacementCodeuiSUN(code);
}

PFN_GLREPLACEMENTCODEUISUN _glReplacementCodeuiSUN = &_get_glReplacementCodeuiSUN;

static void APIENTRY _fail_glReplacementCodeusSUN(GLushort code) {
    const char *_name = "glReplacementCodeusSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeusSUN(GLushort code) {
    PFN_GLREPLACEMENTCODEUSSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUSSUN)_getPrivateProcAddress("glReplacementCodeusSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeusSUN;
    }
    _glReplacementCodeusSUN = _ptr;
    _glReplacementCodeusSUN(code);
}

PFN_GLREPLACEMENTCODEUSSUN _glReplacementCodeusSUN = &_get_glReplacementCodeusSUN;

static void APIENTRY _fail_glReplacementCodeubSUN(GLubyte code) {
    const char *_name = "glReplacementCodeubSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeubSUN(GLubyte code) {
    PFN_GLREPLACEMENTCODEUBSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUBSUN)_getPrivateProcAddress("glReplacementCodeubSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeubSUN;
    }
    _glReplacementCodeubSUN = _ptr;
    _glReplacementCodeubSUN(code);
}

PFN_GLREPLACEMENTCODEUBSUN _glReplacementCodeubSUN = &_get_glReplacementCodeubSUN;

static void APIENTRY _fail_glReplacementCodeuivSUN(const GLuint * code) {
    const char *_name = "glReplacementCodeuivSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeuivSUN(const GLuint * code) {
    PFN_GLREPLACEMENTCODEUIVSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUIVSUN)_getPrivateProcAddress("glReplacementCodeuivSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeuivSUN;
    }
    _glReplacementCodeuivSUN = _ptr;
    _glReplacementCodeuivSUN(code);
}

PFN_GLREPLACEMENTCODEUIVSUN _glReplacementCodeuivSUN = &_get_glReplacementCodeuivSUN;

static void APIENTRY _fail_glReplacementCodeusvSUN(const GLushort * code) {
    const char *_name = "glReplacementCodeusvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeusvSUN(const GLushort * code) {
    PFN_GLREPLACEMENTCODEUSVSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUSVSUN)_getPrivateProcAddress("glReplacementCodeusvSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeusvSUN;
    }
    _glReplacementCodeusvSUN = _ptr;
    _glReplacementCodeusvSUN(code);
}

PFN_GLREPLACEMENTCODEUSVSUN _glReplacementCodeusvSUN = &_get_glReplacementCodeusvSUN;

static void APIENTRY _fail_glReplacementCodeubvSUN(const GLubyte * code) {
    const char *_name = "glReplacementCodeubvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeubvSUN(const GLubyte * code) {
    PFN_GLREPLACEMENTCODEUBVSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUBVSUN)_getPrivateProcAddress("glReplacementCodeubvSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeubvSUN;
    }
    _glReplacementCodeubvSUN = _ptr;
    _glReplacementCodeubvSUN(code);
}

PFN_GLREPLACEMENTCODEUBVSUN _glReplacementCodeubvSUN = &_get_glReplacementCodeubvSUN;

static void APIENTRY _fail_glReplacementCodePointerSUN(GLenum type, GLsizei stride, const GLvoid * * pointer) {
    const char *_name = "glReplacementCodePointerSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodePointerSUN(GLenum type, GLsizei stride, const GLvoid * * pointer) {
    PFN_GLREPLACEMENTCODEPOINTERSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEPOINTERSUN)_getPrivateProcAddress("glReplacementCodePointerSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodePointerSUN;
    }
    _glReplacementCodePointerSUN = _ptr;
    _glReplacementCodePointerSUN(type, stride, pointer);
}

PFN_GLREPLACEMENTCODEPOINTERSUN _glReplacementCodePointerSUN = &_get_glReplacementCodePointerSUN;

static void APIENTRY _fail_glColor4ubVertex2fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y) {
    const char *_name = "glColor4ubVertex2fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4ubVertex2fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y) {
    PFN_GLCOLOR4UBVERTEX2FSUN _ptr;
    _ptr = (PFN_GLCOLOR4UBVERTEX2FSUN)_getPrivateProcAddress("glColor4ubVertex2fSUN");
    if (!_ptr) {
        _ptr = &_fail_glColor4ubVertex2fSUN;
    }
    _glColor4ubVertex2fSUN = _ptr;
    _glColor4ubVertex2fSUN(r, g, b, a, x, y);
}

PFN_GLCOLOR4UBVERTEX2FSUN _glColor4ubVertex2fSUN = &_get_glColor4ubVertex2fSUN;

static void APIENTRY _fail_glColor4ubVertex2fvSUN(const GLubyte * c, const GLfloat * v) {
    const char *_name = "glColor4ubVertex2fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4ubVertex2fvSUN(const GLubyte * c, const GLfloat * v) {
    PFN_GLCOLOR4UBVERTEX2FVSUN _ptr;
    _ptr = (PFN_GLCOLOR4UBVERTEX2FVSUN)_getPrivateProcAddress("glColor4ubVertex2fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glColor4ubVertex2fvSUN;
    }
    _glColor4ubVertex2fvSUN = _ptr;
    _glColor4ubVertex2fvSUN(c, v);
}

PFN_GLCOLOR4UBVERTEX2FVSUN _glColor4ubVertex2fvSUN = &_get_glColor4ubVertex2fvSUN;

static void APIENTRY _fail_glColor4ubVertex3fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glColor4ubVertex3fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4ubVertex3fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLCOLOR4UBVERTEX3FSUN _ptr;
    _ptr = (PFN_GLCOLOR4UBVERTEX3FSUN)_getPrivateProcAddress("glColor4ubVertex3fSUN");
    if (!_ptr) {
        _ptr = &_fail_glColor4ubVertex3fSUN;
    }
    _glColor4ubVertex3fSUN = _ptr;
    _glColor4ubVertex3fSUN(r, g, b, a, x, y, z);
}

PFN_GLCOLOR4UBVERTEX3FSUN _glColor4ubVertex3fSUN = &_get_glColor4ubVertex3fSUN;

static void APIENTRY _fail_glColor4ubVertex3fvSUN(const GLubyte * c, const GLfloat * v) {
    const char *_name = "glColor4ubVertex3fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4ubVertex3fvSUN(const GLubyte * c, const GLfloat * v) {
    PFN_GLCOLOR4UBVERTEX3FVSUN _ptr;
    _ptr = (PFN_GLCOLOR4UBVERTEX3FVSUN)_getPrivateProcAddress("glColor4ubVertex3fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glColor4ubVertex3fvSUN;
    }
    _glColor4ubVertex3fvSUN = _ptr;
    _glColor4ubVertex3fvSUN(c, v);
}

PFN_GLCOLOR4UBVERTEX3FVSUN _glColor4ubVertex3fvSUN = &_get_glColor4ubVertex3fvSUN;

static void APIENTRY _fail_glColor3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glColor3fVertex3fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLCOLOR3FVERTEX3FSUN _ptr;
    _ptr = (PFN_GLCOLOR3FVERTEX3FSUN)_getPrivateProcAddress("glColor3fVertex3fSUN");
    if (!_ptr) {
        _ptr = &_fail_glColor3fVertex3fSUN;
    }
    _glColor3fVertex3fSUN = _ptr;
    _glColor3fVertex3fSUN(r, g, b, x, y, z);
}

PFN_GLCOLOR3FVERTEX3FSUN _glColor3fVertex3fSUN = &_get_glColor3fVertex3fSUN;

static void APIENTRY _fail_glColor3fVertex3fvSUN(const GLfloat * c, const GLfloat * v) {
    const char *_name = "glColor3fVertex3fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor3fVertex3fvSUN(const GLfloat * c, const GLfloat * v) {
    PFN_GLCOLOR3FVERTEX3FVSUN _ptr;
    _ptr = (PFN_GLCOLOR3FVERTEX3FVSUN)_getPrivateProcAddress("glColor3fVertex3fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glColor3fVertex3fvSUN;
    }
    _glColor3fVertex3fvSUN = _ptr;
    _glColor3fVertex3fvSUN(c, v);
}

PFN_GLCOLOR3FVERTEX3FVSUN _glColor3fVertex3fvSUN = &_get_glColor3fVertex3fvSUN;

static void APIENTRY _fail_glNormal3fVertex3fSUN(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glNormal3fVertex3fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormal3fVertex3fSUN(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLNORMAL3FVERTEX3FSUN _ptr;
    _ptr = (PFN_GLNORMAL3FVERTEX3FSUN)_getPrivateProcAddress("glNormal3fVertex3fSUN");
    if (!_ptr) {
        _ptr = &_fail_glNormal3fVertex3fSUN;
    }
    _glNormal3fVertex3fSUN = _ptr;
    _glNormal3fVertex3fSUN(nx, ny, nz, x, y, z);
}

PFN_GLNORMAL3FVERTEX3FSUN _glNormal3fVertex3fSUN = &_get_glNormal3fVertex3fSUN;

static void APIENTRY _fail_glNormal3fVertex3fvSUN(const GLfloat * n, const GLfloat * v) {
    const char *_name = "glNormal3fVertex3fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glNormal3fVertex3fvSUN(const GLfloat * n, const GLfloat * v) {
    PFN_GLNORMAL3FVERTEX3FVSUN _ptr;
    _ptr = (PFN_GLNORMAL3FVERTEX3FVSUN)_getPrivateProcAddress("glNormal3fVertex3fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glNormal3fVertex3fvSUN;
    }
    _glNormal3fVertex3fvSUN = _ptr;
    _glNormal3fVertex3fvSUN(n, v);
}

PFN_GLNORMAL3FVERTEX3FVSUN _glNormal3fVertex3fvSUN = &_get_glNormal3fVertex3fvSUN;

static void APIENTRY _fail_glColor4fNormal3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glColor4fNormal3fVertex3fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4fNormal3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLCOLOR4FNORMAL3FVERTEX3FSUN _ptr;
    _ptr = (PFN_GLCOLOR4FNORMAL3FVERTEX3FSUN)_getPrivateProcAddress("glColor4fNormal3fVertex3fSUN");
    if (!_ptr) {
        _ptr = &_fail_glColor4fNormal3fVertex3fSUN;
    }
    _glColor4fNormal3fVertex3fSUN = _ptr;
    _glColor4fNormal3fVertex3fSUN(r, g, b, a, nx, ny, nz, x, y, z);
}

PFN_GLCOLOR4FNORMAL3FVERTEX3FSUN _glColor4fNormal3fVertex3fSUN = &_get_glColor4fNormal3fVertex3fSUN;

static void APIENTRY _fail_glColor4fNormal3fVertex3fvSUN(const GLfloat * c, const GLfloat * n, const GLfloat * v) {
    const char *_name = "glColor4fNormal3fVertex3fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glColor4fNormal3fVertex3fvSUN(const GLfloat * c, const GLfloat * n, const GLfloat * v) {
    PFN_GLCOLOR4FNORMAL3FVERTEX3FVSUN _ptr;
    _ptr = (PFN_GLCOLOR4FNORMAL3FVERTEX3FVSUN)_getPrivateProcAddress("glColor4fNormal3fVertex3fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glColor4fNormal3fVertex3fvSUN;
    }
    _glColor4fNormal3fVertex3fvSUN = _ptr;
    _glColor4fNormal3fVertex3fvSUN(c, n, v);
}

PFN_GLCOLOR4FNORMAL3FVERTEX3FVSUN _glColor4fNormal3fVertex3fvSUN = &_get_glColor4fNormal3fVertex3fvSUN;

static void APIENTRY _fail_glTexCoord2fVertex3fSUN(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glTexCoord2fVertex3fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2fVertex3fSUN(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLTEXCOORD2FVERTEX3FSUN _ptr;
    _ptr = (PFN_GLTEXCOORD2FVERTEX3FSUN)_getPrivateProcAddress("glTexCoord2fVertex3fSUN");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2fVertex3fSUN;
    }
    _glTexCoord2fVertex3fSUN = _ptr;
    _glTexCoord2fVertex3fSUN(s, t, x, y, z);
}

PFN_GLTEXCOORD2FVERTEX3FSUN _glTexCoord2fVertex3fSUN = &_get_glTexCoord2fVertex3fSUN;

static void APIENTRY _fail_glTexCoord2fVertex3fvSUN(const GLfloat * tc, const GLfloat * v) {
    const char *_name = "glTexCoord2fVertex3fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2fVertex3fvSUN(const GLfloat * tc, const GLfloat * v) {
    PFN_GLTEXCOORD2FVERTEX3FVSUN _ptr;
    _ptr = (PFN_GLTEXCOORD2FVERTEX3FVSUN)_getPrivateProcAddress("glTexCoord2fVertex3fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2fVertex3fvSUN;
    }
    _glTexCoord2fVertex3fvSUN = _ptr;
    _glTexCoord2fVertex3fvSUN(tc, v);
}

PFN_GLTEXCOORD2FVERTEX3FVSUN _glTexCoord2fVertex3fvSUN = &_get_glTexCoord2fVertex3fvSUN;

static void APIENTRY _fail_glTexCoord4fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glTexCoord4fVertex4fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord4fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    PFN_GLTEXCOORD4FVERTEX4FSUN _ptr;
    _ptr = (PFN_GLTEXCOORD4FVERTEX4FSUN)_getPrivateProcAddress("glTexCoord4fVertex4fSUN");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord4fVertex4fSUN;
    }
    _glTexCoord4fVertex4fSUN = _ptr;
    _glTexCoord4fVertex4fSUN(s, t, p, q, x, y, z, w);
}

PFN_GLTEXCOORD4FVERTEX4FSUN _glTexCoord4fVertex4fSUN = &_get_glTexCoord4fVertex4fSUN;

static void APIENTRY _fail_glTexCoord4fVertex4fvSUN(const GLfloat * tc, const GLfloat * v) {
    const char *_name = "glTexCoord4fVertex4fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord4fVertex4fvSUN(const GLfloat * tc, const GLfloat * v) {
    PFN_GLTEXCOORD4FVERTEX4FVSUN _ptr;
    _ptr = (PFN_GLTEXCOORD4FVERTEX4FVSUN)_getPrivateProcAddress("glTexCoord4fVertex4fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord4fVertex4fvSUN;
    }
    _glTexCoord4fVertex4fvSUN = _ptr;
    _glTexCoord4fVertex4fvSUN(tc, v);
}

PFN_GLTEXCOORD4FVERTEX4FVSUN _glTexCoord4fVertex4fvSUN = &_get_glTexCoord4fVertex4fvSUN;

static void APIENTRY _fail_glTexCoord2fColor4ubVertex3fSUN(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glTexCoord2fColor4ubVertex3fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2fColor4ubVertex3fSUN(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLTEXCOORD2FCOLOR4UBVERTEX3FSUN _ptr;
    _ptr = (PFN_GLTEXCOORD2FCOLOR4UBVERTEX3FSUN)_getPrivateProcAddress("glTexCoord2fColor4ubVertex3fSUN");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2fColor4ubVertex3fSUN;
    }
    _glTexCoord2fColor4ubVertex3fSUN = _ptr;
    _glTexCoord2fColor4ubVertex3fSUN(s, t, r, g, b, a, x, y, z);
}

PFN_GLTEXCOORD2FCOLOR4UBVERTEX3FSUN _glTexCoord2fColor4ubVertex3fSUN = &_get_glTexCoord2fColor4ubVertex3fSUN;

static void APIENTRY _fail_glTexCoord2fColor4ubVertex3fvSUN(const GLfloat * tc, const GLubyte * c, const GLfloat * v) {
    const char *_name = "glTexCoord2fColor4ubVertex3fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2fColor4ubVertex3fvSUN(const GLfloat * tc, const GLubyte * c, const GLfloat * v) {
    PFN_GLTEXCOORD2FCOLOR4UBVERTEX3FVSUN _ptr;
    _ptr = (PFN_GLTEXCOORD2FCOLOR4UBVERTEX3FVSUN)_getPrivateProcAddress("glTexCoord2fColor4ubVertex3fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2fColor4ubVertex3fvSUN;
    }
    _glTexCoord2fColor4ubVertex3fvSUN = _ptr;
    _glTexCoord2fColor4ubVertex3fvSUN(tc, c, v);
}

PFN_GLTEXCOORD2FCOLOR4UBVERTEX3FVSUN _glTexCoord2fColor4ubVertex3fvSUN = &_get_glTexCoord2fColor4ubVertex3fvSUN;

static void APIENTRY _fail_glTexCoord2fColor3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glTexCoord2fColor3fVertex3fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2fColor3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLTEXCOORD2FCOLOR3FVERTEX3FSUN _ptr;
    _ptr = (PFN_GLTEXCOORD2FCOLOR3FVERTEX3FSUN)_getPrivateProcAddress("glTexCoord2fColor3fVertex3fSUN");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2fColor3fVertex3fSUN;
    }
    _glTexCoord2fColor3fVertex3fSUN = _ptr;
    _glTexCoord2fColor3fVertex3fSUN(s, t, r, g, b, x, y, z);
}

PFN_GLTEXCOORD2FCOLOR3FVERTEX3FSUN _glTexCoord2fColor3fVertex3fSUN = &_get_glTexCoord2fColor3fVertex3fSUN;

static void APIENTRY _fail_glTexCoord2fColor3fVertex3fvSUN(const GLfloat * tc, const GLfloat * c, const GLfloat * v) {
    const char *_name = "glTexCoord2fColor3fVertex3fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2fColor3fVertex3fvSUN(const GLfloat * tc, const GLfloat * c, const GLfloat * v) {
    PFN_GLTEXCOORD2FCOLOR3FVERTEX3FVSUN _ptr;
    _ptr = (PFN_GLTEXCOORD2FCOLOR3FVERTEX3FVSUN)_getPrivateProcAddress("glTexCoord2fColor3fVertex3fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2fColor3fVertex3fvSUN;
    }
    _glTexCoord2fColor3fVertex3fvSUN = _ptr;
    _glTexCoord2fColor3fVertex3fvSUN(tc, c, v);
}

PFN_GLTEXCOORD2FCOLOR3FVERTEX3FVSUN _glTexCoord2fColor3fVertex3fvSUN = &_get_glTexCoord2fColor3fVertex3fvSUN;

static void APIENTRY _fail_glTexCoord2fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glTexCoord2fNormal3fVertex3fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLTEXCOORD2FNORMAL3FVERTEX3FSUN _ptr;
    _ptr = (PFN_GLTEXCOORD2FNORMAL3FVERTEX3FSUN)_getPrivateProcAddress("glTexCoord2fNormal3fVertex3fSUN");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2fNormal3fVertex3fSUN;
    }
    _glTexCoord2fNormal3fVertex3fSUN = _ptr;
    _glTexCoord2fNormal3fVertex3fSUN(s, t, nx, ny, nz, x, y, z);
}

PFN_GLTEXCOORD2FNORMAL3FVERTEX3FSUN _glTexCoord2fNormal3fVertex3fSUN = &_get_glTexCoord2fNormal3fVertex3fSUN;

static void APIENTRY _fail_glTexCoord2fNormal3fVertex3fvSUN(const GLfloat * tc, const GLfloat * n, const GLfloat * v) {
    const char *_name = "glTexCoord2fNormal3fVertex3fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2fNormal3fVertex3fvSUN(const GLfloat * tc, const GLfloat * n, const GLfloat * v) {
    PFN_GLTEXCOORD2FNORMAL3FVERTEX3FVSUN _ptr;
    _ptr = (PFN_GLTEXCOORD2FNORMAL3FVERTEX3FVSUN)_getPrivateProcAddress("glTexCoord2fNormal3fVertex3fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2fNormal3fVertex3fvSUN;
    }
    _glTexCoord2fNormal3fVertex3fvSUN = _ptr;
    _glTexCoord2fNormal3fVertex3fvSUN(tc, n, v);
}

PFN_GLTEXCOORD2FNORMAL3FVERTEX3FVSUN _glTexCoord2fNormal3fVertex3fvSUN = &_get_glTexCoord2fNormal3fVertex3fvSUN;

static void APIENTRY _fail_glTexCoord2fColor4fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glTexCoord2fColor4fNormal3fVertex3fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2fColor4fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUN _ptr;
    _ptr = (PFN_GLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUN)_getPrivateProcAddress("glTexCoord2fColor4fNormal3fVertex3fSUN");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2fColor4fNormal3fVertex3fSUN;
    }
    _glTexCoord2fColor4fNormal3fVertex3fSUN = _ptr;
    _glTexCoord2fColor4fNormal3fVertex3fSUN(s, t, r, g, b, a, nx, ny, nz, x, y, z);
}

PFN_GLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUN _glTexCoord2fColor4fNormal3fVertex3fSUN = &_get_glTexCoord2fColor4fNormal3fVertex3fSUN;

static void APIENTRY _fail_glTexCoord2fColor4fNormal3fVertex3fvSUN(const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v) {
    const char *_name = "glTexCoord2fColor4fNormal3fVertex3fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord2fColor4fNormal3fVertex3fvSUN(const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v) {
    PFN_GLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUN _ptr;
    _ptr = (PFN_GLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUN)_getPrivateProcAddress("glTexCoord2fColor4fNormal3fVertex3fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord2fColor4fNormal3fVertex3fvSUN;
    }
    _glTexCoord2fColor4fNormal3fVertex3fvSUN = _ptr;
    _glTexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n, v);
}

PFN_GLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUN _glTexCoord2fColor4fNormal3fVertex3fvSUN = &_get_glTexCoord2fColor4fNormal3fVertex3fvSUN;

static void APIENTRY _fail_glTexCoord4fColor4fNormal3fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    const char *_name = "glTexCoord4fColor4fNormal3fVertex4fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord4fColor4fNormal3fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    PFN_GLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUN _ptr;
    _ptr = (PFN_GLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUN)_getPrivateProcAddress("glTexCoord4fColor4fNormal3fVertex4fSUN");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord4fColor4fNormal3fVertex4fSUN;
    }
    _glTexCoord4fColor4fNormal3fVertex4fSUN = _ptr;
    _glTexCoord4fColor4fNormal3fVertex4fSUN(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
}

PFN_GLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUN _glTexCoord4fColor4fNormal3fVertex4fSUN = &_get_glTexCoord4fColor4fNormal3fVertex4fSUN;

static void APIENTRY _fail_glTexCoord4fColor4fNormal3fVertex4fvSUN(const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v) {
    const char *_name = "glTexCoord4fColor4fNormal3fVertex4fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glTexCoord4fColor4fNormal3fVertex4fvSUN(const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v) {
    PFN_GLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUN _ptr;
    _ptr = (PFN_GLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUN)_getPrivateProcAddress("glTexCoord4fColor4fNormal3fVertex4fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glTexCoord4fColor4fNormal3fVertex4fvSUN;
    }
    _glTexCoord4fColor4fNormal3fVertex4fvSUN = _ptr;
    _glTexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n, v);
}

PFN_GLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUN _glTexCoord4fColor4fNormal3fVertex4fvSUN = &_get_glTexCoord4fColor4fNormal3fVertex4fvSUN;

static void APIENTRY _fail_glReplacementCodeuiVertex3fSUN(GLuint rc, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glReplacementCodeuiVertex3fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeuiVertex3fSUN(GLuint rc, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLREPLACEMENTCODEUIVERTEX3FSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUIVERTEX3FSUN)_getPrivateProcAddress("glReplacementCodeuiVertex3fSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeuiVertex3fSUN;
    }
    _glReplacementCodeuiVertex3fSUN = _ptr;
    _glReplacementCodeuiVertex3fSUN(rc, x, y, z);
}

PFN_GLREPLACEMENTCODEUIVERTEX3FSUN _glReplacementCodeuiVertex3fSUN = &_get_glReplacementCodeuiVertex3fSUN;

static void APIENTRY _fail_glReplacementCodeuiVertex3fvSUN(const GLuint * rc, const GLfloat * v) {
    const char *_name = "glReplacementCodeuiVertex3fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeuiVertex3fvSUN(const GLuint * rc, const GLfloat * v) {
    PFN_GLREPLACEMENTCODEUIVERTEX3FVSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUIVERTEX3FVSUN)_getPrivateProcAddress("glReplacementCodeuiVertex3fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeuiVertex3fvSUN;
    }
    _glReplacementCodeuiVertex3fvSUN = _ptr;
    _glReplacementCodeuiVertex3fvSUN(rc, v);
}

PFN_GLREPLACEMENTCODEUIVERTEX3FVSUN _glReplacementCodeuiVertex3fvSUN = &_get_glReplacementCodeuiVertex3fvSUN;

static void APIENTRY _fail_glReplacementCodeuiColor4ubVertex3fSUN(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glReplacementCodeuiColor4ubVertex3fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeuiColor4ubVertex3fSUN(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUN)_getPrivateProcAddress("glReplacementCodeuiColor4ubVertex3fSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeuiColor4ubVertex3fSUN;
    }
    _glReplacementCodeuiColor4ubVertex3fSUN = _ptr;
    _glReplacementCodeuiColor4ubVertex3fSUN(rc, r, g, b, a, x, y, z);
}

PFN_GLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUN _glReplacementCodeuiColor4ubVertex3fSUN = &_get_glReplacementCodeuiColor4ubVertex3fSUN;

static void APIENTRY _fail_glReplacementCodeuiColor4ubVertex3fvSUN(const GLuint * rc, const GLubyte * c, const GLfloat * v) {
    const char *_name = "glReplacementCodeuiColor4ubVertex3fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeuiColor4ubVertex3fvSUN(const GLuint * rc, const GLubyte * c, const GLfloat * v) {
    PFN_GLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUN)_getPrivateProcAddress("glReplacementCodeuiColor4ubVertex3fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeuiColor4ubVertex3fvSUN;
    }
    _glReplacementCodeuiColor4ubVertex3fvSUN = _ptr;
    _glReplacementCodeuiColor4ubVertex3fvSUN(rc, c, v);
}

PFN_GLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUN _glReplacementCodeuiColor4ubVertex3fvSUN = &_get_glReplacementCodeuiColor4ubVertex3fvSUN;

static void APIENTRY _fail_glReplacementCodeuiColor3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glReplacementCodeuiColor3fVertex3fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeuiColor3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLREPLACEMENTCODEUICOLOR3FVERTEX3FSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUICOLOR3FVERTEX3FSUN)_getPrivateProcAddress("glReplacementCodeuiColor3fVertex3fSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeuiColor3fVertex3fSUN;
    }
    _glReplacementCodeuiColor3fVertex3fSUN = _ptr;
    _glReplacementCodeuiColor3fVertex3fSUN(rc, r, g, b, x, y, z);
}

PFN_GLREPLACEMENTCODEUICOLOR3FVERTEX3FSUN _glReplacementCodeuiColor3fVertex3fSUN = &_get_glReplacementCodeuiColor3fVertex3fSUN;

static void APIENTRY _fail_glReplacementCodeuiColor3fVertex3fvSUN(const GLuint * rc, const GLfloat * c, const GLfloat * v) {
    const char *_name = "glReplacementCodeuiColor3fVertex3fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeuiColor3fVertex3fvSUN(const GLuint * rc, const GLfloat * c, const GLfloat * v) {
    PFN_GLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUN)_getPrivateProcAddress("glReplacementCodeuiColor3fVertex3fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeuiColor3fVertex3fvSUN;
    }
    _glReplacementCodeuiColor3fVertex3fvSUN = _ptr;
    _glReplacementCodeuiColor3fVertex3fvSUN(rc, c, v);
}

PFN_GLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUN _glReplacementCodeuiColor3fVertex3fvSUN = &_get_glReplacementCodeuiColor3fVertex3fvSUN;

static void APIENTRY _fail_glReplacementCodeuiNormal3fVertex3fSUN(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glReplacementCodeuiNormal3fVertex3fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeuiNormal3fVertex3fSUN(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLREPLACEMENTCODEUINORMAL3FVERTEX3FSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUINORMAL3FVERTEX3FSUN)_getPrivateProcAddress("glReplacementCodeuiNormal3fVertex3fSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeuiNormal3fVertex3fSUN;
    }
    _glReplacementCodeuiNormal3fVertex3fSUN = _ptr;
    _glReplacementCodeuiNormal3fVertex3fSUN(rc, nx, ny, nz, x, y, z);
}

PFN_GLREPLACEMENTCODEUINORMAL3FVERTEX3FSUN _glReplacementCodeuiNormal3fVertex3fSUN = &_get_glReplacementCodeuiNormal3fVertex3fSUN;

static void APIENTRY _fail_glReplacementCodeuiNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * n, const GLfloat * v) {
    const char *_name = "glReplacementCodeuiNormal3fVertex3fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeuiNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * n, const GLfloat * v) {
    PFN_GLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUN)_getPrivateProcAddress("glReplacementCodeuiNormal3fVertex3fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeuiNormal3fVertex3fvSUN;
    }
    _glReplacementCodeuiNormal3fVertex3fvSUN = _ptr;
    _glReplacementCodeuiNormal3fVertex3fvSUN(rc, n, v);
}

PFN_GLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUN _glReplacementCodeuiNormal3fVertex3fvSUN = &_get_glReplacementCodeuiNormal3fVertex3fvSUN;

static void APIENTRY _fail_glReplacementCodeuiColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glReplacementCodeuiColor4fNormal3fVertex3fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeuiColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUN)_getPrivateProcAddress("glReplacementCodeuiColor4fNormal3fVertex3fSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeuiColor4fNormal3fVertex3fSUN;
    }
    _glReplacementCodeuiColor4fNormal3fVertex3fSUN = _ptr;
    _glReplacementCodeuiColor4fNormal3fVertex3fSUN(rc, r, g, b, a, nx, ny, nz, x, y, z);
}

PFN_GLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUN _glReplacementCodeuiColor4fNormal3fVertex3fSUN = &_get_glReplacementCodeuiColor4fNormal3fVertex3fSUN;

static void APIENTRY _fail_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * c, const GLfloat * n, const GLfloat * v) {
    const char *_name = "glReplacementCodeuiColor4fNormal3fVertex3fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * c, const GLfloat * n, const GLfloat * v) {
    PFN_GLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUN)_getPrivateProcAddress("glReplacementCodeuiColor4fNormal3fVertex3fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeuiColor4fNormal3fVertex3fvSUN;
    }
    _glReplacementCodeuiColor4fNormal3fVertex3fvSUN = _ptr;
    _glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n, v);
}

PFN_GLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUN _glReplacementCodeuiColor4fNormal3fVertex3fvSUN = &_get_glReplacementCodeuiColor4fNormal3fVertex3fvSUN;

static void APIENTRY _fail_glReplacementCodeuiTexCoord2fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glReplacementCodeuiTexCoord2fVertex3fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeuiTexCoord2fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUN)_getPrivateProcAddress("glReplacementCodeuiTexCoord2fVertex3fSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeuiTexCoord2fVertex3fSUN;
    }
    _glReplacementCodeuiTexCoord2fVertex3fSUN = _ptr;
    _glReplacementCodeuiTexCoord2fVertex3fSUN(rc, s, t, x, y, z);
}

PFN_GLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUN _glReplacementCodeuiTexCoord2fVertex3fSUN = &_get_glReplacementCodeuiTexCoord2fVertex3fSUN;

static void APIENTRY _fail_glReplacementCodeuiTexCoord2fVertex3fvSUN(const GLuint * rc, const GLfloat * tc, const GLfloat * v) {
    const char *_name = "glReplacementCodeuiTexCoord2fVertex3fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeuiTexCoord2fVertex3fvSUN(const GLuint * rc, const GLfloat * tc, const GLfloat * v) {
    PFN_GLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUN)_getPrivateProcAddress("glReplacementCodeuiTexCoord2fVertex3fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeuiTexCoord2fVertex3fvSUN;
    }
    _glReplacementCodeuiTexCoord2fVertex3fvSUN = _ptr;
    _glReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc, v);
}

PFN_GLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUN _glReplacementCodeuiTexCoord2fVertex3fvSUN = &_get_glReplacementCodeuiTexCoord2fVertex3fvSUN;

static void APIENTRY _fail_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUN)_getPrivateProcAddress("glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
    }
    _glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = _ptr;
    _glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc, s, t, nx, ny, nz, x, y, z);
}

PFN_GLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUN _glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = &_get_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;

static void APIENTRY _fail_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * tc, const GLfloat * n, const GLfloat * v) {
    const char *_name = "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * tc, const GLfloat * n, const GLfloat * v) {
    PFN_GLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUN)_getPrivateProcAddress("glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
    }
    _glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = _ptr;
    _glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n, v);
}

PFN_GLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUN _glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = &_get_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;

static void APIENTRY _fail_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    const char *_name = "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
    PFN_GLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUN)_getPrivateProcAddress("glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
    }
    _glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = _ptr;
    _glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
}

PFN_GLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUN _glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = &_get_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;

static void APIENTRY _fail_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v) {
    const char *_name = "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const GLuint * rc, const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v) {
    PFN_GLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUN _ptr;
    _ptr = (PFN_GLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUN)_getPrivateProcAddress("glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN");
    if (!_ptr) {
        _ptr = &_fail_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
    }
    _glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = _ptr;
    _glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n, v);
}

PFN_GLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUN _glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = &_get_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;

static void APIENTRY _fail_glAddSwapHintRectWIN(GLint x, GLint y, GLsizei width, GLsizei height) {
    const char *_name = "glAddSwapHintRectWIN";
    os::log("warning: ignoring call to unavailable function %s\n", _name);
    return;
}

static void APIENTRY _get_glAddSwapHintRectWIN(GLint x, GLint y, GLsizei width, GLsizei height) {
    PFN_GLADDSWAPHINTRECTWIN _ptr;
    _ptr = (PFN_GLADDSWAPHINTRECTWIN)_getPrivateProcAddress("glAddSwapHintRectWIN");
    if (!_ptr) {
        _ptr = &_fail_glAddSwapHintRectWIN;
    }
    _glAddSwapHintRectWIN = _ptr;
    _glAddSwapHintRectWIN(x, y, width, height);
}

PFN_GLADDSWAPHINTRECTWIN _glAddSwapHintRectWIN = &_get_glAddSwapHintRectWIN;


